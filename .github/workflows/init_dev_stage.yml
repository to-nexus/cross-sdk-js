name: Seed packages from prod registry

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Target env to seed (dev or stage)"
        required: true
        type: choice
        options: [dev, stage]
      packages:
        description: "Comma-separated package list (full names). Empty=auto-discover workspace @to-nexus/* packages"
        required: false
        default: ""
      tag:
        description: "Dist-tag to use in target registry (default: env â†’ alpha/beta)"
        required: false
        default: ""
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
      packages:
        required: false
        type: string
        default: ""
      tag:
        required: false
        type: string
        default: ""

permissions:
  contents: read

jobs:
  seed:
    name: Seed from prod
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'

      - name: Install pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9.5.0

      - name: Resolve registries
        id: regs
        run: |
          # Target registry by env (vars fallback to secrets)
          if [ "${{ inputs.environment }}" = "dev" ]; then
            TARGET_URL="${DEV_VAR:-$DEV_SECRET}"
            DEF_TAG=alpha
          else
            TARGET_URL="${STAGE_VAR:-$STAGE_SECRET}"
            DEF_TAG=beta
          fi
          if [ -z "$TARGET_URL" ]; then
            echo "ERROR: TARGET registry URL is not configured for environment '${{ inputs.environment }}' (check vars/secrets NEXUS_DEV_REGISTRY_URL or NEXUS_STAGE_REGISTRY_URL)." >&2
            exit 1
          fi
          echo "TARGET_REG=${TARGET_URL}" >> $GITHUB_OUTPUT
          echo "DEF_TAG=${DEF_TAG}" >> $GITHUB_OUTPUT
          # Prod registry (source)
          PROD_URL="${PROD_VAR:-$PROD_SECRET}"
          if [ -z "$PROD_URL" ]; then
            PROD_URL="${PROD_ALT_VAR:-$PROD_ALT_SECRET}"
          fi
          if [ -z "$PROD_URL" ]; then
            echo "ERROR: PROD registry URL is not configured (set vars/secrets NEXUS_REGISTRY_URL or NEXUS_PROD_REGISTRY_URL)." >&2
            exit 1
          fi
          echo "PROD_REG=${PROD_URL}" >> $GITHUB_OUTPUT

          # Also expose other known source registries for fallback discovery
          echo "DEV_REG=${DEV_VAR:-$DEV_SECRET}" >> $GITHUB_OUTPUT
          echo "STAGE_REG=${STAGE_VAR:-$STAGE_SECRET}" >> $GITHUB_OUTPUT
        env:
          DEV_VAR: ${{ vars.NEXUS_DEV_REGISTRY_URL }}
          DEV_SECRET: ${{ secrets.NEXUS_DEV_REGISTRY_URL }}
          STAGE_VAR: ${{ vars.NEXUS_STAGE_REGISTRY_URL }}
          STAGE_SECRET: ${{ secrets.NEXUS_STAGE_REGISTRY_URL }}
          PROD_VAR: ${{ vars.NEXUS_REGISTRY_URL }}
          PROD_SECRET: ${{ secrets.NEXUS_REGISTRY_URL }}
          PROD_ALT_VAR: ${{ vars.NEXUS_PROD_REGISTRY_URL }}
          PROD_ALT_SECRET: ${{ secrets.NEXUS_PROD_REGISTRY_URL }}

      - name: Configure npm auth for both registries
        run: |
          # Target auth
          echo "//${TARGET_REG#https://}:_auth=${{ secrets.NEXUS_CREDENTIALS_BASE64 }}" > .npmrc
          echo "@to-nexus:registry=${TARGET_REG}" >> .npmrc
          # Create a separate userconfig for PROD read to avoid scope override by target .npmrc
          echo "//${PROD_REG#https://}:_auth=${{ secrets.NEXUS_CREDENTIALS_BASE64 }}" > .npmrc.prod
          echo "@to-nexus:registry=${PROD_REG}" >> .npmrc.prod
          # Add auth for fallback registries if defined
          if [ -n "${STAGE_REG}" ]; then echo "//${STAGE_REG#https://}:_auth=${{ secrets.NEXUS_CREDENTIALS_BASE64 }}" >> .npmrc; fi
          if [ -n "${DEV_REG}" ]; then echo "//${DEV_REG#https://}:_auth=${{ secrets.NEXUS_CREDENTIALS_BASE64 }}" >> .npmrc; fi
          echo "### Target registry: ${TARGET_REG}" >> $GITHUB_STEP_SUMMARY
          echo "### Source(prod) registry: ${PROD_REG}" >> $GITHUB_STEP_SUMMARY
          if [ -n "${STAGE_REG}" ]; then echo "### Fallback(stage) registry: ${STAGE_REG}" >> $GITHUB_STEP_SUMMARY; fi
          if [ -n "${DEV_REG}" ]; then echo "### Fallback(dev) registry: ${DEV_REG}" >> $GITHUB_STEP_SUMMARY; fi
        env:
          TARGET_REG: ${{ steps.regs.outputs.TARGET_REG }}
          PROD_REG: ${{ steps.regs.outputs.PROD_REG }}
          STAGE_REG: ${{ steps.regs.outputs.STAGE_REG }}
          DEV_REG: ${{ steps.regs.outputs.DEV_REG }}

      - name: Discover workspace @to-nexus/* packages (when packages input empty)
        id: discover
        run: |
          if [ -n "${{ inputs.packages }}" ]; then
            echo "PKGS_INPUT=${{ inputs.packages }}" >> $GITHUB_OUTPUT
            exit 0
          fi
          list=$(git ls-files 'packages/**/package.json' 'providers/**/package.json' | while read -r f; do node -e "const fs=require('fs');const p=JSON.parse(fs.readFileSync(process.argv[1],'utf8')); if(p.name&&/^@to-nexus\//.test(p.name)) console.log(p.name)" "$f"; done | sort -u | tr '\n' ',')
          list=${list%,}
          echo "PKGS_DISCOVERED=$list" >> $GITHUB_OUTPUT

      - name: Seed packages
        run: |
          set -e
          # Resolve list: prefer explicit input, else discovered workspace packages
          SRC_LIST="${{ inputs.packages }}"
          if [ -z "$SRC_LIST" ]; then
            SRC_LIST="${{ steps.discover.outputs.PKGS_DISCOVERED }}"
          fi
          echo "Packages to seed: $SRC_LIST"
          IFS=',' read -ra LIST <<< "$SRC_LIST"
          TAG_INPUT='${{ inputs.tag }}'
          TAG=${TAG_INPUT:-${{ steps.regs.outputs.DEF_TAG }}}
          mkdir -p seed

          prod_reg='${{ steps.regs.outputs.PROD_REG }}'

          for key in "${LIST[@]}"; do
            pkg=$(echo "$key" | xargs)
            if [ -z "$pkg" ]; then continue; fi
            echo "Resolving $pkg from prod..."
            echo "DEBUG: Using prod registry: $prod_reg"
            echo "DEBUG: All registry env vars:"
            echo "  PROD_VAR: ${{ vars.NEXUS_REGISTRY_URL }}"
            echo "  PROD_SECRET: ${{ secrets.NEXUS_REGISTRY_URL }}"  
            echo "  PROD_ALT_VAR: ${{ vars.NEXUS_PROD_REGISTRY_URL }}"
            echo "  PROD_ALT_SECRET: ${{ secrets.NEXUS_PROD_REGISTRY_URL }}"
            echo "DEBUG: Contents of .npmrc.prod:"
            cat .npmrc.prod || echo "No .npmrc.prod file"
            # 1) Prefer latest stable by dist-tag in prod
            set +e
            ver=$(npm --userconfig .npmrc.prod view "$pkg" version 2>/dev/null)
            echo "DEBUG: npm view $pkg version returned: '$ver'"
            # guard: accept only semver-looking strings
            if [[ ! "$ver" =~ ^[0-9]+\.[0-9]+\.[0-9]+([.-][0-9A-Za-z]+)*$ ]]; then ver=""; fi
            set -e
            # 2) If unavailable or invalid, pick highest stable from versions list in prod
            if [ -z "$ver" ]; then
              versions_json=$(npm --userconfig .npmrc.prod view "$pkg" versions --json 2>/dev/null || true)
              echo "DEBUG: npm view $pkg versions --json returned: '$versions_json'"
              if [ -n "$versions_json" ] && [ "$versions_json" != "null" ]; then
                ver=$(echo "$versions_json" | node -e "let s='';process.stdin.on('data',d=>s+=d).on('end',()=>{try{const arr=JSON.parse(s)||[];const stable=arr.filter(v=>/^\\d+\\.\\d+\\.\\d+$/.test(v));if(!stable.length){process.exit(0)}stable.sort((a,b)=>{const ax=a.split('.') .map(Number);const bx=b.split('.') .map(Number);for(let i=0;i<3;i++){if(ax[i]!==bx[i]) return bx[i]-ax[i];}return 0;});console.log(stable[0]);}catch(e){}})")
                echo "DEBUG: Selected version from versions array: '$ver'"
              fi
            fi
            # final guard
            if [[ -z "$ver" || ! "$ver" =~ ^[0-9]+\.[0-9]+\.[0-9]+([.-][0-9A-Za-z]+)*$ ]]; then echo "No valid version resolved on prod for $pkg"; continue; fi
            if [ -z "$ver" ]; then echo "No version found on prod for $pkg"; continue; fi
            echo "Found $pkg@$ver from $prod_reg"
            tgz=$(npm --userconfig .npmrc.prod pack "$pkg@$ver" --pack-destination ./seed | tail -n 1)
            if [ -z "$tgz" ] || [ ! -f "seed/$tgz" ]; then echo "Pack failed for $pkg@$ver"; continue; fi
            echo "Publishing $tgz to target with tag $TAG..."
            if ! npm publish "seed/$tgz" --registry "${{ steps.regs.outputs.TARGET_REG }}" --tag "$TAG"; then
              echo "Publish failed, trying to add dist-tag (maybe already present)..."
              npm dist-tag add "$pkg@$ver" "$TAG" --registry "${{ steps.regs.outputs.TARGET_REG }}" || true
            fi
          done

      - name: Done
        run: echo "Seeding complete."

