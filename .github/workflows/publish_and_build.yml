name: CI - Publish

on:
  push:
    branches:
      - main
      - ci/*
  workflow_dispatch:
    inputs:
      environment:
        description: "배포 환경 선택"
        required: true
        type: choice
        options:
          - dev
          - stage
          - prod
      publish_version:
        description: "배포 버전 (develop 필수, release/*는 미입력 시 브랜치명 사용)"
        required: false
        type: string
      dry_run:
        description: "실제 퍼블리시/태깅 없이 검증만 수행"
        required: false
        default: 'false'
        type: choice
        options: ['false', 'true']

permissions:
  id-token: write
  contents: write
  packages: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ inputs.environment || 'na' }}
  cancel-in-progress: true

jobs:
  version_bump:
    name: Version Bump (reusable)
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'push' && github.ref == 'refs/heads/main')
    uses: ./.github/workflows/version_bump.yml
    with:
      environment: ${{ inputs.environment || (github.ref == 'refs/heads/main' && 'prod') || 'dev' }}
      versions: ''
    secrets: inherit

  publish:
    name: Publish to Nexus NPM
    runs-on: ubuntu-latest
    needs: [version_bump]
    if: |
      (
        github.event_name == 'workflow_dispatch' && (
          (github.ref_name == 'develop' && inputs.environment == 'dev') ||
          (startsWith(github.ref_name, 'release/') && inputs.environment == 'stage') ||
          (github.ref_name == 'main' && inputs.environment == 'prod') ||
          (startsWith(github.ref_name, 'ci/') && inputs.environment == 'dev')
        )
      ) || (github.event_name == 'push' && github.ref == 'refs/heads/main')
    environment: ${{ inputs.environment || (github.ref == 'refs/heads/main' && 'prod') || 'dev' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'

      - name: Resolve Nexus registry URL
        id: registry
        run: |
          if [ "${{ inputs.environment || (github.ref == 'refs/heads/main' && 'prod') || 'dev' }}" = "dev" ]; then
            url="${DEV_VAR:-$DEV_SECRET}"
          elif [ "${{ inputs.environment || (github.ref == 'refs/heads/main' && 'prod') || 'dev' }}" = "stage" ]; then
            url="${STAGE_VAR:-$STAGE_SECRET}"
          else
            url="$PROD_SECRET"
          fi
          echo "NEXUS_URL=$url" >> $GITHUB_OUTPUT
        env:
          DEV_VAR: ${{ vars.NEXUS_DEV_REGISTRY_URL }}
          DEV_SECRET: ${{ secrets.NEXUS_DEV_REGISTRY_URL }}
          STAGE_VAR: ${{ vars.NEXUS_STAGE_REGISTRY_URL }}
          STAGE_SECRET: ${{ secrets.NEXUS_STAGE_REGISTRY_URL }}
          PROD_SECRET: ${{ secrets.NEXUS_REGISTRY_URL }}

      - name: Configure npm for Nexus
        run: |
          echo "::add-mask::${NPM_TOKEN}" || true

          HOST_PATH="${NEXUS_REGISTRY_URL#https://}"
          HOST_PATH_NO_SLASH="${HOST_PATH%/}"
          HOST_DOMAIN="${HOST_PATH%%/*}"
          echo "registry=https://registry.npmjs.org/" > .npmrc
          echo "@to-nexus:registry=${NEXUS_REGISTRY_URL}" >> .npmrc
          echo "//${HOST_PATH}/:_authToken=${NPM_TOKEN}" >> .npmrc
          echo "//${HOST_PATH_NO_SLASH}:_authToken=${NPM_TOKEN}" >> .npmrc
          echo "//${HOST_DOMAIN}/:_authToken=${NPM_TOKEN}" >> .npmrc
          echo "//${HOST_DOMAIN}/repository/:_authToken=${NPM_TOKEN}" >> .npmrc
          echo "//${HOST_PATH}/:always-auth=true" >> .npmrc
          echo "//${HOST_PATH_NO_SLASH}:always-auth=true" >> .npmrc
          echo "//${HOST_DOMAIN}/repository/:always-auth=true" >> .npmrc
          echo "always-auth=true" >> .npmrc
          echo "email=${GITHUB_ACTOR}@users.noreply.github.com" >> .npmrc
          echo "NPM_CONFIG_USERCONFIG=$GITHUB_WORKSPACE/.npmrc" >> $GITHUB_ENV
          echo "### NPM Publish Registry\n${NEXUS_REGISTRY_URL}" >> $GITHUB_STEP_SUMMARY

          # Also write to HOME to satisfy tooling that reads default userconfig
          cp .npmrc "$HOME/.npmrc"
        env:
          NEXUS_REGISTRY_URL: ${{ steps.registry.outputs.NEXUS_URL }}
          NPM_TOKEN: ${{ secrets.NEXUS_NPM_TOKEN }}

      - name: Verify npm auth (gate)
        run: |
          set -e
          export NPM_CONFIG_USERCONFIG="$GITHUB_WORKSPACE/.npmrc"
          echo "Verifying npm auth against ${NEXUS_REGISTRY_URL}"
          if npm whoami --registry "${NEXUS_REGISTRY_URL}" >/dev/null 2>&1 || npm whoami --registry "${NEXUS_REGISTRY_URL%/}/" >/dev/null 2>&1; then
            echo "npm whoami succeeded"
          else
            echo "npm whoami failed; attempting HTTP whoami as fallback"
            echo "::add-mask::${NPM_TOKEN}" || true
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer ${NPM_TOKEN}" "${NEXUS_REGISTRY_URL}/-/whoami")
            if [ "$STATUS" != "200" ]; then
              echo "Auth verification failed (HTTP $STATUS). Aborting."
              exit 1
            fi
          fi
        env:
          NEXUS_REGISTRY_URL: ${{ steps.registry.outputs.NEXUS_URL }}
          NPM_TOKEN: ${{ secrets.NEXUS_NPM_TOKEN }}

      - name: Install dependencies (workspaces)
        run: npm install --workspaces

      - name: Ensure Changesets CLI available
        run: npm i -D @changesets/cli@2.28.1 --no-save

      - name: Ensure not in Changesets pre mode (best-effort)
        run: npm run changeset -- pre exit || true

      - name: Compute version from inputs/branch
        id: compute
        run: |
          BRANCH="${GITHUB_REF_NAME}"
          ENVIRONMENT="${{ inputs.environment || (github.ref == 'refs/heads/main' && 'prod') || 'dev' }}"
          INPUT_VER="${{ inputs.publish_version }}"
          REF_VERSION=""

          if [[ "$ENVIRONMENT" == "stage" && "$BRANCH" == release/* ]]; then
            # stage on release/*: default to branch x.y.z, override if manual input present
            BASE_FROM_BRANCH="${BRANCH#release/}"
            if [[ -n "$INPUT_VER" ]]; then
              REF_VERSION="$INPUT_VER"
              echo "Using manual version for stage: $REF_VERSION"
            else
              REF_VERSION="$BASE_FROM_BRANCH"
              echo "Using version from branch: $REF_VERSION"
            fi
          elif [[ "$ENVIRONMENT" == "dev" ]]; then
            # develop requires manual version
            if [[ -z "$INPUT_VER" ]]; then
              echo "❌ publish_version is required for develop (environment=dev)"
              exit 1
            fi
            REF_VERSION="$INPUT_VER"
            echo "Using manual version for dev: $REF_VERSION"
          else
            # prod or others: optional input, otherwise derive from package.json later
            if [[ -n "$INPUT_VER" ]]; then
              REF_VERSION="$INPUT_VER"
              echo "Using manual version for prod: $REF_VERSION"
            else
              echo "No manual version provided; prod will derive from package.json"
            fi
          fi

          echo "REF_VERSION=$REF_VERSION" >> $GITHUB_OUTPUT

      - name: Generate changeset from inputs/branch (dev/stage only)
        if: (inputs.environment == 'dev' || inputs.environment == 'stage') && inputs.dry_run == 'false'
        run: |
          PUBLISH_VERSION=${{ steps.compute.outputs.REF_VERSION || '' }} \
          RELEASE_VERSION=${{ steps.compute.outputs.REF_VERSION || '' }} \
          node scripts/auto-changeset.cjs

      - name: Enter Changesets pre mode (alpha/beta)
        if: (inputs.environment == 'dev' || inputs.environment == 'stage') && inputs.dry_run == 'false'
        run: |
          PREID=$([[ "${{ inputs.environment }}" == "stage" ]] && echo "beta" || echo "alpha")
          npm run changeset -- pre enter "$PREID"

      - name: Version packages (pre)
        if: (inputs.environment == 'dev' || inputs.environment == 'stage') && inputs.dry_run == 'false'
        run: npm run version-packages

      - name: Exit Changesets pre mode (dev/stage)
        if: (inputs.environment == 'dev' || inputs.environment == 'stage') && inputs.dry_run == 'false'
        run: npm run changeset -- pre exit

      - name: Set stable version in root package.json (prod)
        if: inputs.environment == 'prod' && inputs.dry_run == 'false'
        id: setver_prod
        run: |
          BASE_INPUT="${{ steps.compute.outputs.REF_VERSION }}"
          if [[ -n "$BASE_INPUT" ]]; then
            BASE_VERSION="${BASE_INPUT%%-*}"
          else
            BASE_VERSION=$(node -e "console.log(require('./package.json').version.replace(/-.*/, ''))")
          fi
          node -e "const fs=require('fs');const p=require('./package.json');p.version='${BASE_VERSION}';fs.writeFileSync('package.json',JSON.stringify(p,null,2)+'\n')"
          echo "Set root version (prod) -> ${BASE_VERSION}"
          echo "BASE_VERSION=${BASE_VERSION}" >> $GITHUB_OUTPUT
          git add package.json
          # prod에서는 버전 파일을 커밋/푸시하지 않음 (충돌 방지)

      - name: Set prerelease version in root package.json (dev/stage)
        if: (inputs.environment == 'dev' || inputs.environment == 'stage') && inputs.dry_run == 'false'
        id: setver
        run: |
          PREID=$([[ "${{ inputs.environment }}" == "stage" ]] && echo "beta" || echo "alpha")
          BASE="${{ steps.compute.outputs.REF_VERSION }}"
          if [[ -z "$BASE" ]]; then
            # fallback to current base if not provided (shouldn't happen for dev/stage)
            BASE=$(node -e "console.log(require('./package.json').version.replace(/-.*/, ''))")
          fi
          if [[ "$BASE" == *-* ]]; then
            NEW_VER="$BASE"
          else
            NEW_VER="${BASE}-${PREID}"
          fi
          node -e "const fs=require('fs');const p=require('./package.json');p.version='${NEW_VER}';fs.writeFileSync('package.json',JSON.stringify(p,null,2)+'\n')"
          echo "Set root version -> ${NEW_VER}"
          echo "NEW_VERSION=${NEW_VER}" >> $GITHUB_OUTPUT
          git add package.json
          if [ -n "$(git status --porcelain)" ]; then
            echo "VERSION_CHANGES_READY=true" >> $GITHUB_OUTPUT
          else
            echo "VERSION_CHANGES_READY=false" >> $GITHUB_OUTPUT
          fi

      - name: Propagate version to linked packages (prebuild helper)
        if: (inputs.environment == 'dev' || inputs.environment == 'stage') && inputs.dry_run == 'false'
        run: |
          node scripts/inject-version.js || true
          git add -A

      - name: Align internal @to-nexus/* dependency versions (exact match)
        if: (inputs.environment == 'dev' || inputs.environment == 'stage') && inputs.dry_run == 'false'
        run: |
          node -e '
            const fs = require("fs");
            const path = require("path");
            function collect(root){const out=[];if(!fs.existsSync(root))return out;const s=[root];while(s.length){const d=s.pop();for(const e of fs.readdirSync(d,{withFileTypes:true})){if(e.name==="node_modules"||e.name.startsWith("."))continue;const p=path.join(d,e.name);if(e.isDirectory())s.push(p);else if(e.isFile()&&e.name==="package.json")out.push(p);} } return out;}
            const pkgFiles=[...collect("./packages"),...collect("./providers")];
            // build map of workspace package name -> version
            const versionMap=new Map();
            for(const f of pkgFiles){try{const j=JSON.parse(fs.readFileSync(f,"utf8"));if(j.name&&j.version)versionMap.set(j.name,j.version);}catch{}}
            let updates=0;
            for(const f of pkgFiles){let changed=false;const j=JSON.parse(fs.readFileSync(f,"utf8"));
              for(const sec of ["dependencies","devDependencies","peerDependencies"]){ if(!j[sec]) continue; for(const dep of Object.keys(j[sec])){ if(dep.startsWith("@to-nexus/")){ const v=versionMap.get(dep); if(v && j[sec][dep]!==v){ j[sec][dep]=v; changed=true; console.log(`Aligned ${dep} -> ${v} in ${f}`);} } } }
              if(changed){ fs.writeFileSync(f,JSON.stringify(j,null,2)+"\n"); updates++; }
            }
            console.log(`Updated dependency ranges in ${updates} file(s)`);
          '
          git add -A

      - name: Build (workspaces)
        run: npm run build --workspaces --if-present

      - name: Extract version from package.json
        id: version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          BASE_VERSION=$(node -e "console.log(require('./package.json').version.replace(/-.*/, ''))")
          echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT
          echo "BASE_VERSION=${BASE_VERSION}" >> $GITHUB_OUTPUT

      - name: Publish (dev → alpha)
        if: inputs.environment == 'dev' && inputs.dry_run == 'false'
        run: npm run publish:alpha
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NEXUS_NPM_TOKEN }}
          NPM_CONFIG_USERCONFIG: ${{ env.NPM_CONFIG_USERCONFIG }}

      - name: Publish (stage → beta)
        if: inputs.environment == 'stage' && inputs.dry_run == 'false'
        run: npm run publish:beta
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NEXUS_NPM_TOKEN }}
          NPM_CONFIG_USERCONFIG: ${{ env.NPM_CONFIG_USERCONFIG }}

      - name: Commit version changes (after successful publish)
        if: (inputs.environment == 'dev' || inputs.environment == 'stage') && inputs.dry_run == 'false' && steps.setver.outputs.VERSION_CHANGES_READY == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add -A
          git restore --staged .npmrc 2>/dev/null || true
          git commit -m "chore: set workspace version to ${{ steps.setver.outputs.NEW_VERSION }}"
          git fetch origin "${GITHUB_REF_NAME}" || true
          git rebase "origin/${GITHUB_REF_NAME}" || git merge --ff-only "origin/${GITHUB_REF_NAME}" || true
          git push || git push --force-with-lease

      - name: Publish (prod → latest)
        if: |
          (github.event_name == 'workflow_dispatch' && inputs.environment == 'prod' && inputs.dry_run == 'false' && github.ref == 'refs/heads/main') ||
          (github.event_name == 'push' && github.ref == 'refs/heads/main')
        run: npm run publish:latest
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NEXUS_NPM_TOKEN }}
          NPM_CONFIG_USERCONFIG: ${{ env.NPM_CONFIG_USERCONFIG }}

      - name: Create tag (dev/stage prerelease)
        if: (inputs.environment == 'dev' || inputs.environment == 'stage') && inputs.dry_run == 'false'
        run: |
          VERSION=$(node -p "require('./package.json').version")
          TAG="release/${VERSION}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG already exists, skipping"
          else
            git tag -a "$TAG" -m "Pre-Release $VERSION"
            git fetch origin "$TAG" || true
            git push origin "$TAG" || git push --force-with-lease origin "$TAG"
          fi

      - name: Create GitHub Pre-Release (dev/stage)
        if: (inputs.environment == 'dev' || inputs.environment == 'stage') && inputs.dry_run == 'false'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: release/${{ steps.version.outputs.VERSION }}
          name: Pre-Release ${{ steps.version.outputs.VERSION }} (${{ inputs.environment }})
          prerelease: true
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create tag & GitHub Release (prod)
        if: inputs.environment == 'prod' && inputs.dry_run == 'false' && github.ref == 'refs/heads/main'
        run: |
          VERSION=$(node -p "require('./package.json').version.replace(/-.*/, '')")
          TAG="release/${VERSION}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG already exists, skipping"
          else
            git tag -a "$TAG" -m "Release $TAG"
            git fetch origin "$TAG" || true
            git push origin "$TAG" || git push --force-with-lease origin "$TAG"
          fi

      - name: Create GitHub Release (prod)
        if: inputs.environment == 'prod' && inputs.dry_run == 'false' && github.ref == 'refs/heads/main'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: release/${{ steps.version.outputs.BASE_VERSION }}
          name: Release ${{ steps.version.outputs.BASE_VERSION }}
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Rollback version changes (if publish failed)
        if: (inputs.environment == 'dev' || inputs.environment == 'stage') && steps.setver.outputs.VERSION_CHANGES_READY == 'true' && failure()
        run: |
          echo "Publish failed, rolling back local version changes"
          git reset --hard HEAD

