name: CI - Publish & Build

on:
  push:
    branches:
      - main
      - ci/*
      - feature/*
  workflow_dispatch:
    inputs:
      environment:
        description: "ë°°í¬ í™˜ê²½ ì„ íƒ"
        required: true
        type: choice
        options:
          - dev
          - stage
          - prod
      services:
        description: "ë°°í¬ ì„œë¹„ìŠ¤ ì„ íƒ"
        required: true
        type: choice
        options:
          - all
          - changeset
          - package-publish
          - sample-page
          - cdn-publish

      publish_version:
        description: "ë°°í¬ ë²„ì „ ìž…ë ¥ (release/* ë¸Œëžœì¹˜ëŠ” ì„ íƒì‚¬í•­, develop ë¸Œëžœì¹˜ëŠ” í•„ìˆ˜)"
        required: true
        type: string
        
      dry_run:
        description: "ì‹¤ì œ í¼ë¸”ë¦¬ì‹œ/í‘¸ì‹œ/íƒœê¹… ì—†ì´ ê²€ì¦ë§Œ ìˆ˜í–‰"
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

      package_versions:
        description: "ì™¸ë¶€ ì˜ì¡´ì„± ì˜¤ë²„ë¼ì´ë“œ (ì˜ˆ: core=2.19.11,universal=2.19.11,sign-client=2.19.11,sdk=1.16.6)"
        required: false
        default: ''
        type: string

      publish_filters:
        description: "í¼ë¸”ë¦¬ì‹œ í—ˆìš© íŒ¨í„´(ì‰¼í‘œ êµ¬ë¶„). ì˜ˆ: @reown/appkit-*,@to-nexus/appkit*,@to-nexus/sdk,@to-nexus/sdk-cdn,@to-nexus/sign-client"
        required: false
        default: '@reown/appkit-*,@to-nexus/appkit*,@to-nexus/sdk,@to-nexus/sdk-cdn,@to-nexus/sign-client'
        type: string


permissions:
  id-token: write
  contents: write
  packages: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ inputs.environment || 'na' }}-${{ inputs.services || 'na' }}
  cancel-in-progress: true

jobs:
  display_info:
    name: ${{ format('{0} | {1} | {2} | {3}{4}{5}{6}', inputs.services || 'auto-trigger', inputs.environment || github.ref_name, inputs.publish_version || 'latest', inputs.dry_run == 'true' && ' [DRY-RUN]' || '', inputs.package_versions && format(' | pkg:{0}', inputs.package_versions) || '', inputs.publish_filters != '@reown/appkit-*,@to-nexus/appkit*,@to-nexus/sdk,@to-nexus/sdk-cdn,@to-nexus/sign-client' && ' | [CUSTOM-FILTERS]' || '', github.event_name == 'push' && ' | [AUTO-PUSH]' || '') }}
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Display Workflow Information
        run: |
          echo "##  Workflow Execution Info" >> $GITHUB_STEP_SUMMARY
          echo "- **Services**: ${{ inputs.services || 'auto-trigger' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ inputs.environment || github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ inputs.publish_version || 'latest' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Trigger**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Dry Run**: ${{ inputs.dry_run || 'false' }}" >> $GITHUB_STEP_SUMMARY
          if [ -n "${{ inputs.package_versions }}" ]; then
            echo "- **Package Versions**: ${{ inputs.package_versions }}" >> $GITHUB_STEP_SUMMARY
          fi
          if [ "${{ inputs.publish_filters }}" != "@reown/appkit-*,@to-nexus/appkit*,@to-nexus/sdk,@to-nexus/sdk-cdn,@to-nexus/sign-client" ]; then
            echo "- **Custom Filters**: ${{ inputs.publish_filters }}" >> $GITHUB_STEP_SUMMARY
          fi

  changeset_prepare:
    name: Prepare Changeset (auto for preview)
    # develop(dev) | release/*(stage) | feature/*(dev/stage) ì „ìš©, í•´ë‹¹ í™˜ê²½ì—ì„œ ë‹¤ë¥¸ ì„œë¹„ìŠ¤ ì‹¤í–‰ ì „ ìžë™ ìˆ˜í–‰
    environment: ${{ inputs.environment }}
    if: |
      github.event_name == 'workflow_dispatch' && (
        (github.ref == 'refs/heads/develop' && inputs.environment == 'dev') ||
        (startsWith(github.ref, 'refs/heads/release/') && inputs.environment == 'stage') ||
        (startsWith(github.ref, 'refs/heads/ci/') && inputs.environment == 'dev') ||
        (startsWith(github.ref, 'refs/heads/feature/') && (inputs.environment == 'dev' || inputs.environment == 'stage'))
      ) && (inputs.services == 'all' || inputs.services == 'package-publish' || inputs.services == 'cdn-publish' || inputs.services == 'changeset')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'

      - name: Resolve Nexus registry URL (prepare)
        id: registry_prepare
        run: |
          if [ "${{ inputs.environment }}" = "dev" ]; then
            url="${DEV_VAR:-$DEV_SECRET}"
          elif [ "${{ inputs.environment }}" = "stage" ]; then
            url="${STAGE_VAR:-$STAGE_SECRET}"
          else
            url="$PROD_SECRET"
          fi
          echo "NEXUS_URL=$url" >> $GITHUB_OUTPUT
        env:
          DEV_VAR: ${{ vars.NEXUS_DEV_REGISTRY_URL }}
          DEV_SECRET: ${{ secrets.NEXUS_DEV_REGISTRY_URL }}
          STAGE_VAR: ${{ vars.NEXUS_STAGE_REGISTRY_URL }}
          STAGE_SECRET: ${{ secrets.NEXUS_STAGE_REGISTRY_URL }}
          PROD_SECRET: ${{ secrets.NEXUS_REGISTRY_URL }}

      - name: Configure npm registries (workspace .npmrc)
        run: |
          HOST_PATH="${NEXUS_REGISTRY_URL#https://}"
          echo "registry=https://registry.npmjs.org/" > .npmrc
          echo "@to-nexus:registry=${NEXUS_REGISTRY_URL}" >> .npmrc
          echo "//${HOST_PATH}/:_authToken=${NPM_TOKEN}" >> .npmrc
          echo "//${HOST_PATH}/:always-auth=true" >> .npmrc
          echo "NPM_CONFIG_USERCONFIG=$GITHUB_WORKSPACE/.npmrc" >> $GITHUB_ENV
        env:
          NEXUS_REGISTRY_URL: ${{ steps.registry_prepare.outputs.NEXUS_URL }}
          NPM_TOKEN: ${{ secrets.NEXUS_NPM_TOKEN }}

      - name: Install pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9.5.0

      - name: Install dependencies (packages only)
        run: pnpm install --no-frozen-lockfile

      - name: Install root toolchain (turbo & scripts)
        run: pnpm -w --filter . install --no-frozen-lockfile

      - name: Ensure not in pre mode (best-effort)
        run: pnpm dlx @changesets/cli@2.27.12 pre exit || true

      # - name: Align internal package dependency versions
      #   run: |
      #     pnpm run workspace:align || true
      #     pnpm run packages:version:switch || true
      #     git config --local user.email "action@github.com"
      #     git config --local user.name "GitHub Action"
      #     git add -A
      #     if [ -n "$(git status --porcelain)" ]; then
      #       if [ "${{ inputs.dry_run }}" = "false" ]; then
      #         git commit -m "chore: align internal dependency versions"
      #         git fetch origin "${GITHUB_REF_NAME}" || true
      #         git rebase "origin/${GITHUB_REF_NAME}" || git merge --ff-only "origin/${GITHUB_REF_NAME}" || true
      #         git push || git push --force-with-lease
      #       else
      #         echo "Dry-run: internal dependency changes detected but not committed"
      #       fi
      #     else
      #       echo "No internal dependency changes"
      #     fi

      - name: Bump @to-nexus/* to latest (workspace)
        run: |
          pnpm -r up "@to-nexus/*@latest" -P || true
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add -A
          git restore --staged .npmrc 2>/dev/null || true
          if [ -n "$(git status --porcelain)" ]; then
            if [ "${{ inputs.dry_run }}" = "false" ]; then
              git commit -m "chore: bump @to-nexus/* to latest"
              git fetch origin "${GITHUB_REF_NAME}" || true
              git rebase "origin/${GITHUB_REF_NAME}" || git merge --ff-only "origin/${GITHUB_REF_NAME}" || true
              git push || git push --force-with-lease
            else
              echo "Dry-run: dependency bump detected but not committed"
            fi
          else
            echo "No dependency changes to commit"
          fi

      - name: Generate changeset from version.json or branch
        run: |
          PUBLISH_VERSION="${{ inputs.publish_version }}" pnpm run auto-changeset
        
      - name: Detect changed packages since last release
        id: changes
        run: |
          # Get changed packages compared to last published version (environment-specific)
          if [[ "${{ inputs.environment }}" == "dev" ]]; then
            # Dev environment: look for alpha tags
            LAST_TAG=$(git tag -l "release/*-alpha.*" | sort -V | tail -n1 2>/dev/null || echo "")
            PRERELEASE_TYPE="alpha"
          elif [[ "${{ inputs.environment }}" == "stage" ]]; then
            # Stage environment: look for beta tags
            LAST_TAG=$(git tag -l "release/*-beta.*" | sort -V | tail -n1 2>/dev/null || echo "")
            PRERELEASE_TYPE="beta"
          else
            # Prod environment: look for stable release tags (no prerelease suffix)
            LAST_TAG=$(git tag -l "release/*" | grep -v -E "(alpha|beta)" | sort -V | tail -n1 2>/dev/null || echo "")
            PRERELEASE_TYPE="stable"
          fi
          
          if [ -n "$LAST_TAG" ]; then
            echo "Comparing against last $PRERELEASE_TYPE tag: $LAST_TAG"
            CHANGED_FILES=$(git diff --name-only "$LAST_TAG"..HEAD -- packages/ providers/ | grep -E "(src/|package\.json)" | head -20)
          else
            echo "No previous $PRERELEASE_TYPE release tag found, treating all packages as changed"
            CHANGED_FILES=$(find packages providers -name "package.json" | head -20)
          fi
          
          # Extract package names from changed files
          CHANGED_PACKAGES=""
          for file in $CHANGED_FILES; do
            if [[ "$file" == */package.json ]]; then
              pkg_name=$(node -e "try { console.log(require('./$file').name) } catch(e) {}")
              if [[ "$pkg_name" == @to-nexus/* ]] || [[ "$pkg_name" == @reown/* ]]; then
                CHANGED_PACKAGES="$CHANGED_PACKAGES,$pkg_name"
              fi
            elif [[ "$file" == packages/*/src/* ]] || [[ "$file" == providers/*/src/* ]]; then
              dir=$(dirname "$file" | sed 's|/src.*||')
              if [ -f "$dir/package.json" ]; then
                pkg_name=$(node -e "try { console.log(require('./$dir/package.json').name) } catch(e) {}")
                if [[ "$pkg_name" == @to-nexus/* ]] || [[ "$pkg_name" == @reown/* ]]; then
                  CHANGED_PACKAGES="$CHANGED_PACKAGES,$pkg_name"
                fi
              fi
            fi
          done
          
          CHANGED_PACKAGES=$(echo "$CHANGED_PACKAGES" | sed 's/^,//' | tr ',' '\n' | sort -u | tr '\n' ',' | sed 's/,$//')
          echo "CHANGED_PACKAGES=${CHANGED_PACKAGES}" >> $GITHUB_OUTPUT
          echo "Changed packages: $CHANGED_PACKAGES"
      - name: Enter Changeset pre mode
        if: needs.version_bump.outputs.can_publish == 'true'
        run: |
          PREID=$([[ "${{ inputs.environment }}" == "stage" ]] && echo "beta" || echo "alpha")
          echo "Using preid: ${PREID}"
          pnpm dlx @changesets/cli@2.27.12 pre enter ${PREID}

      - name: Version packages (pre)
        if: needs.version_bump.outputs.can_publish == 'true'
        run: pnpm dlx @changesets/cli@2.27.12 version

      - name: Commit changeset
        if: inputs.dry_run == 'false' && needs.version_bump.outputs.can_publish == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add -A
          git restore --staged .npmrc 2>/dev/null || true
          if [ -n "$(git status --porcelain)" ]; then
            git commit -m "chore: auto-generate changeset"
            git fetch origin "${GITHUB_REF_NAME}" || true
            git rebase "origin/${GITHUB_REF_NAME}" || git merge --ff-only "origin/${GITHUB_REF_NAME}" || true
            git push || git push --force-with-lease
          else
            echo "No changes to commit"
          fi
  sonarqube:
    name: SonarQube Analysis
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && (inputs.environment == 'stage' || inputs.environment == 'prod') && (inputs.services == 'all' || inputs.services == 'package-publish' || inputs.services == 'sample-page' || inputs.services == 'cdn-publish')
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@v5
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  version_bump:
    name: Version Bump (reusable)
    needs: [changeset_prepare]
    # Runs for dev/stage on release/* and feature/*, and for prod on main when relevant services selected
    if: |
      github.event_name == 'workflow_dispatch' && (
        (
          github.ref == 'refs/heads/develop' && inputs.environment == 'dev' &&
          (inputs.services == 'all' || inputs.services == 'package-publish' || inputs.services == 'cdn-publish')
        ) || (
          startsWith(github.ref, 'refs/heads/feature/') && (inputs.environment == 'dev' || inputs.environment == 'stage') &&
          (inputs.services == 'all' || inputs.services == 'package-publish' || inputs.services == 'cdn-publish')
        ) || (
          startsWith(github.ref, 'refs/heads/release/') && inputs.environment == 'stage' &&
          (inputs.services == 'all' || inputs.services == 'package-publish' || inputs.services == 'cdn-publish')
        ) || (
          github.ref == 'refs/heads/main' && inputs.environment == 'prod' &&
          (inputs.services == 'all' || inputs.services == 'package-publish' || inputs.services == 'cdn-publish')
        )
      ) || (github.event_name == 'push' && github.ref == 'refs/heads/main')
    uses: ./.github/workflows/version_bump.yml
    with:
      environment: ${{ inputs.environment || 'prod' }}
      versions: ${{ inputs.package_versions }}
    secrets: inherit

  publish_npm_preview:
    name: Publish to Nexus NPM (preview)
    needs: [changeset_prepare, version_bump]
    # develop(dev) | feature/*(dev/stage) | release/*(stage) ì „ìš©
    if: |
      github.event_name == 'workflow_dispatch' && (
        (github.ref == 'refs/heads/develop' && inputs.environment == 'dev') ||
        (startsWith(github.ref, 'refs/heads/feature/') && (inputs.environment == 'dev' || inputs.environment == 'stage')) ||
        (startsWith(github.ref, 'refs/heads/release/') && inputs.environment == 'stage')
      ) && (inputs.services == 'all' || inputs.services == 'package-publish')
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    env:
      VITE_PROJECT_ID: ${{ secrets.VITE_PROJECT_ID }}
      VITE_API_URL: ${{ secrets.VITE_API_URL }}
    steps:
      - name: Resolve Nexus registry URL
        id: registry
        run: |
          if [ "${{ inputs.environment }}" = "dev" ]; then
            url="${DEV_VAR:-$DEV_SECRET}"
          elif [ "${{ inputs.environment }}" = "stage" ]; then
            url="${STAGE_VAR:-$STAGE_SECRET}"
          else
            url="$PROD_SECRET"
          fi
          echo "NEXUS_URL=$url" >> $GITHUB_OUTPUT
        env:
          DEV_VAR: ${{ vars.NEXUS_DEV_REGISTRY_URL }}
          DEV_SECRET: ${{ secrets.NEXUS_DEV_REGISTRY_URL }}
          STAGE_VAR: ${{ vars.NEXUS_STAGE_REGISTRY_URL }}
          STAGE_SECRET: ${{ secrets.NEXUS_STAGE_REGISTRY_URL }}
          PROD_SECRET: ${{ secrets.NEXUS_REGISTRY_URL }}
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'

      - name: Configure npm for Nexus
        run: |
          HOST_PATH="${NEXUS_REGISTRY_URL#https://}"
          HOST_PATH_NO_SLASH="${HOST_PATH%/}"
          HOST_DOMAIN="${HOST_PATH%%/*}"
          echo "@to-nexus:registry=${NEXUS_REGISTRY_URL}" > .npmrc
          echo "//${HOST_PATH}/:_authToken=${NPM_TOKEN}" >> .npmrc
          echo "//${HOST_PATH_NO_SLASH}:_authToken=${NPM_TOKEN}" >> .npmrc
          echo "//${HOST_DOMAIN}/:_authToken=${NPM_TOKEN}" >> .npmrc
          echo "//${HOST_DOMAIN}/repository/:_authToken=${NPM_TOKEN}" >> .npmrc
          echo "//${HOST_PATH}/:always-auth=true" >> .npmrc
          echo "//${HOST_PATH_NO_SLASH}:always-auth=true" >> .npmrc
          echo "//${HOST_DOMAIN}/repository/:always-auth=true" >> .npmrc
          echo "always-auth=true" >> .npmrc
          echo "Using Nexus registry: ${NEXUS_REGISTRY_URL}"
          echo "### NPM Publish Registry\n${NEXUS_REGISTRY_URL}" >> $GITHUB_STEP_SUMMARY
          echo "NPM_CONFIG_USERCONFIG=$GITHUB_WORKSPACE/.npmrc" >> $GITHUB_ENV
        env:
          NEXUS_REGISTRY_URL: ${{ steps.registry.outputs.NEXUS_URL }}
          NPM_TOKEN: ${{ secrets.NEXUS_NPM_TOKEN }}
          NPM_CONFIG_USERCONFIG: ${{ github.workspace }}/.npmrc

      - name: Verify npm auth and test publish (gate)
        run: |
          set -e
          echo "::add-mask::${NPM_TOKEN}" || true
          
          echo "=== Verifying via -/whoami (Bearer) ==="
          RESP=$(curl -s -w "\n%{http_code}" -H "Authorization: Bearer ${NPM_TOKEN}" "${NEXUS_REGISTRY_URL}/-/whoami")
          BODY=$(echo "$RESP" | head -n1)
          STATUS=$(echo "$RESP" | tail -n1)
          if [ "$STATUS" != "200" ]; then
            echo "Auth verification failed (HTTP $STATUS). Aborting."
            exit 1
          fi
          USER=$(printf "%s" "$BODY" | node -e "let s='';process.stdin.on('data',d=>s+=d);process.stdin.on('end',()=>{try{const o=JSON.parse(s);console.log(o?.username||'');}catch(e){}})")
          if [ -n "$USER" ]; then echo "Logged in as: $USER"; else echo "Logged in (username not exposed)"; fi
          
          echo "=== Test publish to verify write access ==="
          TMP_DIR=$(mktemp -d)
          pushd "$TMP_DIR" > /dev/null
          NAME="@to-nexus/test-publish-ci-$(date +%s)-$RANDOM"
          npm init -y >/dev/null 2>&1
          npm pkg set name="$NAME" version="0.0.0-alpha.0" main="index.js" >/dev/null
          echo "console.log('ok')" > index.js
          npm publish --access public --tag alpha --registry "${NEXUS_REGISTRY_URL}" >/dev/null
          echo "Test publish OK: $NAME"
          # cleanup best-effort
          npm unpublish "$NAME" --force --registry "${NEXUS_REGISTRY_URL}" >/dev/null 2>&1 || \
            npm deprecate "$NAME@*" "ci test package" --registry "${NEXUS_REGISTRY_URL}" >/dev/null 2>&1 || true
          popd > /dev/null
          rm -rf "$TMP_DIR"
        env:
          NEXUS_REGISTRY_URL: ${{ steps.registry.outputs.NEXUS_URL }}
          NPM_TOKEN: ${{ secrets.NEXUS_NPM_TOKEN }}

      - name: Install pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9.5.0

      - name: Install dependencies (packages only)
        run: pnpm install --no-frozen-lockfile

      - name: Compute version and resolve dependencies
        id: version
        run: |
          # Version resolution strategy based on branch type
          if [[ "${GITHUB_REF_NAME}" == release/* ]]; then
            # Release branch: publish_version > branch name
            if [ -n "${{ inputs.publish_version }}" ]; then
              REF_VERSION="${{ inputs.publish_version }}"
              echo "Using manual version for release branch: $REF_VERSION"
            else
              REF_VERSION="${GITHUB_REF_NAME#release/}"
              echo "Using version from release branch: $REF_VERSION"
            fi
          else
            # Develop/other branches: publish_version is required
            if [ -n "${{ inputs.publish_version }}" ]; then
              REF_VERSION="${{ inputs.publish_version }}"
              echo "Using manual version for develop branch: $REF_VERSION"
            else
              echo "âŒ ERROR: publish_version is required for non-release branches"
              echo "Current branch: ${GITHUB_REF_NAME}"
              echo "Please provide publish_version input for develop branch deployment"
              exit 1
            fi
          fi
          echo "REF_VERSION=${REF_VERSION}" >> $GITHUB_OUTPUT
          
          # Auto-append or increment prerelease suffix for dev/stage
          if [[ "${{ inputs.environment }}" == "dev" ]]; then
            echo "=== Alpha ë²„ì „ ì²˜ë¦¬ ì‹œìž‘ ==="
            
            # ê¸°ì¡´ alpha ë²„ì „ì´ í¬í•¨ë˜ì–´ ìžˆë‹¤ë©´ ë² ì´ìŠ¤ ë²„ì „ ì¶”ì¶œ
            BASE_VERSION="$REF_VERSION"
            if [[ "$REF_VERSION" == *-alpha* ]]; then
              BASE_VERSION=$(echo "$REF_VERSION" | sed 's/-alpha.*//')
              echo "ê¸°ì¡´ alpha ë²„ì „ì—ì„œ ë² ì´ìŠ¤ ë²„ì „ ì¶”ì¶œ: $BASE_VERSION"
            fi
            
            # í˜„ìž¬ ë ˆì§€ìŠ¤íŠ¸ë¦¬ì—ì„œ ìµœì‹  alpha ë²„ì „ í™•ì¸ (ê°œì„ ëœ ë¡œì§)
            REGISTRY_URL="${{ steps.registry.outputs.NEXUS_URL }}"
            echo "ðŸ” ë ˆì§€ìŠ¤íŠ¸ë¦¬ì—ì„œ ê¸°ì¡´ alpha ë²„ì „ í™•ì¸ ì¤‘: $REGISTRY_URL"
            echo "ðŸ” ë² ì´ìŠ¤ ë²„ì „: $BASE_VERSION"
            echo "ðŸ” í˜„ìž¬ í™˜ê²½: ${{ inputs.environment }}"
            echo "ðŸ” ìž…ë ¥ëœ publish_version: ${{ inputs.publish_version }}"
            
            LATEST_ALPHA_NUM=-1
            
            # ì—¬ëŸ¬ íŒ¨í‚¤ì§€ë¥¼ ìˆœì°¨ì ìœ¼ë¡œ í™•ì¸í•˜ì—¬ ê¸°ì¡´ alpha ë²„ì „ë“¤ ì°¾ê¸°
            PACKAGES_TO_CHECK=("@to-nexus/appkit" "@to-nexus/appkit-siwe" "@to-nexus/sdk" "@to-nexus/appkit-core")
            EXISTING_VERSIONS=""
            
            for PACKAGE in "${PACKAGES_TO_CHECK[@]}"; do
              echo "ðŸ” npm view $PACKAGE versions --json --registry=$REGISTRY_URL ì‹¤í–‰ ì¤‘..."
              set +e
              PACKAGE_VERSIONS=$(npm view "$PACKAGE" versions --json --registry="$REGISTRY_URL" 2>/dev/null)
              EXIT_CODE=$?
              set -e
              
              echo "ðŸ” $PACKAGE ì¡°íšŒ ì¢…ë£Œ ì½”ë“œ: $EXIT_CODE"
              
              if [ $EXIT_CODE -eq 0 ] && [ -n "$PACKAGE_VERSIONS" ] && [ "$PACKAGE_VERSIONS" != "null" ]; then
                echo "ðŸ” $PACKAGEì—ì„œ ë²„ì „ ë°œê²¬: ${PACKAGE_VERSIONS:0:200}..."
                EXISTING_VERSIONS="$PACKAGE_VERSIONS"
                break
              else
                echo "ðŸ” $PACKAGEì—ì„œ ë²„ì „ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ"
              fi
            done
            
            echo "ðŸ” ìµœì¢… ê¸°ì¡´ ë²„ì „ ì¡°íšŒ ê²°ê³¼ (ì²˜ìŒ 500ìž): ${EXISTING_VERSIONS:0:500}"
            
            if [ -n "$EXISTING_VERSIONS" ] && [ "$EXISTING_VERSIONS" != "null" ]; then
              # JSON ë°°ì—´ì—ì„œ í•´ë‹¹ ë² ì´ìŠ¤ ë²„ì „ì˜ alpha ë²ˆí˜¸ë“¤ ì¶”ì¶œ (ê°œì„ ëœ ë¡œì§)
              ALPHA_VERSIONS=$(echo "$EXISTING_VERSIONS" | node -e "
                try {
                  const input = require('fs').readFileSync(0, 'utf8').trim();
                  const versions = JSON.parse(input);
                  const baseVersion = '$BASE_VERSION';
                  const alphaVersions = Array.isArray(versions) ? versions : [versions];
                  const alphaNums = alphaVersions
                    .filter(v => typeof v === 'string' && v.startsWith(baseVersion + '-alpha.'))
                    .map(v => {
                      const match = v.match(/^.+-alpha\.(\d+)$/);
                      return match ? parseInt(match[1], 10) : null;
                    })
                    .filter(n => n !== null && !isNaN(n));
                  
                  console.error('Found alpha versions for', baseVersion + ':', alphaNums);
                  console.log(alphaNums.length > 0 ? Math.max(...alphaNums) : -1);
                } catch(e) {
                  console.error('Error parsing versions:', e.message);
                  console.log(-1);
                }
              " 2>/dev/null)
              
              echo "ðŸ” íŒŒì‹±ëœ ALPHA_VERSIONS: '$ALPHA_VERSIONS'"
              if [[ "$ALPHA_VERSIONS" =~ ^-?[0-9]+$ ]]; then
                LATEST_ALPHA_NUM=$ALPHA_VERSIONS
                echo "ðŸ” ìµœì‹  alpha ë²ˆí˜¸ ì„¤ì •: $LATEST_ALPHA_NUM"
              else
                echo "ðŸ” alpha ë²ˆí˜¸ íŒŒì‹± ì‹¤íŒ¨, ê¸°ë³¸ê°’ -1 ìœ ì§€"
              fi
            else
              echo "ðŸ” ê¸°ì¡´ ë²„ì „ì´ ì—†ê±°ë‚˜ null"
            fi
            
            # ë‹¤ìŒ alpha ë²ˆí˜¸ ê³„ì‚°
            NEXT_ALPHA_NUM=$((LATEST_ALPHA_NUM + 1))
            REF_VERSION="$BASE_VERSION-alpha.$NEXT_ALPHA_NUM"
            echo "ðŸ” ê³„ì‚°ëœ ë‹¤ìŒ alpha ë²„ì „: $REF_VERSION (ì´ì „ ìµœì‹ : alpha.$LATEST_ALPHA_NUM)"
            
            echo "ìžë™ ì¦ê°€ëœ alpha ë²„ì „: $REF_VERSION"
          elif [[ "${{ inputs.environment }}" == "stage" ]]; then
            echo "=== Beta ë²„ì „ ì²˜ë¦¬ ì‹œìž‘ ==="
            
            # ê¸°ì¡´ beta ë²„ì „ì´ í¬í•¨ë˜ì–´ ìžˆë‹¤ë©´ ë² ì´ìŠ¤ ë²„ì „ ì¶”ì¶œ
            BASE_VERSION="$REF_VERSION"
            if [[ "$REF_VERSION" == *-beta* ]]; then
              BASE_VERSION=$(echo "$REF_VERSION" | sed 's/-beta.*//')
              echo "ê¸°ì¡´ beta ë²„ì „ì—ì„œ ë² ì´ìŠ¤ ë²„ì „ ì¶”ì¶œ: $BASE_VERSION"
            fi
            
            # í˜„ìž¬ ë ˆì§€ìŠ¤íŠ¸ë¦¬ì—ì„œ ìµœì‹  beta ë²„ì „ í™•ì¸ (ê°œì„ ëœ ë¡œì§)
            REGISTRY_URL="${{ steps.registry.outputs.NEXUS_URL }}"
            echo "ë ˆì§€ìŠ¤íŠ¸ë¦¬ì—ì„œ ê¸°ì¡´ beta ë²„ì „ í™•ì¸ ì¤‘: $REGISTRY_URL"
            
            LATEST_BETA_NUM=-1
            
            # ì—¬ëŸ¬ íŒ¨í‚¤ì§€ë¥¼ ìˆœì°¨ì ìœ¼ë¡œ í™•ì¸í•˜ì—¬ ê¸°ì¡´ beta ë²„ì „ë“¤ ì°¾ê¸°
            PACKAGES_TO_CHECK=("@to-nexus/appkit" "@to-nexus/appkit-siwe" "@to-nexus/sdk" "@to-nexus/appkit-core")
            EXISTING_VERSIONS=""
            
            for PACKAGE in "${PACKAGES_TO_CHECK[@]}"; do
              echo "ðŸ” npm view $PACKAGE versions --json --registry=$REGISTRY_URL ì‹¤í–‰ ì¤‘..."
              set +e
              PACKAGE_VERSIONS=$(npm view "$PACKAGE" versions --json --registry="$REGISTRY_URL" 2>/dev/null)
              EXIT_CODE=$?
              set -e
              
              echo "ðŸ” $PACKAGE ì¡°íšŒ ì¢…ë£Œ ì½”ë“œ: $EXIT_CODE"
              
              if [ $EXIT_CODE -eq 0 ] && [ -n "$PACKAGE_VERSIONS" ] && [ "$PACKAGE_VERSIONS" != "null" ]; then
                echo "ðŸ” $PACKAGEì—ì„œ ë²„ì „ ë°œê²¬: ${PACKAGE_VERSIONS:0:200}..."
                EXISTING_VERSIONS="$PACKAGE_VERSIONS"
                break
              else
                echo "ðŸ” $PACKAGEì—ì„œ ë²„ì „ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ"
              fi
            done
            
            echo "ðŸ” ìµœì¢… ê¸°ì¡´ ë²„ì „ ì¡°íšŒ ê²°ê³¼: $EXISTING_VERSIONS"
            
            if [ -n "$EXISTING_VERSIONS" ] && [ "$EXISTING_VERSIONS" != "null" ]; then
              # JSON ë°°ì—´ì—ì„œ í•´ë‹¹ ë² ì´ìŠ¤ ë²„ì „ì˜ beta ë²ˆí˜¸ë“¤ ì¶”ì¶œ (ê°œì„ ëœ ë¡œì§)
              BETA_VERSIONS=$(echo "$EXISTING_VERSIONS" | node -e "
                try {
                  const input = require('fs').readFileSync(0, 'utf8').trim();
                  const versions = JSON.parse(input);
                  const baseVersion = '$BASE_VERSION';
                  const betaVersions = Array.isArray(versions) ? versions : [versions];
                  const betaNums = betaVersions
                    .filter(v => typeof v === 'string' && v.startsWith(baseVersion + '-beta.'))
                    .map(v => {
                      const match = v.match(/^.+-beta\.(\d+)$/);
                      return match ? parseInt(match[1], 10) : null;
                    })
                    .filter(n => n !== null && !isNaN(n));
                  
                  console.error('Found beta versions for', baseVersion + ':', betaNums);
                  console.log(betaNums.length > 0 ? Math.max(...betaNums) : -1);
                } catch(e) {
                  console.error('Error parsing versions:', e.message);
                  console.log(-1);
                }
              " 2>/dev/null)
              
              if [[ "$BETA_VERSIONS" =~ ^-?[0-9]+$ ]]; then
                LATEST_BETA_NUM=$BETA_VERSIONS
              fi
            fi
            
            # ë‹¤ìŒ beta ë²ˆí˜¸ ê³„ì‚°
            NEXT_BETA_NUM=$((LATEST_BETA_NUM + 1))
            REF_VERSION="$BASE_VERSION-beta.$NEXT_BETA_NUM"
            echo "ê³„ì‚°ëœ ë‹¤ìŒ beta ë²„ì „: $REF_VERSION (ì´ì „ ìµœì‹ : beta.$LATEST_BETA_NUM)"
            
            echo "ìžë™ ì¦ê°€ëœ beta ë²„ì „: $REF_VERSION"
          fi
          # Re-export possibly adjusted version
          echo "REF_VERSION=${REF_VERSION}" > tmp_ref_version
          echo "REF_VERSION=$(cat tmp_ref_version | cut -d'=' -f2)" >> $GITHUB_OUTPUT
          rm -f tmp_ref_version

          # Apply dependency overrides (package_versions) to force external versions over workspace:*
          if [ -n "${{ inputs.package_versions }}" ]; then
            echo "Applying dependency overrides: ${{ inputs.package_versions }}"
            node -e '
              const fs = require("fs");
              const path = require("path");
              const raw = `${process.env.PACKAGE_VERSIONS}`;
              const pairs = raw.split(",").map(s => s.trim()).filter(Boolean);
              const map = {};
              const alias = {
                core: "@to-nexus/core",
                universal: "@to-nexus/universal-provider",
                "sign-client": "@to-nexus/sign-client",
                sdk: "@to-nexus/sdk"
              };
              for (const p of pairs) {
                const [k, v] = p.split("=").map(s => s && s.trim());
                if (!k || !v) continue;
                const full = alias[k] || k;
                map[full] = v;
              }
              function collectPackageJsons(rootDir) {
                const results = [];
                const stack = [rootDir];
                while (stack.length) {
                  const dir = stack.pop();
                  if (!fs.existsSync(dir)) continue;
                  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
                    if (entry.name === "node_modules" || entry.name.startsWith(".")) continue;
                    const fullPath = path.join(dir, entry.name);
                    if (entry.isDirectory()) {
                      stack.push(fullPath);
                    } else if (entry.isFile() && entry.name === "package.json") {
                      results.push(fullPath);
                    }
                  }
                }
                return results;
              }
              const files = [...collectPackageJsons("./packages"), ...collectPackageJsons("./providers")];
              for (const file of files) {
                const pkg = JSON.parse(fs.readFileSync(file, "utf8"));
                let changed = false;
                for (const section of ["dependencies","devDependencies","peerDependencies"]) {
                  if (!pkg[section]) continue;
                  for (const depName of Object.keys(map)) {
                      if (pkg[section][depName]) {
                      if (pkg[section][depName] !== map[depName]) {
                        pkg[section][depName] = map[depName];
                        changed = true;
                        console.log(`Updated ${file}: ${depName} -> ${map[depName]}`);
                      }
                  }
                  }
                }
                if (changed) {
                  fs.writeFileSync(file, JSON.stringify(pkg, null, 2) + "\n");
                }
              }
            ' \
            PACKAGE_VERSIONS='${{ inputs.package_versions }}'
          else
            echo "No dependency overrides provided"
          fi

          # ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì‚¬ìš©í•œ ê²½ìš° ë²„ì „ì´ ì´ë¯¸ ì„¤ì •ë˜ì—ˆìœ¼ë¯€ë¡œ ì¡°ê±´ë¶€ ì„¤ì •
          if [[ "${{ inputs.environment }}" == "dev" ]] || [[ "${{ inputs.environment }}" == "stage" ]]; then
            echo "ìŠ¤í¬ë¦½íŠ¸ì—ì„œ ì´ë¯¸ ì›Œí¬ìŠ¤íŽ˜ì´ìŠ¤ ë²„ì „ì´ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤."
          else
            # Bulk set version across all packages (prod í™˜ê²½ìš©)
            pnpm run version:set "${REF_VERSION#v}"
          fi

          # Mark as bumped for downstream steps
          echo "VERSION_BUMPED=true" >> $GITHUB_OUTPUT

          # Keep version changes staged (no commit). Publish will read bumped versions
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add -A
          if [ -n "$(git status --porcelain)" ]; then
            echo "VERSION_CHANGES_READY=true" >> $GITHUB_OUTPUT
          else
            echo "VERSION_CHANGES_READY=false" >> $GITHUB_OUTPUT
          fi

      - name: Build packages (packages only)
        run: |
          pnpm -w run build
          # uses package.json script: turbo run build --filter={./packages/*}
        env:
          APP_VERSION: ${{ steps.version.outputs.REF_VERSION }}

      # Removed per-package post-build version bump; using bulk version set above

      - name: Override publishConfig.registry to env registry (dev/stage, exclude sign-client)
        if: inputs.dry_run == 'false'
        run: |
          node -e '
            const fs = require("fs");
            const path = require("path");
            const target = process.env.NEXUS_URL;
            function collect(root){
              const out=[]; if(!fs.existsSync(root)) return out;
              const stack=[root];
              while(stack.length){
                const dir=stack.pop();
                for(const ent of fs.readdirSync(dir,{withFileTypes:true})){
                  if(ent.name === "node_modules" || ent.name.startsWith(".")) continue;
                  const p=path.join(dir, ent.name);
                  if(ent.isDirectory()) stack.push(p);
                  else if(ent.isFile() && ent.name === "package.json") out.push(p);
                }
              }
              return out;
            }
            const files=[...collect("./packages"), ...collect("./providers")];
            let count=0;
            for(const f of files){
              const pkg=JSON.parse(fs.readFileSync(f, "utf8"));
              if(pkg.name && /^@to-nexus\//.test(pkg.name)){
                if(pkg.name === "@to-nexus/sign-client") continue; // exclude from any publish-related mutations
                pkg.publishConfig = pkg.publishConfig || {};
                if(pkg.publishConfig.registry !== target){
                  pkg.publishConfig.registry = target;
                  fs.writeFileSync(f, JSON.stringify(pkg, null, 2) + "\n");
                  console.log("publishConfig.registry ->", target, "in", f);
                  count++;
                }
              }
            }
            console.log("Updated", count, "package.json files");
          '
        env:
          NEXUS_URL: ${{ steps.registry.outputs.NEXUS_URL }}

      - name: Publish package to Nexus (dev â†’ alpha)
        if: inputs.environment == 'dev' && inputs.dry_run == 'false' && steps.version.outputs.VERSION_BUMPED == 'true'
        id: publish_dev
        run: |
          # Ensure .npmrc exists for this step
          HOST_PATH="${NEXUS_REGISTRY_URL#https://}"
          HOST_PATH_NO_SLASH="${HOST_PATH%/}"
          HOST_DOMAIN="${HOST_PATH%%/*}"
          
          # Create .npmrc and set npm environment variables
          echo "registry=https://registry.npmjs.org/" > .npmrc
          echo "@to-nexus:registry=${NEXUS_REGISTRY_URL}" >> .npmrc
          echo "//${HOST_PATH}/:_authToken=${NPM_TOKEN}" >> .npmrc
          echo "//${HOST_PATH_NO_SLASH}:_authToken=${NPM_TOKEN}" >> .npmrc
          echo "//${HOST_DOMAIN}/:_authToken=${NPM_TOKEN}" >> .npmrc
          echo "//${HOST_DOMAIN}/repository/:_authToken=${NPM_TOKEN}" >> .npmrc
          echo "//${HOST_PATH}/:always-auth=true" >> .npmrc
          echo "//${HOST_PATH_NO_SLASH}:always-auth=true" >> .npmrc
          echo "//${HOST_DOMAIN}/repository/:always-auth=true" >> .npmrc
          
          # Also set as environment variables for npm
          export NPM_CONFIG_USERCONFIG="$GITHUB_WORKSPACE/.npmrc"
          export NPM_CONFIG_REGISTRY="https://registry.npmjs.org/"
          export NPM_CONFIG_ALWAYS_AUTH="true"

          # Publish only @to-nexus/* workspaces using pnpm recursive publish
          echo "::add-mask::${NPM_TOKEN}" || true
          echo "=== Verifying auth via -/whoami (gate) ==="
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer ${NPM_TOKEN}" "${NEXUS_REGISTRY_URL}/-/whoami")
          if [ "$STATUS" != "200" ]; then
            echo "Auth verification failed (HTTP $STATUS). Aborting publish."
            exit 1
          fi
          echo "=== Attempting npm whoami (optional) ==="
          npm whoami --registry "${NEXUS_REGISTRY_URL}" || echo "whoami may be hidden with bearer token"

          echo "=== Publishing via pnpm (recursive, @to-nexus/* only) ==="
          # Ensure both env vars are present for npm config resolution
          export npm_config_userconfig="$GITHUB_WORKSPACE/.npmrc"
          if NPM_CONFIG_USERCONFIG="$GITHUB_WORKSPACE/.npmrc" pnpm -r \
            --filter "@to-nexus/*" \
            --filter "!@to-nexus/sign-client" \
            publish --access public --tag alpha --registry "${NEXUS_REGISTRY_URL}" --no-git-checks; then
            echo "PUBLISH_SUCCESS=true" >> $GITHUB_OUTPUT
          else
            echo "PUBLISH_SUCCESS=false" >> $GITHUB_OUTPUT
            exit 1
          fi
        env:
          NEXUS_REGISTRY_URL: ${{ steps.registry.outputs.NEXUS_URL }}
          NPM_TOKEN: ${{ secrets.NEXUS_NPM_TOKEN }}

      - name: Restore publishConfig.registry from HEAD (dev)
        if: inputs.environment == 'dev' && inputs.dry_run == 'false'
        run: |
          node -e '
            const { execSync } = require("child_process");
            const fs = require("fs");
            const path = require("path");
            function collect(root){
              const out=[]; if(!fs.existsSync(root)) return out;
              const stack=[root];
              while(stack.length){
                const dir=stack.pop();
                for(const ent of fs.readdirSync(dir,{withFileTypes:true})){
                  if(ent.name === "node_modules" || ent.name.startsWith(".")) continue;
                  const p=path.join(dir, ent.name);
                  if(ent.isDirectory()) stack.push(p);
                  else if(ent.isFile() && ent.name === "package.json") out.push(p);
                }
              }
              return out;
            }
            const files=[...collect("./packages"), ...collect("./providers")];
            let reverted=0;
            for(const f of files){
              const curr = JSON.parse(fs.readFileSync(f, "utf8"));
              if(!curr.name || !/^@to-nexus\//.test(curr.name)) continue;
              try{
                const headJson = execSync(`git show HEAD:${f}`,{stdio:["ignore","pipe","pipe"]}).toString();
                const head = JSON.parse(headJson);
                const headReg = head.publishConfig && head.publishConfig.registry;
                if(curr.publishConfig && curr.publishConfig.registry && headReg && curr.publishConfig.registry !== headReg){
                  curr.publishConfig.registry = headReg;
                  fs.writeFileSync(f, JSON.stringify(curr, null, 2) + "\n");
                  reverted++;
                }
              }catch(e){ /* ignore if file not in HEAD */ }
            }
            console.log("publishConfig.registry restored for", reverted, "files");
          '

      - name: Commit version changes (dev - after successful publish)
        if: inputs.environment == 'dev' && inputs.dry_run == 'false' && steps.publish_dev.outputs.PUBLISH_SUCCESS == 'true' && steps.version.outputs.VERSION_CHANGES_READY == 'true'
        run: |
          git add -A
          git restore --staged .npmrc 2>/dev/null || true
          git commit -m "chore: set workspace version to ${{ steps.version.outputs.REF_VERSION }}"
          git fetch origin "${GITHUB_REF_NAME}" || true
          git rebase "origin/${GITHUB_REF_NAME}" || git merge --ff-only "origin/${GITHUB_REF_NAME}" || true
          git push || git push --force-with-lease

      - name: Rollback version changes (dev - if publish failed)
        if: inputs.environment == 'dev' && failure() && steps.version.outputs.VERSION_CHANGES_READY == 'true'
        run: |
          echo "âš ï¸ Publish failed, rolling back version changes..."
          git reset --hard HEAD


      - name: Publish package to Nexus (stage â†’ beta)
        if: inputs.environment == 'stage' && inputs.dry_run == 'false' && steps.version.outputs.VERSION_BUMPED == 'true'
        id: publish_stage
        run: |
          HOST_PATH="${NEXUS_REGISTRY_URL#https://}"
          HOST_PATH_NO_SLASH="${HOST_PATH%/}"
          HOST_DOMAIN="${HOST_PATH%%/*}"
          
          # Create .npmrc and set npm environment variables
          echo "registry=https://registry.npmjs.org/" > .npmrc
          echo "@to-nexus:registry=${NEXUS_REGISTRY_URL}" >> .npmrc
          echo "//${HOST_PATH}/:_authToken=${NPM_TOKEN}" >> .npmrc
          echo "//${HOST_PATH}/:always-auth=true" >> .npmrc
          echo "//${HOST_DOMAIN}/repository/:_authToken=${NPM_TOKEN}" >> .npmrc
          echo "//${HOST_DOMAIN}/repository/:always-auth=true" >> .npmrc
          
          # Also set as environment variables for npm
          export NPM_CONFIG_USERCONFIG="$GITHUB_WORKSPACE/.npmrc"
          export NPM_CONFIG_REGISTRY="https://registry.npmjs.org/"
          export NPM_CONFIG_ALWAYS_AUTH="true"

          echo "::add-mask::${NPM_TOKEN}" || true
          echo "=== Testing npm whoami ==="
          npm whoami --registry "${NEXUS_REGISTRY_URL}" || echo "npm whoami failed"
          
          export npm_config_userconfig="$GITHUB_WORKSPACE/.npmrc"
          if NPM_CONFIG_USERCONFIG="$GITHUB_WORKSPACE/.npmrc" pnpm -r \
            --filter "@to-nexus/*" \
            --filter "!@to-nexus/sign-client" \
            publish --access public --tag beta --registry "${NEXUS_REGISTRY_URL}" --no-git-checks; then
            echo "PUBLISH_SUCCESS=true" >> $GITHUB_OUTPUT
          else
            echo "PUBLISH_SUCCESS=false" >> $GITHUB_OUTPUT
            exit 1
          fi
        env:
          NEXUS_REGISTRY_URL: ${{ steps.registry.outputs.NEXUS_URL }}
          NPM_TOKEN: ${{ secrets.NEXUS_NPM_TOKEN }}

      - name: Restore publishConfig.registry from HEAD (stage)
        if: inputs.environment == 'stage' && inputs.dry_run == 'false'
        run: |
          node -e '
            const { execSync } = require("child_process");
            const fs = require("fs");
            const path = require("path");
            function collect(root){
              const out=[]; if(!fs.existsSync(root)) return out;
              const stack=[root];
              while(stack.length){
                const dir=stack.pop();
                for(const ent of fs.readdirSync(dir,{withFileTypes:true})){
                  if(ent.name === "node_modules" || ent.name.startsWith(".")) continue;
                  const p=path.join(dir, ent.name);
                  if(ent.isDirectory()) stack.push(p);
                  else if(ent.isFile() && ent.name === "package.json") out.push(p);
                }
              }
              return out;
            }
            const files=[...collect("./packages"), ...collect("./providers")];
            let reverted=0;
            for(const f of files){
              const curr = JSON.parse(fs.readFileSync(f, "utf8"));
              if(!curr.name || !/^@to-nexus\//.test(curr.name)) continue;
              try{
                const headJson = execSync(`git show HEAD:${f}`,{stdio:["ignore","pipe","pipe"]}).toString();
                const head = JSON.parse(headJson);
                const headReg = head.publishConfig && head.publishConfig.registry;
                if(curr.publishConfig && curr.publishConfig.registry && headReg && curr.publishConfig.registry !== headReg){
                  curr.publishConfig.registry = headReg;
                  fs.writeFileSync(f, JSON.stringify(curr, null, 2) + "\n");
                  reverted++;
                }
              }catch(e){ /* ignore if file not in HEAD */ }
            }
            console.log("publishConfig.registry restored for", reverted, "files");
          '

      - name: Commit version changes (stage - after successful publish)
        if: inputs.environment == 'stage' && inputs.dry_run == 'false' && steps.publish_stage.outputs.PUBLISH_SUCCESS == 'true' && steps.version.outputs.VERSION_CHANGES_READY == 'true'
        run: |
          git add -A
          git restore --staged .npmrc 2>/dev/null || true
          git commit -m "chore: set workspace version to ${{ steps.version.outputs.REF_VERSION }}"
          git fetch origin "${GITHUB_REF_NAME}" || true
          git rebase "origin/${GITHUB_REF_NAME}" || git merge --ff-only "origin/${GITHUB_REF_NAME}" || true
          git push || git push --force-with-lease

      - name: Rollback version changes (stage - if publish failed)
        if: inputs.environment == 'stage' && failure() && steps.version.outputs.VERSION_CHANGES_READY == 'true'
        run: |
          echo "âš ï¸ Publish failed, rolling back version changes..."
          git reset --hard HEAD

      - name: Publish package to Nexus (prod â†’ latest)
        if: inputs.environment == 'prod' && inputs.dry_run == 'false' && github.ref == 'refs/heads/main' && steps.version_bump.outputs.VERSION_BUMPED == 'true'
        run: pnpm run publish:latest
        env:
          NEXUS_REGISTRY_URL: ${{ secrets.NEXUS_REGISTRY_URL }}

      - name: Create and push release tag (prod)
        if: inputs.environment == 'prod' && inputs.dry_run == 'false' && github.ref == 'refs/heads/main'
        run: |
          TAG="release/${{ steps.version.outputs.REF_VERSION }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG already exists, skipping"
          else
            git tag -a "$TAG" -m "Release $TAG"
            git fetch origin "$TAG" || true
            git push origin "$TAG" || git push --force-with-lease origin "$TAG"
          fi

      - name: Create GitHub Release (prod)
        if: inputs.environment == 'prod' && inputs.dry_run == 'false' && github.ref == 'refs/heads/main'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: release/${{ steps.version.outputs.REF_VERSION }}
          name: Release ${{ steps.version.outputs.REF_VERSION }}
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create and push pre-release tag (dev/stage)
        if: (inputs.environment == 'dev' || inputs.environment == 'stage') && inputs.dry_run == 'false'
        run: |
          # Use REF_VERSION as-is since it already contains the prerelease suffix
          TAG="release/${{ steps.version.outputs.REF_VERSION }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG already exists, skipping"
          else
            git tag -a "$TAG" -m "Pre-Release ${{ steps.version.outputs.REF_VERSION }}"
            git fetch origin "$TAG" || true
            git push origin "$TAG" || git push --force-with-lease origin "$TAG"
          fi

      - name: Create GitHub Pre-Release (dev/stage)
        if: (inputs.environment == 'dev' || inputs.environment == 'stage') && inputs.dry_run == 'false'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: release/${{ steps.version.outputs.REF_VERSION }}
          name: Pre-Release ${{ steps.version.outputs.REF_VERSION }} (${{ inputs.environment }})
          prerelease: true
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Dry-run summary (no publish/tag)
        if: inputs.dry_run == 'true'
        run: |
          echo "## Dry Run Summary" >> $GITHUB_STEP_SUMMARY
          echo "- Environment: ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- Service: ${{ inputs.services }}" >> $GITHUB_STEP_SUMMARY
          echo "- Version: ${{ steps.version.outputs.REF_VERSION }}" >> $GITHUB_STEP_SUMMARY
          echo "- Actions Skipped: publish, tag, GitHub Release" >> $GITHUB_STEP_SUMMARY

  publish_npm_prod:
    name: Publish to Nexus NPM (prod)
    needs: [sonarqube, version_bump]
    if: |
      (github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main' && inputs.environment == 'prod' && (inputs.services == 'all' || inputs.services == 'package-publish')) ||
      (github.event_name == 'push' && github.ref == 'refs/heads/main')
    runs-on: ubuntu-latest
    environment: prod
    env:
      VITE_PROJECT_ID: ${{ secrets.VITE_PROJECT_ID }}
      VITE_API_URL: ${{ secrets.VITE_API_URL }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
      
      - name: Configure npm for Nexus
        run: |
          HOST_PATH="${NEXUS_REGISTRY_URL#https://}"
          HOST_PATH_NO_SLASH="${HOST_PATH%/}"
          HOST_DOMAIN="${HOST_PATH%%/*}"
          echo "@to-nexus:registry=${NEXUS_REGISTRY_URL}" > .npmrc
          echo "//${HOST_PATH}/:_authToken=${NPM_TOKEN}" >> .npmrc
          echo "//${HOST_PATH_NO_SLASH}:_authToken=${NPM_TOKEN}" >> .npmrc
          echo "//${HOST_DOMAIN}/:_authToken=${NPM_TOKEN}" >> .npmrc
          echo "//${HOST_DOMAIN}/repository/:_authToken=${NPM_TOKEN}" >> .npmrc
          echo "//${HOST_PATH}/:always-auth=true" >> .npmrc
          echo "//${HOST_PATH_NO_SLASH}:always-auth=true" >> .npmrc
          echo "//${HOST_DOMAIN}/repository/:always-auth=true" >> .npmrc
          echo "always-auth=true" >> .npmrc
          echo "NPM_CONFIG_USERCONFIG=$GITHUB_WORKSPACE/.npmrc" >> $GITHUB_ENV
        env:
          NEXUS_REGISTRY_URL: ${{ secrets.NEXUS_REGISTRY_URL }}
          NPM_TOKEN: ${{ secrets.NEXUS_NPM_TOKEN }}
          NPM_CONFIG_USERCONFIG: ${{ github.workspace }}/.npmrc
      
      - name: Verify npm authentication
        run: |
          echo "::add-mask::${NPM_TOKEN}" || true
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer ${NPM_TOKEN}" "${NEXUS_REGISTRY_URL}/-/whoami")
          if [ "$STATUS" != "200" ]; then
            echo "Auth verification failed (HTTP $STATUS)."
            exit 1
          fi
          npm ping --registry "${NEXUS_REGISTRY_URL}" || true
      
      - name: Install pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9.5.0
      
      - name: Install dependencies
        run: pnpm install --no-frozen-lockfile
      
      - name: Compute version
        id: version
        run: |
          VERSION=$(node -e "const fs=require('fs'); let v=null; if(fs.existsSync('version.json')){v=JSON.parse(fs.readFileSync('version.json','utf8')).version;} else {v=require('./package.json').version;} console.log(v)")
          BASE_VERSION=$(echo "$VERSION" | sed 's/-.*$//')
          echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT
          echo "BASE_VERSION=${BASE_VERSION}" >> $GITHUB_OUTPUT

      - name: Set workspace version to base (prod)
        run: |
          pnpm run version:set "${{ steps.version.outputs.BASE_VERSION }}"

      - name: Build packages
        run: |
          pnpm -w run build
        env:
          APP_VERSION: ${{ steps.version.outputs.BASE_VERSION }} 
      
      - name: Publish package to Nexus (prod â†’ latest)
        if: inputs.dry_run == 'false' && needs.version_bump.outputs.can_publish == 'true'
        run: |
          export NPM_CONFIG_USERCONFIG="$GITHUB_WORKSPACE/.npmrc"
          export npm_config_userconfig="$GITHUB_WORKSPACE/.npmrc"
          pnpm -r \
            --filter "@to-nexus/*" \
            --filter "!@to-nexus/sign-client" \
            publish --access public --tag latest --registry "${NEXUS_REGISTRY_URL}" --no-git-checks
        env:
          NEXUS_REGISTRY_URL: ${{ secrets.NEXUS_REGISTRY_URL }}
      
      - name: Create and push release tag (prod)
        if: inputs.dry_run == 'false' && needs.version_bump.outputs.can_publish == 'true'
        run: |
          TAG="release/${{ steps.version.outputs.BASE_VERSION }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG already exists, skipping"
          else
            git tag -a "$TAG" -m "Release $TAG"
            git fetch origin "$TAG" || true
            git push origin "$TAG" || git push --force-with-lease origin "$TAG"
          fi
      
      - name: Create GitHub Release (prod)
        if: inputs.dry_run == 'false' && needs.version_bump.outputs.can_publish == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: release/${{ steps.version.outputs.BASE_VERSION }}
          name: Release v${{ steps.version.outputs.BASE_VERSION }}
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build_and_push_dev:
    name: Build and Push Docker Image (dev)
    # develop ì˜ dev ì „ìš©, sample-pageëŠ” ë…ë¦½ ì‹¤í–‰
    if: |
      github.event_name == 'workflow_dispatch' && ((github.ref == 'refs/heads/develop') || startsWith(github.ref, 'refs/heads/feature/')) && inputs.environment == 'dev' && (inputs.services == 'all' || inputs.services == 'sample-page')
    runs-on: ubuntu-latest

    environment: ${{ inputs.environment }}
    env:
      VITE_PROJECT_ID: ${{ secrets.VITE_PROJECT_ID }}
      VITE_API_URL: ${{ secrets.VITE_API_URL }}

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Resolve Nexus registry URL (dev)
        id: registry_dev
        run: |
          if [ "${{ inputs.environment }}" = "dev" ]; then
            url="${DEV_VAR:-$DEV_SECRET}"
          elif [ "${{ inputs.environment }}" = "stage" ]; then
            url="${STAGE_VAR:-$STAGE_SECRET}"
          else
            url="$PROD_SECRET"
          fi
          echo "NEXUS_URL=$url" >> $GITHUB_OUTPUT
        env:
          DEV_VAR: ${{ vars.NEXUS_DEV_REGISTRY_URL }}
          DEV_SECRET: ${{ secrets.NEXUS_DEV_REGISTRY_URL }}
          STAGE_VAR: ${{ vars.NEXUS_STAGE_REGISTRY_URL }}
          STAGE_SECRET: ${{ secrets.NEXUS_STAGE_REGISTRY_URL }}
          PROD_SECRET: ${{ secrets.NEXUS_REGISTRY_URL }}

      - name: Configure npm for Nexus
        run: |
          echo "//${NEXUS_REGISTRY_URL#https://}:_authToken=${NPM_TOKEN}" > .npmrc
          echo "@to-nexus:registry=${{ steps.registry_dev.outputs.NEXUS_URL }}" >> .npmrc
        env:
          NEXUS_REGISTRY_URL: ${{ secrets.NEXUS_REGISTRY_URL }}
          NPM_TOKEN: ${{ secrets.NEXUS_NPM_TOKEN }}

      - name: Get Service Name
        id: env
        run: |
          REPO_NAME=$(echo ${{ github.repository }} | cut -d'/' -f2)
          echo "SERVICE_NAME=${REPO_NAME}" >> $GITHUB_OUTPUT
          echo "GIT_SHA=$(echo $GITHUB_SHA | cut -c1-7)" >> $GITHUB_OUTPUT
          ENV_NAME=${{ inputs.environment }}
          echo "ENV_NAME=${ENV_NAME}" >> $GITHUB_OUTPUT
          echo "ECR_REPO=${ENV_NAME}/${REPO_NAME}" >> $GITHUB_OUTPUT

      - name: Configure AWS Credentials
        if: inputs.dry_run == 'false'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ vars.ACCOUNT_ID }}:role/${{ vars.OIDC_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Login to AWS ECR
        if: inputs.dry_run == 'false'
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build and Push Docker Image
        if: inputs.dry_run == 'false'
        uses: docker/build-push-action@v6
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        with:
          context: .
          file: ./Dockerfile
          push: true
          cache-from: type=gha
          cache-to: type=gha,mode=max
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ steps.env.outputs.ECR_REPO }}:${{ steps.env.outputs.GIT_SHA }}
            ${{ steps.login-ecr.outputs.registry }}/${{ steps.env.outputs.ECR_REPO }}:latest
          platforms: linux/amd64
          build-args: |
            WORKDIR=/nexus/apps/${{ steps.env.outputs.SERVICE_NAME }}
            SERVICE_NAME=${{ steps.env.outputs.SERVICE_NAME }}
            VITE_PROJECT_ID=${{ secrets.VITE_PROJECT_ID }}
            VITE_ENV_MODE=${{ vars.VITE_ENV_MODE }}
            REGISTRY_URL=${{ steps.registry_dev.outputs.NEXUS_URL }}
          secrets: |
            github_token=${{ secrets.READ_ONLY_REPO }}
            npmrc=./.npmrc

      - name: Build Docker Image (dry run, no push)
        if: inputs.dry_run == 'true'
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: false
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64
          build-args: |
            WORKDIR=/nexus/apps/${{ steps.env.outputs.SERVICE_NAME }}
            SERVICE_NAME=${{ steps.env.outputs.SERVICE_NAME }}
            VITE_PROJECT_ID=${{ secrets.VITE_PROJECT_ID }}
            VITE_ENV_MODE=${{ vars.VITE_ENV_MODE }}
            REGISTRY_URL=${{ steps.registry_dev.outputs.NEXUS_URL }}
          secrets: |
            github_token=${{ secrets.READ_ONLY_REPO }}
            npmrc=./.npmrc

  build_and_push_stage:
    name: Build and Push Docker Image (stage)
    needs: [sonarqube]
    # release/* | feature/* ì˜ stage ì „ìš©, sample-pageëŠ” ë…ë¦½ ì‹¤í–‰, SonarQube í›„ ì‹¤í–‰
    if: |
      github.event_name == 'workflow_dispatch' && (startsWith(github.ref, 'refs/heads/release/') || startsWith(github.ref, 'refs/heads/feature/')) && inputs.environment == 'stage' && (inputs.services == 'all' || inputs.services == 'sample-page')
    runs-on: ubuntu-latest

    environment: ${{ inputs.environment }}
    env:
      VITE_PROJECT_ID: ${{ secrets.VITE_PROJECT_ID }}
      VITE_API_URL: ${{ secrets.VITE_API_URL }}

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Resolve Nexus registry URL (stage)
        id: registry_stage
        run: |
          if [ "${{ inputs.environment }}" = "dev" ]; then
            url="${DEV_VAR:-$DEV_SECRET}"
          elif [ "${{ inputs.environment }}" = "stage" ]; then
            url="${STAGE_VAR:-$STAGE_SECRET}"
          else
            url="$PROD_SECRET"
          fi
          echo "NEXUS_URL=$url" >> $GITHUB_OUTPUT
        env:
          DEV_VAR: ${{ vars.NEXUS_DEV_REGISTRY_URL }}
          DEV_SECRET: ${{ secrets.NEXUS_DEV_REGISTRY_URL }}
          STAGE_VAR: ${{ vars.NEXUS_STAGE_REGISTRY_URL }}
          STAGE_SECRET: ${{ secrets.NEXUS_STAGE_REGISTRY_URL }}
          PROD_SECRET: ${{ secrets.NEXUS_REGISTRY_URL }}

      - name: Configure npm for Nexus
        run: |
          echo "//${NEXUS_REGISTRY_URL#https://}:_authToken=${NPM_TOKEN}" > .npmrc
          echo "@to-nexus:registry=${{ steps.registry_stage.outputs.NEXUS_URL }}" >> .npmrc
        env:
          NEXUS_REGISTRY_URL: ${{ secrets.NEXUS_REGISTRY_URL }}
          NPM_TOKEN: ${{ secrets.NEXUS_NPM_TOKEN }}

      - name: Get Service Name
        id: env
        run: |
          REPO_NAME=$(echo ${{ github.repository }} | cut -d'/' -f2)
          echo "SERVICE_NAME=${REPO_NAME}" >> $GITHUB_OUTPUT
          echo "GIT_SHA=$(echo $GITHUB_SHA | cut -c1-7)" >> $GITHUB_OUTPUT
          ENV_NAME=${{ inputs.environment }}
          echo "ENV_NAME=${ENV_NAME}" >> $GITHUB_OUTPUT
          echo "ECR_REPO=${ENV_NAME}/${REPO_NAME}" >> $GITHUB_OUTPUT

      - name: Configure AWS Credentials
        if: inputs.dry_run == 'false'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ vars.ACCOUNT_ID }}:role/${{ vars.OIDC_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Login to AWS ECR
        if: inputs.dry_run == 'false'
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build and Push Docker Image
        if: inputs.dry_run == 'false'
        uses: docker/build-push-action@v6
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        with:
          context: .
          file: ./Dockerfile
          push: true
          cache-from: type=gha
          cache-to: type=gha,mode=max
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ steps.env.outputs.ECR_REPO }}:${{ steps.env.outputs.GIT_SHA }}
            ${{ steps.login-ecr.outputs.registry }}/${{ steps.env.outputs.ECR_REPO }}:latest
          platforms: linux/amd64
          build-args: |
            WORKDIR=/nexus/apps/${{ steps.env.outputs.SERVICE_NAME }}
            SERVICE_NAME=${{ steps.env.outputs.SERVICE_NAME }}
            VITE_PROJECT_ID=${{ secrets.VITE_PROJECT_ID }}
            VITE_ENV_MODE=${{ vars.VITE_ENV_MODE }}
            REGISTRY_URL=${{ steps.registry_stage.outputs.NEXUS_URL }}
          secrets: |
            github_token=${{ secrets.READ_ONLY_REPO }}
            npmrc=./.npmrc

      - name: Build Docker Image (dry run, no push)
        if: inputs.dry_run == 'true'
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: false
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64
          build-args: |
            WORKDIR=/nexus/apps/${{ steps.env.outputs.SERVICE_NAME }}
            SERVICE_NAME=${{ steps.env.outputs.SERVICE_NAME }}
            VITE_PROJECT_ID=${{ secrets.VITE_PROJECT_ID }}
            VITE_ENV_MODE=${{ vars.VITE_ENV_MODE }}
            REGISTRY_URL=${{ steps.registry_stage.outputs.NEXUS_URL }}
          secrets: |
            github_token=${{ secrets.READ_ONLY_REPO }}
            npmrc=./.npmrc

  build_and_push_prod:
    name: Build and Push Docker Image (prod)
    needs: [sonarqube]
    if: |
      github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main' && inputs.environment == 'prod' && (inputs.services == 'all' || inputs.services == 'sample-page')
    runs-on: ubuntu-latest

    environment: ${{ inputs.environment }}

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'

      - name: Install pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9.5.0

      - name: Set workspace version for prod build
        run: |
          # For prod, use publish_version without prerelease suffix
          VERSION="${{ inputs.publish_version }}"
          # Remove any existing prerelease suffix for prod
          VERSION=$(echo "$VERSION" | sed 's/-.*$//')
          echo "Setting workspace version to: $VERSION"
          pnpm run version:set "$VERSION"

      - name: Configure npm for Nexus
        run: |
          echo "//${NEXUS_REGISTRY_URL#https://}:_authToken=${NPM_TOKEN}" > .npmrc
          echo "@to-nexus:registry=${{ secrets.NEXUS_REGISTRY_URL }}" >> .npmrc
        env:
          NEXUS_REGISTRY_URL: ${{ secrets.NEXUS_REGISTRY_URL }}
          NPM_TOKEN: ${{ secrets.NEXUS_NPM_TOKEN }}

      - name: Get Service Name
        id: env
        run: |
          REPO_NAME=$(echo ${{ github.repository }} | cut -d'/' -f2)
          echo "SERVICE_NAME=${REPO_NAME}" >> $GITHUB_OUTPUT
          echo "GIT_SHA=$(echo $GITHUB_SHA | cut -c1-7)" >> $GITHUB_OUTPUT
          ENV_NAME=${{ inputs.environment }}
          echo "ENV_NAME=${ENV_NAME}" >> $GITHUB_OUTPUT
          echo "ECR_REPO=${ENV_NAME}/${REPO_NAME}" >> $GITHUB_OUTPUT

      - name: Configure AWS Credentials
        if: inputs.dry_run == 'false'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ vars.ACCOUNT_ID }}:role/${{ vars.OIDC_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Login to AWS ECR
        if: inputs.dry_run == 'false'
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build and Push Docker Image
        if: inputs.dry_run == 'false'
        uses: docker/build-push-action@v6
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        with:
          context: .
          file: ./Dockerfile
          push: true
          cache-from: type=gha
          cache-to: type=gha,mode=max
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ steps.env.outputs.ECR_REPO }}:${{ steps.env.outputs.GIT_SHA }}
            ${{ steps.login-ecr.outputs.registry }}/${{ steps.env.outputs.ECR_REPO }}:latest
          platforms: linux/amd64
          build-args: |
            WORKDIR=/nexus/apps/${{ steps.env.outputs.SERVICE_NAME }}
            SERVICE_NAME=${{ steps.env.outputs.SERVICE_NAME }}
            VITE_PROJECT_ID=${{ secrets.VITE_PROJECT_ID }}
            VITE_ENV_MODE=${{ vars.VITE_ENV_MODE }}
          secrets: |
            github_token=${{ secrets.READ_ONLY_REPO }}
            npmrc=./.npmrc


      
  cdn_publish_manual:
    name: CDN Publish (prod)
    needs: [sonarqube]
    if: |
      github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main' && inputs.environment == 'prod' && (inputs.services == 'all' || inputs.services == 'cdn-publish')
    runs-on: ubuntu-latest

    environment: ${{ inputs.environment }}
    env:
      VITE_PROJECT_ID: ${{ secrets.VITE_PROJECT_ID }}
      VITE_API_URL: ${{ secrets.VITE_API_URL }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20.x"

      - name: Install pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9.5.0

      - name: Install dependencies
        run: pnpm install --no-frozen-lockfile

      - name: Extract version from package.json
        id: extract_version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "CURRENT_VERSION=${VERSION}" >> $GITHUB_OUTPUT
          echo "Current version: ${VERSION}"

      - name: Configure AWS Credentials
        if: inputs.dry_run == 'false'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ vars.CDN_ACCOUNT_ID }}:role/${{ vars.OIDC_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Check existing versions in S3
        if: inputs.dry_run == 'false'
        id: check_versions
        run: |
          CURRENT_VERSION="${{ steps.extract_version.outputs.CURRENT_VERSION }}"
          BUCKET_NAME="${{ vars.S3_BUCKET_NAME }}"
          aws s3 ls s3://${BUCKET_NAME}/cross-sdk/ --recursive | grep -E "cross-sdk/[0-9]+\.[0-9]+\.[0-9]+" | sed -E 's/.*cross-sdk\/([0-9]+\.[0-9]+\.[0-9]+)\/.*/\1/' | sort -V | uniq > existing_versions.txt || true
          if [ -s existing_versions.txt ]; then
            LATEST_VERSION=$(tail -n 1 existing_versions.txt)
            echo "LATEST_S3_VERSION=${LATEST_VERSION}" >> $GITHUB_OUTPUT
            if [ "${CURRENT_VERSION}" = "${LATEST_VERSION}" ]; then
              echo "VERSION_EXISTS=true" >> $GITHUB_OUTPUT
            else
              echo "VERSION_EXISTS=false" >> $GITHUB_OUTPUT
            fi
            if printf '%s\n%s\n' "${LATEST_VERSION}" "${CURRENT_VERSION}" | sort -V -C; then
              echo "IS_NEWER=true" >> $GITHUB_OUTPUT
            else
              echo "IS_NEWER=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "VERSION_EXISTS=false" >> $GITHUB_OUTPUT
            echo "IS_NEWER=true" >> $GITHUB_OUTPUT
            echo "LATEST_S3_VERSION=" >> $GITHUB_OUTPUT
          fi

      - name: Build CDN packages
        if: inputs.dry_run == 'false' && steps.check_versions.outputs.VERSION_EXISTS != 'true' && steps.check_versions.outputs.IS_NEWER == 'true'
        run: pnpm run build
        env:
          APP_VERSION: ${{ steps.extract_version.outputs.CURRENT_VERSION }}

      - name: Upload to S3 with version prefix
        if: inputs.dry_run == 'false' && steps.check_versions.outputs.VERSION_EXISTS != 'true' && steps.check_versions.outputs.IS_NEWER == 'true'
        run: |
          CURRENT_VERSION="${{ steps.extract_version.outputs.CURRENT_VERSION }}"
          BUCKET_NAME="${{ vars.S3_BUCKET_NAME }}"
          aws s3 sync packages/cdn/dist/ s3://${BUCKET_NAME}/cross-sdk/${CURRENT_VERSION}/ --delete --cache-control "public, max-age=31536000, immutable" --metadata-directive REPLACE

      - name: Update latest if current version is newest
        if: inputs.dry_run == 'false' && steps.check_versions.outputs.VERSION_EXISTS != 'true' && steps.check_versions.outputs.IS_NEWER == 'true'
        run: |
          CURRENT_VERSION="${{ steps.extract_version.outputs.CURRENT_VERSION }}"
          BUCKET_NAME="${{ vars.S3_BUCKET_NAME }}"
          aws s3 sync s3://${BUCKET_NAME}/cross-sdk/${CURRENT_VERSION}/ s3://${BUCKET_NAME}/cross-sdk/latest/ --delete --cache-control "public, max-age=3600" --metadata-directive REPLACE

      - name: Invalidate CloudFront cache
        if: inputs.dry_run == 'false' && steps.check_versions.outputs.VERSION_EXISTS != 'true' && steps.check_versions.outputs.IS_NEWER == 'true'
        run: |
          CURRENT_VERSION="${{ steps.extract_version.outputs.CURRENT_VERSION }}"
          aws cloudfront create-invalidation --distribution-id "${{ vars.CLOUDFRONT_DISTRIBUTION_ID }}" --paths "/cross-sdk/${CURRENT_VERSION}/*" "/cross-sdk/latest/*"

      - name: CDN summary
        run: |
          CURRENT_VERSION="${{ steps.extract_version.outputs.CURRENT_VERSION }}"
          echo "## CDN Publish Summary" >> $GITHUB_STEP_SUMMARY
          echo "- Version: ${CURRENT_VERSION}" >> $GITHUB_STEP_SUMMARY
          echo "- Dry-run: ${{ inputs.dry_run }}" >> $GITHUB_STEP_SUMMARY
