var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __publicField = (obj, key2, value) => __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var _a2, _b, _listener, _listeners2, _cancelled, _allowInsecure, _gzip, _headers, _method, _timeout, _url, _body, _bodyType, _creds, _preflight, _process, _retry, _signal, _throttle, _getUrlFunc, _FetchRequest_instances, send_fn, _statusCode, _statusMessage, _headers2, _body2, _request, _error, _format, _val, _tens, _FixedNumber_instances, checkFormat_fn, checkValue_fn, add_fn, sub_fn, mul_fn, div_fn, _names, _data, _dataLength, _Writer_instances, writeData_fn, _data2, _offset, _bytesRead, _parent, _maxInflation, _Reader_instances, incrementBytesRead_fn, peekBytes_fn, _r2, _s2, _v, _networkV, _privateKey, _options, _type, _to, _data3, _nonce, _gasLimit, _gasPrice, _maxPriorityFeePerGas, _maxFeePerGas, _value, _chainId, _sig, _accessList, _maxFeePerBlobGas, _blobVersionedHashes, _kzg, _blobs, _Transaction_instances, getSerialized_fn, _types, _fullTypes, _encoderCache, _TypedDataEncoder_instances, getEncoder_fn, _offset2, _tokens, _TokenString_instances, subTokenString_fn, _ParamType_instances, walkAsync_fn, _AbiCoder_instances, getCoder_fn, _errors, _events, _functions, _abiCoder, _Interface_instances, getFunction_fn, getEvent_fn, _transactions, _logs, _startBlock, _iface, _iface2, _filter, _c2, _supports2544, _resolver, _EnsResolver_instances, fetch_fn, _EnsResolver_static, getResolver_fn, _url2, _processFunc, _name, _chainId2, _plugins, _provider, _poller, _interval, _blockNumber, _PollingBlockSubscriber_instances, poll_fn, _provider2, _poll, _running, _tag, _lastBlock, _filter2, _hash, _provider3, _filter3, _poller2, _running2, _blockNumber2, _PollingEventSubscriber_instances, poll_fn2, _subs, _plugins2, _pausedState, _destroyed, _networkPromise, _anyNetwork, _performCache, _lastBlockNumber, _nextTimer, _timers, _disableCcipRead, _options2, _AbstractProvider_instances, perform_fn, call_fn, checkNetwork_fn, getAccountValue_fn, getBlock_fn, hasSub_fn, getSub_fn, _provider4, _filterIdPromise, _poller3, _running3, _network, _hault, _FilterIdSubscriber_instances, poll_fn3, teardown_fn, _event, _options3, _nextId, _payloads, _drainTimer, _notReady, _network2, _pendingDetectNetwork, _JsonRpcApiProvider_instances, scheduleDrain_fn, _pollingInterval, _connect, _provider5, _filter4, _filterId, _paused, _emitPromise, _logFilter, _callbacks, _subs2, _pending, _connect2, _websocket, _request2;
const e$7 = Symbol(), t$3 = Symbol(), r$9 = "a", n$a = "w";
let o$a = (e3, t2) => new Proxy(e3, t2);
const s$6 = Object.getPrototypeOf, c$a = /* @__PURE__ */ new WeakMap(), l$5 = (e3) => e3 && (c$a.has(e3) ? c$a.get(e3) : s$6(e3) === Object.prototype || s$6(e3) === Array.prototype), f$b = (e3) => "object" == typeof e3 && null !== e3, i$9 = (e3) => {
  if (Array.isArray(e3)) return Array.from(e3);
  const t2 = Object.getOwnPropertyDescriptors(e3);
  return Object.values(t2).forEach((e4) => {
    e4.configurable = true;
  }), Object.create(s$6(e3), t2);
}, u$3 = (e3) => e3[t$3] || e3, a$3 = (s2, c2, f6, p2) => {
  if (!l$5(s2)) return s2;
  let g2 = p2 && p2.get(s2);
  if (!g2) {
    const e3 = u$3(s2);
    g2 = ((e4) => Object.values(Object.getOwnPropertyDescriptors(e4)).some((e5) => !e5.configurable && !e5.writable))(e3) ? [e3, i$9(e3)] : [e3], null == p2 || p2.set(s2, g2);
  }
  const [y4, h5] = g2;
  let w2 = f6 && f6.get(y4);
  return w2 && w2[1].f === !!h5 || (w2 = ((o3, s3) => {
    const c3 = { f: s3 };
    let l2 = false;
    const f7 = (e3, t2) => {
      if (!l2) {
        let s4 = c3[r$9].get(o3);
        if (s4 || (s4 = {}, c3[r$9].set(o3, s4)), e3 === n$a) s4[n$a] = true;
        else {
          let r3 = s4[e3];
          r3 || (r3 = /* @__PURE__ */ new Set(), s4[e3] = r3), r3.add(t2);
        }
      }
    }, i4 = { get: (e3, n5) => n5 === t$3 ? o3 : (f7("k", n5), a$3(Reflect.get(e3, n5), c3[r$9], c3.c, c3.t)), has: (t2, n5) => n5 === e$7 ? (l2 = true, c3[r$9].delete(o3), true) : (f7("h", n5), Reflect.has(t2, n5)), getOwnPropertyDescriptor: (e3, t2) => (f7("o", t2), Reflect.getOwnPropertyDescriptor(e3, t2)), ownKeys: (e3) => (f7(n$a), Reflect.ownKeys(e3)) };
    return s3 && (i4.set = i4.deleteProperty = () => false), [i4, c3];
  })(y4, !!h5), w2[1].p = o$a(h5 || y4, w2[0]), f6 && f6.set(y4, w2)), w2[1][r$9] = c2, w2[1].c = f6, w2[1].t = p2, w2[1].p;
}, p$a = (e3, t2, r3, o3, s2 = Object.is) => {
  if (s2(e3, t2)) return false;
  if (!f$b(e3) || !f$b(t2)) return true;
  const c2 = r3.get(u$3(e3));
  if (!c2) return true;
  if (o3) {
    const r4 = o3.get(e3);
    if (r4 && r4.n === t2) return r4.g;
    o3.set(e3, { n: t2, g: false });
  }
  let l2 = null;
  try {
    for (const r4 of c2.h || []) if (l2 = Reflect.has(e3, r4) !== Reflect.has(t2, r4), l2) return l2;
    if (true === c2[n$a]) {
      if (l2 = ((e4, t3) => {
        const r4 = Reflect.ownKeys(e4), n5 = Reflect.ownKeys(t3);
        return r4.length !== n5.length || r4.some((e5, t4) => e5 !== n5[t4]);
      })(e3, t2), l2) return l2;
    } else for (const r4 of c2.o || []) if (l2 = !!Reflect.getOwnPropertyDescriptor(e3, r4) != !!Reflect.getOwnPropertyDescriptor(t2, r4), l2) return l2;
    for (const n5 of c2.k || []) if (l2 = p$a(e3[n5], t2[n5], r3, o3, s2), l2) return l2;
    return null === l2 && (l2 = true), l2;
  } finally {
    o3 && o3.set(e3, { n: t2, g: l2 });
  }
}, y$7 = (e3) => l$5(e3) && e3[t$3] || null, h$9 = (e3, t2 = true) => {
  c$a.set(e3, t2);
}, w$5 = (e3, t2, r3) => {
  const o3 = [], s2 = /* @__PURE__ */ new WeakSet(), c2 = (e4, l2) => {
    if (s2.has(e4)) return;
    f$b(e4) && s2.add(e4);
    const i4 = f$b(e4) && t2.get(u$3(e4));
    if (i4) {
      var a2, p2;
      if (null == (a2 = i4.h) || a2.forEach((e5) => {
        const t3 = `:has(${String(e5)})`;
        o3.push(l2 ? [...l2, t3] : [t3]);
      }), true === i4[n$a]) {
        const e5 = ":ownKeys";
        o3.push(l2 ? [...l2, e5] : [e5]);
      } else {
        var g2;
        null == (g2 = i4.o) || g2.forEach((e5) => {
          const t3 = `:hasOwn(${String(e5)})`;
          o3.push(l2 ? [...l2, t3] : [t3]);
        });
      }
      null == (p2 = i4.k) || p2.forEach((t3) => {
        !("value" in (Object.getOwnPropertyDescriptor(e4, t3) || {})) || c2(e4[t3], l2 ? [...l2, t3] : [t3]);
      });
    } else l2 && o3.push(l2);
  };
  return c2(e3), o3;
};
const __vite_import_meta_env__$2 = {};
const isObject = (x2) => typeof x2 === "object" && x2 !== null;
const proxyStateMap = /* @__PURE__ */ new WeakMap();
const refSet = /* @__PURE__ */ new WeakSet();
const buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), canProxy = (x2) => isObject(x2) && !refSet.has(x2) && (Array.isArray(x2) || !(Symbol.iterator in x2)) && !(x2 instanceof WeakMap) && !(x2 instanceof WeakSet) && !(x2 instanceof Error) && !(x2 instanceof Number) && !(x2 instanceof Date) && !(x2 instanceof String) && !(x2 instanceof RegExp) && !(x2 instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version2, handlePromise = defaultHandlePromise) => {
  const cache = snapCache.get(target);
  if ((cache == null ? void 0 : cache[0]) === version2) {
    return cache[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  h$9(snap, true);
  snapCache.set(target, [version2, snap]);
  Reflect.ownKeys(target).forEach((key2) => {
    if (Object.getOwnPropertyDescriptor(snap, key2)) {
      return;
    }
    const value = Reflect.get(target, key2);
    const { enumerable } = Reflect.getOwnPropertyDescriptor(
      target,
      key2
    );
    const desc = {
      value,
      enumerable,
      // This is intentional to avoid copying with proxy-compare.
      // It's still non-writable, so it avoids assigning a value.
      configurable: true
    };
    if (refSet.has(value)) {
      h$9(value, false);
    } else if (value instanceof Promise) {
      delete desc.value;
      desc.get = () => handlePromise(value);
    } else if (proxyStateMap.has(value)) {
      const [target2, ensureVersion] = proxyStateMap.get(
        value
      );
      desc.value = createSnapshot(
        target2,
        ensureVersion(),
        handlePromise
      );
    }
    Object.defineProperty(snap, key2, desc);
  });
  return Object.preventExtensions(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction = (initialObject) => {
  if (!isObject(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version2 = versionHolder[0];
  const listeners2 = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version2 !== nextVersion) {
      version2 = nextVersion;
      listeners2.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners2.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version2) {
          version2 = propVersion;
        }
      });
    }
    return version2;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if ((__vite_import_meta_env__$2 ? "production" : void 0) !== "production" && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners2.size) {
      const remove = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a3;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a3 = entry[1]) == null ? void 0 : _a3.call(entry);
    }
  };
  const addListener2 = (listener) => {
    listeners2.add(listener);
    if (listeners2.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if ((__vite_import_meta_env__$2 ? "production" : void 0) !== "production" && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove]);
      });
    }
    const removeListener2 = () => {
      listeners2.delete(listener);
      if (listeners2.size === 0) {
        propProxyStates.forEach(([propProxyState, remove], prop) => {
          if (remove) {
            remove();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener2;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject(value)) {
        value = y$7(value) || value;
      }
      let nextValue = value;
      if (value instanceof Promise) {
        value.then((v2) => {
          value.status = "fulfilled";
          value.value = v2;
          notifyUpdate(["resolve", [prop], v2]);
        }).catch((e3) => {
          value.status = "rejected";
          value.reason = e3;
          notifyUpdate(["reject", [prop], e3]);
        });
      } else {
        if (!proxyStateMap.has(value) && canProxy(value)) {
          nextValue = proxyFunction(value);
        }
        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [
    baseObject,
    ensureVersion,
    createSnapshot,
    addListener2
  ];
  proxyStateMap.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key2) => {
    const desc = Object.getOwnPropertyDescriptor(
      initialObject,
      key2
    );
    if ("value" in desc) {
      proxyObject[key2] = initialObject[key2];
      delete desc.value;
      delete desc.writable;
    }
    Object.defineProperty(baseObject, key2, desc);
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction,
  // shared state
  proxyStateMap,
  refSet,
  // internal things
  objectIs,
  newProxy,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
const [defaultProxyFunction] = buildProxyFunction();
function proxy(initialObject = {}) {
  return defaultProxyFunction(initialObject);
}
function subscribe(proxyObject, callback, notifyInSync) {
  const proxyState = proxyStateMap.get(proxyObject);
  if ((__vite_import_meta_env__$2 ? "production" : void 0) !== "production" && !proxyState) {
    console.warn("Please use proxy object");
  }
  let promise;
  const ops = [];
  const addListener2 = proxyState[3];
  let isListenerActive = false;
  const listener = (op) => {
    ops.push(op);
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        if (isListenerActive) {
          callback(ops.splice(0));
        }
      });
    }
  };
  const removeListener2 = addListener2(listener);
  isListenerActive = true;
  return () => {
    isListenerActive = false;
    removeListener2();
  };
}
function snapshot(proxyObject, handlePromise) {
  const proxyState = proxyStateMap.get(proxyObject);
  if ((__vite_import_meta_env__$2 ? "production" : void 0) !== "production" && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}
function ref$1(obj) {
  refSet.add(obj);
  return obj;
}
function subscribeKey(proxyObject, key2, callback, notifyInSync) {
  let prevValue = proxyObject[key2];
  return subscribe(
    proxyObject,
    () => {
      const nextValue = proxyObject[key2];
      if (!Object.is(prevValue, nextValue)) {
        callback(prevValue = nextValue);
      }
    }
  );
}
function proxyMap(entries) {
  const map = proxy({
    data: Array.from([]),
    has(key2) {
      return this.data.some((p2) => p2[0] === key2);
    },
    set(key2, value) {
      const record = this.data.find((p2) => p2[0] === key2);
      if (record) {
        record[1] = value;
      } else {
        this.data.push([key2, value]);
      }
      return this;
    },
    get(key2) {
      var _a3;
      return (_a3 = this.data.find((p2) => p2[0] === key2)) == null ? void 0 : _a3[1];
    },
    delete(key2) {
      const index2 = this.data.findIndex((p2) => p2[0] === key2);
      if (index2 === -1) {
        return false;
      }
      this.data.splice(index2, 1);
      return true;
    },
    clear() {
      this.data.splice(0);
    },
    get size() {
      return this.data.length;
    },
    toJSON() {
      return new Map(this.data);
    },
    forEach(cb) {
      this.data.forEach((p2) => {
        cb(p2[1], p2[0], this);
      });
    },
    keys() {
      return this.data.map((p2) => p2[0]).values();
    },
    values() {
      return this.data.map((p2) => p2[1]).values();
    },
    entries() {
      return new Map(this.data).entries();
    },
    get [Symbol.toStringTag]() {
      return "Map";
    },
    [Symbol.iterator]() {
      return this.entries();
    }
  });
  Object.defineProperties(map, {
    data: {
      enumerable: false
    },
    size: {
      enumerable: false
    },
    toJSON: {
      enumerable: false
    }
  });
  Object.seal(map);
  return map;
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs$1(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n5) {
  if (n5.__esModule) return n5;
  var f6 = n5.default;
  if (typeof f6 == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f6, arguments, this.constructor);
      }
      return f6.apply(this, arguments);
    };
    a2.prototype = f6.prototype;
  } else a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n5).forEach(function(k3) {
    var d4 = Object.getOwnPropertyDescriptor(n5, k3);
    Object.defineProperty(a2, k3, d4.get ? d4 : {
      enumerable: true,
      get: function() {
        return n5[k3];
      }
    });
  });
  return a2;
}
var dayjs_min = { exports: {} };
(function(module, exports2) {
  !function(t2, e3) {
    module.exports = e3();
  }(commonjsGlobal, function() {
    var t2 = 1e3, e3 = 6e4, n5 = 36e5, r3 = "millisecond", i4 = "second", s2 = "minute", u2 = "hour", a2 = "day", o3 = "week", c2 = "month", f6 = "quarter", h5 = "year", d4 = "date", l2 = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y4 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M4 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
      var e4 = ["th", "st", "nd", "rd"], n6 = t3 % 100;
      return "[" + t3 + (e4[(n6 - 20) % 10] || e4[n6] || e4[0]) + "]";
    } }, m4 = function(t3, e4, n6) {
      var r4 = String(t3);
      return !r4 || r4.length >= e4 ? t3 : "" + Array(e4 + 1 - r4.length).join(n6) + t3;
    }, v2 = { s: m4, z: function(t3) {
      var e4 = -t3.utcOffset(), n6 = Math.abs(e4), r4 = Math.floor(n6 / 60), i5 = n6 % 60;
      return (e4 <= 0 ? "+" : "-") + m4(r4, 2, "0") + ":" + m4(i5, 2, "0");
    }, m: function t3(e4, n6) {
      if (e4.date() < n6.date()) return -t3(n6, e4);
      var r4 = 12 * (n6.year() - e4.year()) + (n6.month() - e4.month()), i5 = e4.clone().add(r4, c2), s3 = n6 - i5 < 0, u3 = e4.clone().add(r4 + (s3 ? -1 : 1), c2);
      return +(-(r4 + (n6 - i5) / (s3 ? i5 - u3 : u3 - i5)) || 0);
    }, a: function(t3) {
      return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
    }, p: function(t3) {
      return { M: c2, y: h5, w: o3, d: a2, D: d4, h: u2, m: s2, s: i4, ms: r3, Q: f6 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t3) {
      return void 0 === t3;
    } }, g2 = "en", D2 = {};
    D2[g2] = M4;
    var p2 = "$isDayjsObject", S4 = function(t3) {
      return t3 instanceof _3 || !(!t3 || !t3[p2]);
    }, w2 = function t3(e4, n6, r4) {
      var i5;
      if (!e4) return g2;
      if ("string" == typeof e4) {
        var s3 = e4.toLowerCase();
        D2[s3] && (i5 = s3), n6 && (D2[s3] = n6, i5 = s3);
        var u3 = e4.split("-");
        if (!i5 && u3.length > 1) return t3(u3[0]);
      } else {
        var a3 = e4.name;
        D2[a3] = e4, i5 = a3;
      }
      return !r4 && i5 && (g2 = i5), i5 || !r4 && g2;
    }, O4 = function(t3, e4) {
      if (S4(t3)) return t3.clone();
      var n6 = "object" == typeof e4 ? e4 : {};
      return n6.date = t3, n6.args = arguments, new _3(n6);
    }, b2 = v2;
    b2.l = w2, b2.i = S4, b2.w = function(t3, e4) {
      return O4(t3, { locale: e4.$L, utc: e4.$u, x: e4.$x, $offset: e4.$offset });
    };
    var _3 = function() {
      function M5(t3) {
        this.$L = w2(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p2] = true;
      }
      var m5 = M5.prototype;
      return m5.parse = function(t3) {
        this.$d = function(t4) {
          var e4 = t4.date, n6 = t4.utc;
          if (null === e4) return /* @__PURE__ */ new Date(NaN);
          if (b2.u(e4)) return /* @__PURE__ */ new Date();
          if (e4 instanceof Date) return new Date(e4);
          if ("string" == typeof e4 && !/Z$/i.test(e4)) {
            var r4 = e4.match($2);
            if (r4) {
              var i5 = r4[2] - 1 || 0, s3 = (r4[7] || "0").substring(0, 3);
              return n6 ? new Date(Date.UTC(r4[1], i5, r4[3] || 1, r4[4] || 0, r4[5] || 0, r4[6] || 0, s3)) : new Date(r4[1], i5, r4[3] || 1, r4[4] || 0, r4[5] || 0, r4[6] || 0, s3);
            }
          }
          return new Date(e4);
        }(t3), this.init();
      }, m5.init = function() {
        var t3 = this.$d;
        this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
      }, m5.$utils = function() {
        return b2;
      }, m5.isValid = function() {
        return !(this.$d.toString() === l2);
      }, m5.isSame = function(t3, e4) {
        var n6 = O4(t3);
        return this.startOf(e4) <= n6 && n6 <= this.endOf(e4);
      }, m5.isAfter = function(t3, e4) {
        return O4(t3) < this.startOf(e4);
      }, m5.isBefore = function(t3, e4) {
        return this.endOf(e4) < O4(t3);
      }, m5.$g = function(t3, e4, n6) {
        return b2.u(t3) ? this[e4] : this.set(n6, t3);
      }, m5.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m5.valueOf = function() {
        return this.$d.getTime();
      }, m5.startOf = function(t3, e4) {
        var n6 = this, r4 = !!b2.u(e4) || e4, f7 = b2.p(t3), l3 = function(t4, e5) {
          var i5 = b2.w(n6.$u ? Date.UTC(n6.$y, e5, t4) : new Date(n6.$y, e5, t4), n6);
          return r4 ? i5 : i5.endOf(a2);
        }, $3 = function(t4, e5) {
          return b2.w(n6.toDate()[t4].apply(n6.toDate("s"), (r4 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e5)), n6);
        }, y5 = this.$W, M6 = this.$M, m6 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
        switch (f7) {
          case h5:
            return r4 ? l3(1, 0) : l3(31, 11);
          case c2:
            return r4 ? l3(1, M6) : l3(0, M6 + 1);
          case o3:
            var g3 = this.$locale().weekStart || 0, D3 = (y5 < g3 ? y5 + 7 : y5) - g3;
            return l3(r4 ? m6 - D3 : m6 + (6 - D3), M6);
          case a2:
          case d4:
            return $3(v3 + "Hours", 0);
          case u2:
            return $3(v3 + "Minutes", 1);
          case s2:
            return $3(v3 + "Seconds", 2);
          case i4:
            return $3(v3 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m5.endOf = function(t3) {
        return this.startOf(t3, false);
      }, m5.$set = function(t3, e4) {
        var n6, o4 = b2.p(t3), f7 = "set" + (this.$u ? "UTC" : ""), l3 = (n6 = {}, n6[a2] = f7 + "Date", n6[d4] = f7 + "Date", n6[c2] = f7 + "Month", n6[h5] = f7 + "FullYear", n6[u2] = f7 + "Hours", n6[s2] = f7 + "Minutes", n6[i4] = f7 + "Seconds", n6[r3] = f7 + "Milliseconds", n6)[o4], $3 = o4 === a2 ? this.$D + (e4 - this.$W) : e4;
        if (o4 === c2 || o4 === h5) {
          var y5 = this.clone().set(d4, 1);
          y5.$d[l3]($3), y5.init(), this.$d = y5.set(d4, Math.min(this.$D, y5.daysInMonth())).$d;
        } else l3 && this.$d[l3]($3);
        return this.init(), this;
      }, m5.set = function(t3, e4) {
        return this.clone().$set(t3, e4);
      }, m5.get = function(t3) {
        return this[b2.p(t3)]();
      }, m5.add = function(r4, f7) {
        var d5, l3 = this;
        r4 = Number(r4);
        var $3 = b2.p(f7), y5 = function(t3) {
          var e4 = O4(l3);
          return b2.w(e4.date(e4.date() + Math.round(t3 * r4)), l3);
        };
        if ($3 === c2) return this.set(c2, this.$M + r4);
        if ($3 === h5) return this.set(h5, this.$y + r4);
        if ($3 === a2) return y5(1);
        if ($3 === o3) return y5(7);
        var M6 = (d5 = {}, d5[s2] = e3, d5[u2] = n5, d5[i4] = t2, d5)[$3] || 1, m6 = this.$d.getTime() + r4 * M6;
        return b2.w(m6, this);
      }, m5.subtract = function(t3, e4) {
        return this.add(-1 * t3, e4);
      }, m5.format = function(t3) {
        var e4 = this, n6 = this.$locale();
        if (!this.isValid()) return n6.invalidDate || l2;
        var r4 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i5 = b2.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o4 = n6.weekdays, c3 = n6.months, f7 = n6.meridiem, h6 = function(t4, n7, i6, s4) {
          return t4 && (t4[n7] || t4(e4, r4)) || i6[n7].slice(0, s4);
        }, d5 = function(t4) {
          return b2.s(s3 % 12 || 12, t4, "0");
        }, $3 = f7 || function(t4, e5, n7) {
          var r5 = t4 < 12 ? "AM" : "PM";
          return n7 ? r5.toLowerCase() : r5;
        };
        return r4.replace(y4, function(t4, r5) {
          return r5 || function(t5) {
            switch (t5) {
              case "YY":
                return String(e4.$y).slice(-2);
              case "YYYY":
                return b2.s(e4.$y, 4, "0");
              case "M":
                return a3 + 1;
              case "MM":
                return b2.s(a3 + 1, 2, "0");
              case "MMM":
                return h6(n6.monthsShort, a3, c3, 3);
              case "MMMM":
                return h6(c3, a3);
              case "D":
                return e4.$D;
              case "DD":
                return b2.s(e4.$D, 2, "0");
              case "d":
                return String(e4.$W);
              case "dd":
                return h6(n6.weekdaysMin, e4.$W, o4, 2);
              case "ddd":
                return h6(n6.weekdaysShort, e4.$W, o4, 3);
              case "dddd":
                return o4[e4.$W];
              case "H":
                return String(s3);
              case "HH":
                return b2.s(s3, 2, "0");
              case "h":
                return d5(1);
              case "hh":
                return d5(2);
              case "a":
                return $3(s3, u3, true);
              case "A":
                return $3(s3, u3, false);
              case "m":
                return String(u3);
              case "mm":
                return b2.s(u3, 2, "0");
              case "s":
                return String(e4.$s);
              case "ss":
                return b2.s(e4.$s, 2, "0");
              case "SSS":
                return b2.s(e4.$ms, 3, "0");
              case "Z":
                return i5;
            }
            return null;
          }(t4) || i5.replace(":", "");
        });
      }, m5.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m5.diff = function(r4, d5, l3) {
        var $3, y5 = this, M6 = b2.p(d5), m6 = O4(r4), v3 = (m6.utcOffset() - this.utcOffset()) * e3, g3 = this - m6, D3 = function() {
          return b2.m(y5, m6);
        };
        switch (M6) {
          case h5:
            $3 = D3() / 12;
            break;
          case c2:
            $3 = D3();
            break;
          case f6:
            $3 = D3() / 3;
            break;
          case o3:
            $3 = (g3 - v3) / 6048e5;
            break;
          case a2:
            $3 = (g3 - v3) / 864e5;
            break;
          case u2:
            $3 = g3 / n5;
            break;
          case s2:
            $3 = g3 / e3;
            break;
          case i4:
            $3 = g3 / t2;
            break;
          default:
            $3 = g3;
        }
        return l3 ? $3 : b2.a($3);
      }, m5.daysInMonth = function() {
        return this.endOf(c2).$D;
      }, m5.$locale = function() {
        return D2[this.$L];
      }, m5.locale = function(t3, e4) {
        if (!t3) return this.$L;
        var n6 = this.clone(), r4 = w2(t3, e4, true);
        return r4 && (n6.$L = r4), n6;
      }, m5.clone = function() {
        return b2.w(this.$d, this);
      }, m5.toDate = function() {
        return new Date(this.valueOf());
      }, m5.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m5.toISOString = function() {
        return this.$d.toISOString();
      }, m5.toString = function() {
        return this.$d.toUTCString();
      }, M5;
    }(), k3 = _3.prototype;
    return O4.prototype = k3, [["$ms", r3], ["$s", i4], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", c2], ["$y", h5], ["$D", d4]].forEach(function(t3) {
      k3[t3[1]] = function(e4) {
        return this.$g(e4, t3[0], t3[1]);
      };
    }), O4.extend = function(t3, e4) {
      return t3.$i || (t3(e4, _3, O4), t3.$i = true), O4;
    }, O4.locale = w2, O4.isDayjs = S4, O4.unix = function(t3) {
      return O4(1e3 * t3);
    }, O4.en = D2[g2], O4.Ls = D2, O4.p = {}, O4;
  });
})(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
const dayjs = /* @__PURE__ */ getDefaultExportFromCjs$1(dayjs_minExports);
var en$8 = { exports: {} };
(function(module, exports2) {
  !function(e3, n5) {
    module.exports = n5();
  }(commonjsGlobal, function() {
    return { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(e3) {
      var n5 = ["th", "st", "nd", "rd"], t2 = e3 % 100;
      return "[" + e3 + (n5[(t2 - 20) % 10] || n5[t2] || n5[0]) + "]";
    } };
  });
})(en$8);
var enExports = en$8.exports;
const englishLocale = /* @__PURE__ */ getDefaultExportFromCjs$1(enExports);
var relativeTime$1 = { exports: {} };
(function(module, exports2) {
  !function(r3, e3) {
    module.exports = e3();
  }(commonjsGlobal, function() {
    return function(r3, e3, t2) {
      r3 = r3 || {};
      var n5 = e3.prototype, o3 = { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" };
      function i4(r4, e4, t3, o4) {
        return n5.fromToBase(r4, e4, t3, o4);
      }
      t2.en.relativeTime = o3, n5.fromToBase = function(e4, n6, i5, d5, u2) {
        for (var f6, a2, s2, l2 = i5.$locale().relativeTime || o3, h5 = r3.thresholds || [{ l: "s", r: 44, d: "second" }, { l: "m", r: 89 }, { l: "mm", r: 44, d: "minute" }, { l: "h", r: 89 }, { l: "hh", r: 21, d: "hour" }, { l: "d", r: 35 }, { l: "dd", r: 25, d: "day" }, { l: "M", r: 45 }, { l: "MM", r: 10, d: "month" }, { l: "y", r: 17 }, { l: "yy", d: "year" }], m4 = h5.length, c2 = 0; c2 < m4; c2 += 1) {
          var y4 = h5[c2];
          y4.d && (f6 = d5 ? t2(e4).diff(i5, y4.d, true) : i5.diff(e4, y4.d, true));
          var p2 = (r3.rounding || Math.round)(Math.abs(f6));
          if (s2 = f6 > 0, p2 <= y4.r || !y4.r) {
            p2 <= 1 && c2 > 0 && (y4 = h5[c2 - 1]);
            var v2 = l2[y4.l];
            u2 && (p2 = u2("" + p2)), a2 = "string" == typeof v2 ? v2.replace("%d", p2) : v2(p2, n6, y4.l, s2);
            break;
          }
        }
        if (n6) return a2;
        var M4 = s2 ? l2.future : l2.past;
        return "function" == typeof M4 ? M4(a2) : M4.replace("%s", a2);
      }, n5.to = function(r4, e4) {
        return i4(r4, e4, this, true);
      }, n5.from = function(r4, e4) {
        return i4(r4, e4, this);
      };
      var d4 = function(r4) {
        return r4.$u ? t2.utc() : t2();
      };
      n5.toNow = function(r4) {
        return this.to(d4(this), r4);
      }, n5.fromNow = function(r4) {
        return this.from(d4(this), r4);
      };
    };
  });
})(relativeTime$1);
var relativeTimeExports = relativeTime$1.exports;
const relativeTime = /* @__PURE__ */ getDefaultExportFromCjs$1(relativeTimeExports);
var updateLocale$1 = { exports: {} };
(function(module, exports2) {
  !function(e3, n5) {
    module.exports = n5();
  }(commonjsGlobal, function() {
    return function(e3, n5, t2) {
      t2.updateLocale = function(e4, n6) {
        var o3 = t2.Ls[e4];
        if (o3) return (n6 ? Object.keys(n6) : []).forEach(function(e5) {
          o3[e5] = n6[e5];
        }), o3;
      };
    };
  });
})(updateLocale$1);
var updateLocaleExports = updateLocale$1.exports;
const updateLocale = /* @__PURE__ */ getDefaultExportFromCjs$1(updateLocaleExports);
dayjs.extend(relativeTime);
dayjs.extend(updateLocale);
const localeObject = {
  ...englishLocale,
  name: "en-web3-modal",
  relativeTime: {
    future: "in %s",
    past: "%s ago",
    s: "%d sec",
    m: "1 min",
    mm: "%d min",
    h: "1 hr",
    hh: "%d hrs",
    d: "1 d",
    dd: "%d d",
    M: "1 mo",
    MM: "%d mo",
    y: "1 yr",
    yy: "%d yr"
  }
};
const MONTH_NAMES = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
dayjs.locale("en-web3-modal", localeObject);
const DateUtil = {
  getMonthNameByIndex(monthIndex) {
    return MONTH_NAMES[monthIndex];
  },
  getYear(date = (/* @__PURE__ */ new Date()).toISOString()) {
    return dayjs(date).year();
  },
  getRelativeDateFromNow(date) {
    return dayjs(date).locale("en-web3-modal").fromNow(true);
  },
  formatDate(date, format2 = "DD MMM") {
    return dayjs(date).format(format2);
  }
};
const NetworkUtil = {
  caipNetworkIdToNumber(caipnetworkId) {
    return caipnetworkId ? Number(caipnetworkId.split(":")[1]) : void 0;
  },
  parseEvmChainId(chainId) {
    return typeof chainId === "string" ? this.caipNetworkIdToNumber(chainId) : chainId;
  },
  getNetworksByNamespace(networks, namespace) {
    return (networks == null ? void 0 : networks.filter((network) => network.chainNamespace === namespace)) || [];
  },
  getFirstNetworkByNamespace(networks, namespace) {
    return this.getNetworksByNamespace(networks, namespace)[0];
  }
};
var DP = 20, RM = 1, MAX_DP = 1e6, MAX_POWER = 1e6, NE = -7, PE = 21, STRICT = false, NAME = "[big.js] ", INVALID$1 = NAME + "Invalid ", INVALID_DP = INVALID$1 + "decimal places", INVALID_RM = INVALID$1 + "rounding mode", DIV_BY_ZERO = NAME + "Division by zero", P$6 = {}, UNDEFINED = void 0, NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
function _Big_() {
  function Big2(n5) {
    var x2 = this;
    if (!(x2 instanceof Big2)) return n5 === UNDEFINED ? _Big_() : new Big2(n5);
    if (n5 instanceof Big2) {
      x2.s = n5.s;
      x2.e = n5.e;
      x2.c = n5.c.slice();
    } else {
      if (typeof n5 !== "string") {
        if (Big2.strict === true && typeof n5 !== "bigint") {
          throw TypeError(INVALID$1 + "value");
        }
        n5 = n5 === 0 && 1 / n5 < 0 ? "-0" : String(n5);
      }
      parse(x2, n5);
    }
    x2.constructor = Big2;
  }
  Big2.prototype = P$6;
  Big2.DP = DP;
  Big2.RM = RM;
  Big2.NE = NE;
  Big2.PE = PE;
  Big2.strict = STRICT;
  Big2.roundDown = 0;
  Big2.roundHalfUp = 1;
  Big2.roundHalfEven = 2;
  Big2.roundUp = 3;
  return Big2;
}
function parse(x2, n5) {
  var e3, i4, nl;
  if (!NUMERIC.test(n5)) {
    throw Error(INVALID$1 + "number");
  }
  x2.s = n5.charAt(0) == "-" ? (n5 = n5.slice(1), -1) : 1;
  if ((e3 = n5.indexOf(".")) > -1) n5 = n5.replace(".", "");
  if ((i4 = n5.search(/e/i)) > 0) {
    if (e3 < 0) e3 = i4;
    e3 += +n5.slice(i4 + 1);
    n5 = n5.substring(0, i4);
  } else if (e3 < 0) {
    e3 = n5.length;
  }
  nl = n5.length;
  for (i4 = 0; i4 < nl && n5.charAt(i4) == "0"; ) ++i4;
  if (i4 == nl) {
    x2.c = [x2.e = 0];
  } else {
    for (; nl > 0 && n5.charAt(--nl) == "0"; ) ;
    x2.e = e3 - i4 - 1;
    x2.c = [];
    for (e3 = 0; i4 <= nl; ) x2.c[e3++] = +n5.charAt(i4++);
  }
  return x2;
}
function round$1(x2, sd, rm, more) {
  var xc3 = x2.c;
  if (rm === UNDEFINED) rm = x2.constructor.RM;
  if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {
    throw Error(INVALID_RM);
  }
  if (sd < 1) {
    more = rm === 3 && (more || !!xc3[0]) || sd === 0 && (rm === 1 && xc3[0] >= 5 || rm === 2 && (xc3[0] > 5 || xc3[0] === 5 && (more || xc3[1] !== UNDEFINED)));
    xc3.length = 1;
    if (more) {
      x2.e = x2.e - sd + 1;
      xc3[0] = 1;
    } else {
      xc3[0] = x2.e = 0;
    }
  } else if (sd < xc3.length) {
    more = rm === 1 && xc3[sd] >= 5 || rm === 2 && (xc3[sd] > 5 || xc3[sd] === 5 && (more || xc3[sd + 1] !== UNDEFINED || xc3[sd - 1] & 1)) || rm === 3 && (more || !!xc3[0]);
    xc3.length = sd;
    if (more) {
      for (; ++xc3[--sd] > 9; ) {
        xc3[sd] = 0;
        if (sd === 0) {
          ++x2.e;
          xc3.unshift(1);
          break;
        }
      }
    }
    for (sd = xc3.length; !xc3[--sd]; ) xc3.pop();
  }
  return x2;
}
function stringify$3(x2, doExponential, isNonzero) {
  var e3 = x2.e, s2 = x2.c.join(""), n5 = s2.length;
  if (doExponential) {
    s2 = s2.charAt(0) + (n5 > 1 ? "." + s2.slice(1) : "") + (e3 < 0 ? "e" : "e+") + e3;
  } else if (e3 < 0) {
    for (; ++e3; ) s2 = "0" + s2;
    s2 = "0." + s2;
  } else if (e3 > 0) {
    if (++e3 > n5) {
      for (e3 -= n5; e3--; ) s2 += "0";
    } else if (e3 < n5) {
      s2 = s2.slice(0, e3) + "." + s2.slice(e3);
    }
  } else if (n5 > 1) {
    s2 = s2.charAt(0) + "." + s2.slice(1);
  }
  return x2.s < 0 && isNonzero ? "-" + s2 : s2;
}
P$6.abs = function() {
  var x2 = new this.constructor(this);
  x2.s = 1;
  return x2;
};
P$6.cmp = function(y4) {
  var isneg, x2 = this, xc3 = x2.c, yc2 = (y4 = new x2.constructor(y4)).c, i4 = x2.s, j2 = y4.s, k3 = x2.e, l2 = y4.e;
  if (!xc3[0] || !yc2[0]) return !xc3[0] ? !yc2[0] ? 0 : -j2 : i4;
  if (i4 != j2) return i4;
  isneg = i4 < 0;
  if (k3 != l2) return k3 > l2 ^ isneg ? 1 : -1;
  j2 = (k3 = xc3.length) < (l2 = yc2.length) ? k3 : l2;
  for (i4 = -1; ++i4 < j2; ) {
    if (xc3[i4] != yc2[i4]) return xc3[i4] > yc2[i4] ^ isneg ? 1 : -1;
  }
  return k3 == l2 ? 0 : k3 > l2 ^ isneg ? 1 : -1;
};
P$6.div = function(y4) {
  var x2 = this, Big2 = x2.constructor, a2 = x2.c, b2 = (y4 = new Big2(y4)).c, k3 = x2.s == y4.s ? 1 : -1, dp = Big2.DP;
  if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
    throw Error(INVALID_DP);
  }
  if (!b2[0]) {
    throw Error(DIV_BY_ZERO);
  }
  if (!a2[0]) {
    y4.s = k3;
    y4.c = [y4.e = 0];
    return y4;
  }
  var bl, bt2, n5, cmp, ri2, bz = b2.slice(), ai2 = bl = b2.length, al = a2.length, r3 = a2.slice(0, bl), rl = r3.length, q2 = y4, qc2 = q2.c = [], qi2 = 0, p2 = dp + (q2.e = x2.e - y4.e) + 1;
  q2.s = k3;
  k3 = p2 < 0 ? 0 : p2;
  bz.unshift(0);
  for (; rl++ < bl; ) r3.push(0);
  do {
    for (n5 = 0; n5 < 10; n5++) {
      if (bl != (rl = r3.length)) {
        cmp = bl > rl ? 1 : -1;
      } else {
        for (ri2 = -1, cmp = 0; ++ri2 < bl; ) {
          if (b2[ri2] != r3[ri2]) {
            cmp = b2[ri2] > r3[ri2] ? 1 : -1;
            break;
          }
        }
      }
      if (cmp < 0) {
        for (bt2 = rl == bl ? b2 : bz; rl; ) {
          if (r3[--rl] < bt2[rl]) {
            ri2 = rl;
            for (; ri2 && !r3[--ri2]; ) r3[ri2] = 9;
            --r3[ri2];
            r3[rl] += 10;
          }
          r3[rl] -= bt2[rl];
        }
        for (; !r3[0]; ) r3.shift();
      } else {
        break;
      }
    }
    qc2[qi2++] = cmp ? n5 : ++n5;
    if (r3[0] && cmp) r3[rl] = a2[ai2] || 0;
    else r3 = [a2[ai2]];
  } while ((ai2++ < al || r3[0] !== UNDEFINED) && k3--);
  if (!qc2[0] && qi2 != 1) {
    qc2.shift();
    q2.e--;
    p2--;
  }
  if (qi2 > p2) round$1(q2, p2, Big2.RM, r3[0] !== UNDEFINED);
  return q2;
};
P$6.eq = function(y4) {
  return this.cmp(y4) === 0;
};
P$6.gt = function(y4) {
  return this.cmp(y4) > 0;
};
P$6.gte = function(y4) {
  return this.cmp(y4) > -1;
};
P$6.lt = function(y4) {
  return this.cmp(y4) < 0;
};
P$6.lte = function(y4) {
  return this.cmp(y4) < 1;
};
P$6.minus = P$6.sub = function(y4) {
  var i4, j2, t2, xlty, x2 = this, Big2 = x2.constructor, a2 = x2.s, b2 = (y4 = new Big2(y4)).s;
  if (a2 != b2) {
    y4.s = -b2;
    return x2.plus(y4);
  }
  var xc3 = x2.c.slice(), xe2 = x2.e, yc2 = y4.c, ye2 = y4.e;
  if (!xc3[0] || !yc2[0]) {
    if (yc2[0]) {
      y4.s = -b2;
    } else if (xc3[0]) {
      y4 = new Big2(x2);
    } else {
      y4.s = 1;
    }
    return y4;
  }
  if (a2 = xe2 - ye2) {
    if (xlty = a2 < 0) {
      a2 = -a2;
      t2 = xc3;
    } else {
      ye2 = xe2;
      t2 = yc2;
    }
    t2.reverse();
    for (b2 = a2; b2--; ) t2.push(0);
    t2.reverse();
  } else {
    j2 = ((xlty = xc3.length < yc2.length) ? xc3 : yc2).length;
    for (a2 = b2 = 0; b2 < j2; b2++) {
      if (xc3[b2] != yc2[b2]) {
        xlty = xc3[b2] < yc2[b2];
        break;
      }
    }
  }
  if (xlty) {
    t2 = xc3;
    xc3 = yc2;
    yc2 = t2;
    y4.s = -y4.s;
  }
  if ((b2 = (j2 = yc2.length) - (i4 = xc3.length)) > 0) for (; b2--; ) xc3[i4++] = 0;
  for (b2 = i4; j2 > a2; ) {
    if (xc3[--j2] < yc2[j2]) {
      for (i4 = j2; i4 && !xc3[--i4]; ) xc3[i4] = 9;
      --xc3[i4];
      xc3[j2] += 10;
    }
    xc3[j2] -= yc2[j2];
  }
  for (; xc3[--b2] === 0; ) xc3.pop();
  for (; xc3[0] === 0; ) {
    xc3.shift();
    --ye2;
  }
  if (!xc3[0]) {
    y4.s = 1;
    xc3 = [ye2 = 0];
  }
  y4.c = xc3;
  y4.e = ye2;
  return y4;
};
P$6.mod = function(y4) {
  var ygtx, x2 = this, Big2 = x2.constructor, a2 = x2.s, b2 = (y4 = new Big2(y4)).s;
  if (!y4.c[0]) {
    throw Error(DIV_BY_ZERO);
  }
  x2.s = y4.s = 1;
  ygtx = y4.cmp(x2) == 1;
  x2.s = a2;
  y4.s = b2;
  if (ygtx) return new Big2(x2);
  a2 = Big2.DP;
  b2 = Big2.RM;
  Big2.DP = Big2.RM = 0;
  x2 = x2.div(y4);
  Big2.DP = a2;
  Big2.RM = b2;
  return this.minus(x2.times(y4));
};
P$6.neg = function() {
  var x2 = new this.constructor(this);
  x2.s = -x2.s;
  return x2;
};
P$6.plus = P$6.add = function(y4) {
  var e3, k3, t2, x2 = this, Big2 = x2.constructor;
  y4 = new Big2(y4);
  if (x2.s != y4.s) {
    y4.s = -y4.s;
    return x2.minus(y4);
  }
  var xe2 = x2.e, xc3 = x2.c, ye2 = y4.e, yc2 = y4.c;
  if (!xc3[0] || !yc2[0]) {
    if (!yc2[0]) {
      if (xc3[0]) {
        y4 = new Big2(x2);
      } else {
        y4.s = x2.s;
      }
    }
    return y4;
  }
  xc3 = xc3.slice();
  if (e3 = xe2 - ye2) {
    if (e3 > 0) {
      ye2 = xe2;
      t2 = yc2;
    } else {
      e3 = -e3;
      t2 = xc3;
    }
    t2.reverse();
    for (; e3--; ) t2.push(0);
    t2.reverse();
  }
  if (xc3.length - yc2.length < 0) {
    t2 = yc2;
    yc2 = xc3;
    xc3 = t2;
  }
  e3 = yc2.length;
  for (k3 = 0; e3; xc3[e3] %= 10) k3 = (xc3[--e3] = xc3[e3] + yc2[e3] + k3) / 10 | 0;
  if (k3) {
    xc3.unshift(k3);
    ++ye2;
  }
  for (e3 = xc3.length; xc3[--e3] === 0; ) xc3.pop();
  y4.c = xc3;
  y4.e = ye2;
  return y4;
};
P$6.pow = function(n5) {
  var x2 = this, one = new x2.constructor("1"), y4 = one, isneg = n5 < 0;
  if (n5 !== ~~n5 || n5 < -MAX_POWER || n5 > MAX_POWER) {
    throw Error(INVALID$1 + "exponent");
  }
  if (isneg) n5 = -n5;
  for (; ; ) {
    if (n5 & 1) y4 = y4.times(x2);
    n5 >>= 1;
    if (!n5) break;
    x2 = x2.times(x2);
  }
  return isneg ? one.div(y4) : y4;
};
P$6.prec = function(sd, rm) {
  if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
    throw Error(INVALID$1 + "precision");
  }
  return round$1(new this.constructor(this), sd, rm);
};
P$6.round = function(dp, rm) {
  if (dp === UNDEFINED) dp = 0;
  else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {
    throw Error(INVALID_DP);
  }
  return round$1(new this.constructor(this), dp + this.e + 1, rm);
};
P$6.sqrt = function() {
  var r3, c2, t2, x2 = this, Big2 = x2.constructor, s2 = x2.s, e3 = x2.e, half = new Big2("0.5");
  if (!x2.c[0]) return new Big2(x2);
  if (s2 < 0) {
    throw Error(NAME + "No square root");
  }
  s2 = Math.sqrt(+stringify$3(x2, true, true));
  if (s2 === 0 || s2 === 1 / 0) {
    c2 = x2.c.join("");
    if (!(c2.length + e3 & 1)) c2 += "0";
    s2 = Math.sqrt(c2);
    e3 = ((e3 + 1) / 2 | 0) - (e3 < 0 || e3 & 1);
    r3 = new Big2((s2 == 1 / 0 ? "5e" : (s2 = s2.toExponential()).slice(0, s2.indexOf("e") + 1)) + e3);
  } else {
    r3 = new Big2(s2 + "");
  }
  e3 = r3.e + (Big2.DP += 4);
  do {
    t2 = r3;
    r3 = half.times(t2.plus(x2.div(t2)));
  } while (t2.c.slice(0, e3).join("") !== r3.c.slice(0, e3).join(""));
  return round$1(r3, (Big2.DP -= 4) + r3.e + 1, Big2.RM);
};
P$6.times = P$6.mul = function(y4) {
  var c2, x2 = this, Big2 = x2.constructor, xc3 = x2.c, yc2 = (y4 = new Big2(y4)).c, a2 = xc3.length, b2 = yc2.length, i4 = x2.e, j2 = y4.e;
  y4.s = x2.s == y4.s ? 1 : -1;
  if (!xc3[0] || !yc2[0]) {
    y4.c = [y4.e = 0];
    return y4;
  }
  y4.e = i4 + j2;
  if (a2 < b2) {
    c2 = xc3;
    xc3 = yc2;
    yc2 = c2;
    j2 = a2;
    a2 = b2;
    b2 = j2;
  }
  for (c2 = new Array(j2 = a2 + b2); j2--; ) c2[j2] = 0;
  for (i4 = b2; i4--; ) {
    b2 = 0;
    for (j2 = a2 + i4; j2 > i4; ) {
      b2 = c2[j2] + yc2[i4] * xc3[j2 - i4 - 1] + b2;
      c2[j2--] = b2 % 10;
      b2 = b2 / 10 | 0;
    }
    c2[j2] = b2;
  }
  if (b2) ++y4.e;
  else c2.shift();
  for (i4 = c2.length; !c2[--i4]; ) c2.pop();
  y4.c = c2;
  return y4;
};
P$6.toExponential = function(dp, rm) {
  var x2 = this, n5 = x2.c[0];
  if (dp !== UNDEFINED) {
    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    x2 = round$1(new x2.constructor(x2), ++dp, rm);
    for (; x2.c.length < dp; ) x2.c.push(0);
  }
  return stringify$3(x2, true, !!n5);
};
P$6.toFixed = function(dp, rm) {
  var x2 = this, n5 = x2.c[0];
  if (dp !== UNDEFINED) {
    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    x2 = round$1(new x2.constructor(x2), dp + x2.e + 1, rm);
    for (dp = dp + x2.e + 1; x2.c.length < dp; ) x2.c.push(0);
  }
  return stringify$3(x2, false, !!n5);
};
P$6[Symbol.for("nodejs.util.inspect.custom")] = P$6.toJSON = P$6.toString = function() {
  var x2 = this, Big2 = x2.constructor;
  return stringify$3(x2, x2.e <= Big2.NE || x2.e >= Big2.PE, !!x2.c[0]);
};
P$6.toNumber = function() {
  var n5 = +stringify$3(this, true, true);
  if (this.constructor.strict === true && !this.eq(n5.toString())) {
    throw Error(NAME + "Imprecise conversion");
  }
  return n5;
};
P$6.toPrecision = function(sd, rm) {
  var x2 = this, Big2 = x2.constructor, n5 = x2.c[0];
  if (sd !== UNDEFINED) {
    if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
      throw Error(INVALID$1 + "precision");
    }
    x2 = round$1(new Big2(x2), sd, rm);
    for (; x2.c.length < sd; ) x2.c.push(0);
  }
  return stringify$3(x2, sd <= x2.e || x2.e <= Big2.NE || x2.e >= Big2.PE, !!n5);
};
P$6.valueOf = function() {
  var x2 = this, Big2 = x2.constructor;
  if (Big2.strict === true) {
    throw Error(NAME + "valueOf disallowed");
  }
  return stringify$3(x2, x2.e <= Big2.NE || x2.e >= Big2.PE, true);
};
var Big = _Big_();
const NumberUtil = {
  bigNumber(value) {
    if (!value) {
      return new Big(0);
    }
    return new Big(value);
  },
  multiply(a2, b2) {
    if (a2 === void 0 || b2 === void 0) {
      return new Big(0);
    }
    const aBigNumber = new Big(a2);
    const bBigNumber = new Big(b2);
    return aBigNumber.times(bBigNumber);
  },
  formatNumberToLocalString(value, decimals = 2) {
    if (value === void 0) {
      return "0.00";
    }
    if (typeof value === "number") {
      return value.toLocaleString("en-US", {
        maximumFractionDigits: decimals,
        minimumFractionDigits: decimals
      });
    }
    return parseFloat(value).toLocaleString("en-US", {
      maximumFractionDigits: decimals,
      minimumFractionDigits: decimals
    });
  },
  parseLocalStringToNumber(value) {
    if (value === void 0) {
      return 0;
    }
    return parseFloat(value.replace(/,/gu, ""));
  }
};
const InputUtil = {
  numericInputKeyDown(event, currentValue, onChange) {
    const allowedKeys = [
      "Backspace",
      "Meta",
      "Ctrl",
      "a",
      "A",
      "c",
      "C",
      "x",
      "X",
      "v",
      "V",
      "ArrowLeft",
      "ArrowRight",
      "Tab"
    ];
    const controlPressed = event.metaKey || event.ctrlKey;
    const eventKey = event.key;
    const lowercaseEventKey = eventKey.toLocaleLowerCase();
    const selectAll = lowercaseEventKey === "a";
    const copyKey = lowercaseEventKey === "c";
    const pasteKey = lowercaseEventKey === "v";
    const cutKey = lowercaseEventKey === "x";
    const isComma = eventKey === ",";
    const isDot = eventKey === ".";
    const isNumericKey = eventKey >= "0" && eventKey <= "9";
    if (!controlPressed && (selectAll || copyKey || pasteKey || cutKey)) {
      event.preventDefault();
    }
    if (currentValue === "0" && !isComma && !isDot && eventKey === "0") {
      event.preventDefault();
    }
    if (currentValue === "0" && isNumericKey) {
      onChange(eventKey);
      event.preventDefault();
    }
    if (isComma || isDot) {
      if (!currentValue) {
        onChange("0.");
        event.preventDefault();
      }
      if ((currentValue == null ? void 0 : currentValue.includes(".")) || (currentValue == null ? void 0 : currentValue.includes(","))) {
        event.preventDefault();
      }
    }
    if (!isNumericKey && !allowedKeys.includes(eventKey) && !isDot && !isComma) {
      event.preventDefault();
    }
  }
};
const erc20ABI = [
  {
    type: "function",
    name: "transfer",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  },
  {
    type: "function",
    name: "transferFrom",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "_from",
        type: "address"
      },
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  }
];
const swapABI = [
  {
    type: "function",
    name: "approve",
    stateMutability: "nonpayable",
    inputs: [
      { name: "spender", type: "address" },
      { name: "amount", type: "uint256" }
    ],
    outputs: [{ type: "bool" }]
  }
];
const usdtABI = [
  {
    type: "function",
    name: "transfer",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "recipient",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: []
  },
  {
    type: "function",
    name: "transferFrom",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "sender",
        type: "address"
      },
      {
        name: "recipient",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ]
  }
];
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var browser$e = { exports: {} };
var process = browser$e.exports = {};
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    if (typeof setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e3) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e3) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e3) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e4) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e3) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e4) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len2 = queue.length;
  while (len2) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len2) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len2 = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i4 = 1; i4 < arguments.length; i4++) {
      args[i4 - 1] = arguments[i4];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop$1() {
}
process.on = noop$1;
process.addListener = noop$1;
process.once = noop$1;
process.off = noop$1;
process.removeListener = noop$1;
process.removeAllListeners = noop$1;
process.emit = noop$1;
process.prependListener = noop$1;
process.prependOnceListener = noop$1;
process.listeners = function(name) {
  return [];
};
process.binding = function(name) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(dir) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports = browser$e.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
const __vite_import_meta_env__$1 = {};
function getEnv$1() {
  var _a3, _b2;
  if (__vite_import_meta_env__$1 == null ? void 0 : __vite_import_meta_env__$1["VITE_ENV_MODE"]) {
    return __vite_import_meta_env__$1["VITE_ENV_MODE"];
  }
  if ((_a3 = process$1 == null ? void 0 : process$1.env) == null ? void 0 : _a3["NEXT_PUBLIC_ENV_MODE"]) {
    return process$1.env["NEXT_PUBLIC_ENV_MODE"];
  }
  if ((_b2 = process$1 == null ? void 0 : process$1.env) == null ? void 0 : _b2["NODE_ENV"]) {
    return process$1.env["NODE_ENV"];
  }
  return "production";
}
const ConstantsUtil$4 = {
  WC_NAME_SUFFIX: ".reown.id",
  WC_NAME_SUFFIX_LEGACY: ".wcn.id",
  BLOCKCHAIN_API_RPC_URL: "https://testnet.crosstoken.io:22001",
  PULSE_API_URL: "https://pulse.walletconnect.org",
  getWeb3mApiUrl() {
    const injectedEnv = getEnv$1();
    const envKey = injectedEnv.toUpperCase();
    return ConstantsUtil$4.W3M_API_URL[envKey];
  },
  W3M_API_URL: {
    DEVELOPMENT: "https://wallet-server.crosstoken.io",
    STAGE: "https://wallet-server.crosstoken.io",
    PRODUCTION: "https://wallet-server.crosstoken.io"
  },
  getRelayUrl() {
    var _a3;
    if (__vite_import_meta_env__$1 == null ? void 0 : __vite_import_meta_env__$1["VITE_CROSS_RELAY"]) {
      console.log("Using VITE_CROSS_RELAY from import.meta.env:", __vite_import_meta_env__$1["VITE_CROSS_RELAY"]);
      return __vite_import_meta_env__$1["VITE_CROSS_RELAY"];
    }
    if (__vite_import_meta_env__$1 == null ? void 0 : __vite_import_meta_env__$1["CROSS_RELAY"]) {
      console.log("Using CROSS_RELAY from import.meta.env:", __vite_import_meta_env__$1["CROSS_RELAY"]);
      return __vite_import_meta_env__$1["CROSS_RELAY"];
    }
    if ((_a3 = process$1 == null ? void 0 : process$1.env) == null ? void 0 : _a3["CROSS_RELAY"]) {
      console.log("Using CROSS_RELAY from process.env:", process$1.env["CROSS_RELAY"]);
      return process$1.env["CROSS_RELAY"];
    }
    console.log("Using relay URL:", ConstantsUtil$4.RELAY_URL.PRODUCTION);
    return ConstantsUtil$4.RELAY_URL.PRODUCTION;
  },
  RELAY_URL: {
    DEVELOPMENT: "wss://dev-cross-relay.crosstoken.io/ws",
    STAGE: "wss://stg-cross-relay.crosstoken.io/ws",
    PRODUCTION: "wss://cross-relay.crosstoken.io/ws"
  },
  getUniversalLink() {
    var _a3;
    if (__vite_import_meta_env__$1 == null ? void 0 : __vite_import_meta_env__$1["VITE_UNIVERSAL_LINK"]) {
      console.log("Using VITE_UNIVERSAL_LINK from import.meta.env:", __vite_import_meta_env__$1["VITE_UNIVERSAL_LINK"]);
      return __vite_import_meta_env__$1["VITE_UNIVERSAL_LINK"];
    }
    if (__vite_import_meta_env__$1 == null ? void 0 : __vite_import_meta_env__$1["UNIVERSAL_LINK"]) {
      console.log("Using UNIVERSAL_LINK from import.meta.env:", __vite_import_meta_env__$1["UNIVERSAL_LINK"]);
      return __vite_import_meta_env__$1["UNIVERSAL_LINK"];
    }
    if ((_a3 = process$1 == null ? void 0 : process$1.env) == null ? void 0 : _a3["UNIVERSAL_LINK"]) {
      console.log("Using UNIVERSAL_LINK from process.env:", process$1.env["UNIVERSAL_LINK"]);
      return process$1.env["UNIVERSAL_LINK"];
    }
    console.log("Using universal link:", ConstantsUtil$4.UNIVERSAL_LINK.PRODUCTION);
    return void 0;
  },
  UNIVERSAL_LINK: {
    DEVELOPMENT: "https://dev-cross-wallet.crosstoken.io",
    STAGE: "https://stg-cross-wallet.crosstoken.io",
    PRODUCTION: "https://cross-wallet.crosstoken.io"
  },
  getVerifyUrl() {
    const injectedEnv = getEnv$1();
    const envKey = injectedEnv.toUpperCase();
    return ConstantsUtil$4.VERIFY_URL[envKey];
  },
  VERIFY_URL: {
    DEVELOPMENT: "http://cross-verify.crosstoken.io",
    STAGE: "http://cross-verify.crosstoken.io",
    PRODUCTION: "http://cross-verify.crosstoken.io"
  },
  getCrossWalletWebappLink() {
    const injectedEnv = getEnv$1();
    const envKey = injectedEnv.toUpperCase();
    return ConstantsUtil$4.CROSS_WALLET_WEBAPP_LINK[envKey];
  },
  CROSS_WALLET_WEBAPP_LINK: {
    DEVELOPMENT: "crossx://",
    STAGE: "crossx://",
    PRODUCTION: "crossx://"
  },
  CONNECTOR_ID: {
    WALLET_CONNECT: "cross_wallet",
    INJECTED: "injected",
    WALLET_STANDARD: "announced",
    COINBASE: "coinbaseWallet",
    COINBASE_SDK: "coinbaseWalletSDK",
    SAFE: "safe",
    LEDGER: "ledger",
    OKX: "okx",
    EIP6963: "eip6963",
    AUTH: "ID_AUTH"
  },
  CONNECTOR_NAMES: {
    AUTH: "Auth"
  },
  AUTH_CONNECTOR_SUPPORTED_CHAINS: ["eip155", "solana"],
  LIMITS: {
    PENDING_TRANSACTIONS: 99
  },
  CHAIN: {
    EVM: "eip155",
    SOLANA: "solana",
    POLKADOT: "polkadot",
    BITCOIN: "bip122"
  },
  CHAIN_NAME_MAP: {
    eip155: "Ethereum",
    solana: "Solana",
    polkadot: "Polkadot",
    bip122: "Bitcoin"
  },
  USDT_CONTRACT_ADDRESSES: [
    "0xdac17f958d2ee523a2206206994597c13d831ec7",
    "0xc2132d05d31c914a87c6611c10748aeb04b58e8f",
    "0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7",
    "0x919C1c267BC06a7039e03fcc2eF738525769109c",
    "0x48065fbBE25f71C9282ddf5e1cD6D6A887483D5e",
    "0x55d398326f99059fF775485246999027B3197955",
    "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9"
  ],
  HTTP_STATUS_CODES: {
    SERVICE_UNAVAILABLE: 503,
    FORBIDDEN: 403
  },
  UNSUPPORTED_NETWORK_NAME: "Unknown Network"
};
const ContractUtil = {
  getERC20Abi: (contractAddress) => {
    if (ConstantsUtil$4.USDT_CONTRACT_ADDRESSES.includes(contractAddress)) {
      return usdtABI;
    }
    return erc20ABI;
  },
  getSwapAbi: () => swapABI
};
const NavigationUtil = {
  URLS: {
    FAQ: "https://walletconnect.com/faq"
  }
};
const ParseUtil = {
  validateCaipAddress(address) {
    var _a3;
    if (((_a3 = address.split(":")) == null ? void 0 : _a3.length) !== 3) {
      throw new Error("Invalid CAIP Address");
    }
    return address;
  },
  parseCaipAddress(caipAddress) {
    const parts = caipAddress.split(":");
    if (parts.length !== 3) {
      throw new Error(`Invalid CAIP-10 address: ${caipAddress}`);
    }
    const [chainNamespace, chainId, address] = parts;
    if (!chainNamespace || !chainId || !address) {
      throw new Error(`Invalid CAIP-10 address: ${caipAddress}`);
    }
    return {
      chainNamespace,
      chainId,
      address
    };
  },
  parseCaipNetworkId(caipNetworkId) {
    const parts = caipNetworkId.split(":");
    if (parts.length !== 2) {
      throw new Error(`Invalid CAIP-2 network id: ${caipNetworkId}`);
    }
    const [chainNamespace, chainId] = parts;
    if (!chainNamespace || !chainId) {
      throw new Error(`Invalid CAIP-2 network id: ${caipNetworkId}`);
    }
    return {
      chainNamespace,
      chainId
    };
  }
};
const SafeLocalStorageKeys = {
  WALLET_ID: "@cross/wallet_id",
  WALLET_NAME: "@cross/wallet_name",
  SOLANA_WALLET: "@cross/solana_wallet",
  SOLANA_CAIP_CHAIN: "@cross/solana_caip_chain",
  ACTIVE_CAIP_NETWORK_ID: "@cross/active_caip_network_id",
  CONNECTED_SOCIAL: "@cross/connected_social",
  CONNECTED_SOCIAL_USERNAME: "@cross-wallet/SOCIAL_USERNAME",
  RECENT_WALLETS: "@cross/recent_wallets",
  DEEPLINK_CHOICE: "WALLETCONNECT_DEEPLINK_CHOICE",
  ACTIVE_NAMESPACE: "@cross/active_namespace",
  CONNECTED_NAMESPACES: "@cross/connected_namespaces",
  CONNECTION_STATUS: "@cross/connection_status",
  SIWX_AUTH_TOKEN: "@cross/siwx-auth-token",
  SIWX_NONCE_TOKEN: "@cross/siwx-nonce-token",
  SOCIAL_PROVIDER: "@cross/social_provider",
  NATIVE_BALANCE_CACHE: "@cross/native_balance_cache",
  PORTFOLIO_CACHE: "@cross/portfolio_cache",
  ENS_CACHE: "@cross/ens_cache",
  IDENTITY_CACHE: "@cross/identity_cache"
};
function getSafeConnectorIdKey(namespace) {
  if (!namespace) {
    throw new Error("Namespace is required for CONNECTED_CONNECTOR_ID");
  }
  return `@cross/${namespace}:connected_connector_id`;
}
const SafeLocalStorage = {
  setItem(key2, value) {
    if (isSafe$1() && value !== void 0) {
      localStorage.setItem(key2, value);
    }
  },
  getItem(key2) {
    if (isSafe$1()) {
      return localStorage.getItem(key2) || void 0;
    }
    return void 0;
  },
  removeItem(key2) {
    if (isSafe$1()) {
      localStorage.removeItem(key2);
    }
  },
  clear() {
    if (isSafe$1()) {
      localStorage.clear();
    }
  }
};
function isSafe$1() {
  return typeof window !== "undefined" && typeof localStorage !== "undefined";
}
function getW3mThemeVariables(themeVariables, themeType) {
  if (themeType === "light") {
    return {
      "--w3m-accent": (themeVariables == null ? void 0 : themeVariables["--w3m-accent"]) || "hsla(231, 100%, 70%, 1)",
      "--w3m-background": "#fff"
    };
  }
  return {
    "--w3m-accent": (themeVariables == null ? void 0 : themeVariables["--w3m-accent"]) || "hsla(230, 100%, 67%, 1)",
    "--w3m-background": "#121313"
  };
}
function isReownName(value) {
  return (value == null ? void 0 : value.endsWith(ConstantsUtil$4.WC_NAME_SUFFIX_LEGACY)) || (value == null ? void 0 : value.endsWith(ConstantsUtil$4.WC_NAME_SUFFIX));
}
const SECURE_SITE = "https://secure.walletconnect.org";
const ONRAMP_PROVIDERS = [
  {
    label: "Coinbase",
    name: "coinbase",
    feeRange: "1-2%",
    url: "",
    supportedChains: ["eip155"]
  },
  {
    label: "Meld.io",
    name: "meld",
    feeRange: "1-2%",
    url: "https://meldcrypto.com",
    supportedChains: ["eip155", "solana"]
  }
];
const MELD_PUBLIC_KEY = "WXETMuFUQmqqybHuRkSgxv:25B8LJHSfpG6LVjR2ytU5Cwh7Z4Sch2ocoU";
const ConstantsUtil$3 = {
  FOUR_MINUTES_MS: 24e4,
  TEN_SEC_MS: 1e4,
  FIVE_SEC_MS: 5e3,
  THREE_SEC_MS: 3e3,
  ONE_SEC_MS: 1e3,
  SECURE_SITE,
  SECURE_SITE_DASHBOARD: `${SECURE_SITE}/dashboard`,
  SECURE_SITE_FAVICON: `${SECURE_SITE}/images/favicon.png`,
  RESTRICTED_TIMEZONES: [
    "ASIA/SHANGHAI",
    "ASIA/URUMQI",
    "ASIA/CHONGQING",
    "ASIA/HARBIN",
    "ASIA/KASHGAR",
    "ASIA/MACAU",
    "ASIA/HONG_KONG",
    "ASIA/MACAO",
    "ASIA/BEIJING",
    "ASIA/HARBIN"
  ],
  /**
   * Network name to Coinbase Pay SDK chain name map object
   * @see supported chain names on Coinbase for Pay SDK: https://github.com/coinbase/cbpay-js/blob/d4bda2c05c4d5917c8db6a05476b603546046394/src/types/onramp.ts
   */
  WC_COINBASE_PAY_SDK_CHAINS: [
    "ethereum",
    "arbitrum",
    "polygon",
    "avalanche-c-chain",
    "optimism",
    "celo",
    "base"
  ],
  WC_COINBASE_PAY_SDK_FALLBACK_CHAIN: "ethereum",
  WC_COINBASE_PAY_SDK_CHAIN_NAME_MAP: {
    Ethereum: "ethereum",
    "Arbitrum One": "arbitrum",
    Polygon: "polygon",
    Avalanche: "avalanche-c-chain",
    "OP Mainnet": "optimism",
    Celo: "celo",
    Base: "base"
  },
  WC_COINBASE_ONRAMP_APP_ID: "bf18c88d-495a-463b-b249-0b9d3656cf5e",
  SWAP_SUGGESTED_TOKENS: [
    "ETH",
    "UNI",
    "1INCH",
    "AAVE",
    "SOL",
    "ADA",
    "AVAX",
    "DOT",
    "LINK",
    "NITRO",
    "GAIA",
    "MILK",
    "TRX",
    "NEAR",
    "GNO",
    "WBTC",
    "DAI",
    "WETH",
    "USDC",
    "USDT",
    "ARB",
    "BAL",
    "BICO",
    "CRV",
    "ENS",
    "MATIC",
    "OP"
  ],
  SWAP_POPULAR_TOKENS: [
    "ETH",
    "UNI",
    "1INCH",
    "AAVE",
    "SOL",
    "ADA",
    "AVAX",
    "DOT",
    "LINK",
    "NITRO",
    "GAIA",
    "MILK",
    "TRX",
    "NEAR",
    "GNO",
    "WBTC",
    "DAI",
    "WETH",
    "USDC",
    "USDT",
    "ARB",
    "BAL",
    "BICO",
    "CRV",
    "ENS",
    "MATIC",
    "OP",
    "METAL",
    "DAI",
    "CHAMP",
    "WOLF",
    "SALE",
    "BAL",
    "BUSD",
    "MUST",
    "BTCpx",
    "ROUTE",
    "HEX",
    "WELT",
    "amDAI",
    "VSQ",
    "VISION",
    "AURUM",
    "pSP",
    "SNX",
    "VC",
    "LINK",
    "CHP",
    "amUSDT",
    "SPHERE",
    "FOX",
    "GIDDY",
    "GFC",
    "OMEN",
    "OX_OLD",
    "DE",
    "WNT"
  ],
  BALANCE_SUPPORTED_CHAINS: ["eip155", "solana"],
  SWAP_SUPPORTED_NETWORKS: [
    // Ethereum'
    "eip155:1",
    // Arbitrum One'
    "eip155:42161",
    // Optimism'
    "eip155:10",
    // ZKSync Era'
    "eip155:324",
    // Base'
    "eip155:8453",
    // BNB Smart Chain'
    "eip155:56",
    // Polygon'
    "eip155:137",
    // Gnosis'
    "eip155:100",
    // Avalanche'
    "eip155:43114",
    // Fantom'
    "eip155:250",
    // Klaytn'
    "eip155:8217",
    // Aurora
    "eip155:1313161554"
  ],
  NAMES_SUPPORTED_CHAIN_NAMESPACES: ["eip155"],
  ONRAMP_SUPPORTED_CHAIN_NAMESPACES: ["eip155", "solana"],
  ACTIVITY_ENABLED_CHAIN_NAMESPACES: ["eip155", "solana"],
  NATIVE_TOKEN_ADDRESS: {
    eip155: "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
    solana: "So11111111111111111111111111111111111111111",
    polkadot: "0x",
    bip122: "0x"
  },
  CONVERT_SLIPPAGE_TOLERANCE: 1,
  CONNECT_LABELS: {
    MOBILE: "Open and continue in a new browser tab"
  },
  DEFAULT_FEATURES: {
    swaps: true,
    onramp: true,
    receive: true,
    send: true,
    email: true,
    emailShowWallets: true,
    socials: [
      "google",
      "x",
      "discord",
      "farcaster",
      "github",
      "apple",
      "facebook"
    ],
    history: true,
    analytics: true,
    allWallets: true,
    legalCheckbox: false,
    smartSessions: false,
    collapseWallets: false,
    walletFeaturesOrder: ["onramp", "swaps", "receive", "send"],
    connectMethodsOrder: void 0
  },
  DEFAULT_ACCOUNT_TYPES: {
    bip122: "payment",
    eip155: "smartAccount",
    polkadot: "eoa",
    solana: "eoa"
  },
  TRANSACTION_TYPE: {
    DYNAMIC: 2,
    // ???: 1, accessList (not supported)
    LEGACY: 0
  },
  // Universal Link  (CommonConstantsUtil )
  getUniversalLink() {
    return ConstantsUtil$4.getUniversalLink();
  },
  UNIVERSAL_LINK: ConstantsUtil$4.UNIVERSAL_LINK
};
const CoreHelperUtil = {
  isMobile() {
    if (this.isClient()) {
      return Boolean(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent));
    }
    return false;
  },
  checkCaipNetwork(network, networkName = "") {
    return network == null ? void 0 : network.caipNetworkId.toLocaleLowerCase().includes(networkName.toLowerCase());
  },
  isAndroid() {
    if (!this.isMobile()) {
      return false;
    }
    const ua2 = window.navigator.userAgent.toLowerCase();
    return CoreHelperUtil.isMobile() && ua2.includes("android");
  },
  isIos() {
    if (!this.isMobile()) {
      return false;
    }
    const ua2 = window.navigator.userAgent.toLowerCase();
    return ua2.includes("iphone") || ua2.includes("ipad");
  },
  isSafari() {
    if (!this.isClient()) {
      return false;
    }
    const ua2 = window.navigator.userAgent.toLowerCase();
    return ua2.includes("safari") && !ua2.includes("chrome") && !ua2.includes("crios") && !ua2.includes("fxios") && !ua2.includes("edgios");
  },
  isChrome() {
    if (!this.isClient()) {
      return false;
    }
    const ua2 = window.navigator.userAgent.toLowerCase();
    return ua2.includes("chrome") && !ua2.includes("edg") && // Edge
    !ua2.includes("opr") && // Opera
    !ua2.includes("crios") && // Chrome iOS
    !ua2.includes("fxios") && // Firefox iOS
    !ua2.includes("edgios");
  },
  isCROSSxBrowser() {
    if (!this.isClient()) {
      return false;
    }
    const ua2 = window.navigator.userAgent;
    return /CROSSx\/[\d.]+/i.test(ua2);
  },
  isLandscape() {
    if (!this.isClient()) {
      return false;
    }
    return window.matchMedia("(orientation: landscape)").matches;
  },
  isMobileLandscape() {
    if (!this.isClient()) {
      return false;
    }
    const isLandscapeResult = this.isLandscape();
    const isCoarsePointer = window.matchMedia("(pointer:coarse)").matches;
    const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent);
    const maxDimension = Math.max(window.innerWidth, window.innerHeight);
    const isTabletSize = isCoarsePointer && maxDimension >= 1100;
    const result = isLandscapeResult && isCoarsePointer && isMobileDevice && !isTabletSize;
    return result;
  },
  isClient() {
    return typeof window !== "undefined";
  },
  isPairingExpired(expiry) {
    return expiry ? expiry - Date.now() <= ConstantsUtil$3.TEN_SEC_MS : true;
  },
  isAllowedRetry(lastRetry, differenceMs = ConstantsUtil$3.ONE_SEC_MS) {
    return Date.now() - lastRetry >= differenceMs;
  },
  copyToClopboard(text) {
    navigator.clipboard.writeText(text);
  },
  isIframe() {
    try {
      return window.self !== window.top;
    } catch (e3) {
      return false;
    }
  },
  getPairingExpiry() {
    return Date.now() + ConstantsUtil$3.FOUR_MINUTES_MS;
  },
  getNetworkId(caipAddress) {
    return caipAddress == null ? void 0 : caipAddress.split(":")[1];
  },
  getPlainAddress(caipAddress) {
    return caipAddress == null ? void 0 : caipAddress.split(":")[2];
  },
  async wait(milliseconds) {
    return new Promise((resolve) => {
      setTimeout(resolve, milliseconds);
    });
  },
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  debounce(func, timeout = 500) {
    let timer = void 0;
    return (...args) => {
      function next() {
        func(...args);
      }
      if (timer) {
        clearTimeout(timer);
      }
      timer = setTimeout(next, timeout);
    };
  },
  isHttpUrl(url) {
    return url.startsWith("http://") || url.startsWith("https://");
  },
  formatNativeUrl(appUrl, wcUri) {
    if (CoreHelperUtil.isHttpUrl(appUrl)) {
      return this.formatUniversalUrl(appUrl, wcUri);
    }
    let safeAppUrl = appUrl;
    if (!safeAppUrl.includes("://")) {
      safeAppUrl = appUrl.replaceAll("/", "").replaceAll(":", "");
      safeAppUrl = `${safeAppUrl}://`;
    }
    if (!safeAppUrl.endsWith("/")) {
      safeAppUrl = `${safeAppUrl}/`;
    }
    if (this.isTelegram() && this.isAndroid()) {
      wcUri = encodeURIComponent(wcUri);
    }
    const encodedWcUrl = encodeURIComponent(wcUri);
    let redirectUrl = `${safeAppUrl}wc?uri=${encodedWcUrl}`;
    if (this.isCROSSxBrowser()) {
      redirectUrl += "%26from%3Dcrossx";
    } else if (this.isMobile()) {
      redirectUrl += "%26from%3Dmobile-browser";
    } else {
      redirectUrl += "%26from%3Dbrowser";
    }
    return {
      redirect: redirectUrl,
      href: safeAppUrl
    };
  },
  formatUniversalUrl(appUrl, wcUri) {
    if (!CoreHelperUtil.isHttpUrl(appUrl)) {
      return this.formatNativeUrl(appUrl, wcUri);
    }
    let safeAppUrl = appUrl;
    if (!safeAppUrl.endsWith("/")) {
      safeAppUrl = `${safeAppUrl}/`;
    }
    const encodedWcUrl = encodeURIComponent(wcUri);
    let redirectUrl = `${safeAppUrl}wc?uri=${encodedWcUrl}`;
    if (this.isCROSSxBrowser()) {
      redirectUrl += "%26from%3Dcrossx";
    } else if (this.isMobile()) {
      redirectUrl += "%26from%3Dmobile-browser";
    } else {
      redirectUrl += "%26from%3Dbrowser";
    }
    return {
      redirect: redirectUrl,
      href: safeAppUrl
    };
  },
  getOpenTargetForPlatform(target) {
    if (target === "popupWindow") {
      return target;
    }
    if (this.isTelegram()) {
      if (SafeLocalStorage.getItem(SafeLocalStorageKeys.SOCIAL_PROVIDER)) {
        return "_top";
      }
      return "_blank";
    }
    return target;
  },
  openHref(href, target, features) {
    window.open(href, this.getOpenTargetForPlatform(target), features || "noreferrer noopener");
  },
  returnOpenHref(href, target, features) {
    return window.open(href, this.getOpenTargetForPlatform(target), features || "noreferrer noopener");
  },
  isTelegram() {
    return typeof window !== "undefined" && // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (Boolean(window.TelegramWebviewProxy) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Boolean(window.Telegram) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Boolean(window.TelegramWebviewProxyProto));
  },
  async preloadImage(src2) {
    const imagePromise = new Promise((resolve, reject) => {
      const image = new Image();
      image.onload = resolve;
      image.onerror = reject;
      image.crossOrigin = "anonymous";
      image.src = src2;
    });
    return Promise.race([imagePromise, CoreHelperUtil.wait(2e3)]);
  },
  formatBalance(balance, symbol) {
    let formattedBalance = "0.000";
    if (typeof balance === "string") {
      const number2 = Number(balance);
      if (number2) {
        const formattedValue = Math.floor(number2 * 1e3) / 1e3;
        if (formattedValue) {
          formattedBalance = formattedValue.toString();
        }
      }
    }
    return `${formattedBalance}${symbol ? ` ${symbol}` : ""}`;
  },
  formatBalance2(balance, symbol) {
    var _a3;
    let formattedBalance = void 0;
    if (balance === "0") {
      formattedBalance = "0";
    } else if (typeof balance === "string") {
      const number2 = Number(balance);
      if (number2) {
        formattedBalance = (_a3 = number2.toString().match(/^-?\d+(?:\.\d{0,3})?/u)) == null ? void 0 : _a3[0];
      }
    }
    return {
      value: formattedBalance ?? "0",
      rest: formattedBalance === "0" ? "000" : "",
      symbol
    };
  },
  getApiUrl() {
    return ConstantsUtil$4.getWeb3mApiUrl();
  },
  getBlockchainApiUrl() {
    return ConstantsUtil$4.BLOCKCHAIN_API_RPC_URL;
  },
  getAnalyticsUrl() {
    return ConstantsUtil$4.PULSE_API_URL;
  },
  getUUID() {
    if (crypto == null ? void 0 : crypto.randomUUID) {
      return crypto.randomUUID();
    }
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (c2) => {
      const r3 = Math.random() * 16 | 0;
      const v2 = c2 === "x" ? r3 : r3 & 3 | 8;
      return v2.toString(16);
    });
  },
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  parseError(error) {
    var _a3, _b2;
    if (typeof error === "string") {
      return error;
    } else if (typeof ((_b2 = (_a3 = error == null ? void 0 : error.issues) == null ? void 0 : _a3[0]) == null ? void 0 : _b2.message) === "string") {
      return error.issues[0].message;
    } else if (error instanceof Error) {
      return error.message;
    }
    return "Unknown error";
  },
  sortRequestedNetworks(approvedIds, requestedNetworks = []) {
    const approvedIndexMap = {};
    if (requestedNetworks && approvedIds) {
      approvedIds.forEach((id2, index2) => {
        approvedIndexMap[id2] = index2;
      });
      requestedNetworks.sort((a2, b2) => {
        const indexA = approvedIndexMap[a2.id];
        const indexB = approvedIndexMap[b2.id];
        if (indexA !== void 0 && indexB !== void 0) {
          return indexA - indexB;
        } else if (indexA !== void 0) {
          return -1;
        } else if (indexB !== void 0) {
          return 1;
        }
        return 0;
      });
    }
    return requestedNetworks;
  },
  calculateBalance(array) {
    let sum = 0;
    for (const item of array) {
      sum += item.value ?? 0;
    }
    return sum;
  },
  formatTokenBalance(number2) {
    const roundedNumber = number2.toFixed(2);
    const [dollars, pennies] = roundedNumber.split(".");
    return { dollars, pennies };
  },
  isAddress(address, chain = "eip155") {
    switch (chain) {
      case "eip155":
        if (!/^(?:0x)?[0-9a-f]{40}$/iu.test(address)) {
          return false;
        } else if (/^(?:0x)?[0-9a-f]{40}$/iu.test(address) || /^(?:0x)?[0-9A-F]{40}$/iu.test(address)) {
          return true;
        }
        return false;
      case "solana":
        return /[1-9A-HJ-NP-Za-km-z]{32,44}$/iu.test(address);
      default:
        return false;
    }
  },
  uniqueBy(arr, key2) {
    const set2 = /* @__PURE__ */ new Set();
    return arr.filter((item) => {
      const keyValue = item[key2];
      if (set2.has(keyValue)) {
        return false;
      }
      set2.add(keyValue);
      return true;
    });
  },
  generateSdkVersion(adapters, platform, version2) {
    const noAdapters = adapters.length === 0;
    const adapterNames = noAdapters ? "universal" : adapters.map((adapter) => adapter.adapterType).join(",");
    return `${platform}-${adapterNames}-${version2}`;
  },
  // eslint-disable-next-line max-params
  createAccount(namespace, address, type2, publicKey, path) {
    return {
      namespace,
      address,
      type: type2,
      publicKey,
      path
    };
  },
  isCaipAddress(address) {
    if (typeof address !== "string") {
      return false;
    }
    const sections = address.split(":");
    const namespace = sections[0];
    return sections.filter(Boolean).length === 3 && namespace in ConstantsUtil$4.CHAIN_NAME_MAP;
  },
  isMac() {
    const ua2 = window.navigator.userAgent.toLowerCase();
    return ua2.includes("macintosh") && !ua2.includes("safari");
  },
  formatTelegramSocialLoginUrl(url) {
    const valueToInject = `--${encodeURIComponent(window.location.href)}`;
    const paramToInject = "state=";
    const parsedUrl = new URL(url);
    if (parsedUrl.host === "auth.magic.link") {
      const providerParam = "provider_authorization_url=";
      const providerUrl = url.substring(url.indexOf(providerParam) + providerParam.length);
      const resultUrl = this.injectIntoUrl(decodeURIComponent(providerUrl), paramToInject, valueToInject);
      return url.replace(providerUrl, encodeURIComponent(resultUrl));
    }
    return this.injectIntoUrl(url, paramToInject, valueToInject);
  },
  injectIntoUrl(url, key2, appendString) {
    const keyIndex = url.indexOf(key2);
    if (keyIndex === -1) {
      throw new Error(`${key2} parameter not found in the URL: ${url}`);
    }
    const keyEndIndex = url.indexOf("&", keyIndex);
    const keyLength = key2.length;
    const keyParamEnd = keyEndIndex !== -1 ? keyEndIndex : url.length;
    const beforeKeyValue = url.substring(0, keyIndex + keyLength);
    const currentKeyValue = url.substring(keyIndex + keyLength, keyParamEnd);
    const afterKeyValue = url.substring(keyEndIndex);
    const newKeyValue = currentKeyValue + appendString;
    const newUrl = beforeKeyValue + newKeyValue + afterKeyValue;
    return newUrl;
  },
  isMiniWindow() {
    if (!this.isClient()) {
      return false;
    }
    const isSmallHeight = window.innerHeight <= 300;
    const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent);
    const isCoarsePointer = window.matchMedia("(pointer:coarse)").matches;
    const result = isMobileDevice && isCoarsePointer && isSmallHeight;
    return result;
  }
};
const state$o = proxy({
  walletImages: {},
  networkImages: {},
  chainImages: {},
  connectorImages: {},
  tokenImages: {},
  currencyImages: {}
});
const AssetController = {
  state: state$o,
  subscribeNetworkImages(callback) {
    return subscribe(state$o.networkImages, () => callback(state$o.networkImages));
  },
  subscribeKey(key2, callback) {
    return subscribeKey(state$o, key2, callback);
  },
  subscribe(callback) {
    return subscribe(state$o, () => callback(state$o));
  },
  setWalletImage(key2, value) {
    state$o.walletImages[key2] = value;
  },
  setNetworkImage(key2, value) {
    state$o.networkImages[key2] = value;
  },
  setChainImage(key2, value) {
    state$o.chainImages[key2] = value;
  },
  setConnectorImage(key2, value) {
    state$o.connectorImages = { ...state$o.connectorImages, [key2]: value };
  },
  setTokenImage(key2, value) {
    state$o.tokenImages[key2] = value;
  },
  setCurrencyImage(key2, value) {
    state$o.currencyImages[key2] = value;
  }
};
const namespaceImageIds = {
  // Ethereum
  eip155: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
  // Solana
  solana: "a1b58899-f671-4276-6a5e-56ca5bd59700",
  // Polkadot
  polkadot: "",
  // Bitcoin
  bip122: ""
};
const AssetUtil = {
  async fetchWalletImage(imageId) {
    if (!imageId) {
      return void 0;
    }
    await ApiController$1._fetchWalletImage(imageId);
    return this.getWalletImageById(imageId);
  },
  async fetchNetworkImage(imageId) {
    if (!imageId) {
      return void 0;
    }
    const existingImage = this.getNetworkImageById(imageId);
    if (existingImage) {
      return existingImage;
    }
    await ApiController$1._fetchNetworkImage(imageId);
    return this.getNetworkImageById(imageId);
  },
  getWalletImageById(imageId) {
    if (!imageId) {
      return void 0;
    }
    return AssetController.state.walletImages[imageId];
  },
  getWalletImage(wallet) {
    if (wallet == null ? void 0 : wallet.image_url) {
      return wallet == null ? void 0 : wallet.image_url;
    }
    if (wallet == null ? void 0 : wallet.image_id) {
      return AssetController.state.walletImages[wallet.image_id];
    }
    return "https://contents.crosstoken.io/wallet/token/images/CROSSx.svg";
  },
  getNetworkImage(network) {
    var _a3, _b2, _c3;
    if ((_a3 = network == null ? void 0 : network.assets) == null ? void 0 : _a3.imageUrl) {
      return (_b2 = network == null ? void 0 : network.assets) == null ? void 0 : _b2.imageUrl;
    }
    if ((_c3 = network == null ? void 0 : network.assets) == null ? void 0 : _c3.imageId) {
      return AssetController.state.networkImages[network.assets.imageId];
    }
    return void 0;
  },
  getNetworkImageById(imageId) {
    if (!imageId) {
      return void 0;
    }
    return AssetController.state.networkImages[imageId];
  },
  getConnectorImage(connector) {
    if (connector == null ? void 0 : connector.imageUrl) {
      return connector.imageUrl;
    }
    if (connector == null ? void 0 : connector.imageId) {
      return AssetController.state.connectorImages[connector.imageId];
    }
    return void 0;
  },
  getChainImage(chain) {
    return AssetController.state.networkImages[namespaceImageIds[chain]];
  }
};
async function fetchData(...args) {
  const response = await fetch(...args);
  if (!response.ok) {
    const err = new Error(`HTTP status code: ${response.status}`, {
      cause: response
    });
    throw err;
  }
  return response;
}
class FetchUtil {
  constructor({ baseUrl: baseUrl2, clientId }) {
    this.baseUrl = baseUrl2;
    this.clientId = clientId;
  }
  async get({ headers, signal, cache, ...args }) {
    const url = this.createUrl(args);
    const response = await fetchData(url, { method: "GET", headers, signal, cache });
    return response.json();
  }
  async getBlob({ headers, signal, ...args }) {
    const url = this.createUrl(args);
    const response = await fetchData(url, { method: "GET", headers, signal });
    return response.blob();
  }
  async post({ body, headers, signal, ...args }) {
    const url = this.createUrl(args);
    const response = await fetchData(url, {
      method: "POST",
      headers,
      body: body ? JSON.stringify(body) : void 0,
      signal
    });
    return response.json();
  }
  async put({ body, headers, signal, ...args }) {
    const url = this.createUrl(args);
    const response = await fetchData(url, {
      method: "PUT",
      headers,
      body: body ? JSON.stringify(body) : void 0,
      signal
    });
    return response.json();
  }
  async delete({ body, headers, signal, ...args }) {
    const url = this.createUrl(args);
    const response = await fetchData(url, {
      method: "DELETE",
      headers,
      body: body ? JSON.stringify(body) : void 0,
      signal
    });
    return response.json();
  }
  createUrl({ path, params }) {
    const url = new URL(path, this.baseUrl);
    if (params) {
      Object.entries(params).forEach(([key2, value]) => {
        if (value) {
          url.searchParams.append(key2, value);
        }
      });
    }
    if (this.clientId) {
      url.searchParams.append("clientId", this.clientId);
    }
    return url;
  }
}
const StorageUtil = {
  // Cache expiry in milliseconds
  cacheExpiry: {
    portfolio: 3e4,
    nativeBalance: 3e4,
    ens: 3e5,
    identity: 3e5
  },
  isCacheExpired(timestamp, cacheExpiry) {
    return Date.now() - timestamp > cacheExpiry;
  },
  getActiveNetworkProps() {
    const namespace = StorageUtil.getActiveNamespace();
    const caipNetworkId = StorageUtil.getActiveCaipNetworkId();
    const stringChainId = caipNetworkId ? caipNetworkId.split(":")[1] : void 0;
    const chainId = stringChainId ? isNaN(Number(stringChainId)) ? stringChainId : Number(stringChainId) : void 0;
    return {
      namespace,
      caipNetworkId,
      chainId
    };
  },
  setWalletConnectDeepLink({ name, href }) {
    try {
      SafeLocalStorage.setItem(SafeLocalStorageKeys.DEEPLINK_CHOICE, JSON.stringify({ href, name }));
    } catch {
      console.info("Unable to set WalletConnect deep link");
    }
  },
  getWalletConnectDeepLink() {
    try {
      const deepLink = SafeLocalStorage.getItem(SafeLocalStorageKeys.DEEPLINK_CHOICE);
      if (deepLink) {
        return JSON.parse(deepLink);
      }
    } catch {
      console.info("Unable to get WalletConnect deep link");
    }
    return void 0;
  },
  deleteWalletConnectDeepLink() {
    try {
      SafeLocalStorage.removeItem(SafeLocalStorageKeys.DEEPLINK_CHOICE);
    } catch {
      console.info("Unable to delete WalletConnect deep link");
    }
  },
  setActiveNamespace(namespace) {
    try {
      SafeLocalStorage.setItem(SafeLocalStorageKeys.ACTIVE_NAMESPACE, namespace);
    } catch {
      console.info("Unable to set active namespace");
    }
  },
  setActiveCaipNetworkId(caipNetworkId) {
    try {
      console.log(`setActiveCaipNetworkId - caipNetworkId: ${caipNetworkId} now storing in storage`);
      const previousNetworkId = SafeLocalStorage.getItem(SafeLocalStorageKeys.ACTIVE_CAIP_NETWORK_ID);
      if (previousNetworkId && previousNetworkId !== caipNetworkId) {
        console.log(`Network changed from ${previousNetworkId} to ${caipNetworkId}, clearing all storage for previous network`);
        StorageUtil.clearAddressCache();
      }
      SafeLocalStorage.setItem(SafeLocalStorageKeys.ACTIVE_CAIP_NETWORK_ID, caipNetworkId);
      StorageUtil.setActiveNamespace(caipNetworkId.split(":")[0]);
    } catch {
      console.info("Unable to set active caip network id");
    }
  },
  getActiveCaipNetworkId() {
    try {
      return SafeLocalStorage.getItem(SafeLocalStorageKeys.ACTIVE_CAIP_NETWORK_ID);
    } catch {
      console.info("Unable to get active caip network id");
      return void 0;
    }
  },
  deleteActiveCaipNetworkId() {
    try {
      SafeLocalStorage.removeItem(SafeLocalStorageKeys.ACTIVE_CAIP_NETWORK_ID);
    } catch {
      console.info("Unable to delete active caip network id");
    }
  },
  deleteConnectedConnectorId(namespace) {
    try {
      const key2 = getSafeConnectorIdKey(namespace);
      SafeLocalStorage.removeItem(key2);
    } catch {
      console.info("Unable to delete connected connector id");
    }
  },
  setAppKitRecent(wallet) {
    try {
      const recentWallets = StorageUtil.getRecentWallets();
      const exists2 = recentWallets.find((w2) => w2.id === wallet.id);
      if (!exists2) {
        recentWallets.unshift(wallet);
        if (recentWallets.length > 2) {
          recentWallets.pop();
        }
        SafeLocalStorage.setItem(SafeLocalStorageKeys.RECENT_WALLETS, JSON.stringify(recentWallets));
      }
    } catch {
      console.info("Unable to set AppKit recent");
    }
  },
  getRecentWallets() {
    try {
      const recent = SafeLocalStorage.getItem(SafeLocalStorageKeys.RECENT_WALLETS);
      return recent ? JSON.parse(recent) : [];
    } catch {
      console.info("Unable to get AppKit recent");
    }
    return [];
  },
  setConnectedConnectorId(namespace, connectorId) {
    try {
      const key2 = getSafeConnectorIdKey(namespace);
      SafeLocalStorage.setItem(key2, connectorId);
    } catch {
      console.info("Unable to set Connected Connector Id");
    }
  },
  getActiveNamespace() {
    try {
      const activeNamespace = SafeLocalStorage.getItem(SafeLocalStorageKeys.ACTIVE_NAMESPACE);
      return activeNamespace;
    } catch {
      console.info("Unable to get active namespace");
    }
    return void 0;
  },
  getConnectedConnectorId(namespace) {
    if (!namespace) {
      return void 0;
    }
    try {
      const key2 = getSafeConnectorIdKey(namespace);
      return SafeLocalStorage.getItem(key2);
    } catch (e3) {
      console.info("Unable to get connected connector id in namespace ", namespace);
    }
    return void 0;
  },
  setConnectedSocialProvider(socialProvider) {
    try {
      SafeLocalStorage.setItem(SafeLocalStorageKeys.CONNECTED_SOCIAL, socialProvider);
    } catch {
      console.info("Unable to set connected social provider");
    }
  },
  getConnectedSocialProvider() {
    try {
      return SafeLocalStorage.getItem(SafeLocalStorageKeys.CONNECTED_SOCIAL);
    } catch {
      console.info("Unable to get connected social provider");
    }
    return void 0;
  },
  deleteConnectedSocialProvider() {
    try {
      SafeLocalStorage.removeItem(SafeLocalStorageKeys.CONNECTED_SOCIAL);
    } catch {
      console.info("Unable to delete connected social provider");
    }
  },
  getConnectedSocialUsername() {
    try {
      return SafeLocalStorage.getItem(SafeLocalStorageKeys.CONNECTED_SOCIAL_USERNAME);
    } catch {
      console.info("Unable to get connected social username");
    }
    return void 0;
  },
  getStoredActiveCaipNetworkId() {
    var _a3;
    const storedCaipNetworkId = SafeLocalStorage.getItem(SafeLocalStorageKeys.ACTIVE_CAIP_NETWORK_ID);
    const networkId = (_a3 = storedCaipNetworkId == null ? void 0 : storedCaipNetworkId.split(":")) == null ? void 0 : _a3[1];
    return networkId;
  },
  setConnectionStatus(status) {
    try {
      SafeLocalStorage.setItem(SafeLocalStorageKeys.CONNECTION_STATUS, status);
    } catch {
      console.info("Unable to set connection status");
    }
  },
  getConnectionStatus() {
    try {
      return SafeLocalStorage.getItem(SafeLocalStorageKeys.CONNECTION_STATUS);
    } catch {
      return void 0;
    }
  },
  getConnectedNamespaces() {
    try {
      const namespaces = SafeLocalStorage.getItem(SafeLocalStorageKeys.CONNECTED_NAMESPACES);
      if (!(namespaces == null ? void 0 : namespaces.length)) {
        return [];
      }
      return namespaces.split(",");
    } catch {
      return [];
    }
  },
  setConnectedNamespaces(namespaces) {
    try {
      const uniqueNamespaces = Array.from(new Set(namespaces));
      SafeLocalStorage.setItem(SafeLocalStorageKeys.CONNECTED_NAMESPACES, uniqueNamespaces.join(","));
    } catch {
      console.info("Unable to set namespaces in storage");
    }
  },
  addConnectedNamespace(namespace) {
    try {
      const namespaces = StorageUtil.getConnectedNamespaces();
      if (!namespaces.includes(namespace)) {
        namespaces.push(namespace);
        StorageUtil.setConnectedNamespaces(namespaces);
      }
    } catch {
      console.info("Unable to add connected namespace");
    }
  },
  removeConnectedNamespace(namespace) {
    try {
      const namespaces = StorageUtil.getConnectedNamespaces();
      const index2 = namespaces.indexOf(namespace);
      if (index2 > -1) {
        namespaces.splice(index2, 1);
        StorageUtil.setConnectedNamespaces(namespaces);
      }
    } catch {
      console.info("Unable to remove connected namespace");
    }
  },
  getBalanceCache() {
    let cache = {};
    try {
      const result = SafeLocalStorage.getItem(SafeLocalStorageKeys.PORTFOLIO_CACHE);
      cache = result ? JSON.parse(result) : {};
    } catch {
      console.info("Unable to get balance cache");
    }
    return cache;
  },
  removeAddressFromBalanceCache(caipAddress) {
    try {
      const cache = StorageUtil.getBalanceCache();
      SafeLocalStorage.setItem(SafeLocalStorageKeys.PORTFOLIO_CACHE, JSON.stringify({ ...cache, [caipAddress]: void 0 }));
    } catch {
      console.info("Unable to remove address from balance cache", caipAddress);
    }
  },
  getBalanceCacheForCaipAddress(caipAddress) {
    try {
      const cache = StorageUtil.getBalanceCache();
      const balanceCache = cache[caipAddress];
      if (balanceCache && !this.isCacheExpired(balanceCache.timestamp, this.cacheExpiry.portfolio)) {
        return balanceCache.balance;
      }
      StorageUtil.removeAddressFromBalanceCache(caipAddress);
    } catch {
      console.info("Unable to get balance cache for address", caipAddress);
    }
    return void 0;
  },
  updateBalanceCache(params) {
    try {
      const cache = StorageUtil.getBalanceCache();
      const { caipAddress, balance, timestamp } = params;
      cache[caipAddress] = { balance, timestamp };
      SafeLocalStorage.setItem(SafeLocalStorageKeys.PORTFOLIO_CACHE, JSON.stringify(cache));
    } catch {
      console.info("Unable to update balance cache", params);
    }
  },
  getNativeBalanceCache() {
    let cache = {};
    try {
      const result = SafeLocalStorage.getItem(SafeLocalStorageKeys.NATIVE_BALANCE_CACHE);
      cache = result ? JSON.parse(result) : {};
    } catch {
      console.info("Unable to get balance cache");
    }
    return cache;
  },
  removeAddressFromNativeBalanceCache(caipAddress) {
    try {
      const cache = StorageUtil.getNativeBalanceCache();
      SafeLocalStorage.setItem(SafeLocalStorageKeys.NATIVE_BALANCE_CACHE, JSON.stringify({ ...cache, [caipAddress]: void 0 }));
    } catch {
      console.info("Unable to remove address from native balance cache", caipAddress);
    }
  },
  getNativeBalanceCacheForCaipAddress(caipAddress) {
    try {
      const cache = StorageUtil.getNativeBalanceCache();
      const nativeBalanceCache = cache[caipAddress];
      if (nativeBalanceCache && !this.isCacheExpired(nativeBalanceCache.timestamp, this.cacheExpiry.nativeBalance)) {
        return nativeBalanceCache;
      }
      console.info("Discarding cache for address", caipAddress);
      StorageUtil.removeAddressFromNativeBalanceCache(caipAddress);
    } catch {
      console.info("Unable to get balance cache for address", caipAddress);
    }
    return void 0;
  },
  updateNativeBalanceCache(params) {
    try {
      const cache = StorageUtil.getNativeBalanceCache();
      cache[params.caipAddress] = params;
      SafeLocalStorage.setItem(SafeLocalStorageKeys.NATIVE_BALANCE_CACHE, JSON.stringify(cache));
    } catch {
      console.info("Unable to update balance cache", params);
    }
  },
  getEnsCache() {
    let cache = {};
    try {
      const result = SafeLocalStorage.getItem(SafeLocalStorageKeys.ENS_CACHE);
      cache = result ? JSON.parse(result) : {};
    } catch {
      console.info("Unable to get ens name cache");
    }
    return cache;
  },
  getEnsFromCacheForAddress(address) {
    try {
      const cache = StorageUtil.getEnsCache();
      const ensCache = cache[address];
      if (ensCache && !this.isCacheExpired(ensCache.timestamp, this.cacheExpiry.ens)) {
        return ensCache.ens;
      }
      StorageUtil.removeEnsFromCache(address);
    } catch {
      console.info("Unable to get ens name from cache", address);
    }
    return void 0;
  },
  updateEnsCache(params) {
    try {
      const cache = StorageUtil.getEnsCache();
      cache[params.address] = params;
      SafeLocalStorage.setItem(SafeLocalStorageKeys.ENS_CACHE, JSON.stringify(cache));
    } catch {
      console.info("Unable to update ens name cache", params);
    }
  },
  removeEnsFromCache(address) {
    try {
      const cache = StorageUtil.getEnsCache();
      SafeLocalStorage.setItem(SafeLocalStorageKeys.ENS_CACHE, JSON.stringify({ ...cache, [address]: void 0 }));
    } catch {
      console.info("Unable to remove ens name from cache", address);
    }
  },
  getIdentityCache() {
    let cache = {};
    try {
      const result = SafeLocalStorage.getItem(SafeLocalStorageKeys.IDENTITY_CACHE);
      cache = result ? JSON.parse(result) : {};
    } catch {
      console.info("Unable to get identity cache");
    }
    return cache;
  },
  getIdentityFromCacheForAddress(address) {
    try {
      const cache = StorageUtil.getIdentityCache();
      const identityCache = cache[address];
      if (identityCache && !this.isCacheExpired(identityCache.timestamp, this.cacheExpiry.identity)) {
        return identityCache.identity;
      }
      StorageUtil.removeIdentityFromCache(address);
    } catch {
      console.info("Unable to get identity from cache", address);
    }
    return void 0;
  },
  updateIdentityCache(params) {
    try {
      const cache = StorageUtil.getIdentityCache();
      cache[params.address] = {
        identity: params.identity,
        timestamp: params.timestamp
      };
      SafeLocalStorage.setItem(SafeLocalStorageKeys.IDENTITY_CACHE, JSON.stringify(cache));
    } catch {
      console.info("Unable to update identity cache", params);
    }
  },
  removeIdentityFromCache(address) {
    try {
      const cache = StorageUtil.getIdentityCache();
      SafeLocalStorage.setItem(SafeLocalStorageKeys.IDENTITY_CACHE, JSON.stringify({ ...cache, [address]: void 0 }));
    } catch {
      console.info("Unable to remove identity from cache", address);
    }
  },
  clearAddressCache() {
    try {
      SafeLocalStorage.removeItem(SafeLocalStorageKeys.PORTFOLIO_CACHE);
      SafeLocalStorage.removeItem(SafeLocalStorageKeys.NATIVE_BALANCE_CACHE);
      SafeLocalStorage.removeItem(SafeLocalStorageKeys.ENS_CACHE);
      SafeLocalStorage.removeItem(SafeLocalStorageKeys.IDENTITY_CACHE);
    } catch {
      console.info("Unable to clear address cache");
    }
  }
};
var buffer$2 = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$8 = 0, len = code.length; i$8 < len; ++i$8) {
  lookup[i$8] = code[i$8];
  revLookup[code.charCodeAt(i$8)] = i$8;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len2 = b64.length;
  if (len2 % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1) validLen = len2;
  var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i4;
  for (i4 = 0; i4 < len2; i4 += 4) {
    tmp = revLookup[b64.charCodeAt(i4)] << 18 | revLookup[b64.charCodeAt(i4 + 1)] << 12 | revLookup[b64.charCodeAt(i4 + 2)] << 6 | revLookup[b64.charCodeAt(i4 + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i4)] << 2 | revLookup[b64.charCodeAt(i4 + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i4)] << 10 | revLookup[b64.charCodeAt(i4 + 1)] << 4 | revLookup[b64.charCodeAt(i4 + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output2 = [];
  for (var i4 = start; i4 < end; i4 += 3) {
    tmp = (uint8[i4] << 16 & 16711680) + (uint8[i4 + 1] << 8 & 65280) + (uint8[i4 + 2] & 255);
    output2.push(tripletToBase64(tmp));
  }
  return output2.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len2 = uint8.length;
  var extraBytes = len2 % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i4 = 0, len22 = len2 - extraBytes; i4 < len22; i4 += maxChunkLength) {
    parts.push(encodeChunk(uint8, i4, i4 + maxChunkLength > len22 ? len22 : i4 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len2 - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset, isLE2, mLen, nBytes) {
  var e3, m4;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i4 = isLE2 ? nBytes - 1 : 0;
  var d4 = isLE2 ? -1 : 1;
  var s2 = buffer2[offset + i4];
  i4 += d4;
  e3 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e3 = e3 * 256 + buffer2[offset + i4], i4 += d4, nBits -= 8) {
  }
  m4 = e3 & (1 << -nBits) - 1;
  e3 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m4 = m4 * 256 + buffer2[offset + i4], i4 += d4, nBits -= 8) {
  }
  if (e3 === 0) {
    e3 = 1 - eBias;
  } else if (e3 === eMax) {
    return m4 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m4 = m4 + Math.pow(2, mLen);
    e3 = e3 - eBias;
  }
  return (s2 ? -1 : 1) * m4 * Math.pow(2, e3 - mLen);
};
ieee754.write = function(buffer2, value, offset, isLE2, mLen, nBytes) {
  var e3, m4, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i4 = isLE2 ? 0 : nBytes - 1;
  var d4 = isLE2 ? 1 : -1;
  var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m4 = isNaN(value) ? 1 : 0;
    e3 = eMax;
  } else {
    e3 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c2 = Math.pow(2, -e3)) < 1) {
      e3--;
      c2 *= 2;
    }
    if (e3 + eBias >= 1) {
      value += rt2 / c2;
    } else {
      value += rt2 * Math.pow(2, 1 - eBias);
    }
    if (value * c2 >= 2) {
      e3++;
      c2 /= 2;
    }
    if (e3 + eBias >= eMax) {
      m4 = 0;
      e3 = eMax;
    } else if (e3 + eBias >= 1) {
      m4 = (value * c2 - 1) * Math.pow(2, mLen);
      e3 = e3 + eBias;
    } else {
      m4 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e3 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i4] = m4 & 255, i4 += d4, m4 /= 256, mLen -= 8) {
  }
  e3 = e3 << mLen | m4;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i4] = e3 & 255, i4 += d4, e3 /= 256, eLen -= 8) {
  }
  buffer2[offset + i4 - d4] |= s2 * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports2) {
  const base642 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports2.Buffer = Buffer2;
  exports2.SlowBuffer = SlowBuffer2;
  exports2.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports2.kMaxLength = K_MAX_LENGTH;
  const { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new GlobalUint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e3) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this)) return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this)) return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new GlobalUint8Array(length);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe2(arg);
    }
    return from2(arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  function from2(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString2(value, encodingOrOffset);
    }
    if (GlobalArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length);
    }
    const b2 = fromObject(value);
    if (b2) return b2;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from2(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);
  Object.setPrototypeOf(Buffer2, GlobalUint8Array);
  function assertSize2(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size2 < 0) {
      throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
    }
  }
  function alloc(size2, fill, encoding) {
    assertSize2(size2);
    if (size2 <= 0) {
      return createBuffer(size2);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size2).fill(fill, encoding) : createBuffer(size2).fill(fill);
    }
    return createBuffer(size2);
  }
  Buffer2.alloc = function(size2, fill, encoding) {
    return alloc(size2, fill, encoding);
  };
  function allocUnsafe2(size2) {
    assertSize2(size2);
    return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
  }
  Buffer2.allocUnsafe = function(size2) {
    return allocUnsafe2(size2);
  };
  Buffer2.allocUnsafeSlow = function(size2) {
    return allocUnsafe2(size2);
  };
  function fromString2(string2, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength2(string2, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string2, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i4 = 0; i4 < length; i4 += 1) {
      buf[i4] = array[i4] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, GlobalUint8Array)) {
      const copy2 = new GlobalUint8Array(arrayView);
      return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new GlobalUint8Array(array);
    } else if (length === void 0) {
      buf = new GlobalUint8Array(array, byteOffset);
    } else {
      buf = new GlobalUint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len2 = checked(obj.length) | 0;
      const buf = createBuffer(len2);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len2);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer2(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a2, b2) {
    if (isInstance(a2, GlobalUint8Array)) a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
    if (isInstance(b2, GlobalUint8Array)) b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
    if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b2)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a2 === b2) return 0;
    let x2 = a2.length;
    let y4 = b2.length;
    for (let i4 = 0, len2 = Math.min(x2, y4); i4 < len2; ++i4) {
      if (a2[i4] !== b2[i4]) {
        x2 = a2[i4];
        y4 = b2[i4];
        break;
      }
    }
    if (x2 < y4) return -1;
    if (y4 < x2) return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat2(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i4;
    if (length === void 0) {
      length = 0;
      for (i4 = 0; i4 < list.length; ++i4) {
        length += list[i4].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length);
    let pos = 0;
    for (i4 = 0; i4 < list.length; ++i4) {
      let buf = list[i4];
      if (isInstance(buf, GlobalUint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
          buf.copy(buffer2, pos);
        } else {
          GlobalUint8Array.prototype.set.call(
            buffer2,
            buf,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string2, encoding) {
    if (Buffer2.isBuffer(string2)) {
      return string2.length;
    }
    if (GlobalArrayBuffer.isView(string2) || isInstance(string2, GlobalArrayBuffer)) {
      return string2.byteLength;
    }
    if (typeof string2 !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
      );
    }
    const len2 = string2.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len2 === 0) return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len2;
        case "utf8":
        case "utf-8":
          return utf8ToBytes2(string2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len2 * 2;
        case "hex":
          return len2 >>> 1;
        case "base64":
          return base64ToBytes(string2).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes2(string2).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding) encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b2, n5, m4) {
    const i4 = b2[n5];
    b2[n5] = b2[m4];
    b2[m4] = i4;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len2 = this.length;
    if (len2 % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i4 = 0; i4 < len2; i4 += 2) {
      swap(this, i4, i4 + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len2 = this.length;
    if (len2 % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i4 = 0; i4 < len2; i4 += 4) {
      swap(this, i4, i4 + 3);
      swap(this, i4 + 1, i4 + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len2 = this.length;
    if (len2 % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i4 = 0; i4 < len2; i4 += 8) {
      swap(this, i4, i4 + 7);
      swap(this, i4 + 1, i4 + 6);
      swap(this, i4 + 2, i4 + 5);
      swap(this, i4 + 3, i4 + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString2() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b2) {
    if (!Buffer2.isBuffer(b2)) throw new TypeError("Argument must be a Buffer");
    if (this === b2) return true;
    return Buffer2.compare(this, b2) === 0;
  };
  Buffer2.prototype.inspect = function inspect6() {
    let str = "";
    const max2 = exports2.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max2) str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, GlobalUint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x2 = thisEnd - thisStart;
    let y4 = end - start;
    const len2 = Math.min(x2, y4);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i4 = 0; i4 < len2; ++i4) {
      if (thisCopy[i4] !== targetCopy[i4]) {
        x2 = thisCopy[i4];
        y4 = targetCopy[i4];
        break;
      }
    }
    if (x2 < y4) return -1;
    if (y4 < x2) return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0) return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir) return -1;
      else byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof GlobalUint8Array.prototype.indexOf === "function") {
        if (dir) {
          return GlobalUint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return GlobalUint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i5) {
      if (indexSize === 1) {
        return buf[i5];
      } else {
        return buf.readUInt16BE(i5 * indexSize);
      }
    }
    let i4;
    if (dir) {
      let foundIndex = -1;
      for (i4 = byteOffset; i4 < arrLength; i4++) {
        if (read(arr, i4) === read(val, foundIndex === -1 ? 0 : i4 - foundIndex)) {
          if (foundIndex === -1) foundIndex = i4;
          if (i4 - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i4 -= i4 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i4 = byteOffset; i4 >= 0; i4--) {
        let found = true;
        for (let j2 = 0; j2 < valLength; j2++) {
          if (read(arr, i4 + j2) !== read(val, j2)) {
            found = false;
            break;
          }
        }
        if (found) return i4;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string2, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string2.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i4;
    for (i4 = 0; i4 < length; ++i4) {
      const parsed = parseInt(string2.substr(i4 * 2, 2), 16);
      if (numberIsNaN(parsed)) return i4;
      buf[offset + i4] = parsed;
    }
    return i4;
  }
  function utf8Write(buf, string2, offset, length) {
    return blitBuffer(utf8ToBytes2(string2, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string2, offset, length) {
    return blitBuffer(asciiToBytes(string2), buf, offset, length);
  }
  function base64Write(buf, string2, offset, length) {
    return blitBuffer(base64ToBytes(string2), buf, offset, length);
  }
  function ucs2Write(buf, string2, offset, length) {
    return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length);
  }
  Buffer2.prototype.write = function write3(string2, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0) encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining) length = remaining;
    if (string2.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string2, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string2, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string2, offset, length);
        case "base64":
          return base64Write(this, string2, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string2, offset, length);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON2() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base642.fromByteArray(buf);
    } else {
      return base642.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i4 = start;
    while (i4 < end) {
      const firstByte = buf[i4];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i4 + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i4 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i4 + 1];
            thirdByte = buf[i4 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i4 + 1];
            thirdByte = buf[i4 + 2];
            fourthByte = buf[i4 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i4 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len2 = codePoints.length;
    if (len2 <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i4 = 0;
    while (i4 < len2) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i4, i4 += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i4 = start; i4 < end; ++i4) {
      ret += String.fromCharCode(buf[i4] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i4 = start; i4 < end; ++i4) {
      ret += String.fromCharCode(buf[i4]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len2 = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len2) end = len2;
    let out = "";
    for (let i4 = start; i4 < end; ++i4) {
      out += hexSliceLookupTable[buf[i4]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes2 = buf.slice(start, end);
    let res = "";
    for (let i4 = 0; i4 < bytes2.length - 1; i4 += 2) {
      res += String.fromCharCode(bytes2[i4] + bytes2[i4 + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice(start, end) {
    const len2 = this.length;
    start = ~~start;
    end = end === void 0 ? len2 : ~~end;
    if (start < 0) {
      start += len2;
      if (start < 0) start = 0;
    } else if (start > len2) {
      start = len2;
    }
    if (end < 0) {
      end += len2;
      if (end < 0) end = 0;
    } else if (end > len2) {
      end = len2;
    }
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul6 = 1;
    let i4 = 0;
    while (++i4 < byteLength3 && (mul6 *= 256)) {
      val += this[offset + i4] * mul6;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val = this[offset + --byteLength3];
    let mul6 = 1;
    while (byteLength3 > 0 && (mul6 *= 256)) {
      val += this[offset + --byteLength3] * mul6;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo2 = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi2 = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo2) + (BigInt(hi2) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi2 = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo2 = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi2) << BigInt(32)) + BigInt(lo2);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul6 = 1;
    let i4 = 0;
    while (++i4 < byteLength3 && (mul6 *= 256)) {
      val += this[offset + i4] * mul6;
    }
    mul6 *= 128;
    if (val >= mul6) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let i4 = byteLength3;
    let mul6 = 1;
    let val = this[offset + --i4];
    while (i4 > 0 && (mul6 *= 256)) {
      val += this[offset + --i4] * mul6;
    }
    mul6 *= 128;
    if (val >= mul6) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128)) return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max2, min2) {
    if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max2 || value < min2) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let mul6 = 1;
    let i4 = 0;
    this[offset] = value & 255;
    while (++i4 < byteLength3 && (mul6 *= 256)) {
      this[offset + i4] = value / mul6 & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let i4 = byteLength3 - 1;
    let mul6 = 1;
    this[offset + i4] = value & 255;
    while (--i4 >= 0 && (mul6 *= 256)) {
      this[offset + i4] = value / mul6 & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min2, max2) {
    checkIntBI(value, min2, max2, buf, offset, 7);
    let lo2 = Number(value & BigInt(4294967295));
    buf[offset++] = lo2;
    lo2 = lo2 >> 8;
    buf[offset++] = lo2;
    lo2 = lo2 >> 8;
    buf[offset++] = lo2;
    lo2 = lo2 >> 8;
    buf[offset++] = lo2;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset++] = hi2;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min2, max2) {
    checkIntBI(value, min2, max2, buf, offset, 7);
    let lo2 = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo2;
    lo2 = lo2 >> 8;
    buf[offset + 6] = lo2;
    lo2 = lo2 >> 8;
    buf[offset + 5] = lo2;
    lo2 = lo2 >> 8;
    buf[offset + 4] = lo2;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi2;
    hi2 = hi2 >> 8;
    buf[offset + 2] = hi2;
    hi2 = hi2 >> 8;
    buf[offset + 1] = hi2;
    hi2 = hi2 >> 8;
    buf[offset] = hi2;
    return offset + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i4 = 0;
    let mul6 = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i4 < byteLength3 && (mul6 *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i4 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i4] = (value / mul6 >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i4 = byteLength3 - 1;
    let mul6 = 1;
    let sub = 0;
    this[offset + i4] = value & 255;
    while (--i4 >= 0 && (mul6 *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i4 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i4] = (value / mul6 >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max2, min2) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy2(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len2 = end - start;
    if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      GlobalUint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart
      );
    }
    return len2;
  };
  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) val = 0;
    let i4;
    if (typeof val === "number") {
      for (i4 = start; i4 < end; ++i4) {
        this[i4] = val;
      }
    } else {
      const bytes2 = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      const len2 = bytes2.length;
      if (len2 === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i4 = 0; i4 < end - start; ++i4) {
        this[i4 + start] = bytes2[i4 % len2];
      }
    }
    return this;
  };
  const errors = {};
  function E2(sym, getMessage, Base2) {
    errors[sym] = class NodeError extends Base2 {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E2(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E2(
    "ERR_INVALID_ARG_TYPE",
    function(name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E2(
    "ERR_OUT_OF_RANGE",
    function(str, range2, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range2}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i4 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i4 >= start + 4; i4 -= 3) {
      res = `_${val.slice(i4 - 3, i4)}${res}`;
    }
    return `${val.slice(0, i4)}${res}`;
  }
  function checkBounds(buf, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
      boundsError(offset, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min2, max2, buf, offset, byteLength3) {
    if (value > max2 || value < min2) {
      const n5 = typeof min2 === "bigint" ? "n" : "";
      let range2;
      {
        if (min2 === 0 || min2 === BigInt(0)) {
          range2 = `>= 0${n5} and < 2${n5} ** ${(byteLength3 + 1) * 8}${n5}`;
        } else {
          range2 = `>= -(2${n5} ** ${(byteLength3 + 1) * 8 - 1}${n5}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n5}`;
        }
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range2, value);
    }
    checkBounds(buf, offset, byteLength3);
  }
  function validateNumber(value, name) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
  }
  function boundsError(value, length, type2) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type2);
      throw new errors.ERR_OUT_OF_RANGE("offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(
      "offset",
      `>= ${0} and <= ${length}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes2(string2, units) {
    units = units || Infinity;
    let codePoint;
    const length = string2.length;
    let leadSurrogate = null;
    const bytes2 = [];
    for (let i4 = 0; i4 < length; ++i4) {
      codePoint = string2.charCodeAt(i4);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1) bytes2.push(239, 191, 189);
            continue;
          } else if (i4 + 1 === length) {
            if ((units -= 3) > -1) bytes2.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1) bytes2.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes2.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0) break;
        bytes2.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0) break;
        bytes2.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0) break;
        bytes2.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0) break;
        bytes2.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes2;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i4 = 0; i4 < str.length; ++i4) {
      byteArray.push(str.charCodeAt(i4) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c2, hi2, lo2;
    const byteArray = [];
    for (let i4 = 0; i4 < str.length; ++i4) {
      if ((units -= 2) < 0) break;
      c2 = str.charCodeAt(i4);
      hi2 = c2 >> 8;
      lo2 = c2 % 256;
      byteArray.push(lo2);
      byteArray.push(hi2);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base642.toByteArray(base64clean(str));
  }
  function blitBuffer(src2, dst, offset, length) {
    let i4;
    for (i4 = 0; i4 < length; ++i4) {
      if (i4 + offset >= dst.length || i4 >= src2.length) break;
      dst[i4 + offset] = src2[i4];
    }
    return i4;
  }
  function isInstance(obj, type2) {
    return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet2 = "0123456789abcdef";
    const table = new Array(256);
    for (let i4 = 0; i4 < 16; ++i4) {
      const i16 = i4 * 16;
      for (let j2 = 0; j2 < 16; ++j2) {
        table[i16 + j2] = alphabet2[i4] + alphabet2[j2];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn2) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn2;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer$2);
const Buffer = buffer$2.Buffer;
const Blob$1 = buffer$2.Blob;
const BlobOptions = buffer$2.BlobOptions;
const Buffer$1 = buffer$2.Buffer;
const File = buffer$2.File;
const FileOptions = buffer$2.FileOptions;
const INSPECT_MAX_BYTES = buffer$2.INSPECT_MAX_BYTES;
const SlowBuffer = buffer$2.SlowBuffer;
const TranscodeEncoding = buffer$2.TranscodeEncoding;
const atob$1 = buffer$2.atob;
const btoa$1 = buffer$2.btoa;
const constants$2 = buffer$2.constants;
const isAscii = buffer$2.isAscii;
const isUtf8 = buffer$2.isUtf8;
const kMaxLength = buffer$2.kMaxLength;
const kStringMaxLength = buffer$2.kStringMaxLength;
const resolveObjectURL = buffer$2.resolveObjectURL;
const transcode = buffer$2.transcode;
const dist = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob: Blob$1,
  BlobOptions,
  Buffer: Buffer$1,
  File,
  FileOptions,
  INSPECT_MAX_BYTES,
  SlowBuffer,
  TranscodeEncoding,
  atob: atob$1,
  btoa: btoa$1,
  constants: constants$2,
  default: Buffer,
  isAscii,
  isUtf8,
  kMaxLength,
  kStringMaxLength,
  resolveObjectURL,
  transcode
}, Symbol.toStringTag, { value: "Module" }));
if (typeof window !== "undefined") {
  if (!window.Buffer) {
    window.Buffer = Buffer$1;
  }
  if (!window.global) {
    window.global = window;
  }
  if (!window.process) {
    window.process = {};
  }
  if (!((_a2 = window.process) == null ? void 0 : _a2.env)) {
    window.process = { env: {} };
  }
}
const SECURE_SITE_SDK = "https://secure.walletconnect.org/sdk";
const DEFAULT_LOG_LEVEL = "error";
const SECURE_SITE_SDK_VERSION = 3;
const W3mFrameConstants = {
  APP_EVENT_KEY: "@w3m-app/",
  FRAME_EVENT_KEY: "@w3m-frame/",
  RPC_METHOD_KEY: "RPC_",
  STORAGE_KEY: "@appkit-wallet/",
  SESSION_TOKEN_KEY: "SESSION_TOKEN_KEY",
  EMAIL_LOGIN_USED_KEY: "EMAIL_LOGIN_USED_KEY",
  LAST_USED_CHAIN_KEY: "LAST_USED_CHAIN_KEY",
  LAST_EMAIL_LOGIN_TIME: "LAST_EMAIL_LOGIN_TIME",
  EMAIL: "EMAIL",
  PREFERRED_ACCOUNT_TYPE: "PREFERRED_ACCOUNT_TYPE",
  SMART_ACCOUNT_ENABLED: "SMART_ACCOUNT_ENABLED",
  SMART_ACCOUNT_ENABLED_NETWORKS: "SMART_ACCOUNT_ENABLED_NETWORKS",
  SOCIAL_USERNAME: "SOCIAL_USERNAME",
  APP_SWITCH_NETWORK: "@w3m-app/SWITCH_NETWORK",
  APP_CONNECT_EMAIL: "@w3m-app/CONNECT_EMAIL",
  APP_CONNECT_DEVICE: "@w3m-app/CONNECT_DEVICE",
  APP_CONNECT_OTP: "@w3m-app/CONNECT_OTP",
  APP_CONNECT_SOCIAL: "@w3m-app/CONNECT_SOCIAL",
  APP_GET_SOCIAL_REDIRECT_URI: "@w3m-app/GET_SOCIAL_REDIRECT_URI",
  APP_GET_USER: "@w3m-app/GET_USER",
  APP_SIGN_OUT: "@w3m-app/SIGN_OUT",
  APP_IS_CONNECTED: "@w3m-app/IS_CONNECTED",
  APP_GET_CHAIN_ID: "@w3m-app/GET_CHAIN_ID",
  APP_RPC_REQUEST: "@w3m-app/RPC_REQUEST",
  APP_UPDATE_EMAIL: "@w3m-app/UPDATE_EMAIL",
  APP_UPDATE_EMAIL_PRIMARY_OTP: "@w3m-app/UPDATE_EMAIL_PRIMARY_OTP",
  APP_UPDATE_EMAIL_SECONDARY_OTP: "@w3m-app/UPDATE_EMAIL_SECONDARY_OTP",
  APP_AWAIT_UPDATE_EMAIL: "@w3m-app/AWAIT_UPDATE_EMAIL",
  APP_SYNC_THEME: "@w3m-app/SYNC_THEME",
  APP_SYNC_DAPP_DATA: "@w3m-app/SYNC_DAPP_DATA",
  APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS: "@w3m-app/GET_SMART_ACCOUNT_ENABLED_NETWORKS",
  APP_INIT_SMART_ACCOUNT: "@w3m-app/INIT_SMART_ACCOUNT",
  APP_SET_PREFERRED_ACCOUNT: "@w3m-app/SET_PREFERRED_ACCOUNT",
  APP_CONNECT_FARCASTER: "@w3m-app/CONNECT_FARCASTER",
  APP_GET_FARCASTER_URI: "@w3m-app/GET_FARCASTER_URI",
  APP_RELOAD: "@w3m-app/RELOAD",
  FRAME_SWITCH_NETWORK_ERROR: "@w3m-frame/SWITCH_NETWORK_ERROR",
  FRAME_SWITCH_NETWORK_SUCCESS: "@w3m-frame/SWITCH_NETWORK_SUCCESS",
  FRAME_CONNECT_EMAIL_ERROR: "@w3m-frame/CONNECT_EMAIL_ERROR",
  FRAME_CONNECT_EMAIL_SUCCESS: "@w3m-frame/CONNECT_EMAIL_SUCCESS",
  FRAME_CONNECT_DEVICE_ERROR: "@w3m-frame/CONNECT_DEVICE_ERROR",
  FRAME_CONNECT_DEVICE_SUCCESS: "@w3m-frame/CONNECT_DEVICE_SUCCESS",
  FRAME_CONNECT_OTP_SUCCESS: "@w3m-frame/CONNECT_OTP_SUCCESS",
  FRAME_CONNECT_OTP_ERROR: "@w3m-frame/CONNECT_OTP_ERROR",
  FRAME_CONNECT_SOCIAL_SUCCESS: "@w3m-frame/CONNECT_SOCIAL_SUCCESS",
  FRAME_CONNECT_SOCIAL_ERROR: "@w3m-frame/CONNECT_SOCIAL_ERROR",
  FRAME_CONNECT_FARCASTER_SUCCESS: "@w3m-frame/CONNECT_FARCASTER_SUCCESS",
  FRAME_CONNECT_FARCASTER_ERROR: "@w3m-frame/CONNECT_FARCASTER_ERROR",
  FRAME_GET_FARCASTER_URI_SUCCESS: "@w3m-frame/GET_FARCASTER_URI_SUCCESS",
  FRAME_GET_FARCASTER_URI_ERROR: "@w3m-frame/GET_FARCASTER_URI_ERROR",
  FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS: "@w3m-frame/GET_SOCIAL_REDIRECT_URI_SUCCESS",
  FRAME_GET_SOCIAL_REDIRECT_URI_ERROR: "@w3m-frame/GET_SOCIAL_REDIRECT_URI_ERROR",
  FRAME_GET_USER_SUCCESS: "@w3m-frame/GET_USER_SUCCESS",
  FRAME_GET_USER_ERROR: "@w3m-frame/GET_USER_ERROR",
  FRAME_SIGN_OUT_SUCCESS: "@w3m-frame/SIGN_OUT_SUCCESS",
  FRAME_SIGN_OUT_ERROR: "@w3m-frame/SIGN_OUT_ERROR",
  FRAME_IS_CONNECTED_SUCCESS: "@w3m-frame/IS_CONNECTED_SUCCESS",
  FRAME_IS_CONNECTED_ERROR: "@w3m-frame/IS_CONNECTED_ERROR",
  FRAME_GET_CHAIN_ID_SUCCESS: "@w3m-frame/GET_CHAIN_ID_SUCCESS",
  FRAME_GET_CHAIN_ID_ERROR: "@w3m-frame/GET_CHAIN_ID_ERROR",
  FRAME_RPC_REQUEST_SUCCESS: "@w3m-frame/RPC_REQUEST_SUCCESS",
  FRAME_RPC_REQUEST_ERROR: "@w3m-frame/RPC_REQUEST_ERROR",
  FRAME_SESSION_UPDATE: "@w3m-frame/SESSION_UPDATE",
  FRAME_UPDATE_EMAIL_SUCCESS: "@w3m-frame/UPDATE_EMAIL_SUCCESS",
  FRAME_UPDATE_EMAIL_ERROR: "@w3m-frame/UPDATE_EMAIL_ERROR",
  FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS: "@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_SUCCESS",
  FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR: "@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_ERROR",
  FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS: "@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_SUCCESS",
  FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR: "@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_ERROR",
  FRAME_SYNC_THEME_SUCCESS: "@w3m-frame/SYNC_THEME_SUCCESS",
  FRAME_SYNC_THEME_ERROR: "@w3m-frame/SYNC_THEME_ERROR",
  FRAME_SYNC_DAPP_DATA_SUCCESS: "@w3m-frame/SYNC_DAPP_DATA_SUCCESS",
  FRAME_SYNC_DAPP_DATA_ERROR: "@w3m-frame/SYNC_DAPP_DATA_ERROR",
  FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS: "@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS",
  FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR: "@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR",
  FRAME_INIT_SMART_ACCOUNT_SUCCESS: "@w3m-frame/INIT_SMART_ACCOUNT_SUCCESS",
  FRAME_INIT_SMART_ACCOUNT_ERROR: "@w3m-frame/INIT_SMART_ACCOUNT_ERROR",
  FRAME_SET_PREFERRED_ACCOUNT_SUCCESS: "@w3m-frame/SET_PREFERRED_ACCOUNT_SUCCESS",
  FRAME_SET_PREFERRED_ACCOUNT_ERROR: "@w3m-frame/SET_PREFERRED_ACCOUNT_ERROR",
  FRAME_READY: "@w3m-frame/READY",
  FRAME_RELOAD_SUCCESS: "@w3m-frame/RELOAD_SUCCESS",
  FRAME_RELOAD_ERROR: "@w3m-frame/RELOAD_ERROR",
  RPC_RESPONSE_TYPE_ERROR: "RPC_RESPONSE_ERROR",
  RPC_RESPONSE_TYPE_TX: "RPC_RESPONSE_TRANSACTION_HASH",
  RPC_RESPONSE_TYPE_OBJECT: "RPC_RESPONSE_OBJECT"
};
const W3mFrameRpcConstants = {
  SAFE_RPC_METHODS: [
    "eth_accounts",
    "eth_blockNumber",
    "eth_call",
    "eth_chainId",
    "eth_estimateGas",
    "eth_feeHistory",
    "eth_gasPrice",
    "eth_getAccount",
    "eth_getBalance",
    "eth_getBlockByHash",
    "eth_getBlockByNumber",
    "eth_getBlockReceipts",
    "eth_getBlockTransactionCountByHash",
    "eth_getBlockTransactionCountByNumber",
    "eth_getCode",
    "eth_getFilterChanges",
    "eth_getFilterLogs",
    "eth_getLogs",
    "eth_getProof",
    "eth_getStorageAt",
    "eth_getTransactionByBlockHashAndIndex",
    "eth_getTransactionByBlockNumberAndIndex",
    "eth_getTransactionByHash",
    "eth_getTransactionCount",
    "eth_getTransactionReceipt",
    "eth_getUncleCountByBlockHash",
    "eth_getUncleCountByBlockNumber",
    "eth_maxPriorityFeePerGas",
    "eth_newBlockFilter",
    "eth_newFilter",
    "eth_newPendingTransactionFilter",
    "eth_sendRawTransaction",
    "eth_syncing",
    "eth_uninstallFilter",
    "wallet_getCapabilities",
    "wallet_getCallsStatus",
    "eth_getUserOperationReceipt",
    "eth_estimateUserOperationGas",
    "eth_getUserOperationByHash",
    "eth_supportedEntryPoints",
    "wallet_getAssets"
  ],
  NOT_SAFE_RPC_METHODS: [
    "eth_sign",
    "personal_sign",
    "eth_signTypedData_v4",
    "eth_sendTransaction",
    "solana_signMessage",
    "solana_signTransaction",
    "solana_signAllTransactions",
    "solana_signAndSendTransaction",
    "wallet_sendCalls",
    "wallet_grantPermissions",
    "wallet_revokePermissions",
    "eth_sendUserOperation"
  ],
  GET_CHAIN_ID: "eth_chainId",
  RPC_METHOD_NOT_ALLOWED_MESSAGE: "Requested RPC call is not allowed",
  RPC_METHOD_NOT_ALLOWED_UI_MESSAGE: "Action not allowed",
  ACCOUNT_TYPES: {
    EOA: "eoa",
    SMART_ACCOUNT: "smartAccount"
  }
};
const RegexUtil = {
  transactionHash: /^0x(?:[A-Fa-f0-9]{64})$/u,
  signedMessage: /^0x(?:[a-fA-F0-9]{62,})$/u
};
const W3mFrameStorage = {
  set(key2, value) {
    if (W3mFrameHelpers.isClient) {
      localStorage.setItem(`${W3mFrameConstants.STORAGE_KEY}${key2}`, value);
    }
  },
  get(key2) {
    if (W3mFrameHelpers.isClient) {
      return localStorage.getItem(`${W3mFrameConstants.STORAGE_KEY}${key2}`);
    }
    return null;
  },
  delete(key2, social) {
    if (W3mFrameHelpers.isClient) {
      if (social) {
        localStorage.removeItem(key2);
      } else {
        localStorage.removeItem(`${W3mFrameConstants.STORAGE_KEY}${key2}`);
      }
    }
  }
};
const EMAIL_MINIMUM_TIMEOUT = 30 * 1e3;
const W3mFrameHelpers = {
  checkIfAllowedToTriggerEmail() {
    const lastEmailLoginTime = W3mFrameStorage.get(W3mFrameConstants.LAST_EMAIL_LOGIN_TIME);
    if (lastEmailLoginTime) {
      const difference = Date.now() - Number(lastEmailLoginTime);
      if (difference < EMAIL_MINIMUM_TIMEOUT) {
        const cooldownSec = Math.ceil((EMAIL_MINIMUM_TIMEOUT - difference) / 1e3);
        throw new Error(`Please try again after ${cooldownSec} seconds`);
      }
    }
  },
  getTimeToNextEmailLogin() {
    const lastEmailLoginTime = W3mFrameStorage.get(W3mFrameConstants.LAST_EMAIL_LOGIN_TIME);
    if (lastEmailLoginTime) {
      const difference = Date.now() - Number(lastEmailLoginTime);
      if (difference < EMAIL_MINIMUM_TIMEOUT) {
        return Math.ceil((EMAIL_MINIMUM_TIMEOUT - difference) / 1e3);
      }
    }
    return 0;
  },
  checkIfRequestExists(request) {
    return W3mFrameRpcConstants.NOT_SAFE_RPC_METHODS.includes(request.method) || W3mFrameRpcConstants.SAFE_RPC_METHODS.includes(request.method);
  },
  getResponseType(response) {
    const isPayloadString = typeof response === "string";
    const isTransactionHash = isPayloadString && ((response == null ? void 0 : response.match(RegexUtil.transactionHash)) || (response == null ? void 0 : response.match(RegexUtil.signedMessage)));
    if (isTransactionHash) {
      return W3mFrameConstants.RPC_RESPONSE_TYPE_TX;
    }
    return W3mFrameConstants.RPC_RESPONSE_TYPE_OBJECT;
  },
  checkIfRequestIsSafe(request) {
    return W3mFrameRpcConstants.SAFE_RPC_METHODS.includes(request.method);
  },
  isClient: typeof window !== "undefined"
};
var util$2;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k3) => typeof obj[obj[k3]] !== "number");
    const filtered = {};
    for (const k3 of validKeys) {
      filtered[k3] = obj[k3];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e3) {
      return obj[e3];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
    const keys2 = [];
    for (const key2 in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key2)) {
        keys2.push(key2);
      }
    }
    return keys2;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_3, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$2 || (util$2 = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util$2.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data2) => {
  const t2 = typeof data2;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data2) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data2)) {
        return ZodParsedType.array;
      }
      if (data2 === null) {
        return ZodParsedType.null;
      }
      if (data2.then && typeof data2.then === "function" && data2.catch && typeof data2.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data2 instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data2 instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data2 instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util$2.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i4 = 0;
          while (i4 < issue.path.length) {
            const el = issue.path[i4];
            const terminal = i4 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i4++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$2.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
const errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util$2.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$2.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$2.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$2.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util$2.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$2.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params) => {
  const { data: data2, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m4) => !!m4).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data: data2, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s2 of results) {
      if (s2.status === "aborted")
        return INVALID;
      if (s2.status === "dirty")
        status.dirty();
      arrayValue.push(s2.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key: key2, value } = pair;
      if (key2.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key2.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key2.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key2.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x2) => x2.status === "aborted";
const isDirty = (x2) => x2.status === "dirty";
const isValid = (x2) => x2.status === "valid";
const isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
class ParseInputLazyPath {
  constructor(parent2, value, path, key2) {
    this._cachedPath = [];
    this.parent = parent2;
    this.data = value;
    this._path = path;
    this._key = key2;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
class ZodType {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data2, params) {
    const result = this.safeParse(data2, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data2, params) {
    var _a3;
    const ctx = {
      common: {
        issues: [],
        async: (_a3 = params === null || params === void 0 ? void 0 : params.async) !== null && _a3 !== void 0 ? _a3 : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data2,
      parsedType: getParsedType(data2)
    };
    const result = this._parseSync({ data: data2, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data2, params) {
    const result = await this.safeParseAsync(data2, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data2, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data2,
      parsedType: getParsedType(data2)
    };
    const maybeAsyncResult = this._parse({ data: data2, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data2) => {
          if (!data2) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[a-z][a-z0-9]*$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
};
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a3) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex2 = datetimeRegex(check);
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$2.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex2, validation, message) {
    return this.refinement((data2) => regex2.test(data2), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a3;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a3 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a3 !== void 0 ? _a3 : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  regex(regex2, message) {
    return this._addCheck({
      kind: "regex",
      regex: regex2,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len2, message) {
    return this._addCheck({
      kind: "length",
      value: len2,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxLength() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
}
ZodString.create = (params) => {
  var _a3;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a3 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a3 !== void 0 ? _a3 : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$2.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$2.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$2.isInteger(ch.value));
  }
  get isFinite() {
    let max2 = null, min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      } else if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return Number.isFinite(min2) && Number.isFinite(max2);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$2.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
}
ZodBigInt.create = (params) => {
  var _a3;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a3 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a3 !== void 0 ? _a3 : false,
    ...processCreateParams(params)
  });
};
class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$2.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2 != null ? new Date(min2) : null;
  }
  get maxDate() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2 != null ? new Date(max2) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i4) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i4));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i4) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i4));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len2, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len2, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key2 in schema.shape) {
      const fieldSchema = schema.shape[key2];
      newShape[key2] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys2 = util$2.objectKeys(shape);
    return this._cached = { shape, keys: keys2 };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key2 in ctx.data) {
        if (!shapeKeys.includes(key2)) {
          extraKeys.push(key2);
        }
      }
    }
    const pairs = [];
    for (const key2 of shapeKeys) {
      const keyValidator = shape[key2];
      const value = ctx.data[key2];
      pairs.push({
        key: { status: "valid", value: key2 },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key2)),
        alwaysSet: key2 in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key2 of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key2 },
            value: { status: "valid", value: ctx.data[key2] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key2 of extraKeys) {
        const value = ctx.data[key2];
        pairs.push({
          key: { status: "valid", value: key2 },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key2)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key2 in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key2 = await pair.key;
          syncPairs.push({
            key: key2,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a3, _b2, _c3, _d;
          const defaultError = (_c3 = (_b2 = (_a3 = this._def).errorMap) === null || _b2 === void 0 ? void 0 : _b2.call(_a3, issue, ctx).message) !== null && _c3 !== void 0 ? _c3 : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key2, schema) {
    return this.augment({ [key2]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask2) {
    const shape = {};
    util$2.objectKeys(mask2).forEach((key2) => {
      if (mask2[key2] && this.shape[key2]) {
        shape[key2] = this.shape[key2];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask2) {
    const shape = {};
    util$2.objectKeys(this.shape).forEach((key2) => {
      if (!mask2[key2]) {
        shape[key2] = this.shape[key2];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask2) {
    const newShape = {};
    util$2.objectKeys(this.shape).forEach((key2) => {
      const fieldSchema = this.shape[key2];
      if (mask2 && !mask2[key2]) {
        newShape[key2] = fieldSchema;
      } else {
        newShape[key2] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask2) {
    const newShape = {};
    util$2.objectKeys(this.shape).forEach((key2) => {
      if (mask2 && !mask2[key2]) {
        newShape[key2] = this.shape[key2];
      } else {
        const fieldSchema = this.shape[key2];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key2] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util$2.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types2, params) => {
  return new ZodUnion({
    options: types2,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
const getDiscriminator = (type2) => {
  if (type2 instanceof ZodLazy) {
    return getDiscriminator(type2.schema);
  } else if (type2 instanceof ZodEffects) {
    return getDiscriminator(type2.innerType());
  } else if (type2 instanceof ZodLiteral) {
    return [type2.value];
  } else if (type2 instanceof ZodEnum) {
    return type2.options;
  } else if (type2 instanceof ZodNativeEnum) {
    return Object.keys(type2.enum);
  } else if (type2 instanceof ZodDefault) {
    return getDiscriminator(type2._def.innerType);
  } else if (type2 instanceof ZodUndefined) {
    return [void 0];
  } else if (type2 instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type2 of options) {
      const discriminatorValues = getDiscriminator(type2.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type2);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a2, b2) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b2);
  if (a2 === b2) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util$2.objectKeys(b2);
    const sharedKeys = util$2.objectKeys(a2).filter((key2) => bKeys.indexOf(key2) !== -1);
    const newObj = { ...a2, ...b2 };
    for (const key2 of sharedKeys) {
      const sharedValue = mergeValues(a2[key2], b2[key2]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key2] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b2.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a2.length; index2++) {
      const itemA = a2[index2];
      const itemB = b2[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b2) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key2 in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, key2)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key2], ctx.path, key2))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key2, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key2 = await pair.key;
          const value = await pair.value;
          if (key2.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key2.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key2.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key2 = pair.key;
        const value = pair.value;
        if (key2.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key2.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key2.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i4) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i4)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size2, message) {
    return this.min(size2, message).max(size2, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn2 = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me2 = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me2._def.args.parseAsync(args, params).catch((e3) => {
          error.addIssue(makeArgsIssue(args, e3));
          throw error;
        });
        const result = await Reflect.apply(fn2, this, parsedArgs);
        const parsedReturns = await me2._def.returns._def.type.parseAsync(result, params).catch((e3) => {
          error.addIssue(makeReturnsIssue(result, e3));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me2 = this;
      return OK(function(...args) {
        const parsedArgs = me2._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn2, this, parsedArgs.data);
        const parsedReturns = me2._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util$2.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values) {
    return ZodEnum.create(values);
  }
  exclude(values) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
  }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util$2.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util$2.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util$2.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util$2.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data2) => {
      return this._def.type.parseAsync(data2, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base3 = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base3))
          return base3;
        const result = effect.transform(base3.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base3) => {
          if (!isValid(base3))
            return base3;
          return Promise.resolve(effect.transform(base3.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util$2.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type2, params) => {
  return new ZodOptional({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type2, params) => {
  return new ZodNullable({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data2 = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data2 = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data: data2,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type2, params) => {
  return new ZodDefault({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type2, params) => {
  return new ZodCatch({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data2 = ctx.data;
    return this._def.type._parse({
      data: data2,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a2, b2) {
    return new ZodPipeline({
      in: a2,
      out: b2,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
}
ZodReadonly.create = (type2, params) => {
  return new ZodReadonly({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
const custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data2, ctx) => {
      var _a3, _b2;
      if (!check(data2)) {
        const p2 = typeof params === "function" ? params(data2) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b2 = (_a3 = p2.fatal) !== null && _a3 !== void 0 ? _a3 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
        const p22 = typeof p2 === "string" ? { message: p2 } : p2;
        ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
const late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data2) => data2 instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce$1 = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
const NEVER = INVALID;
var z$c = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util$2;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce: coerce$1,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});
const zError = z$c.object({ message: z$c.string() });
function zType(key2) {
  return z$c.literal(W3mFrameConstants[key2]);
}
z$c.object({
  accessList: z$c.array(z$c.string()),
  blockHash: z$c.string().nullable(),
  blockNumber: z$c.string().nullable(),
  chainId: z$c.string().or(z$c.number()),
  from: z$c.string(),
  gas: z$c.string(),
  hash: z$c.string(),
  input: z$c.string().nullable(),
  maxFeePerGas: z$c.string(),
  maxPriorityFeePerGas: z$c.string(),
  nonce: z$c.string(),
  r: z$c.string(),
  s: z$c.string(),
  to: z$c.string(),
  transactionIndex: z$c.string().nullable(),
  type: z$c.string(),
  v: z$c.string(),
  value: z$c.string()
});
const AppSwitchNetworkRequest = z$c.object({ chainId: z$c.string().or(z$c.number()) });
const AppConnectEmailRequest = z$c.object({ email: z$c.string().email() });
const AppConnectOtpRequest = z$c.object({ otp: z$c.string() });
const AppConnectSocialRequest = z$c.object({ uri: z$c.string() });
const AppGetUserRequest = z$c.object({
  chainId: z$c.optional(z$c.string().or(z$c.number())),
  preferredAccountType: z$c.optional(z$c.string())
});
const AppGetSocialRedirectUriRequest = z$c.object({
  provider: z$c.enum(["google", "github", "apple", "facebook", "x", "discord"])
});
const AppUpdateEmailRequest = z$c.object({ email: z$c.string().email() });
const AppUpdateEmailPrimaryOtpRequest = z$c.object({ otp: z$c.string() });
const AppUpdateEmailSecondaryOtpRequest = z$c.object({ otp: z$c.string() });
const AppSyncThemeRequest = z$c.object({
  themeMode: z$c.optional(z$c.enum(["light", "dark"])),
  themeVariables: z$c.optional(z$c.record(z$c.string(), z$c.string().or(z$c.number()))),
  w3mThemeVariables: z$c.optional(z$c.record(z$c.string(), z$c.string()))
});
const AppSyncDappDataRequest = z$c.object({
  metadata: z$c.object({
    name: z$c.string(),
    description: z$c.string(),
    url: z$c.string(),
    icons: z$c.array(z$c.string())
  }).optional(),
  sdkVersion: z$c.string().optional(),
  sdkType: z$c.string().optional(),
  projectId: z$c.string()
});
const AppSetPreferredAccountRequest = z$c.object({ type: z$c.string() });
const FrameConnectEmailResponse = z$c.object({
  action: z$c.enum(["VERIFY_DEVICE", "VERIFY_OTP", "CONNECT"])
});
const FrameGetFarcasterUriResponse = z$c.object({
  url: z$c.string()
});
const FrameConnectFarcasterResponse = z$c.object({
  userName: z$c.string()
});
const FrameConnectSocialResponse = z$c.object({
  email: z$c.string(),
  address: z$c.string(),
  chainId: z$c.string().or(z$c.number()),
  accounts: z$c.array(z$c.object({
    address: z$c.string(),
    type: z$c.enum([
      W3mFrameRpcConstants.ACCOUNT_TYPES.EOA,
      W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
    ])
  })).optional(),
  userName: z$c.string().optional()
});
const FrameUpdateEmailResponse = z$c.object({
  action: z$c.enum(["VERIFY_PRIMARY_OTP", "VERIFY_SECONDARY_OTP"])
});
const FrameGetUserResponse = z$c.object({
  email: z$c.string().email().optional().nullable(),
  address: z$c.string(),
  chainId: z$c.string().or(z$c.number()),
  smartAccountDeployed: z$c.optional(z$c.boolean()),
  accounts: z$c.array(z$c.object({
    address: z$c.string(),
    type: z$c.enum([
      W3mFrameRpcConstants.ACCOUNT_TYPES.EOA,
      W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
    ])
  })).optional(),
  preferredAccountType: z$c.optional(z$c.string())
});
const FrameGetSocialRedirectUriResponse = z$c.object({ uri: z$c.string() });
const FrameIsConnectedResponse = z$c.object({ isConnected: z$c.boolean() });
const FrameGetChainIdResponse = z$c.object({ chainId: z$c.string().or(z$c.number()) });
const FrameSwitchNetworkResponse = z$c.object({ chainId: z$c.string().or(z$c.number()) });
const FrameUpdateEmailSecondaryOtpResponse = z$c.object({ newEmail: z$c.string().email() });
const FrameGetSmartAccountEnabledNetworksResponse = z$c.object({
  smartAccountEnabledNetworks: z$c.array(z$c.number())
});
z$c.object({
  address: z$c.string(),
  isDeployed: z$c.boolean()
});
const FrameReadyResponse = z$c.object({
  version: z$c.string().optional()
});
const FrameSetPreferredAccountResponse = z$c.object({ type: z$c.string(), address: z$c.string() });
const RpcResponse = z$c.any();
const RpcEthAccountsRequest = z$c.object({
  method: z$c.literal("eth_accounts")
});
const RpcEthBlockNumber = z$c.object({
  method: z$c.literal("eth_blockNumber")
});
const RpcEthCall = z$c.object({
  method: z$c.literal("eth_call"),
  params: z$c.array(z$c.any())
});
const RpcEthChainId = z$c.object({
  method: z$c.literal("eth_chainId")
});
const RpcEthEstimateGas = z$c.object({
  method: z$c.literal("eth_estimateGas"),
  params: z$c.array(z$c.any())
});
const RpcEthFeeHistory = z$c.object({
  method: z$c.literal("eth_feeHistory"),
  params: z$c.array(z$c.any())
});
const RpcEthGasPrice = z$c.object({
  method: z$c.literal("eth_gasPrice")
});
const RpcEthGetAccount = z$c.object({
  method: z$c.literal("eth_getAccount"),
  params: z$c.array(z$c.any())
});
const RpcEthGetBalance = z$c.object({
  method: z$c.literal("eth_getBalance"),
  params: z$c.array(z$c.any())
});
const RpcEthGetBlockyByHash = z$c.object({
  method: z$c.literal("eth_getBlockByHash"),
  params: z$c.array(z$c.any())
});
const RpcEthGetBlockByNumber = z$c.object({
  method: z$c.literal("eth_getBlockByNumber"),
  params: z$c.array(z$c.any())
});
const RpcEthGetBlockReceipts = z$c.object({
  method: z$c.literal("eth_getBlockReceipts"),
  params: z$c.array(z$c.any())
});
const RcpEthGetBlockTransactionCountByHash = z$c.object({
  method: z$c.literal("eth_getBlockTransactionCountByHash"),
  params: z$c.array(z$c.any())
});
const RcpEthGetBlockTransactionCountByNumber = z$c.object({
  method: z$c.literal("eth_getBlockTransactionCountByNumber"),
  params: z$c.array(z$c.any())
});
const RpcEthGetCode = z$c.object({
  method: z$c.literal("eth_getCode"),
  params: z$c.array(z$c.any())
});
const RpcEthGetFilter = z$c.object({
  method: z$c.literal("eth_getFilterChanges"),
  params: z$c.array(z$c.any())
});
const RpcEthGetFilterLogs = z$c.object({
  method: z$c.literal("eth_getFilterLogs"),
  params: z$c.array(z$c.any())
});
const RpcEthGetLogs = z$c.object({
  method: z$c.literal("eth_getLogs"),
  params: z$c.array(z$c.any())
});
const RpcEthGetProof = z$c.object({
  method: z$c.literal("eth_getProof"),
  params: z$c.array(z$c.any())
});
const RpcEthGetStorageAt = z$c.object({
  method: z$c.literal("eth_getStorageAt"),
  params: z$c.array(z$c.any())
});
const RpcEthGetTransactionByBlockHashAndIndex = z$c.object({
  method: z$c.literal("eth_getTransactionByBlockHashAndIndex"),
  params: z$c.array(z$c.any())
});
const RpcEthGetTransactionByBlockNumberAndIndex = z$c.object({
  method: z$c.literal("eth_getTransactionByBlockNumberAndIndex"),
  params: z$c.array(z$c.any())
});
const RpcEthGetTransactionByHash = z$c.object({
  method: z$c.literal("eth_getTransactionByHash"),
  params: z$c.array(z$c.any())
});
const RpcEthGetTransactionCount = z$c.object({
  method: z$c.literal("eth_getTransactionCount"),
  params: z$c.array(z$c.any())
});
const RpcEthGetTransactionReceipt = z$c.object({
  method: z$c.literal("eth_getTransactionReceipt"),
  params: z$c.array(z$c.any())
});
const RpcEthGetUncleCountByBlockHash = z$c.object({
  method: z$c.literal("eth_getUncleCountByBlockHash"),
  params: z$c.array(z$c.any())
});
const RpcEthGetUncleCountByBlockNumber = z$c.object({
  method: z$c.literal("eth_getUncleCountByBlockNumber"),
  params: z$c.array(z$c.any())
});
const RpcEthMaxPriorityFeePerGas = z$c.object({
  method: z$c.literal("eth_maxPriorityFeePerGas")
});
const RpcEthNewBlockFilter = z$c.object({
  method: z$c.literal("eth_newBlockFilter")
});
const RpcEthNewFilter = z$c.object({
  method: z$c.literal("eth_newFilter"),
  params: z$c.array(z$c.any())
});
const RpcEthNewPendingTransactionFilter = z$c.object({
  method: z$c.literal("eth_newPendingTransactionFilter")
});
const RpcEthSendRawTransaction = z$c.object({
  method: z$c.literal("eth_sendRawTransaction"),
  params: z$c.array(z$c.any())
});
const RpcEthSyncing = z$c.object({
  method: z$c.literal("eth_syncing"),
  params: z$c.array(z$c.any())
});
const RpcUnistallFilter = z$c.object({
  method: z$c.literal("eth_uninstallFilter"),
  params: z$c.array(z$c.any())
});
const RpcPersonalSignRequest = z$c.object({
  method: z$c.literal("personal_sign"),
  params: z$c.array(z$c.any())
});
z$c.object({
  method: z$c.literal("eth_sign"),
  params: z$c.array(z$c.any())
});
const RpcEthSignTypedDataV4 = z$c.object({
  method: z$c.literal("eth_signTypedData_v4"),
  params: z$c.array(z$c.any())
});
const RpcEthSendTransactionRequest = z$c.object({
  method: z$c.literal("eth_sendTransaction"),
  params: z$c.array(z$c.any())
});
const RpcSolanaSignMessageRequest = z$c.object({
  method: z$c.literal("solana_signMessage"),
  params: z$c.object({
    message: z$c.string(),
    pubkey: z$c.string()
  })
});
const RpcSolanaSignTransactionRequest = z$c.object({
  method: z$c.literal("solana_signTransaction"),
  params: z$c.object({
    transaction: z$c.string()
  })
});
const RpcSolanaSignAllTransactionsRequest = z$c.object({
  method: z$c.literal("solana_signAllTransactions"),
  params: z$c.object({
    transactions: z$c.array(z$c.string())
  })
});
const RpcSolanaSignAndSendTransactionRequest = z$c.object({
  method: z$c.literal("solana_signAndSendTransaction"),
  params: z$c.object({
    transaction: z$c.string(),
    options: z$c.object({
      skipPreflight: z$c.boolean().optional(),
      preflightCommitment: z$c.enum([
        "processed",
        "confirmed",
        "finalized",
        "recent",
        "single",
        "singleGossip",
        "root",
        "max"
      ]).optional(),
      maxRetries: z$c.number().optional(),
      minContextSlot: z$c.number().optional()
    }).optional()
  })
});
const WalletSendCallsRequest = z$c.object({
  method: z$c.literal("wallet_sendCalls"),
  params: z$c.array(z$c.object({
    chainId: z$c.string().or(z$c.number()).optional(),
    from: z$c.string().optional(),
    version: z$c.string().optional(),
    capabilities: z$c.any().optional(),
    calls: z$c.array(z$c.object({
      to: z$c.string().startsWith("0x"),
      data: z$c.string().startsWith("0x").optional(),
      value: z$c.string().optional()
    }))
  }))
});
const WalletGetCallsReceiptRequest = z$c.object({
  method: z$c.literal("wallet_getCallsStatus"),
  params: z$c.array(z$c.string())
});
const WalletGetCapabilitiesRequest = z$c.object({
  method: z$c.literal("wallet_getCapabilities")
});
const WalletGrantPermissionsRequest = z$c.object({
  method: z$c.literal("wallet_grantPermissions"),
  params: z$c.array(z$c.any())
});
const WalletRevokePermissionsRequest = z$c.object({
  method: z$c.literal("wallet_revokePermissions"),
  params: z$c.any()
});
const WalletGetAssetsRequest = z$c.object({
  method: z$c.literal("wallet_getAssets"),
  params: z$c.any()
});
const FrameSession = z$c.object({
  token: z$c.string()
});
const EventSchema = z$c.object({
  id: z$c.string().optional()
});
const W3mFrameSchema = {
  appEvent: EventSchema.extend({
    type: zType("APP_SWITCH_NETWORK"),
    payload: AppSwitchNetworkRequest
  }).or(EventSchema.extend({
    type: zType("APP_CONNECT_EMAIL"),
    payload: AppConnectEmailRequest
  })).or(EventSchema.extend({ type: zType("APP_CONNECT_DEVICE") })).or(EventSchema.extend({ type: zType("APP_CONNECT_OTP"), payload: AppConnectOtpRequest })).or(EventSchema.extend({
    type: zType("APP_CONNECT_SOCIAL"),
    payload: AppConnectSocialRequest
  })).or(EventSchema.extend({ type: zType("APP_GET_FARCASTER_URI") })).or(EventSchema.extend({ type: zType("APP_CONNECT_FARCASTER") })).or(EventSchema.extend({
    type: zType("APP_GET_USER"),
    payload: z$c.optional(AppGetUserRequest)
  })).or(EventSchema.extend({
    type: zType("APP_GET_SOCIAL_REDIRECT_URI"),
    payload: AppGetSocialRedirectUriRequest
  })).or(EventSchema.extend({ type: zType("APP_SIGN_OUT") })).or(EventSchema.extend({
    type: zType("APP_IS_CONNECTED"),
    payload: z$c.optional(FrameSession)
  })).or(EventSchema.extend({ type: zType("APP_GET_CHAIN_ID") })).or(EventSchema.extend({ type: zType("APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS") })).or(EventSchema.extend({ type: zType("APP_INIT_SMART_ACCOUNT") })).or(EventSchema.extend({
    type: zType("APP_SET_PREFERRED_ACCOUNT"),
    payload: AppSetPreferredAccountRequest
  })).or(EventSchema.extend({
    type: zType("APP_RPC_REQUEST"),
    payload: RpcPersonalSignRequest.or(WalletGetAssetsRequest).or(RpcEthAccountsRequest).or(RpcEthBlockNumber).or(RpcEthCall).or(RpcEthChainId).or(RpcEthEstimateGas).or(RpcEthFeeHistory).or(RpcEthGasPrice).or(RpcEthGetAccount).or(RpcEthGetBalance).or(RpcEthGetBlockyByHash).or(RpcEthGetBlockByNumber).or(RpcEthGetBlockReceipts).or(RcpEthGetBlockTransactionCountByHash).or(RcpEthGetBlockTransactionCountByNumber).or(RpcEthGetCode).or(RpcEthGetFilter).or(RpcEthGetFilterLogs).or(RpcEthGetLogs).or(RpcEthGetProof).or(RpcEthGetStorageAt).or(RpcEthGetTransactionByBlockHashAndIndex).or(RpcEthGetTransactionByBlockNumberAndIndex).or(RpcEthGetTransactionByHash).or(RpcEthGetTransactionCount).or(RpcEthGetTransactionReceipt).or(RpcEthGetUncleCountByBlockHash).or(RpcEthGetUncleCountByBlockNumber).or(RpcEthMaxPriorityFeePerGas).or(RpcEthNewBlockFilter).or(RpcEthNewFilter).or(RpcEthNewPendingTransactionFilter).or(RpcEthSendRawTransaction).or(RpcEthSyncing).or(RpcUnistallFilter).or(RpcPersonalSignRequest).or(RpcEthSignTypedDataV4).or(RpcEthSendTransactionRequest).or(RpcSolanaSignMessageRequest).or(RpcSolanaSignTransactionRequest).or(RpcSolanaSignAllTransactionsRequest).or(RpcSolanaSignAndSendTransactionRequest).or(WalletGetCallsReceiptRequest).or(WalletSendCallsRequest).or(WalletGetCapabilitiesRequest).or(WalletGrantPermissionsRequest).or(WalletRevokePermissionsRequest)
  })).or(EventSchema.extend({ type: zType("APP_UPDATE_EMAIL"), payload: AppUpdateEmailRequest })).or(EventSchema.extend({
    type: zType("APP_UPDATE_EMAIL_PRIMARY_OTP"),
    payload: AppUpdateEmailPrimaryOtpRequest
  })).or(EventSchema.extend({
    type: zType("APP_UPDATE_EMAIL_SECONDARY_OTP"),
    payload: AppUpdateEmailSecondaryOtpRequest
  })).or(EventSchema.extend({ type: zType("APP_SYNC_THEME"), payload: AppSyncThemeRequest })).or(EventSchema.extend({
    type: zType("APP_SYNC_DAPP_DATA"),
    payload: AppSyncDappDataRequest
  })).or(EventSchema.extend({
    type: zType("APP_RELOAD")
  })),
  frameEvent: EventSchema.extend({ type: zType("FRAME_SWITCH_NETWORK_ERROR"), payload: zError }).or(EventSchema.extend({
    type: zType("FRAME_SWITCH_NETWORK_SUCCESS"),
    payload: FrameSwitchNetworkResponse
  })).or(EventSchema.extend({
    type: zType("FRAME_CONNECT_EMAIL_SUCCESS"),
    payload: FrameConnectEmailResponse
  })).or(EventSchema.extend({ type: zType("FRAME_CONNECT_EMAIL_ERROR"), payload: zError })).or(EventSchema.extend({
    type: zType("FRAME_GET_FARCASTER_URI_SUCCESS"),
    payload: FrameGetFarcasterUriResponse
  })).or(EventSchema.extend({ type: zType("FRAME_GET_FARCASTER_URI_ERROR"), payload: zError })).or(EventSchema.extend({
    type: zType("FRAME_CONNECT_FARCASTER_SUCCESS"),
    payload: FrameConnectFarcasterResponse
  })).or(EventSchema.extend({ type: zType("FRAME_CONNECT_FARCASTER_ERROR"), payload: zError })).or(EventSchema.extend({ type: zType("FRAME_CONNECT_OTP_ERROR"), payload: zError })).or(EventSchema.extend({ type: zType("FRAME_CONNECT_OTP_SUCCESS") })).or(EventSchema.extend({ type: zType("FRAME_CONNECT_DEVICE_ERROR"), payload: zError })).or(EventSchema.extend({ type: zType("FRAME_CONNECT_DEVICE_SUCCESS") })).or(EventSchema.extend({
    type: zType("FRAME_CONNECT_SOCIAL_SUCCESS"),
    payload: FrameConnectSocialResponse
  })).or(EventSchema.extend({
    type: zType("FRAME_CONNECT_SOCIAL_ERROR"),
    payload: zError
  })).or(EventSchema.extend({ type: zType("FRAME_GET_USER_ERROR"), payload: zError })).or(EventSchema.extend({
    type: zType("FRAME_GET_USER_SUCCESS"),
    payload: FrameGetUserResponse
  })).or(EventSchema.extend({
    type: zType("FRAME_GET_SOCIAL_REDIRECT_URI_ERROR"),
    payload: zError
  })).or(EventSchema.extend({
    type: zType("FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS"),
    payload: FrameGetSocialRedirectUriResponse
  })).or(EventSchema.extend({ type: zType("FRAME_SIGN_OUT_ERROR"), payload: zError })).or(EventSchema.extend({ type: zType("FRAME_SIGN_OUT_SUCCESS") })).or(EventSchema.extend({ type: zType("FRAME_IS_CONNECTED_ERROR"), payload: zError })).or(EventSchema.extend({
    type: zType("FRAME_IS_CONNECTED_SUCCESS"),
    payload: FrameIsConnectedResponse
  })).or(EventSchema.extend({ type: zType("FRAME_GET_CHAIN_ID_ERROR"), payload: zError })).or(EventSchema.extend({
    type: zType("FRAME_GET_CHAIN_ID_SUCCESS"),
    payload: FrameGetChainIdResponse
  })).or(EventSchema.extend({ type: zType("FRAME_RPC_REQUEST_ERROR"), payload: zError })).or(EventSchema.extend({ type: zType("FRAME_RPC_REQUEST_SUCCESS"), payload: RpcResponse })).or(EventSchema.extend({ type: zType("FRAME_SESSION_UPDATE"), payload: FrameSession })).or(EventSchema.extend({ type: zType("FRAME_UPDATE_EMAIL_ERROR"), payload: zError })).or(EventSchema.extend({
    type: zType("FRAME_UPDATE_EMAIL_SUCCESS"),
    payload: FrameUpdateEmailResponse
  })).or(EventSchema.extend({
    type: zType("FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR"),
    payload: zError
  })).or(EventSchema.extend({ type: zType("FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS") })).or(EventSchema.extend({
    type: zType("FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR"),
    payload: zError
  })).or(EventSchema.extend({
    type: zType("FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS"),
    payload: FrameUpdateEmailSecondaryOtpResponse
  })).or(EventSchema.extend({ type: zType("FRAME_SYNC_THEME_ERROR"), payload: zError })).or(EventSchema.extend({ type: zType("FRAME_SYNC_THEME_SUCCESS") })).or(EventSchema.extend({ type: zType("FRAME_SYNC_DAPP_DATA_ERROR"), payload: zError })).or(EventSchema.extend({ type: zType("FRAME_SYNC_DAPP_DATA_SUCCESS") })).or(EventSchema.extend({
    type: zType("FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS"),
    payload: FrameGetSmartAccountEnabledNetworksResponse
  })).or(EventSchema.extend({
    type: zType("FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR"),
    payload: zError
  })).or(EventSchema.extend({ type: zType("FRAME_INIT_SMART_ACCOUNT_ERROR"), payload: zError })).or(EventSchema.extend({
    type: zType("FRAME_SET_PREFERRED_ACCOUNT_SUCCESS"),
    payload: FrameSetPreferredAccountResponse
  })).or(EventSchema.extend({
    type: zType("FRAME_SET_PREFERRED_ACCOUNT_ERROR"),
    payload: zError
  })).or(EventSchema.extend({ type: zType("FRAME_READY"), payload: FrameReadyResponse })).or(EventSchema.extend({
    type: zType("FRAME_RELOAD_ERROR"),
    payload: zError
  })).or(EventSchema.extend({ type: zType("FRAME_RELOAD_SUCCESS") }))
};
function shouldHandleEvent(eventKey, data2 = {}) {
  var _a3;
  return typeof (data2 == null ? void 0 : data2.type) === "string" && ((_a3 = data2 == null ? void 0 : data2.type) == null ? void 0 : _a3.includes(eventKey));
}
class W3mFrame {
  constructor({ projectId, isAppClient = false, chainId = "eip155:1", enableLogger = true }) {
    this.iframe = null;
    this.rpcUrl = ConstantsUtil$4.BLOCKCHAIN_API_RPC_URL;
    this.initFrame = () => {
      const isFrameInitialized = document.getElementById("w3m-iframe");
      if (this.iframe && !isFrameInitialized) {
        document.body.appendChild(this.iframe);
      }
    };
    this.events = {
      registerFrameEventHandler: (id2, callback, signal) => {
        function eventHandler({ data: data2 }) {
          if (!shouldHandleEvent(W3mFrameConstants.FRAME_EVENT_KEY, data2)) {
            return;
          }
          const frameEvent = W3mFrameSchema.frameEvent.parse(data2);
          if (frameEvent.id === id2) {
            callback(frameEvent);
            window.removeEventListener("message", eventHandler);
          }
        }
        if (W3mFrameHelpers.isClient) {
          window.addEventListener("message", eventHandler);
          signal.addEventListener("abort", () => {
            window.removeEventListener("message", eventHandler);
          });
        }
      },
      onFrameEvent: (callback) => {
        if (W3mFrameHelpers.isClient) {
          window.addEventListener("message", ({ data: data2 }) => {
            if (!shouldHandleEvent(W3mFrameConstants.FRAME_EVENT_KEY, data2)) {
              return;
            }
            const frameEvent = W3mFrameSchema.frameEvent.parse(data2);
            callback(frameEvent);
          });
        }
      },
      onAppEvent: (callback) => {
        if (W3mFrameHelpers.isClient) {
          window.addEventListener("message", ({ data: data2 }) => {
            if (!shouldHandleEvent(W3mFrameConstants.APP_EVENT_KEY, data2)) {
              return;
            }
            const appEvent = W3mFrameSchema.appEvent.parse(data2);
            callback(appEvent);
          });
        }
      },
      postAppEvent: (event) => {
        var _a3;
        if (W3mFrameHelpers.isClient) {
          if (!((_a3 = this.iframe) == null ? void 0 : _a3.contentWindow)) {
            throw new Error("W3mFrame: iframe is not set");
          }
          W3mFrameSchema.appEvent.parse(event);
          this.iframe.contentWindow.postMessage(event, "*");
        }
      },
      postFrameEvent: (event) => {
        if (W3mFrameHelpers.isClient) {
          if (!parent) {
            throw new Error("W3mFrame: parent is not set");
          }
          W3mFrameSchema.frameEvent.parse(event);
          parent.postMessage(event, "*");
        }
      }
    };
    this.projectId = projectId;
    this.frameLoadPromise = new Promise((resolve, reject) => {
      this.frameLoadPromiseResolver = { resolve, reject };
    });
    if (isAppClient) {
      this.frameLoadPromise = new Promise((resolve, reject) => {
        this.frameLoadPromiseResolver = { resolve, reject };
      });
      if (W3mFrameHelpers.isClient) {
        const iframe = document.createElement("iframe");
        iframe.id = "w3m-iframe";
        iframe.src = `${SECURE_SITE_SDK}?projectId=${projectId}&chainId=${chainId}&version=${SECURE_SITE_SDK_VERSION}&enableLogger=${enableLogger}`;
        iframe.name = "w3m-secure-iframe";
        iframe.style.position = "fixed";
        iframe.style.zIndex = "999999";
        iframe.style.display = "none";
        iframe.style.animationDelay = "0s, 50ms";
        iframe.style.borderBottomLeftRadius = `clamp(0px, var(--wui-border-radius-l), 44px)`;
        iframe.style.borderBottomRightRadius = `clamp(0px, var(--wui-border-radius-l), 44px)`;
        this.iframe = iframe;
        this.iframe.onerror = () => {
          var _a3;
          (_a3 = this.frameLoadPromiseResolver) == null ? void 0 : _a3.reject("Unable to load email login dependency");
        };
        this.events.onFrameEvent((event) => {
          var _a3;
          if (event.type === "@w3m-frame/READY") {
            (_a3 = this.frameLoadPromiseResolver) == null ? void 0 : _a3.resolve(void 0);
          }
        });
      }
    }
  }
  get networks() {
    const data2 = [
      "eip155:1",
      "eip155:5",
      "eip155:11155111",
      "eip155:10",
      "eip155:420",
      "eip155:42161",
      "eip155:421613",
      "eip155:137",
      "eip155:80001",
      "eip155:42220",
      "eip155:1313161554",
      "eip155:1313161555",
      "eip155:56",
      "eip155:97",
      "eip155:43114",
      "eip155:43113",
      "eip155:324",
      "eip155:280",
      "eip155:100",
      "eip155:8453",
      "eip155:84531",
      "eip155:84532",
      "eip155:7777777",
      "eip155:999",
      "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
      "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
      "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1"
    ].map((id2) => ({
      [id2]: {
        rpcUrl: `${this.rpcUrl}/v1/?chainId=${id2}&projectId=${this.projectId}`,
        chainId: id2
      }
    }));
    return Object.assign({}, ...data2);
  }
}
function tryStringify(o3) {
  try {
    return JSON.stringify(o3);
  } catch (e3) {
    return '"[Circular]"';
  }
}
var quickFormatUnescaped = format$1;
function format$1(f6, args, opts) {
  var ss2 = opts && opts.stringify || tryStringify;
  var offset = 1;
  if (typeof f6 === "object" && f6 !== null) {
    var len2 = args.length + offset;
    if (len2 === 1) return f6;
    var objects = new Array(len2);
    objects[0] = ss2(f6);
    for (var index2 = 1; index2 < len2; index2++) {
      objects[index2] = ss2(args[index2]);
    }
    return objects.join(" ");
  }
  if (typeof f6 !== "string") {
    return f6;
  }
  var argLen = args.length;
  if (argLen === 0) return f6;
  var str = "";
  var a2 = 1 - offset;
  var lastPos = -1;
  var flen = f6 && f6.length || 0;
  for (var i4 = 0; i4 < flen; ) {
    if (f6.charCodeAt(i4) === 37 && i4 + 1 < flen) {
      lastPos = lastPos > -1 ? lastPos : 0;
      switch (f6.charCodeAt(i4 + 1)) {
        case 100:
        case 102:
          if (a2 >= argLen)
            break;
          if (args[a2] == null) break;
          if (lastPos < i4)
            str += f6.slice(lastPos, i4);
          str += Number(args[a2]);
          lastPos = i4 + 2;
          i4++;
          break;
        case 105:
          if (a2 >= argLen)
            break;
          if (args[a2] == null) break;
          if (lastPos < i4)
            str += f6.slice(lastPos, i4);
          str += Math.floor(Number(args[a2]));
          lastPos = i4 + 2;
          i4++;
          break;
        case 79:
        case 111:
        case 106:
          if (a2 >= argLen)
            break;
          if (args[a2] === void 0) break;
          if (lastPos < i4)
            str += f6.slice(lastPos, i4);
          var type2 = typeof args[a2];
          if (type2 === "string") {
            str += "'" + args[a2] + "'";
            lastPos = i4 + 2;
            i4++;
            break;
          }
          if (type2 === "function") {
            str += args[a2].name || "<anonymous>";
            lastPos = i4 + 2;
            i4++;
            break;
          }
          str += ss2(args[a2]);
          lastPos = i4 + 2;
          i4++;
          break;
        case 115:
          if (a2 >= argLen)
            break;
          if (lastPos < i4)
            str += f6.slice(lastPos, i4);
          str += String(args[a2]);
          lastPos = i4 + 2;
          i4++;
          break;
        case 37:
          if (lastPos < i4)
            str += f6.slice(lastPos, i4);
          str += "%";
          lastPos = i4 + 2;
          i4++;
          a2--;
          break;
      }
      ++a2;
    }
    ++i4;
  }
  if (lastPos === -1)
    return f6;
  else if (lastPos < flen) {
    str += f6.slice(lastPos);
  }
  return str;
}
const format = quickFormatUnescaped;
var browser$d = pino;
const _console = pfGlobalThisOrFallback().console || {};
const stdSerializers = {
  mapHttpRequest: mock,
  mapHttpResponse: mock,
  wrapRequestSerializer: passthrough,
  wrapResponseSerializer: passthrough,
  wrapErrorSerializer: passthrough,
  req: mock,
  res: mock,
  err: asErrValue
};
function shouldSerialize(serialize, serializers) {
  if (Array.isArray(serialize)) {
    const hasToFilter = serialize.filter(function(k3) {
      return k3 !== "!stdSerializers.err";
    });
    return hasToFilter;
  } else if (serialize === true) {
    return Object.keys(serializers);
  }
  return false;
}
function pino(opts) {
  opts = opts || {};
  opts.browser = opts.browser || {};
  const transmit2 = opts.browser.transmit;
  if (transmit2 && typeof transmit2.send !== "function") {
    throw Error("pino: transmit option must have a send function");
  }
  const proto = opts.browser.write || _console;
  if (opts.browser.write) opts.browser.asObject = true;
  const serializers = opts.serializers || {};
  const serialize = shouldSerialize(opts.browser.serialize, serializers);
  let stdErrSerialize = opts.browser.serialize;
  if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf("!stdSerializers.err") > -1) stdErrSerialize = false;
  const levels = ["error", "fatal", "warn", "info", "debug", "trace"];
  if (typeof proto === "function") {
    proto.error = proto.fatal = proto.warn = proto.info = proto.debug = proto.trace = proto;
  }
  if (opts.enabled === false) opts.level = "silent";
  const level = opts.level || "info";
  const logger = Object.create(proto);
  if (!logger.log) logger.log = noop;
  Object.defineProperty(logger, "levelVal", {
    get: getLevelVal
  });
  Object.defineProperty(logger, "level", {
    get: getLevel,
    set: setLevel
  });
  const setOpts = {
    transmit: transmit2,
    serialize,
    asObject: opts.browser.asObject,
    levels,
    timestamp: getTimeFunction(opts)
  };
  logger.levels = pino.levels;
  logger.level = level;
  logger.setMaxListeners = logger.getMaxListeners = logger.emit = logger.addListener = logger.on = logger.prependListener = logger.once = logger.prependOnceListener = logger.removeListener = logger.removeAllListeners = logger.listeners = logger.listenerCount = logger.eventNames = logger.write = logger.flush = noop;
  logger.serializers = serializers;
  logger._serialize = serialize;
  logger._stdErrSerialize = stdErrSerialize;
  logger.child = child;
  if (transmit2) logger._logEvent = createLogEventShape();
  function getLevelVal() {
    return this.level === "silent" ? Infinity : this.levels.values[this.level];
  }
  function getLevel() {
    return this._level;
  }
  function setLevel(level2) {
    if (level2 !== "silent" && !this.levels.values[level2]) {
      throw Error("unknown level " + level2);
    }
    this._level = level2;
    set$1(setOpts, logger, "error", "log");
    set$1(setOpts, logger, "fatal", "error");
    set$1(setOpts, logger, "warn", "error");
    set$1(setOpts, logger, "info", "log");
    set$1(setOpts, logger, "debug", "log");
    set$1(setOpts, logger, "trace", "log");
  }
  function child(bindings, childOptions) {
    if (!bindings) {
      throw new Error("missing bindings for child Pino");
    }
    childOptions = childOptions || {};
    if (serialize && bindings.serializers) {
      childOptions.serializers = bindings.serializers;
    }
    const childOptionsSerializers = childOptions.serializers;
    if (serialize && childOptionsSerializers) {
      var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
      var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize;
      delete bindings.serializers;
      applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
    }
    function Child(parent2) {
      this._childLevel = (parent2._childLevel | 0) + 1;
      this.error = bind(parent2, bindings, "error");
      this.fatal = bind(parent2, bindings, "fatal");
      this.warn = bind(parent2, bindings, "warn");
      this.info = bind(parent2, bindings, "info");
      this.debug = bind(parent2, bindings, "debug");
      this.trace = bind(parent2, bindings, "trace");
      if (childSerializers) {
        this.serializers = childSerializers;
        this._serialize = childSerialize;
      }
      if (transmit2) {
        this._logEvent = createLogEventShape(
          [].concat(parent2._logEvent.bindings, bindings)
        );
      }
    }
    Child.prototype = this;
    return new Child(this);
  }
  return logger;
}
pino.levels = {
  values: {
    fatal: 60,
    error: 50,
    warn: 40,
    info: 30,
    debug: 20,
    trace: 10
  },
  labels: {
    10: "trace",
    20: "debug",
    30: "info",
    40: "warn",
    50: "error",
    60: "fatal"
  }
};
pino.stdSerializers = stdSerializers;
pino.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
function set$1(opts, logger, level, fallback2) {
  const proto = Object.getPrototypeOf(logger);
  logger[level] = logger.levelVal > logger.levels.values[level] ? noop : proto[level] ? proto[level] : _console[level] || _console[fallback2] || noop;
  wrap(opts, logger, level);
}
function wrap(opts, logger, level) {
  if (!opts.transmit && logger[level] === noop) return;
  logger[level] = /* @__PURE__ */ function(write3) {
    return function LOG() {
      const ts2 = opts.timestamp();
      const args = new Array(arguments.length);
      const proto = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
      for (var i4 = 0; i4 < args.length; i4++) args[i4] = arguments[i4];
      if (opts.serialize && !opts.asObject) {
        applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
      }
      if (opts.asObject) write3.call(proto, asObject(this, level, args, ts2));
      else write3.apply(proto, args);
      if (opts.transmit) {
        const transmitLevel = opts.transmit.level || logger.level;
        const transmitValue = pino.levels.values[transmitLevel];
        const methodValue = pino.levels.values[level];
        if (methodValue < transmitValue) return;
        transmit(this, {
          ts: ts2,
          methodLevel: level,
          methodValue,
          transmitValue: pino.levels.values[opts.transmit.level || logger.level],
          send: opts.transmit.send,
          val: logger.levelVal
        }, args);
      }
    };
  }(logger[level]);
}
function asObject(logger, level, args, ts2) {
  if (logger._serialize) applySerializers(args, logger._serialize, logger.serializers, logger._stdErrSerialize);
  const argsCloned = args.slice();
  let msg = argsCloned[0];
  const o3 = {};
  if (ts2) {
    o3.time = ts2;
  }
  o3.level = pino.levels.values[level];
  let lvl = (logger._childLevel | 0) + 1;
  if (lvl < 1) lvl = 1;
  if (msg !== null && typeof msg === "object") {
    while (lvl-- && typeof argsCloned[0] === "object") {
      Object.assign(o3, argsCloned.shift());
    }
    msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : void 0;
  } else if (typeof msg === "string") msg = format(argsCloned.shift(), argsCloned);
  if (msg !== void 0) o3.msg = msg;
  return o3;
}
function applySerializers(args, serialize, serializers, stdErrSerialize) {
  for (const i4 in args) {
    if (stdErrSerialize && args[i4] instanceof Error) {
      args[i4] = pino.stdSerializers.err(args[i4]);
    } else if (typeof args[i4] === "object" && !Array.isArray(args[i4])) {
      for (const k3 in args[i4]) {
        if (serialize && serialize.indexOf(k3) > -1 && k3 in serializers) {
          args[i4][k3] = serializers[k3](args[i4][k3]);
        }
      }
    }
  }
}
function bind(parent2, bindings, level) {
  return function() {
    const args = new Array(1 + arguments.length);
    args[0] = bindings;
    for (var i4 = 1; i4 < args.length; i4++) {
      args[i4] = arguments[i4 - 1];
    }
    return parent2[level].apply(this, args);
  };
}
function transmit(logger, opts, args) {
  const send = opts.send;
  const ts2 = opts.ts;
  const methodLevel = opts.methodLevel;
  const methodValue = opts.methodValue;
  const val = opts.val;
  const bindings = logger._logEvent.bindings;
  applySerializers(
    args,
    logger._serialize || Object.keys(logger.serializers),
    logger.serializers,
    logger._stdErrSerialize === void 0 ? true : logger._stdErrSerialize
  );
  logger._logEvent.ts = ts2;
  logger._logEvent.messages = args.filter(function(arg) {
    return bindings.indexOf(arg) === -1;
  });
  logger._logEvent.level.label = methodLevel;
  logger._logEvent.level.value = methodValue;
  send(methodLevel, logger._logEvent, val);
  logger._logEvent = createLogEventShape(bindings);
}
function createLogEventShape(bindings) {
  return {
    ts: 0,
    messages: [],
    bindings: bindings || [],
    level: { label: "", value: 0 }
  };
}
function asErrValue(err) {
  const obj = {
    type: err.constructor.name,
    msg: err.message,
    stack: err.stack
  };
  for (const key2 in err) {
    if (obj[key2] === void 0) {
      obj[key2] = err[key2];
    }
  }
  return obj;
}
function getTimeFunction(opts) {
  if (typeof opts.timestamp === "function") {
    return opts.timestamp;
  }
  if (opts.timestamp === false) {
    return nullTime;
  }
  return epochTime;
}
function mock() {
  return {};
}
function passthrough(a2) {
  return a2;
}
function noop() {
}
function nullTime() {
  return false;
}
function epochTime() {
  return Date.now();
}
function unixTime() {
  return Math.round(Date.now() / 1e3);
}
function isoTime() {
  return new Date(Date.now()).toISOString();
}
function pfGlobalThisOrFallback() {
  function defd(o3) {
    return typeof o3 !== "undefined" && o3;
  }
  try {
    if (typeof globalThis !== "undefined") return globalThis;
    Object.defineProperty(Object.prototype, "globalThis", {
      get: function() {
        delete Object.prototype.globalThis;
        return this.globalThis = this;
      },
      configurable: true
    });
    return globalThis;
  } catch (e3) {
    return defd(self) || defd(window) || defd(this) || {};
  }
}
const gt$3 = /* @__PURE__ */ getDefaultExportFromCjs$1(browser$d);
const JSONStringify = (data2) => JSON.stringify(data2, (_3, value) => typeof value === "bigint" ? value.toString() + "n" : value);
const JSONParse = (json) => {
  const numbersBiggerThanMaxInt = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g;
  const serializedData = json.replace(numbersBiggerThanMaxInt, '$1"$2n"$3');
  return JSON.parse(serializedData, (_3, value) => {
    const isCustomFormatBigInt = typeof value === "string" && value.match(/^\d+n$/);
    if (isCustomFormatBigInt)
      return BigInt(value.substring(0, value.length - 1));
    return value;
  });
};
function safeJsonParse(value) {
  if (typeof value !== "string") {
    throw new Error(`Cannot safe json parse value of type ${typeof value}`);
  }
  try {
    return JSONParse(value);
  } catch (_a3) {
    return value;
  }
}
function safeJsonStringify(value) {
  return typeof value === "string" ? value : JSONStringify(value) || "";
}
const c$9 = { level: "info" }, n$9 = "custom_context", l$4 = 1e3 * 1024;
let O$6 = class O2 {
  constructor(e3) {
    this.nodeValue = e3, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null;
  }
  get value() {
    return this.nodeValue;
  }
  get size() {
    return this.sizeInBytes;
  }
};
let d$7 = class d2 {
  constructor(e3) {
    this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = e3, this.sizeInBytes = 0;
  }
  append(e3) {
    const t2 = new O$6(e3);
    if (t2.size > this.maxSizeInBytes) throw new Error(`[LinkedList] Value too big to insert into list: ${e3} with size ${t2.size}`);
    for (; this.size + t2.size > this.maxSizeInBytes; ) this.shift();
    this.head ? (this.tail && (this.tail.next = t2), this.tail = t2) : (this.head = t2, this.tail = t2), this.lengthInNodes++, this.sizeInBytes += t2.size;
  }
  shift() {
    if (!this.head) return;
    const e3 = this.head;
    this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= e3.size;
  }
  toArray() {
    const e3 = [];
    let t2 = this.head;
    for (; t2 !== null; ) e3.push(t2.value), t2 = t2.next;
    return e3;
  }
  get length() {
    return this.lengthInNodes;
  }
  get size() {
    return this.sizeInBytes;
  }
  toOrderedArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let e3 = this.head;
    return { next: () => {
      if (!e3) return { done: true, value: null };
      const t2 = e3.value;
      return e3 = e3.next, { done: false, value: t2 };
    } };
  }
};
let L$6 = class L2 {
  constructor(e3, t2 = l$4) {
    this.level = e3 ?? "error", this.levelValue = browser$d.levels.values[this.level], this.MAX_LOG_SIZE_IN_BYTES = t2, this.logs = new d$7(this.MAX_LOG_SIZE_IN_BYTES);
  }
  forwardToConsole(e3, t2) {
    t2 === browser$d.levels.values.error ? console.error(e3) : t2 === browser$d.levels.values.warn ? console.warn(e3) : t2 === browser$d.levels.values.debug ? console.debug(e3) : t2 === browser$d.levels.values.trace ? console.trace(e3) : console.log(e3);
  }
  appendToLogs(e3) {
    this.logs.append(safeJsonStringify({ timestamp: (/* @__PURE__ */ new Date()).toISOString(), log: e3 }));
    const t2 = typeof e3 == "string" ? JSON.parse(e3).level : e3.level;
    t2 >= this.levelValue && this.forwardToConsole(e3, t2);
  }
  getLogs() {
    return this.logs;
  }
  clearLogs() {
    this.logs = new d$7(this.MAX_LOG_SIZE_IN_BYTES);
  }
  getLogArray() {
    return Array.from(this.logs);
  }
  logsToBlob(e3) {
    const t2 = this.getLogArray();
    return t2.push(safeJsonStringify({ extraMetadata: e3 })), new Blob(t2, { type: "application/json" });
  }
};
let m$2 = class m2 {
  constructor(e3, t2 = l$4) {
    this.baseChunkLogger = new L$6(e3, t2);
  }
  write(e3) {
    this.baseChunkLogger.appendToLogs(e3);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e3) {
    return this.baseChunkLogger.logsToBlob(e3);
  }
  downloadLogsBlobInBrowser(e3) {
    const t2 = URL.createObjectURL(this.logsToBlob(e3)), o3 = document.createElement("a");
    o3.href = t2, o3.download = `walletconnect-logs-${(/* @__PURE__ */ new Date()).toISOString()}.txt`, document.body.appendChild(o3), o3.click(), document.body.removeChild(o3), URL.revokeObjectURL(t2);
  }
};
let B$6 = class B2 {
  constructor(e3, t2 = l$4) {
    this.baseChunkLogger = new L$6(e3, t2);
  }
  write(e3) {
    this.baseChunkLogger.appendToLogs(e3);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e3) {
    return this.baseChunkLogger.logsToBlob(e3);
  }
};
var x$9 = Object.defineProperty, S$7 = Object.defineProperties, _$9 = Object.getOwnPropertyDescriptors, p$9 = Object.getOwnPropertySymbols, T$7 = Object.prototype.hasOwnProperty, z$b = Object.prototype.propertyIsEnumerable, f$a = (r3, e3, t2) => e3 in r3 ? x$9(r3, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r3[e3] = t2, i$7 = (r3, e3) => {
  for (var t2 in e3 || (e3 = {})) T$7.call(e3, t2) && f$a(r3, t2, e3[t2]);
  if (p$9) for (var t2 of p$9(e3)) z$b.call(e3, t2) && f$a(r3, t2, e3[t2]);
  return r3;
}, g$4 = (r3, e3) => S$7(r3, _$9(e3));
function k$7(r3) {
  return g$4(i$7({}, r3), { level: (r3 == null ? void 0 : r3.level) || c$9.level });
}
function v$8(r3, e3 = n$9) {
  return r3[e3] || "";
}
function b$7(r3, e3, t2 = n$9) {
  return r3[t2] = e3, r3;
}
function y$6(r3, e3 = n$9) {
  let t2 = "";
  return typeof r3.bindings > "u" ? t2 = v$8(r3, e3) : t2 = r3.bindings().context || "", t2;
}
function w$4(r3, e3, t2 = n$9) {
  const o3 = y$6(r3, t2);
  return o3.trim() ? `${o3}/${e3}` : e3;
}
function E$7(r3, e3, t2 = n$9) {
  const o3 = w$4(r3, e3, t2), a2 = r3.child({ context: o3 });
  return b$7(a2, o3, t2);
}
function C$7(r3) {
  var e3, t2;
  const o3 = new m$2((e3 = r3.opts) == null ? void 0 : e3.level, r3.maxSizeInBytes);
  return { logger: gt$3(g$4(i$7({}, r3.opts), { level: "trace", browser: g$4(i$7({}, (t2 = r3.opts) == null ? void 0 : t2.browser), { write: (a2) => o3.write(a2) }) })), chunkLoggerController: o3 };
}
function I$5(r3) {
  var e3;
  const t2 = new B$6((e3 = r3.opts) == null ? void 0 : e3.level, r3.maxSizeInBytes);
  return { logger: gt$3(g$4(i$7({}, r3.opts), { level: "trace" }), t2), chunkLoggerController: t2 };
}
function A$4(r3) {
  return typeof r3.loggerOverride < "u" && typeof r3.loggerOverride != "string" ? { logger: r3.loggerOverride, chunkLoggerController: null } : typeof window < "u" ? C$7(r3) : I$5(r3);
}
class W3mFrameLogger {
  constructor(projectId) {
    var _a3;
    const loggerOptions = k$7({
      level: DEFAULT_LOG_LEVEL
    });
    const { logger, chunkLoggerController } = A$4({
      opts: loggerOptions
    });
    this.logger = E$7(logger, this.constructor.name);
    this.chunkLoggerController = chunkLoggerController;
    if (typeof window !== "undefined" && ((_a3 = this.chunkLoggerController) == null ? void 0 : _a3.downloadLogsBlobInBrowser)) {
      if (!window.downloadAppKitLogsBlob) {
        window.downloadAppKitLogsBlob = {};
      }
      window.downloadAppKitLogsBlob["sdk"] = () => {
        var _a4;
        if ((_a4 = this.chunkLoggerController) == null ? void 0 : _a4.downloadLogsBlobInBrowser) {
          this.chunkLoggerController.downloadLogsBlobInBrowser({
            projectId
          });
        }
      };
    }
  }
}
class W3mFrameProvider {
  constructor({ projectId, chainId, enableLogger = true, onTimeout }) {
    this.openRpcRequests = [];
    if (enableLogger) {
      this.w3mLogger = new W3mFrameLogger(projectId);
    }
    this.w3mFrame = new W3mFrame({ projectId, isAppClient: true, chainId, enableLogger });
    this.onTimeout = onTimeout;
    if (this.getLoginEmailUsed()) {
      this.w3mFrame.initFrame();
    }
    this.w3mFrame.events.onFrameEvent((event) => {
      if (event.type === W3mFrameConstants.FRAME_GET_USER_SUCCESS) {
        this.user = event.payload;
      }
    });
    this.initPromise = new Promise((resolve) => {
      this.w3mFrame.events.onFrameEvent((event) => {
        if (event.type === W3mFrameConstants.FRAME_READY) {
          this.initPromise = void 0;
          resolve();
        }
      });
    });
  }
  async init() {
    this.w3mFrame.initFrame();
    if (this.initPromise) {
      await this.initPromise;
    }
  }
  getLoginEmailUsed() {
    return Boolean(W3mFrameStorage.get(W3mFrameConstants.EMAIL_LOGIN_USED_KEY));
  }
  getEmail() {
    return W3mFrameStorage.get(W3mFrameConstants.EMAIL);
  }
  getUsername() {
    return W3mFrameStorage.get(W3mFrameConstants.SOCIAL_USERNAME);
  }
  async reload() {
    var _a3;
    try {
      this.w3mFrame.initFrame();
      await this.appEvent({
        type: W3mFrameConstants.APP_RELOAD
      });
    } catch (error) {
      (_a3 = this.w3mLogger) == null ? void 0 : _a3.logger.error({ error }, "Error reloading iframe");
      throw error;
    }
  }
  async connectEmail(payload) {
    var _a3;
    try {
      W3mFrameHelpers.checkIfAllowedToTriggerEmail();
      this.w3mFrame.initFrame();
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_CONNECT_EMAIL,
        payload
      });
      this.setNewLastEmailLoginTime();
      return response;
    } catch (error) {
      (_a3 = this.w3mLogger) == null ? void 0 : _a3.logger.error({ error }, "Error connecting email");
      throw error;
    }
  }
  async connectDevice() {
    var _a3;
    try {
      return this.appEvent({
        type: W3mFrameConstants.APP_CONNECT_DEVICE
      });
    } catch (error) {
      (_a3 = this.w3mLogger) == null ? void 0 : _a3.logger.error({ error }, "Error connecting device");
      throw error;
    }
  }
  async connectOtp(payload) {
    var _a3;
    try {
      return this.appEvent({
        type: W3mFrameConstants.APP_CONNECT_OTP,
        payload
      });
    } catch (error) {
      (_a3 = this.w3mLogger) == null ? void 0 : _a3.logger.error({ error }, "Error connecting otp");
      throw error;
    }
  }
  async isConnected() {
    var _a3;
    try {
      if (!this.getLoginEmailUsed()) {
        return { isConnected: false };
      }
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_IS_CONNECTED
      });
      if (!response.isConnected) {
        this.deleteAuthLoginCache();
      }
      return response;
    } catch (error) {
      this.deleteAuthLoginCache();
      (_a3 = this.w3mLogger) == null ? void 0 : _a3.logger.error({ error }, "Error checking connection");
      throw error;
    }
  }
  async getChainId() {
    var _a3;
    try {
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_GET_CHAIN_ID
      });
      this.setLastUsedChainId(response.chainId);
      return response;
    } catch (error) {
      (_a3 = this.w3mLogger) == null ? void 0 : _a3.logger.error({ error }, "Error getting chain id");
      throw error;
    }
  }
  async getSocialRedirectUri(payload) {
    var _a3;
    try {
      this.w3mFrame.initFrame();
      return this.appEvent({
        type: W3mFrameConstants.APP_GET_SOCIAL_REDIRECT_URI,
        payload
      });
    } catch (error) {
      (_a3 = this.w3mLogger) == null ? void 0 : _a3.logger.error({ error }, "Error getting social redirect uri");
      throw error;
    }
  }
  async updateEmail(payload) {
    var _a3;
    try {
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_UPDATE_EMAIL,
        payload
      });
      this.setNewLastEmailLoginTime();
      return response;
    } catch (error) {
      (_a3 = this.w3mLogger) == null ? void 0 : _a3.logger.error({ error }, "Error updating email");
      throw error;
    }
  }
  async updateEmailPrimaryOtp(payload) {
    var _a3;
    try {
      return this.appEvent({
        type: W3mFrameConstants.APP_UPDATE_EMAIL_PRIMARY_OTP,
        payload
      });
    } catch (error) {
      (_a3 = this.w3mLogger) == null ? void 0 : _a3.logger.error({ error }, "Error updating email primary otp");
      throw error;
    }
  }
  async updateEmailSecondaryOtp(payload) {
    var _a3;
    try {
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_UPDATE_EMAIL_SECONDARY_OTP,
        payload
      });
      this.setLoginSuccess(response.newEmail);
      return response;
    } catch (error) {
      (_a3 = this.w3mLogger) == null ? void 0 : _a3.logger.error({ error }, "Error updating email secondary otp");
      throw error;
    }
  }
  async syncTheme(payload) {
    var _a3;
    try {
      return this.appEvent({
        type: W3mFrameConstants.APP_SYNC_THEME,
        payload
      });
    } catch (error) {
      (_a3 = this.w3mLogger) == null ? void 0 : _a3.logger.error({ error }, "Error syncing theme");
      throw error;
    }
  }
  async syncDappData(payload) {
    var _a3;
    try {
      return this.appEvent({
        type: W3mFrameConstants.APP_SYNC_DAPP_DATA,
        payload
      });
    } catch (error) {
      (_a3 = this.w3mLogger) == null ? void 0 : _a3.logger.error({ error }, "Error syncing dapp data");
      throw error;
    }
  }
  async getSmartAccountEnabledNetworks() {
    var _a3;
    try {
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS
      });
      this.persistSmartAccountEnabledNetworks(response.smartAccountEnabledNetworks);
      return response;
    } catch (error) {
      this.persistSmartAccountEnabledNetworks([]);
      (_a3 = this.w3mLogger) == null ? void 0 : _a3.logger.error({ error }, "Error getting smart account enabled networks");
      throw error;
    }
  }
  async setPreferredAccount(type2) {
    var _a3;
    try {
      return this.appEvent({
        type: W3mFrameConstants.APP_SET_PREFERRED_ACCOUNT,
        payload: { type: type2 }
      });
    } catch (error) {
      (_a3 = this.w3mLogger) == null ? void 0 : _a3.logger.error({ error }, "Error setting preferred account");
      throw error;
    }
  }
  async connect(payload) {
    var _a3;
    try {
      const chainId = (payload == null ? void 0 : payload.chainId) || this.getLastUsedChainId() || 1;
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_GET_USER,
        payload: { ...payload, chainId }
      });
      this.setLoginSuccess(response.email);
      this.setLastUsedChainId(response.chainId);
      return response;
    } catch (error) {
      (_a3 = this.w3mLogger) == null ? void 0 : _a3.logger.error({ error }, "Error connecting");
      throw error;
    }
  }
  async getUser(payload) {
    var _a3;
    try {
      const chainId = (payload == null ? void 0 : payload.chainId) || this.getLastUsedChainId() || 1;
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_GET_USER,
        payload: { ...payload, chainId }
      });
      return response;
    } catch (error) {
      (_a3 = this.w3mLogger) == null ? void 0 : _a3.logger.error({ error }, "Error connecting");
      throw error;
    }
  }
  async connectSocial(uri2) {
    var _a3;
    try {
      this.w3mFrame.initFrame();
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_CONNECT_SOCIAL,
        payload: { uri: uri2 }
      });
      if (response.userName) {
        this.setSocialLoginSuccess(response.userName);
      }
      return response;
    } catch (error) {
      (_a3 = this.w3mLogger) == null ? void 0 : _a3.logger.error({ error }, "Error connecting social");
      throw error;
    }
  }
  async getFarcasterUri() {
    var _a3;
    try {
      this.w3mFrame.initFrame();
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_GET_FARCASTER_URI
      });
      return response;
    } catch (error) {
      (_a3 = this.w3mLogger) == null ? void 0 : _a3.logger.error({ error }, "Error getting farcaster uri");
      throw error;
    }
  }
  async connectFarcaster() {
    var _a3;
    try {
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_CONNECT_FARCASTER
      });
      if (response.userName) {
        this.setSocialLoginSuccess(response.userName);
      }
      return response;
    } catch (error) {
      (_a3 = this.w3mLogger) == null ? void 0 : _a3.logger.error({ error }, "Error connecting farcaster");
      throw error;
    }
  }
  async switchNetwork(chainId) {
    var _a3;
    try {
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_SWITCH_NETWORK,
        payload: { chainId }
      });
      this.setLastUsedChainId(response.chainId);
      return response;
    } catch (error) {
      (_a3 = this.w3mLogger) == null ? void 0 : _a3.logger.error({ error }, "Error switching network");
      throw error;
    }
  }
  async disconnect() {
    var _a3;
    try {
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_SIGN_OUT
      });
      this.deleteAuthLoginCache();
      return response;
    } catch (error) {
      (_a3 = this.w3mLogger) == null ? void 0 : _a3.logger.error({ error }, "Error disconnecting");
      throw error;
    }
  }
  async request(req) {
    var _a3, _b2, _c3, _d;
    try {
      if (W3mFrameRpcConstants.GET_CHAIN_ID === req.method) {
        return this.getLastUsedChainId();
      }
      (_a3 = this.rpcRequestHandler) == null ? void 0 : _a3.call(this, req);
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_RPC_REQUEST,
        payload: req
      });
      (_b2 = this.rpcSuccessHandler) == null ? void 0 : _b2.call(this, response, req);
      return response;
    } catch (error) {
      (_c3 = this.rpcErrorHandler) == null ? void 0 : _c3.call(this, error, req);
      (_d = this.w3mLogger) == null ? void 0 : _d.logger.error({ error }, "Error requesting");
      throw error;
    }
  }
  onRpcRequest(callback) {
    this.rpcRequestHandler = callback;
  }
  onRpcSuccess(callback) {
    this.rpcSuccessHandler = callback;
  }
  onRpcError(callback) {
    this.rpcErrorHandler = callback;
  }
  onIsConnected(callback) {
    this.w3mFrame.events.onFrameEvent((event) => {
      if (event.type === W3mFrameConstants.FRAME_IS_CONNECTED_SUCCESS && event.payload.isConnected) {
        callback();
      }
    });
  }
  onNotConnected(callback) {
    this.w3mFrame.events.onFrameEvent((event) => {
      if (event.type === W3mFrameConstants.FRAME_IS_CONNECTED_ERROR) {
        callback();
      }
      if (event.type === W3mFrameConstants.FRAME_IS_CONNECTED_SUCCESS && !event.payload.isConnected) {
        callback();
      }
    });
  }
  onConnect(callback) {
    this.w3mFrame.events.onFrameEvent((event) => {
      if (event.type === W3mFrameConstants.FRAME_GET_USER_SUCCESS) {
        callback(event.payload);
      }
    });
  }
  onSocialConnected(callback) {
    this.w3mFrame.events.onFrameEvent((event) => {
      if (event.type === W3mFrameConstants.FRAME_CONNECT_SOCIAL_SUCCESS) {
        callback(event.payload);
      }
    });
  }
  async getCapabilities() {
    try {
      const capabilities = await this.request({
        method: "wallet_getCapabilities"
      });
      return capabilities || {};
    } catch {
      return {};
    }
  }
  onSetPreferredAccount(callback) {
    this.w3mFrame.events.onFrameEvent((event) => {
      if (event.type === W3mFrameConstants.FRAME_SET_PREFERRED_ACCOUNT_SUCCESS) {
        callback(event.payload);
      } else if (event.type === W3mFrameConstants.FRAME_SET_PREFERRED_ACCOUNT_ERROR) {
        callback({ type: W3mFrameRpcConstants.ACCOUNT_TYPES.EOA });
      }
    });
  }
  onGetSmartAccountEnabledNetworks(callback) {
    this.w3mFrame.events.onFrameEvent((event) => {
      if (event.type === W3mFrameConstants.FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS) {
        callback(event.payload.smartAccountEnabledNetworks);
      } else if (event.type === W3mFrameConstants.FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR) {
        callback([]);
      }
    });
  }
  getAvailableChainIds() {
    return Object.keys(this.w3mFrame.networks);
  }
  rejectRpcRequests() {
    var _a3;
    try {
      this.openRpcRequests.forEach(({ abortController, method }) => {
        if (!W3mFrameRpcConstants.SAFE_RPC_METHODS.includes(method)) {
          abortController.abort();
        }
      });
      this.openRpcRequests = [];
    } catch (e3) {
      (_a3 = this.w3mLogger) == null ? void 0 : _a3.logger.error({ error: e3 }, "Error aborting RPC request");
    }
  }
  async appEvent(event) {
    await this.w3mFrame.frameLoadPromise;
    let timer = void 0;
    function replaceEventType(type3) {
      return type3.replace("@w3m-app/", "");
    }
    const abortController = new AbortController();
    const type2 = replaceEventType(event.type);
    const shouldCheckForTimeout = [
      W3mFrameConstants.APP_CONNECT_EMAIL,
      W3mFrameConstants.APP_CONNECT_DEVICE,
      W3mFrameConstants.APP_CONNECT_OTP,
      W3mFrameConstants.APP_CONNECT_SOCIAL,
      W3mFrameConstants.APP_GET_SOCIAL_REDIRECT_URI
    ].map(replaceEventType).includes(type2);
    if (shouldCheckForTimeout) {
      timer = setTimeout(() => {
        var _a3;
        (_a3 = this.onTimeout) == null ? void 0 : _a3.call(this);
        abortController.abort();
      }, 3e4);
    }
    return new Promise((resolve, reject) => {
      var _a3, _b2, _c3;
      const id2 = Math.random().toString(36).substring(7);
      (_c3 = (_a3 = this.w3mLogger) == null ? void 0 : (_b2 = _a3.logger).info) == null ? void 0 : _c3.call(_b2, { event, id: id2 }, "Sending app event");
      this.w3mFrame.events.postAppEvent({ ...event, id: id2 });
      if (type2 === "RPC_REQUEST") {
        const rpcEvent = event;
        this.openRpcRequests = [...this.openRpcRequests, { ...rpcEvent.payload, abortController }];
      }
      abortController.signal.addEventListener("abort", () => {
        if (type2 === "RPC_REQUEST") {
          reject(new Error("Request was aborted"));
        } else if (type2 !== "GET_FARCASTER_URI") {
          reject(new Error("Something went wrong"));
        }
      });
      function handler(framEvent, logger) {
        var _a4, _b3, _c4;
        if (framEvent.id !== id2) {
          return;
        }
        (_b3 = logger == null ? void 0 : (_a4 = logger.logger).info) == null ? void 0 : _b3.call(_a4, { framEvent, id: id2 }, "Received frame response");
        if (framEvent.type === `@w3m-frame/${type2}_SUCCESS`) {
          if (timer) {
            clearTimeout(timer);
          }
          if ("payload" in framEvent) {
            resolve(framEvent.payload);
          }
          resolve(void 0);
        } else if (framEvent.type === `@w3m-frame/${type2}_ERROR`) {
          if (timer) {
            clearTimeout(timer);
          }
          if ("payload" in framEvent) {
            reject(new Error(((_c4 = framEvent.payload) == null ? void 0 : _c4.message) || "An error occurred"));
          }
          reject(new Error("An error occurred"));
        }
      }
      this.w3mFrame.events.registerFrameEventHandler(id2, (frameEvent) => handler(frameEvent, this.w3mLogger), abortController.signal);
    });
  }
  setNewLastEmailLoginTime() {
    W3mFrameStorage.set(W3mFrameConstants.LAST_EMAIL_LOGIN_TIME, Date.now().toString());
  }
  setSocialLoginSuccess(username) {
    W3mFrameStorage.set(W3mFrameConstants.SOCIAL_USERNAME, username);
  }
  setLoginSuccess(email) {
    if (email) {
      W3mFrameStorage.set(W3mFrameConstants.EMAIL, email);
    }
    W3mFrameStorage.set(W3mFrameConstants.EMAIL_LOGIN_USED_KEY, "true");
    W3mFrameStorage.delete(W3mFrameConstants.LAST_EMAIL_LOGIN_TIME);
  }
  deleteAuthLoginCache() {
    W3mFrameStorage.delete(W3mFrameConstants.EMAIL_LOGIN_USED_KEY);
    W3mFrameStorage.delete(W3mFrameConstants.EMAIL);
    W3mFrameStorage.delete(W3mFrameConstants.LAST_USED_CHAIN_KEY);
    W3mFrameStorage.delete(W3mFrameConstants.SOCIAL_USERNAME);
  }
  setLastUsedChainId(chainId) {
    if (chainId) {
      W3mFrameStorage.set(W3mFrameConstants.LAST_USED_CHAIN_KEY, String(chainId));
    }
  }
  getLastUsedChainId() {
    const chainId = W3mFrameStorage.get(W3mFrameConstants.LAST_USED_CHAIN_KEY) ?? void 0;
    const numberChainId = Number(chainId);
    return isNaN(numberChainId) ? chainId : numberChainId;
  }
  persistSmartAccountEnabledNetworks(networks) {
    W3mFrameStorage.set(W3mFrameConstants.SMART_ACCOUNT_ENABLED_NETWORKS, networks.join(","));
  }
}
const global$1 = globalThis || void 0 || self;
var events = { exports: {} };
var R$6 = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R$6 && typeof R$6.apply === "function" ? R$6.apply : function ReflectApply2(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R$6 && typeof R$6.ownKeys === "function") {
  ReflectOwnKeys = R$6.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
  return value !== value;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter.init = function() {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n5) {
  if (typeof n5 !== "number" || n5 < 0 || NumberIsNaN(n5)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n5 + ".");
  }
  this._maxListeners = n5;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit2(type2) {
  var args = [];
  for (var i4 = 1; i4 < arguments.length; i4++) args.push(arguments[i4]);
  var doError = type2 === "error";
  var events2 = this._events;
  if (events2 !== void 0)
    doError = doError && events2.error === void 0;
  else if (!doError)
    return false;
  if (doError) {
    var er4;
    if (args.length > 0)
      er4 = args[0];
    if (er4 instanceof Error) {
      throw er4;
    }
    var err = new Error("Unhandled error." + (er4 ? " (" + er4.message + ")" : ""));
    err.context = er4;
    throw err;
  }
  var handler = events2[type2];
  if (handler === void 0)
    return false;
  if (typeof handler === "function") {
    ReflectApply(handler, this, args);
  } else {
    var len2 = handler.length;
    var listeners2 = arrayClone(handler, len2);
    for (var i4 = 0; i4 < len2; ++i4)
      ReflectApply(listeners2[i4], this, args);
  }
  return true;
};
function _addListener(target, type2, listener, prepend) {
  var m4;
  var events2;
  var existing;
  checkListener(listener);
  events2 = target._events;
  if (events2 === void 0) {
    events2 = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events2.newListener !== void 0) {
      target.emit(
        "newListener",
        type2,
        listener.listener ? listener.listener : listener
      );
      events2 = target._events;
    }
    existing = events2[type2];
  }
  if (existing === void 0) {
    existing = events2[type2] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type2] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m4 = _getMaxListeners(target);
    if (m4 > 0 && existing.length > m4 && !existing.warned) {
      existing.warned = true;
      var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      w2.name = "MaxListenersExceededWarning";
      w2.emitter = target;
      w2.type = type2;
      w2.count = existing.length;
      ProcessEmitWarning(w2);
    }
  }
  return target;
}
EventEmitter.prototype.addListener = function addListener(type2, listener) {
  return _addListener(this, type2, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type2, listener) {
  return _addListener(this, type2, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type2, listener) {
  var state2 = { fired: false, wrapFn: void 0, target, type: type2, listener };
  var wrapped = onceWrapper.bind(state2);
  wrapped.listener = listener;
  state2.wrapFn = wrapped;
  return wrapped;
}
EventEmitter.prototype.once = function once2(type2, listener) {
  checkListener(listener);
  this.on(type2, _onceWrap(this, type2, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type2, listener) {
  checkListener(listener);
  this.prependListener(type2, _onceWrap(this, type2, listener));
  return this;
};
EventEmitter.prototype.removeListener = function removeListener(type2, listener) {
  var list, events2, position, i4, originalListener;
  checkListener(listener);
  events2 = this._events;
  if (events2 === void 0)
    return this;
  list = events2[type2];
  if (list === void 0)
    return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = /* @__PURE__ */ Object.create(null);
    else {
      delete events2[type2];
      if (events2.removeListener)
        this.emit("removeListener", type2, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i4 = list.length - 1; i4 >= 0; i4--) {
      if (list[i4] === listener || list[i4].listener === listener) {
        originalListener = list[i4].listener;
        position = i4;
        break;
      }
    }
    if (position < 0)
      return this;
    if (position === 0)
      list.shift();
    else {
      spliceOne(list, position);
    }
    if (list.length === 1)
      events2[type2] = list[0];
    if (events2.removeListener !== void 0)
      this.emit("removeListener", type2, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type2) {
  var listeners2, events2, i4;
  events2 = this._events;
  if (events2 === void 0)
    return this;
  if (events2.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events2[type2] !== void 0) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else
        delete events2[type2];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys2 = Object.keys(events2);
    var key2;
    for (i4 = 0; i4 < keys2.length; ++i4) {
      key2 = keys2[i4];
      if (key2 === "removeListener") continue;
      this.removeAllListeners(key2);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners2 = events2[type2];
  if (typeof listeners2 === "function") {
    this.removeListener(type2, listeners2);
  } else if (listeners2 !== void 0) {
    for (i4 = listeners2.length - 1; i4 >= 0; i4--) {
      this.removeListener(type2, listeners2[i4]);
    }
  }
  return this;
};
function _listeners(target, type2, unwrap) {
  var events2 = target._events;
  if (events2 === void 0)
    return [];
  var evlistener = events2[type2];
  if (evlistener === void 0)
    return [];
  if (typeof evlistener === "function")
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type2) {
  return _listeners(this, type2, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type2) {
  return _listeners(this, type2, false);
};
EventEmitter.listenerCount = function(emitter, type2) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type2);
  } else {
    return listenerCount.call(emitter, type2);
  }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type2) {
  var events2 = this._events;
  if (events2 !== void 0) {
    var evlistener = events2[type2];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n5) {
  var copy2 = new Array(n5);
  for (var i4 = 0; i4 < n5; ++i4)
    copy2[i4] = arr[i4];
  return copy2;
}
function spliceOne(list, index2) {
  for (; index2 + 1 < list.length; index2++)
    list[index2] = list[index2 + 1];
  list.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i4 = 0; i4 < ret.length; ++i4) {
    ret[i4] = arr[i4].listener || arr[i4];
  }
  return ret;
}
function once(emitter, name) {
  return new Promise(function(resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      resolve([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== "error") {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === "function") {
    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name, function wrapListener(arg) {
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
var eventsExports = events.exports;
const wt$7 = /* @__PURE__ */ getDefaultExportFromCjs$1(eventsExports);
var cjs$3 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d4, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b3) {
    d5.__proto__ = b3;
  } || function(d5, b3) {
    for (var p2 in b3) if (b3.hasOwnProperty(p2)) d5[p2] = b3[p2];
  };
  return extendStatics(d4, b2);
};
function __extends(d4, b2) {
  extendStatics(d4, b2);
  function __() {
    this.constructor = d4;
  }
  d4.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i4 = 1, n5 = arguments.length; i4 < n5; i4++) {
      s2 = arguments[i4];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e3) {
  var t2 = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
    t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p2 = Object.getOwnPropertySymbols(s2); i4 < p2.length; i4++) {
      if (e3.indexOf(p2[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i4]))
        t2[p2[i4]] = s2[p2[i4]];
    }
  return t2;
}
function __decorate$30(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
}
function __param(paramIndex, decorator) {
  return function(target, key2) {
    decorator(target, key2, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _3 = { label: 0, sent: function() {
    if (t2[0] & 1) throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f6, y4, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n5) {
    return function(v2) {
      return step([n5, v2]);
    };
  }
  function step(op) {
    if (f6) throw new TypeError("Generator is already executing.");
    while (_3) try {
      if (f6 = 1, y4 && (t2 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t2 = y4["return"]) && t2.call(y4), 0) : y4.next) && !(t2 = t2.call(y4, op[1])).done) return t2;
      if (y4 = 0, t2) op = [op[0] & 2, t2.value];
      switch (op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          _3.label++;
          return { value: op[1], done: false };
        case 5:
          _3.label++;
          y4 = op[1];
          op = [0];
          continue;
        case 7:
          op = _3.ops.pop();
          _3.trys.pop();
          continue;
        default:
          if (!(t2 = _3.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _3 = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _3.label = op[1];
            break;
          }
          if (op[0] === 6 && _3.label < t2[1]) {
            _3.label = t2[1];
            t2 = op;
            break;
          }
          if (t2 && _3.label < t2[2]) {
            _3.label = t2[2];
            _3.ops.push(op);
            break;
          }
          if (t2[2]) _3.ops.pop();
          _3.trys.pop();
          continue;
      }
      op = body.call(thisArg, _3);
    } catch (e3) {
      op = [6, e3];
      y4 = 0;
    } finally {
      f6 = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding(o3, m4, k3, k22) {
  if (k22 === void 0) k22 = k3;
  o3[k22] = m4[k3];
}
function __exportStar(m4, exports2) {
  for (var p2 in m4) if (p2 !== "default" && !exports2.hasOwnProperty(p2)) exports2[p2] = m4[p2];
}
function __values(o3) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m4 = s2 && o3[s2], i4 = 0;
  if (m4) return m4.call(o3);
  if (o3 && typeof o3.length === "number") return {
    next: function() {
      if (o3 && i4 >= o3.length) o3 = void 0;
      return { value: o3 && o3[i4++], done: !o3 };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o3, n5) {
  var m4 = typeof Symbol === "function" && o3[Symbol.iterator];
  if (!m4) return o3;
  var i4 = m4.call(o3), r3, ar2 = [], e3;
  try {
    while ((n5 === void 0 || n5-- > 0) && !(r3 = i4.next()).done) ar2.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m4 = i4["return"])) m4.call(i4);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar2;
}
function __spread() {
  for (var ar2 = [], i4 = 0; i4 < arguments.length; i4++)
    ar2 = ar2.concat(__read(arguments[i4]));
  return ar2;
}
function __spreadArrays() {
  for (var s2 = 0, i4 = 0, il = arguments.length; i4 < il; i4++) s2 += arguments[i4].length;
  for (var r3 = Array(s2), k3 = 0, i4 = 0; i4 < il; i4++)
    for (var a2 = arguments[i4], j2 = 0, jl = a2.length; j2 < jl; j2++, k3++)
      r3[k3] = a2[j2];
  return r3;
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i4, q2 = [];
  return i4 = {}, verb("next"), verb("throw"), verb("return"), i4[Symbol.asyncIterator] = function() {
    return this;
  }, i4;
  function verb(n5) {
    if (g2[n5]) i4[n5] = function(v2) {
      return new Promise(function(a2, b2) {
        q2.push([n5, v2, a2, b2]) > 1 || resume(n5, v2);
      });
    };
  }
  function resume(n5, v2) {
    try {
      step(g2[n5](v2));
    } catch (e3) {
      settle(q2[0][3], e3);
    }
  }
  function step(r3) {
    r3.value instanceof __await ? Promise.resolve(r3.value.v).then(fulfill, reject) : settle(q2[0][2], r3);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f6, v2) {
    if (f6(v2), q2.shift(), q2.length) resume(q2[0][0], q2[0][1]);
  }
}
function __asyncDelegator(o3) {
  var i4, p2;
  return i4 = {}, verb("next"), verb("throw", function(e3) {
    throw e3;
  }), verb("return"), i4[Symbol.iterator] = function() {
    return this;
  }, i4;
  function verb(n5, f6) {
    i4[n5] = o3[n5] ? function(v2) {
      return (p2 = !p2) ? { value: __await(o3[n5](v2)), done: n5 === "return" } : f6 ? f6(v2) : v2;
    } : f6;
  }
}
function __asyncValues(o3) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m4 = o3[Symbol.asyncIterator], i4;
  return m4 ? m4.call(o3) : (o3 = typeof __values === "function" ? __values(o3) : o3[Symbol.iterator](), i4 = {}, verb("next"), verb("throw"), verb("return"), i4[Symbol.asyncIterator] = function() {
    return this;
  }, i4);
  function verb(n5) {
    i4[n5] = o3[n5] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o3[n5](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d4, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d4 });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod2) {
  if (mod2 && mod2.__esModule) return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k3 in mod2) if (Object.hasOwnProperty.call(mod2, k3)) result[k3] = mod2[k3];
  }
  result.default = mod2;
  return result;
}
function __importDefault(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
const tslib_es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __createBinding,
  __decorate: __decorate$30,
  __exportStar,
  __extends,
  __generator,
  __importDefault,
  __importStar,
  __makeTemplateObject,
  __metadata,
  __param,
  __read,
  __rest,
  __spread,
  __spreadArrays,
  __values
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6);
var utils$q = {};
var delay = {};
var hasRequiredDelay;
function requireDelay() {
  if (hasRequiredDelay) return delay;
  hasRequiredDelay = 1;
  Object.defineProperty(delay, "__esModule", { value: true });
  delay.delay = void 0;
  function delay$1(timeout) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve(true);
      }, timeout);
    });
  }
  delay.delay = delay$1;
  return delay;
}
var convert = {};
var constants$1 = {};
var misc = {};
var hasRequiredMisc;
function requireMisc() {
  if (hasRequiredMisc) return misc;
  hasRequiredMisc = 1;
  Object.defineProperty(misc, "__esModule", { value: true });
  misc.ONE_THOUSAND = misc.ONE_HUNDRED = void 0;
  misc.ONE_HUNDRED = 100;
  misc.ONE_THOUSAND = 1e3;
  return misc;
}
var time = {};
var hasRequiredTime;
function requireTime() {
  if (hasRequiredTime) return time;
  hasRequiredTime = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ONE_YEAR = exports2.FOUR_WEEKS = exports2.THREE_WEEKS = exports2.TWO_WEEKS = exports2.ONE_WEEK = exports2.THIRTY_DAYS = exports2.SEVEN_DAYS = exports2.FIVE_DAYS = exports2.THREE_DAYS = exports2.ONE_DAY = exports2.TWENTY_FOUR_HOURS = exports2.TWELVE_HOURS = exports2.SIX_HOURS = exports2.THREE_HOURS = exports2.ONE_HOUR = exports2.SIXTY_MINUTES = exports2.THIRTY_MINUTES = exports2.TEN_MINUTES = exports2.FIVE_MINUTES = exports2.ONE_MINUTE = exports2.SIXTY_SECONDS = exports2.THIRTY_SECONDS = exports2.TEN_SECONDS = exports2.FIVE_SECONDS = exports2.ONE_SECOND = void 0;
    exports2.ONE_SECOND = 1;
    exports2.FIVE_SECONDS = 5;
    exports2.TEN_SECONDS = 10;
    exports2.THIRTY_SECONDS = 30;
    exports2.SIXTY_SECONDS = 60;
    exports2.ONE_MINUTE = exports2.SIXTY_SECONDS;
    exports2.FIVE_MINUTES = exports2.ONE_MINUTE * 5;
    exports2.TEN_MINUTES = exports2.ONE_MINUTE * 10;
    exports2.THIRTY_MINUTES = exports2.ONE_MINUTE * 30;
    exports2.SIXTY_MINUTES = exports2.ONE_MINUTE * 60;
    exports2.ONE_HOUR = exports2.SIXTY_MINUTES;
    exports2.THREE_HOURS = exports2.ONE_HOUR * 3;
    exports2.SIX_HOURS = exports2.ONE_HOUR * 6;
    exports2.TWELVE_HOURS = exports2.ONE_HOUR * 12;
    exports2.TWENTY_FOUR_HOURS = exports2.ONE_HOUR * 24;
    exports2.ONE_DAY = exports2.TWENTY_FOUR_HOURS;
    exports2.THREE_DAYS = exports2.ONE_DAY * 3;
    exports2.FIVE_DAYS = exports2.ONE_DAY * 5;
    exports2.SEVEN_DAYS = exports2.ONE_DAY * 7;
    exports2.THIRTY_DAYS = exports2.ONE_DAY * 30;
    exports2.ONE_WEEK = exports2.SEVEN_DAYS;
    exports2.TWO_WEEKS = exports2.ONE_WEEK * 2;
    exports2.THREE_WEEKS = exports2.ONE_WEEK * 3;
    exports2.FOUR_WEEKS = exports2.ONE_WEEK * 4;
    exports2.ONE_YEAR = exports2.ONE_DAY * 365;
  })(time);
  return time;
}
var hasRequiredConstants$1;
function requireConstants$1() {
  if (hasRequiredConstants$1) return constants$1;
  hasRequiredConstants$1 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$2;
    tslib_1.__exportStar(requireMisc(), exports2);
    tslib_1.__exportStar(requireTime(), exports2);
  })(constants$1);
  return constants$1;
}
var hasRequiredConvert;
function requireConvert() {
  if (hasRequiredConvert) return convert;
  hasRequiredConvert = 1;
  Object.defineProperty(convert, "__esModule", { value: true });
  convert.fromMiliseconds = convert.toMiliseconds = void 0;
  const constants_1 = requireConstants$1();
  function toMiliseconds(seconds) {
    return seconds * constants_1.ONE_THOUSAND;
  }
  convert.toMiliseconds = toMiliseconds;
  function fromMiliseconds(miliseconds) {
    return Math.floor(miliseconds / constants_1.ONE_THOUSAND);
  }
  convert.fromMiliseconds = fromMiliseconds;
  return convert;
}
var hasRequiredUtils$2;
function requireUtils$2() {
  if (hasRequiredUtils$2) return utils$q;
  hasRequiredUtils$2 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$2;
    tslib_1.__exportStar(requireDelay(), exports2);
    tslib_1.__exportStar(requireConvert(), exports2);
  })(utils$q);
  return utils$q;
}
var watch$2 = {};
var hasRequiredWatch$1;
function requireWatch$1() {
  if (hasRequiredWatch$1) return watch$2;
  hasRequiredWatch$1 = 1;
  Object.defineProperty(watch$2, "__esModule", { value: true });
  watch$2.Watch = void 0;
  class Watch {
    constructor() {
      this.timestamps = /* @__PURE__ */ new Map();
    }
    start(label) {
      if (this.timestamps.has(label)) {
        throw new Error(`Watch already started for label: ${label}`);
      }
      this.timestamps.set(label, { started: Date.now() });
    }
    stop(label) {
      const timestamp = this.get(label);
      if (typeof timestamp.elapsed !== "undefined") {
        throw new Error(`Watch already stopped for label: ${label}`);
      }
      const elapsed = Date.now() - timestamp.started;
      this.timestamps.set(label, { started: timestamp.started, elapsed });
    }
    get(label) {
      const timestamp = this.timestamps.get(label);
      if (typeof timestamp === "undefined") {
        throw new Error(`No timestamp found for label: ${label}`);
      }
      return timestamp;
    }
    elapsed(label) {
      const timestamp = this.get(label);
      const elapsed = timestamp.elapsed || Date.now() - timestamp.started;
      return elapsed;
    }
  }
  watch$2.Watch = Watch;
  watch$2.default = Watch;
  return watch$2;
}
var types$1 = {};
var watch$1 = {};
var hasRequiredWatch;
function requireWatch() {
  if (hasRequiredWatch) return watch$1;
  hasRequiredWatch = 1;
  Object.defineProperty(watch$1, "__esModule", { value: true });
  watch$1.IWatch = void 0;
  class IWatch {
  }
  watch$1.IWatch = IWatch;
  return watch$1;
}
var hasRequiredTypes$1;
function requireTypes$1() {
  if (hasRequiredTypes$1) return types$1;
  hasRequiredTypes$1 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$2;
    tslib_1.__exportStar(requireWatch(), exports2);
  })(types$1);
  return types$1;
}
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  const tslib_1 = require$$0$2;
  tslib_1.__exportStar(requireUtils$2(), exports2);
  tslib_1.__exportStar(requireWatch$1(), exports2);
  tslib_1.__exportStar(requireTypes$1(), exports2);
  tslib_1.__exportStar(requireConstants$1(), exports2);
})(cjs$3);
class IEvents {
}
let n$8 = class n2 extends IEvents {
  constructor(e3) {
    super();
  }
};
const s$5 = cjs$3.FIVE_SECONDS, r$8 = { pulse: "heartbeat_pulse" };
let i$6 = class i2 extends n$8 {
  constructor(e3) {
    super(e3), this.events = new eventsExports.EventEmitter(), this.interval = s$5, this.interval = (e3 == null ? void 0 : e3.interval) || s$5;
  }
  static async init(e3) {
    const t2 = new i2(e3);
    return await t2.init(), t2;
  }
  async init() {
    await this.initialize();
  }
  stop() {
    clearInterval(this.intervalRef);
  }
  on(e3, t2) {
    this.events.on(e3, t2);
  }
  once(e3, t2) {
    this.events.once(e3, t2);
  }
  off(e3, t2) {
    this.events.off(e3, t2);
  }
  removeListener(e3, t2) {
    this.events.removeListener(e3, t2);
  }
  async initialize() {
    this.intervalRef = setInterval(() => this.pulse(), cjs$3.toMiliseconds(this.interval));
  }
  pulse() {
    this.events.emit(r$8.pulse);
  }
};
const suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
const suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
const JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(key2, value) {
  if (key2 === "__proto__" || key2 === "constructor" && value && typeof value === "object" && "prototype" in value) {
    warnKeyDropped(key2);
    return;
  }
  return value;
}
function warnKeyDropped(key2) {
  console.warn(`[destr] Dropping "${key2}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
  if (typeof value !== "string") {
    return value;
  }
  if (value[0] === '"' && value[value.length - 1] === '"' && value.indexOf("\\") === -1) {
    return value.slice(1, -1);
  }
  const _value2 = value.trim();
  if (_value2.length <= 9) {
    switch (_value2.toLowerCase()) {
      case "true": {
        return true;
      }
      case "false": {
        return false;
      }
      case "undefined": {
        return void 0;
      }
      case "null": {
        return null;
      }
      case "nan": {
        return Number.NaN;
      }
      case "infinity": {
        return Number.POSITIVE_INFINITY;
      }
      case "-infinity": {
        return Number.NEGATIVE_INFINITY;
      }
    }
  }
  if (!JsonSigRx.test(value)) {
    if (options.strict) {
      throw new SyntaxError("[destr] Invalid JSON");
    }
    return value;
  }
  try {
    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
      if (options.strict) {
        throw new Error("[destr] Possible prototype pollution");
      }
      return JSON.parse(value, jsonParseTransform);
    }
    return JSON.parse(value);
  } catch (error) {
    if (options.strict) {
      throw error;
    }
    return value;
  }
}
function wrapToPromise(value) {
  if (!value || typeof value.then !== "function") {
    return Promise.resolve(value);
  }
  return value;
}
function asyncCall(function_, ...arguments_) {
  try {
    return wrapToPromise(function_(...arguments_));
  } catch (error) {
    return Promise.reject(error);
  }
}
function isPrimitive(value) {
  const type2 = typeof value;
  return value === null || type2 !== "object" && type2 !== "function";
}
function isPureObject(value) {
  const proto = Object.getPrototypeOf(value);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify$2(value) {
  if (isPrimitive(value)) {
    return String(value);
  }
  if (isPureObject(value) || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (typeof value.toJSON === "function") {
    return stringify$2(value.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
const BASE64_PREFIX = "base64:";
function serializeRaw(value) {
  if (typeof value === "string") {
    return value;
  }
  return BASE64_PREFIX + base64Encode(value);
}
function deserializeRaw(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!value.startsWith(BASE64_PREFIX)) {
    return value;
  }
  return base64Decode(value.slice(BASE64_PREFIX.length));
}
function base64Decode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input, "base64");
  }
  return Uint8Array.from(
    globalThis.atob(input),
    (c2) => c2.codePointAt(0)
  );
}
function base64Encode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input).toString("base64");
  }
  return globalThis.btoa(String.fromCodePoint(...input));
}
function normalizeKey(key2) {
  var _a3;
  if (!key2) {
    return "";
  }
  return ((_a3 = key2.split("?")[0]) == null ? void 0 : _a3.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "")) || "";
}
function joinKeys(...keys2) {
  return normalizeKey(keys2.join(":"));
}
function normalizeBaseKey(base3) {
  base3 = normalizeKey(base3);
  return base3 ? base3 + ":" : "";
}
function filterKeyByDepth(key2, depth) {
  if (depth === void 0) {
    return true;
  }
  let substrCount = 0;
  let index2 = key2.indexOf(":");
  while (index2 > -1) {
    substrCount++;
    index2 = key2.indexOf(":", index2 + 1);
  }
  return substrCount <= depth;
}
function filterKeyByBase(key2, base3) {
  if (base3) {
    return key2.startsWith(base3) && key2[key2.length - 1] !== "$";
  }
  return key2[key2.length - 1] !== "$";
}
function defineDriver(factory) {
  return factory;
}
const DRIVER_NAME = "memory";
const memory = defineDriver(() => {
  const data2 = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME,
    getInstance: () => data2,
    hasItem(key2) {
      return data2.has(key2);
    },
    getItem(key2) {
      return data2.get(key2) ?? null;
    },
    getItemRaw(key2) {
      return data2.get(key2) ?? null;
    },
    setItem(key2, value) {
      data2.set(key2, value);
    },
    setItemRaw(key2, value) {
      data2.set(key2, value);
    },
    removeItem(key2) {
      data2.delete(key2);
    },
    getKeys() {
      return [...data2.keys()];
    },
    clear() {
      data2.clear();
    },
    dispose() {
      data2.clear();
    }
  };
});
function createStorage(options = {}) {
  const context = {
    mounts: { "": options.driver || memory() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = (key2) => {
    for (const base3 of context.mountpoints) {
      if (key2.startsWith(base3)) {
        return {
          base: base3,
          relativeKey: key2.slice(base3.length),
          driver: context.mounts[base3]
        };
      }
    }
    return {
      base: "",
      relativeKey: key2,
      driver: context.mounts[""]
    };
  };
  const getMounts = (base3, includeParent) => {
    return context.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base3) || includeParent && base3.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base3.length > mountpoint.length ? base3.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context.mounts[mountpoint]
    }));
  };
  const onChange = (event, key2) => {
    if (!context.watching) {
      return;
    }
    key2 = normalizeKey(key2);
    for (const listener of context.watchListeners) {
      listener(event, key2);
    }
  };
  const startWatch = async () => {
    if (context.watching) {
      return;
    }
    context.watching = true;
    for (const mountpoint in context.mounts) {
      context.unwatch[mountpoint] = await watch(
        context.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  };
  const stopWatch = async () => {
    if (!context.watching) {
      return;
    }
    for (const mountpoint in context.unwatch) {
      await context.unwatch[mountpoint]();
    }
    context.unwatch = {};
    context.watching = false;
  };
  const runBatch = (items, commonOptions, cb) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = (mount) => {
      let batch = batches.get(mount.base);
      if (!batch) {
        batch = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch);
      }
      return batch;
    };
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key2 = normalizeKey(isStringItem ? item : item.key);
      const value = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key2);
      getBatch(mount).items.push({
        key: key2,
        value,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
      (r3) => r3.flat()
    );
  };
  const storage = {
    // Item
    hasItem(key2, opts = {}) {
      key2 = normalizeKey(key2);
      const { relativeKey, driver } = getMount(key2);
      return asyncCall(driver.hasItem, relativeKey, opts);
    },
    getItem(key2, opts = {}) {
      key2 = normalizeKey(key2);
      const { relativeKey, driver } = getMount(key2);
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => destr(value)
      );
    },
    getItems(items, commonOptions = {}) {
      return runBatch(items, commonOptions, (batch) => {
        if (batch.driver.getItems) {
          return asyncCall(
            batch.driver.getItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r3) => r3.map((item) => ({
              key: joinKeys(batch.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value) => ({
              key: item.key,
              value: destr(value)
            }));
          })
        );
      });
    },
    getItemRaw(key2, opts = {}) {
      key2 = normalizeKey(key2);
      const { relativeKey, driver } = getMount(key2);
      if (driver.getItemRaw) {
        return asyncCall(driver.getItemRaw, relativeKey, opts);
      }
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => deserializeRaw(value)
      );
    },
    async setItem(key2, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key2);
      }
      key2 = normalizeKey(key2);
      const { relativeKey, driver } = getMount(key2);
      if (!driver.setItem) {
        return;
      }
      await asyncCall(driver.setItem, relativeKey, stringify$2(value), opts);
      if (!driver.watch) {
        onChange("update", key2);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch) => {
        if (batch.driver.setItems) {
          return asyncCall(
            batch.driver.setItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              value: stringify$2(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch.driver.setItem) {
          return;
        }
        await Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.setItem,
              item.relativeKey,
              stringify$2(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key2, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key2, opts);
      }
      key2 = normalizeKey(key2);
      const { relativeKey, driver } = getMount(key2);
      if (driver.setItemRaw) {
        await asyncCall(driver.setItemRaw, relativeKey, value, opts);
      } else if (driver.setItem) {
        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key2);
      }
    },
    async removeItem(key2, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { removeMeta: opts };
      }
      key2 = normalizeKey(key2);
      const { relativeKey, driver } = getMount(key2);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall(driver.removeItem, relativeKey, opts);
      if (opts.removeMeta || opts.removeMata) {
        await asyncCall(driver.removeItem, relativeKey + "$", opts);
      }
      if (!driver.watch) {
        onChange("remove", key2);
      }
    },
    // Meta
    async getMeta(key2, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { nativeOnly: opts };
      }
      key2 = normalizeKey(key2);
      const { relativeKey, driver } = getMount(key2);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));
      }
      if (!opts.nativeOnly) {
        const value = await asyncCall(
          driver.getItem,
          relativeKey + "$",
          opts
        ).then((value_) => destr(value_));
        if (value && typeof value === "object") {
          if (typeof value.atime === "string") {
            value.atime = new Date(value.atime);
          }
          if (typeof value.mtime === "string") {
            value.mtime = new Date(value.mtime);
          }
          Object.assign(meta, value);
        }
      }
      return meta;
    },
    setMeta(key2, value, opts = {}) {
      return this.setItem(key2 + "$", value, opts);
    },
    removeMeta(key2, opts = {}) {
      return this.removeItem(key2 + "$", opts);
    },
    // Keys
    async getKeys(base3, opts = {}) {
      var _a3;
      base3 = normalizeBaseKey(base3);
      const mounts = getMounts(base3, true);
      let maskedMounts = [];
      const allKeys = [];
      let allMountsSupportMaxDepth = true;
      for (const mount of mounts) {
        if (!((_a3 = mount.driver.flags) == null ? void 0 : _a3.maxDepth)) {
          allMountsSupportMaxDepth = false;
        }
        const rawKeys = await asyncCall(
          mount.driver.getKeys,
          mount.relativeBase,
          opts
        );
        for (const key2 of rawKeys) {
          const fullKey = mount.mountpoint + normalizeKey(key2);
          if (!maskedMounts.some((p2) => fullKey.startsWith(p2))) {
            allKeys.push(fullKey);
          }
        }
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p2) => !p2.startsWith(mount.mountpoint))
        ];
      }
      const shouldFilterByDepth = opts.maxDepth !== void 0 && !allMountsSupportMaxDepth;
      return allKeys.filter(
        (key2) => (!shouldFilterByDepth || filterKeyByDepth(key2, opts.maxDepth)) && filterKeyByBase(key2, base3)
      );
    },
    // Utils
    async clear(base3, opts = {}) {
      base3 = normalizeBaseKey(base3);
      await Promise.all(
        getMounts(base3, false).map(async (m4) => {
          if (m4.driver.clear) {
            return asyncCall(m4.driver.clear, m4.relativeBase, opts);
          }
          if (m4.driver.removeItem) {
            const keys2 = await m4.driver.getKeys(m4.relativeBase || "", opts);
            return Promise.all(
              keys2.map((key2) => m4.driver.removeItem(key2, opts))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context.mounts).map((driver) => dispose(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context.watchListeners.push(callback);
      return async () => {
        context.watchListeners = context.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base3, driver) {
      base3 = normalizeBaseKey(base3);
      if (base3 && context.mounts[base3]) {
        throw new Error(`already mounted at ${base3}`);
      }
      if (base3) {
        context.mountpoints.push(base3);
        context.mountpoints.sort((a2, b2) => b2.length - a2.length);
      }
      context.mounts[base3] = driver;
      if (context.watching) {
        Promise.resolve(watch(driver, onChange, base3)).then((unwatcher) => {
          context.unwatch[base3] = unwatcher;
        }).catch(console.error);
      }
      return storage;
    },
    async unmount(base3, _dispose = true) {
      var _a3, _b2;
      base3 = normalizeBaseKey(base3);
      if (!base3 || !context.mounts[base3]) {
        return;
      }
      if (context.watching && base3 in context.unwatch) {
        (_b2 = (_a3 = context.unwatch)[base3]) == null ? void 0 : _b2.call(_a3);
        delete context.unwatch[base3];
      }
      if (_dispose) {
        await dispose(context.mounts[base3]);
      }
      context.mountpoints = context.mountpoints.filter((key2) => key2 !== base3);
      delete context.mounts[base3];
    },
    getMount(key2 = "") {
      key2 = normalizeKey(key2) + ":";
      const m4 = getMount(key2);
      return {
        driver: m4.driver,
        base: m4.base
      };
    },
    getMounts(base3 = "", opts = {}) {
      base3 = normalizeKey(base3);
      const mounts = getMounts(base3, opts.parents);
      return mounts.map((m4) => ({
        driver: m4.driver,
        base: m4.mountpoint
      }));
    },
    // Aliases
    keys: (base3, opts = {}) => storage.getKeys(base3, opts),
    get: (key2, opts = {}) => storage.getItem(key2, opts),
    set: (key2, value, opts = {}) => storage.setItem(key2, value, opts),
    has: (key2, opts = {}) => storage.hasItem(key2, opts),
    del: (key2, opts = {}) => storage.removeItem(key2, opts),
    remove: (key2, opts = {}) => storage.removeItem(key2, opts)
  };
  return storage;
}
function watch(driver, onChange, base3) {
  return driver.watch ? driver.watch((event, key2) => onChange(event, base3 + key2)) : () => {
  };
}
async function dispose(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall(driver.dispose);
  }
}
function promisifyRequest(request) {
  return new Promise((resolve, reject) => {
    request.oncomplete = request.onsuccess = () => resolve(request.result);
    request.onabort = request.onerror = () => reject(request.error);
  });
}
function createStore(dbName, storeName) {
  let dbp;
  const getDB = () => {
    if (dbp)
      return dbp;
    const request = indexedDB.open(dbName);
    request.onupgradeneeded = () => request.result.createObjectStore(storeName);
    dbp = promisifyRequest(request);
    dbp.then((db) => {
      db.onclose = () => dbp = void 0;
    }, () => {
    });
    return dbp;
  };
  return (txMode, callback) => getDB().then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
let defaultGetStoreFunc;
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get$1(key2, customStore = defaultGetStore()) {
  return customStore("readonly", (store) => promisifyRequest(store.get(key2)));
}
function set(key2, value, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.put(value, key2);
    return promisifyRequest(store.transaction);
  });
}
function del(key2, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.delete(key2);
    return promisifyRequest(store.transaction);
  });
}
function clear(customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.clear();
    return promisifyRequest(store.transaction);
  });
}
function eachCursor(store, callback) {
  store.openCursor().onsuccess = function() {
    if (!this.result)
      return;
    callback(this.result);
    this.result.continue();
  };
  return promisifyRequest(store.transaction);
}
function keys(customStore = defaultGetStore()) {
  return customStore("readonly", (store) => {
    if (store.getAllKeys) {
      return promisifyRequest(store.getAllKeys());
    }
    const items = [];
    return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);
  });
}
const x$8 = "idb-keyval";
var z$a = (i4 = {}) => {
  const t2 = i4.base && i4.base.length > 0 ? `${i4.base}:` : "", e3 = (s2) => t2 + s2;
  let n5;
  return i4.dbName && i4.storeName && (n5 = createStore(i4.dbName, i4.storeName)), { name: x$8, options: i4, async hasItem(s2) {
    return !(typeof await get$1(e3(s2), n5) > "u");
  }, async getItem(s2) {
    return await get$1(e3(s2), n5) ?? null;
  }, setItem(s2, a2) {
    return set(e3(s2), a2, n5);
  }, removeItem(s2) {
    return del(e3(s2), n5);
  }, getKeys() {
    return keys(n5);
  }, clear() {
    return clear(n5);
  } };
};
const D$2 = "WALLET_CONNECT_V2_INDEXED_DB", E$6 = "keyvaluestorage";
let _$8 = class _2 {
  constructor() {
    this.indexedDb = createStorage({ driver: z$a({ dbName: D$2, storeName: E$6 }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t2) => [t2.key, t2.value]);
  }
  async getItem(t2) {
    const e3 = await this.indexedDb.getItem(t2);
    if (e3 !== null) return e3;
  }
  async setItem(t2, e3) {
    await this.indexedDb.setItem(t2, safeJsonStringify(e3));
  }
  async removeItem(t2) {
    await this.indexedDb.removeItem(t2);
  }
};
var l$3 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global$1 < "u" ? global$1 : typeof self < "u" ? self : {}, c$8 = { exports: {} };
(function() {
  let i4;
  function t2() {
  }
  i4 = t2, i4.prototype.getItem = function(e3) {
    return this.hasOwnProperty(e3) ? String(this[e3]) : null;
  }, i4.prototype.setItem = function(e3, n5) {
    this[e3] = String(n5);
  }, i4.prototype.removeItem = function(e3) {
    delete this[e3];
  }, i4.prototype.clear = function() {
    const e3 = this;
    Object.keys(e3).forEach(function(n5) {
      e3[n5] = void 0, delete e3[n5];
    });
  }, i4.prototype.key = function(e3) {
    return e3 = e3 || 0, Object.keys(this)[e3];
  }, i4.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l$3 < "u" && l$3.localStorage ? c$8.exports = l$3.localStorage : typeof window < "u" && window.localStorage ? c$8.exports = window.localStorage : c$8.exports = new t2();
})();
function k$6(i4) {
  var t2;
  return [i4[0], safeJsonParse((t2 = i4[1]) != null ? t2 : "")];
}
let K$5 = class K2 {
  constructor() {
    this.localStorage = c$8.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(k$6);
  }
  async getItem(t2) {
    const e3 = this.localStorage.getItem(t2);
    if (e3 !== null) return safeJsonParse(e3);
  }
  async setItem(t2, e3) {
    this.localStorage.setItem(t2, safeJsonStringify(e3));
  }
  async removeItem(t2) {
    this.localStorage.removeItem(t2);
  }
};
const N$6 = "wc_storage_version", y$5 = 1, O$5 = async (i4, t2, e3) => {
  const n5 = N$6, s2 = await t2.getItem(n5);
  if (s2 && s2 >= y$5) {
    e3(t2);
    return;
  }
  const a2 = await i4.getKeys();
  if (!a2.length) {
    e3(t2);
    return;
  }
  const m4 = [];
  for (; a2.length; ) {
    const r3 = a2.shift();
    if (!r3) continue;
    const o3 = r3.toLowerCase();
    if (o3.includes("wc@") || o3.includes("walletconnect") || o3.includes("wc_") || o3.includes("wallet_connect")) {
      const f6 = await i4.getItem(r3);
      await t2.setItem(r3, f6), m4.push(r3);
    }
  }
  await t2.setItem(n5, y$5), e3(t2), j$5(i4, m4);
}, j$5 = async (i4, t2) => {
  t2.length && t2.forEach(async (e3) => {
    await i4.removeItem(e3);
  });
};
let h$8 = class h2 {
  constructor() {
    this.initialized = false, this.setInitialized = (e3) => {
      this.storage = e3, this.initialized = true;
    };
    const t2 = new K$5();
    this.storage = t2;
    try {
      const e3 = new _$8();
      O$5(t2, e3, this.setInitialized);
    } catch {
      this.initialized = true;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(t2) {
    return await this.initialize(), this.storage.getItem(t2);
  }
  async setItem(t2, e3) {
    return await this.initialize(), this.storage.setItem(t2, e3);
  }
  async removeItem(t2) {
    return await this.initialize(), this.storage.removeItem(t2);
  }
  async initialize() {
    this.initialized || await new Promise((t2) => {
      const e3 = setInterval(() => {
        this.initialized && (clearInterval(e3), t2());
      }, 20);
    });
  }
};
var a$2 = Object.defineProperty, u$2 = (e3, s2, r3) => s2 in e3 ? a$2(e3, s2, { enumerable: true, configurable: true, writable: true, value: r3 }) : e3[s2] = r3, c$7 = (e3, s2, r3) => u$2(e3, typeof s2 != "symbol" ? s2 + "" : s2, r3);
let h$7 = class h3 extends IEvents {
  constructor(s2) {
    super(), this.opts = s2, c$7(this, "protocol", "wc"), c$7(this, "version", 2);
  }
};
var p$8 = Object.defineProperty, b$6 = (e3, s2, r3) => s2 in e3 ? p$8(e3, s2, { enumerable: true, configurable: true, writable: true, value: r3 }) : e3[s2] = r3, v$7 = (e3, s2, r3) => b$6(e3, s2 + "", r3);
let I$4 = class I2 extends IEvents {
  constructor(s2, r3) {
    super(), this.core = s2, this.logger = r3, v$7(this, "records", /* @__PURE__ */ new Map());
  }
};
let y$4 = class y2 {
  constructor(s2, r3) {
    this.logger = s2, this.core = r3;
  }
};
let m$1 = class m3 extends IEvents {
  constructor(s2, r3) {
    super(), this.relayer = s2, this.logger = r3;
  }
};
let d$6 = class d3 extends IEvents {
  constructor(s2) {
    super();
  }
};
let f$9 = class f2 {
  constructor(s2, r3, t2, q2) {
    this.core = s2, this.logger = r3, this.name = t2;
  }
};
let P$5 = class P2 extends IEvents {
  constructor(s2, r3) {
    super(), this.relayer = s2, this.logger = r3;
  }
};
let S$6 = class S2 extends IEvents {
  constructor(s2, r3) {
    super(), this.core = s2, this.logger = r3;
  }
};
let M$9 = class M2 {
  constructor(s2, r3, t2) {
    this.core = s2, this.logger = r3, this.store = t2;
  }
};
let O$4 = class O3 {
  constructor(s2, r3) {
    this.projectId = s2, this.logger = r3;
  }
};
let R$5 = class R2 {
  constructor(s2, r3, t2) {
    this.core = s2, this.logger = r3, this.telemetryEnabled = t2;
  }
};
var T$6 = Object.defineProperty, k$5 = (e3, s2, r3) => s2 in e3 ? T$6(e3, s2, { enumerable: true, configurable: true, writable: true, value: r3 }) : e3[s2] = r3, i$5 = (e3, s2, r3) => k$5(e3, typeof s2 != "symbol" ? s2 + "" : s2, r3);
let J$8 = class J2 {
  constructor(s2) {
    this.opts = s2, i$5(this, "protocol", "wc"), i$5(this, "version", 2);
  }
};
let V$a = class V2 {
  constructor(s2) {
    this.client = s2;
  }
};
function En$7(t2) {
  return t2 instanceof Uint8Array || ArrayBuffer.isView(t2) && t2.constructor.name === "Uint8Array";
}
function fe$4(t2, ...e3) {
  if (!En$7(t2)) throw new Error("Uint8Array expected");
  if (e3.length > 0 && !e3.includes(t2.length)) throw new Error("Uint8Array expected of length " + e3 + ", got length=" + t2.length);
}
function De$7(t2, e3 = true) {
  if (t2.destroyed) throw new Error("Hash instance has been destroyed");
  if (e3 && t2.finished) throw new Error("Hash#digest() has already been called");
}
function gn$7(t2, e3) {
  fe$4(t2);
  const n5 = e3.outputLen;
  if (t2.length < n5) throw new Error("digestInto() expects output buffer of length at least " + n5);
}
const it$5 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _t$8 = (t2) => new DataView(t2.buffer, t2.byteOffset, t2.byteLength);
function yn$7(t2) {
  if (typeof t2 != "string") throw new Error("utf8ToBytes expected string, got " + typeof t2);
  return new Uint8Array(new TextEncoder().encode(t2));
}
function de$6(t2) {
  return typeof t2 == "string" && (t2 = yn$7(t2)), fe$4(t2), t2;
}
let xn$7 = class xn2 {
  clone() {
    return this._cloneInto();
  }
};
function Bn$7(t2) {
  const e3 = (r3) => t2().update(de$6(r3)).digest(), n5 = t2();
  return e3.outputLen = n5.outputLen, e3.blockLen = n5.blockLen, e3.create = () => t2(), e3;
}
function he$2(t2 = 32) {
  if (it$5 && typeof it$5.getRandomValues == "function") return it$5.getRandomValues(new Uint8Array(t2));
  if (it$5 && typeof it$5.randomBytes == "function") return it$5.randomBytes(t2);
  throw new Error("crypto.getRandomValues must be defined");
}
function Cn$7(t2, e3, n5, r3) {
  if (typeof t2.setBigUint64 == "function") return t2.setBigUint64(e3, n5, r3);
  const o3 = BigInt(32), s2 = BigInt(4294967295), a2 = Number(n5 >> o3 & s2), u2 = Number(n5 & s2), i4 = r3 ? 4 : 0, D2 = r3 ? 0 : 4;
  t2.setUint32(e3 + i4, a2, r3), t2.setUint32(e3 + D2, u2, r3);
}
let An$7 = class An2 extends xn$7 {
  constructor(e3, n5, r3, o3) {
    super(), this.blockLen = e3, this.outputLen = n5, this.padOffset = r3, this.isLE = o3, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e3), this.view = _t$8(this.buffer);
  }
  update(e3) {
    De$7(this);
    const { view: n5, buffer: r3, blockLen: o3 } = this;
    e3 = de$6(e3);
    const s2 = e3.length;
    for (let a2 = 0; a2 < s2; ) {
      const u2 = Math.min(o3 - this.pos, s2 - a2);
      if (u2 === o3) {
        const i4 = _t$8(e3);
        for (; o3 <= s2 - a2; a2 += o3) this.process(i4, a2);
        continue;
      }
      r3.set(e3.subarray(a2, a2 + u2), this.pos), this.pos += u2, a2 += u2, this.pos === o3 && (this.process(n5, 0), this.pos = 0);
    }
    return this.length += e3.length, this.roundClean(), this;
  }
  digestInto(e3) {
    De$7(this), gn$7(e3, this), this.finished = true;
    const { buffer: n5, view: r3, blockLen: o3, isLE: s2 } = this;
    let { pos: a2 } = this;
    n5[a2++] = 128, this.buffer.subarray(a2).fill(0), this.padOffset > o3 - a2 && (this.process(r3, 0), a2 = 0);
    for (let l2 = a2; l2 < o3; l2++) n5[l2] = 0;
    Cn$7(r3, o3 - 8, BigInt(this.length * 8), s2), this.process(r3, 0);
    const u2 = _t$8(e3), i4 = this.outputLen;
    if (i4 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const D2 = i4 / 4, c2 = this.get();
    if (D2 > c2.length) throw new Error("_sha2: outputLen bigger than state");
    for (let l2 = 0; l2 < D2; l2++) u2.setUint32(4 * l2, c2[l2], s2);
  }
  digest() {
    const { buffer: e3, outputLen: n5 } = this;
    this.digestInto(e3);
    const r3 = e3.slice(0, n5);
    return this.destroy(), r3;
  }
  _cloneInto(e3) {
    e3 || (e3 = new this.constructor()), e3.set(...this.get());
    const { blockLen: n5, buffer: r3, length: o3, finished: s2, destroyed: a2, pos: u2 } = this;
    return e3.length = o3, e3.pos = u2, e3.finished = s2, e3.destroyed = a2, o3 % n5 && e3.buffer.set(r3), e3;
  }
};
const wt$6 = BigInt(2 ** 32 - 1), St$9 = BigInt(32);
function le$6(t2, e3 = false) {
  return e3 ? { h: Number(t2 & wt$6), l: Number(t2 >> St$9 & wt$6) } : { h: Number(t2 >> St$9 & wt$6) | 0, l: Number(t2 & wt$6) | 0 };
}
function mn$7(t2, e3 = false) {
  let n5 = new Uint32Array(t2.length), r3 = new Uint32Array(t2.length);
  for (let o3 = 0; o3 < t2.length; o3++) {
    const { h: s2, l: a2 } = le$6(t2[o3], e3);
    [n5[o3], r3[o3]] = [s2, a2];
  }
  return [n5, r3];
}
const _n$7 = (t2, e3) => BigInt(t2 >>> 0) << St$9 | BigInt(e3 >>> 0), Sn$7 = (t2, e3, n5) => t2 >>> n5, vn$7 = (t2, e3, n5) => t2 << 32 - n5 | e3 >>> n5, In$7 = (t2, e3, n5) => t2 >>> n5 | e3 << 32 - n5, Un$7 = (t2, e3, n5) => t2 << 32 - n5 | e3 >>> n5, Tn$7 = (t2, e3, n5) => t2 << 64 - n5 | e3 >>> n5 - 32, Fn$7 = (t2, e3, n5) => t2 >>> n5 - 32 | e3 << 64 - n5, Nn$7 = (t2, e3) => e3, Ln$7 = (t2, e3) => t2, On$7 = (t2, e3, n5) => t2 << n5 | e3 >>> 32 - n5, Hn$7 = (t2, e3, n5) => e3 << n5 | t2 >>> 32 - n5, zn$7 = (t2, e3, n5) => e3 << n5 - 32 | t2 >>> 64 - n5, Mn$7 = (t2, e3, n5) => t2 << n5 - 32 | e3 >>> 64 - n5;
function qn$7(t2, e3, n5, r3) {
  const o3 = (e3 >>> 0) + (r3 >>> 0);
  return { h: t2 + n5 + (o3 / 2 ** 32 | 0) | 0, l: o3 | 0 };
}
const $n$7 = (t2, e3, n5) => (t2 >>> 0) + (e3 >>> 0) + (n5 >>> 0), kn$7 = (t2, e3, n5, r3) => e3 + n5 + r3 + (t2 / 2 ** 32 | 0) | 0, Rn$7 = (t2, e3, n5, r3) => (t2 >>> 0) + (e3 >>> 0) + (n5 >>> 0) + (r3 >>> 0), jn$7 = (t2, e3, n5, r3, o3) => e3 + n5 + r3 + o3 + (t2 / 2 ** 32 | 0) | 0, Zn$7 = (t2, e3, n5, r3, o3) => (t2 >>> 0) + (e3 >>> 0) + (n5 >>> 0) + (r3 >>> 0) + (o3 >>> 0), Gn$7 = (t2, e3, n5, r3, o3, s2) => e3 + n5 + r3 + o3 + s2 + (t2 / 2 ** 32 | 0) | 0, x$7 = { fromBig: le$6, split: mn$7, toBig: _n$7, shrSH: Sn$7, shrSL: vn$7, rotrSH: In$7, rotrSL: Un$7, rotrBH: Tn$7, rotrBL: Fn$7, rotr32H: Nn$7, rotr32L: Ln$7, rotlSH: On$7, rotlSL: Hn$7, rotlBH: zn$7, rotlBL: Mn$7, add: qn$7, add3L: $n$7, add3H: kn$7, add4L: Rn$7, add4H: jn$7, add5H: Gn$7, add5L: Zn$7 }, [Vn$7, Yn$7] = (() => x$7.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((t2) => BigInt(t2))))(), P$4 = new Uint32Array(80), Q$4 = new Uint32Array(80);
let Jn$7 = class Jn2 extends An$7 {
  constructor() {
    super(128, 64, 16, false), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  get() {
    const { Ah: e3, Al: n5, Bh: r3, Bl: o3, Ch: s2, Cl: a2, Dh: u2, Dl: i4, Eh: D2, El: c2, Fh: l2, Fl: p2, Gh: w2, Gl: h5, Hh: g2, Hl: S4 } = this;
    return [e3, n5, r3, o3, s2, a2, u2, i4, D2, c2, l2, p2, w2, h5, g2, S4];
  }
  set(e3, n5, r3, o3, s2, a2, u2, i4, D2, c2, l2, p2, w2, h5, g2, S4) {
    this.Ah = e3 | 0, this.Al = n5 | 0, this.Bh = r3 | 0, this.Bl = o3 | 0, this.Ch = s2 | 0, this.Cl = a2 | 0, this.Dh = u2 | 0, this.Dl = i4 | 0, this.Eh = D2 | 0, this.El = c2 | 0, this.Fh = l2 | 0, this.Fl = p2 | 0, this.Gh = w2 | 0, this.Gl = h5 | 0, this.Hh = g2 | 0, this.Hl = S4 | 0;
  }
  process(e3, n5) {
    for (let d4 = 0; d4 < 16; d4++, n5 += 4) P$4[d4] = e3.getUint32(n5), Q$4[d4] = e3.getUint32(n5 += 4);
    for (let d4 = 16; d4 < 80; d4++) {
      const m4 = P$4[d4 - 15] | 0, F2 = Q$4[d4 - 15] | 0, q2 = x$7.rotrSH(m4, F2, 1) ^ x$7.rotrSH(m4, F2, 8) ^ x$7.shrSH(m4, F2, 7), z3 = x$7.rotrSL(m4, F2, 1) ^ x$7.rotrSL(m4, F2, 8) ^ x$7.shrSL(m4, F2, 7), I4 = P$4[d4 - 2] | 0, O4 = Q$4[d4 - 2] | 0, ot2 = x$7.rotrSH(I4, O4, 19) ^ x$7.rotrBH(I4, O4, 61) ^ x$7.shrSH(I4, O4, 6), tt2 = x$7.rotrSL(I4, O4, 19) ^ x$7.rotrBL(I4, O4, 61) ^ x$7.shrSL(I4, O4, 6), st2 = x$7.add4L(z3, tt2, Q$4[d4 - 7], Q$4[d4 - 16]), at2 = x$7.add4H(st2, q2, ot2, P$4[d4 - 7], P$4[d4 - 16]);
      P$4[d4] = at2 | 0, Q$4[d4] = st2 | 0;
    }
    let { Ah: r3, Al: o3, Bh: s2, Bl: a2, Ch: u2, Cl: i4, Dh: D2, Dl: c2, Eh: l2, El: p2, Fh: w2, Fl: h5, Gh: g2, Gl: S4, Hh: v2, Hl: L4 } = this;
    for (let d4 = 0; d4 < 80; d4++) {
      const m4 = x$7.rotrSH(l2, p2, 14) ^ x$7.rotrSH(l2, p2, 18) ^ x$7.rotrBH(l2, p2, 41), F2 = x$7.rotrSL(l2, p2, 14) ^ x$7.rotrSL(l2, p2, 18) ^ x$7.rotrBL(l2, p2, 41), q2 = l2 & w2 ^ ~l2 & g2, z3 = p2 & h5 ^ ~p2 & S4, I4 = x$7.add5L(L4, F2, z3, Yn$7[d4], Q$4[d4]), O4 = x$7.add5H(I4, v2, m4, q2, Vn$7[d4], P$4[d4]), ot2 = I4 | 0, tt2 = x$7.rotrSH(r3, o3, 28) ^ x$7.rotrBH(r3, o3, 34) ^ x$7.rotrBH(r3, o3, 39), st2 = x$7.rotrSL(r3, o3, 28) ^ x$7.rotrBL(r3, o3, 34) ^ x$7.rotrBL(r3, o3, 39), at2 = r3 & s2 ^ r3 & u2 ^ s2 & u2, Ct2 = o3 & a2 ^ o3 & i4 ^ a2 & i4;
      v2 = g2 | 0, L4 = S4 | 0, g2 = w2 | 0, S4 = h5 | 0, w2 = l2 | 0, h5 = p2 | 0, { h: l2, l: p2 } = x$7.add(D2 | 0, c2 | 0, O4 | 0, ot2 | 0), D2 = u2 | 0, c2 = i4 | 0, u2 = s2 | 0, i4 = a2 | 0, s2 = r3 | 0, a2 = o3 | 0;
      const At2 = x$7.add3L(ot2, st2, Ct2);
      r3 = x$7.add3H(At2, O4, tt2, at2), o3 = At2 | 0;
    }
    ({ h: r3, l: o3 } = x$7.add(this.Ah | 0, this.Al | 0, r3 | 0, o3 | 0)), { h: s2, l: a2 } = x$7.add(this.Bh | 0, this.Bl | 0, s2 | 0, a2 | 0), { h: u2, l: i4 } = x$7.add(this.Ch | 0, this.Cl | 0, u2 | 0, i4 | 0), { h: D2, l: c2 } = x$7.add(this.Dh | 0, this.Dl | 0, D2 | 0, c2 | 0), { h: l2, l: p2 } = x$7.add(this.Eh | 0, this.El | 0, l2 | 0, p2 | 0), { h: w2, l: h5 } = x$7.add(this.Fh | 0, this.Fl | 0, w2 | 0, h5 | 0), { h: g2, l: S4 } = x$7.add(this.Gh | 0, this.Gl | 0, g2 | 0, S4 | 0), { h: v2, l: L4 } = x$7.add(this.Hh | 0, this.Hl | 0, v2 | 0, L4 | 0), this.set(r3, o3, s2, a2, u2, i4, D2, c2, l2, p2, w2, h5, g2, S4, v2, L4);
  }
  roundClean() {
    P$4.fill(0), Q$4.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
const Kn$7 = Bn$7(() => new Jn$7());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const vt$6 = BigInt(0), be$4 = BigInt(1), Wn$7 = BigInt(2);
function It$6(t2) {
  return t2 instanceof Uint8Array || ArrayBuffer.isView(t2) && t2.constructor.name === "Uint8Array";
}
function Ut$7(t2) {
  if (!It$6(t2)) throw new Error("Uint8Array expected");
}
function Tt$7(t2, e3) {
  if (typeof e3 != "boolean") throw new Error(t2 + " boolean expected, got " + e3);
}
const Xn$7 = Array.from({ length: 256 }, (t2, e3) => e3.toString(16).padStart(2, "0"));
function Ft$7(t2) {
  Ut$7(t2);
  let e3 = "";
  for (let n5 = 0; n5 < t2.length; n5++) e3 += Xn$7[t2[n5]];
  return e3;
}
function pe$4(t2) {
  if (typeof t2 != "string") throw new Error("hex string expected, got " + typeof t2);
  return t2 === "" ? vt$6 : BigInt("0x" + t2);
}
const K$4 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function we$7(t2) {
  if (t2 >= K$4._0 && t2 <= K$4._9) return t2 - K$4._0;
  if (t2 >= K$4.A && t2 <= K$4.F) return t2 - (K$4.A - 10);
  if (t2 >= K$4.a && t2 <= K$4.f) return t2 - (K$4.a - 10);
}
function Ee$7(t2) {
  if (typeof t2 != "string") throw new Error("hex string expected, got " + typeof t2);
  const e3 = t2.length, n5 = e3 / 2;
  if (e3 % 2) throw new Error("hex string expected, got unpadded hex of length " + e3);
  const r3 = new Uint8Array(n5);
  for (let o3 = 0, s2 = 0; o3 < n5; o3++, s2 += 2) {
    const a2 = we$7(t2.charCodeAt(s2)), u2 = we$7(t2.charCodeAt(s2 + 1));
    if (a2 === void 0 || u2 === void 0) {
      const i4 = t2[s2] + t2[s2 + 1];
      throw new Error('hex string expected, got non-hex character "' + i4 + '" at index ' + s2);
    }
    r3[o3] = a2 * 16 + u2;
  }
  return r3;
}
function Pn$7(t2) {
  return pe$4(Ft$7(t2));
}
function Et$9(t2) {
  return Ut$7(t2), pe$4(Ft$7(Uint8Array.from(t2).reverse()));
}
function ge(t2, e3) {
  return Ee$7(t2.toString(16).padStart(e3 * 2, "0"));
}
function Nt$7(t2, e3) {
  return ge(t2, e3).reverse();
}
function W$3(t2, e3, n5) {
  let r3;
  if (typeof e3 == "string") try {
    r3 = Ee$7(e3);
  } catch (s2) {
    throw new Error(t2 + " must be hex string or Uint8Array, cause: " + s2);
  }
  else if (It$6(e3)) r3 = Uint8Array.from(e3);
  else throw new Error(t2 + " must be hex string or Uint8Array");
  const o3 = r3.length;
  if (typeof n5 == "number" && o3 !== n5) throw new Error(t2 + " of length " + n5 + " expected, got " + o3);
  return r3;
}
function ye$2(...t2) {
  let e3 = 0;
  for (let r3 = 0; r3 < t2.length; r3++) {
    const o3 = t2[r3];
    Ut$7(o3), e3 += o3.length;
  }
  const n5 = new Uint8Array(e3);
  for (let r3 = 0, o3 = 0; r3 < t2.length; r3++) {
    const s2 = t2[r3];
    n5.set(s2, o3), o3 += s2.length;
  }
  return n5;
}
const Lt$7 = (t2) => typeof t2 == "bigint" && vt$6 <= t2;
function Qn$7(t2, e3, n5) {
  return Lt$7(t2) && Lt$7(e3) && Lt$7(n5) && e3 <= t2 && t2 < n5;
}
function ft$6(t2, e3, n5, r3) {
  if (!Qn$7(e3, n5, r3)) throw new Error("expected valid " + t2 + ": " + n5 + " <= n < " + r3 + ", got " + e3);
}
function tr$7(t2) {
  let e3;
  for (e3 = 0; t2 > vt$6; t2 >>= be$4, e3 += 1) ;
  return e3;
}
const er$7 = (t2) => (Wn$7 << BigInt(t2 - 1)) - be$4, nr$7 = { bigint: (t2) => typeof t2 == "bigint", function: (t2) => typeof t2 == "function", boolean: (t2) => typeof t2 == "boolean", string: (t2) => typeof t2 == "string", stringOrUint8Array: (t2) => typeof t2 == "string" || It$6(t2), isSafeInteger: (t2) => Number.isSafeInteger(t2), array: (t2) => Array.isArray(t2), field: (t2, e3) => e3.Fp.isValid(t2), hash: (t2) => typeof t2 == "function" && Number.isSafeInteger(t2.outputLen) };
function Ot$6(t2, e3, n5 = {}) {
  const r3 = (o3, s2, a2) => {
    const u2 = nr$7[s2];
    if (typeof u2 != "function") throw new Error("invalid validator function");
    const i4 = t2[o3];
    if (!(a2 && i4 === void 0) && !u2(i4, t2)) throw new Error("param " + String(o3) + " is invalid. Expected " + s2 + ", got " + i4);
  };
  for (const [o3, s2] of Object.entries(e3)) r3(o3, s2, false);
  for (const [o3, s2] of Object.entries(n5)) r3(o3, s2, true);
  return t2;
}
function xe$7(t2) {
  const e3 = /* @__PURE__ */ new WeakMap();
  return (n5, ...r3) => {
    const o3 = e3.get(n5);
    if (o3 !== void 0) return o3;
    const s2 = t2(n5, ...r3);
    return e3.set(n5, s2), s2;
  };
}
const M$8 = BigInt(0), N$5 = BigInt(1), nt$4 = BigInt(2), rr$7 = BigInt(3), Ht$7 = BigInt(4), Be$7 = BigInt(5), Ce$5 = BigInt(8);
function H$7(t2, e3) {
  const n5 = t2 % e3;
  return n5 >= M$8 ? n5 : e3 + n5;
}
function or$8(t2, e3, n5) {
  if (e3 < M$8) throw new Error("invalid exponent, negatives unsupported");
  if (n5 <= M$8) throw new Error("invalid modulus");
  if (n5 === N$5) return M$8;
  let r3 = N$5;
  for (; e3 > M$8; ) e3 & N$5 && (r3 = r3 * t2 % n5), t2 = t2 * t2 % n5, e3 >>= N$5;
  return r3;
}
function J$7(t2, e3, n5) {
  let r3 = t2;
  for (; e3-- > M$8; ) r3 *= r3, r3 %= n5;
  return r3;
}
function Ae$7(t2, e3) {
  if (t2 === M$8) throw new Error("invert: expected non-zero number");
  if (e3 <= M$8) throw new Error("invert: expected positive modulus, got " + e3);
  let n5 = H$7(t2, e3), r3 = e3, o3 = M$8, s2 = N$5;
  for (; n5 !== M$8; ) {
    const u2 = r3 / n5, i4 = r3 % n5, D2 = o3 - s2 * u2;
    r3 = n5, n5 = i4, o3 = s2, s2 = D2;
  }
  if (r3 !== N$5) throw new Error("invert: does not exist");
  return H$7(o3, e3);
}
function sr$7(t2) {
  const e3 = (t2 - N$5) / nt$4;
  let n5, r3, o3;
  for (n5 = t2 - N$5, r3 = 0; n5 % nt$4 === M$8; n5 /= nt$4, r3++) ;
  for (o3 = nt$4; o3 < t2 && or$8(o3, e3, t2) !== t2 - N$5; o3++) if (o3 > 1e3) throw new Error("Cannot find square root: likely non-prime P");
  if (r3 === 1) {
    const a2 = (t2 + N$5) / Ht$7;
    return function(i4, D2) {
      const c2 = i4.pow(D2, a2);
      if (!i4.eql(i4.sqr(c2), D2)) throw new Error("Cannot find square root");
      return c2;
    };
  }
  const s2 = (n5 + N$5) / nt$4;
  return function(u2, i4) {
    if (u2.pow(i4, e3) === u2.neg(u2.ONE)) throw new Error("Cannot find square root");
    let D2 = r3, c2 = u2.pow(u2.mul(u2.ONE, o3), n5), l2 = u2.pow(i4, s2), p2 = u2.pow(i4, n5);
    for (; !u2.eql(p2, u2.ONE); ) {
      if (u2.eql(p2, u2.ZERO)) return u2.ZERO;
      let w2 = 1;
      for (let g2 = u2.sqr(p2); w2 < D2 && !u2.eql(g2, u2.ONE); w2++) g2 = u2.sqr(g2);
      const h5 = u2.pow(c2, N$5 << BigInt(D2 - w2 - 1));
      c2 = u2.sqr(h5), l2 = u2.mul(l2, h5), p2 = u2.mul(p2, c2), D2 = w2;
    }
    return l2;
  };
}
function ir$7(t2) {
  if (t2 % Ht$7 === rr$7) {
    const e3 = (t2 + N$5) / Ht$7;
    return function(r3, o3) {
      const s2 = r3.pow(o3, e3);
      if (!r3.eql(r3.sqr(s2), o3)) throw new Error("Cannot find square root");
      return s2;
    };
  }
  if (t2 % Ce$5 === Be$7) {
    const e3 = (t2 - Be$7) / Ce$5;
    return function(r3, o3) {
      const s2 = r3.mul(o3, nt$4), a2 = r3.pow(s2, e3), u2 = r3.mul(o3, a2), i4 = r3.mul(r3.mul(u2, nt$4), a2), D2 = r3.mul(u2, r3.sub(i4, r3.ONE));
      if (!r3.eql(r3.sqr(D2), o3)) throw new Error("Cannot find square root");
      return D2;
    };
  }
  return sr$7(t2);
}
const ur$7 = (t2, e3) => (H$7(t2, e3) & N$5) === N$5, cr$7 = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function ar$7(t2) {
  const e3 = { ORDER: "bigint", MASK: "bigint", BYTES: "isSafeInteger", BITS: "isSafeInteger" }, n5 = cr$7.reduce((r3, o3) => (r3[o3] = "function", r3), e3);
  return Ot$6(t2, n5);
}
function fr$7(t2, e3, n5) {
  if (n5 < M$8) throw new Error("invalid exponent, negatives unsupported");
  if (n5 === M$8) return t2.ONE;
  if (n5 === N$5) return e3;
  let r3 = t2.ONE, o3 = e3;
  for (; n5 > M$8; ) n5 & N$5 && (r3 = t2.mul(r3, o3)), o3 = t2.sqr(o3), n5 >>= N$5;
  return r3;
}
function Dr$5(t2, e3) {
  const n5 = new Array(e3.length), r3 = e3.reduce((s2, a2, u2) => t2.is0(a2) ? s2 : (n5[u2] = s2, t2.mul(s2, a2)), t2.ONE), o3 = t2.inv(r3);
  return e3.reduceRight((s2, a2, u2) => t2.is0(a2) ? s2 : (n5[u2] = t2.mul(s2, n5[u2]), t2.mul(s2, a2)), o3), n5;
}
function me$2(t2, e3) {
  const n5 = e3 !== void 0 ? e3 : t2.toString(2).length, r3 = Math.ceil(n5 / 8);
  return { nBitLength: n5, nByteLength: r3 };
}
function _e$9(t2, e3, n5 = false, r3 = {}) {
  if (t2 <= M$8) throw new Error("invalid field: expected ORDER > 0, got " + t2);
  const { nBitLength: o3, nByteLength: s2 } = me$2(t2, e3);
  if (s2 > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let a2;
  const u2 = Object.freeze({ ORDER: t2, isLE: n5, BITS: o3, BYTES: s2, MASK: er$7(o3), ZERO: M$8, ONE: N$5, create: (i4) => H$7(i4, t2), isValid: (i4) => {
    if (typeof i4 != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof i4);
    return M$8 <= i4 && i4 < t2;
  }, is0: (i4) => i4 === M$8, isOdd: (i4) => (i4 & N$5) === N$5, neg: (i4) => H$7(-i4, t2), eql: (i4, D2) => i4 === D2, sqr: (i4) => H$7(i4 * i4, t2), add: (i4, D2) => H$7(i4 + D2, t2), sub: (i4, D2) => H$7(i4 - D2, t2), mul: (i4, D2) => H$7(i4 * D2, t2), pow: (i4, D2) => fr$7(u2, i4, D2), div: (i4, D2) => H$7(i4 * Ae$7(D2, t2), t2), sqrN: (i4) => i4 * i4, addN: (i4, D2) => i4 + D2, subN: (i4, D2) => i4 - D2, mulN: (i4, D2) => i4 * D2, inv: (i4) => Ae$7(i4, t2), sqrt: r3.sqrt || ((i4) => (a2 || (a2 = ir$7(t2)), a2(u2, i4))), invertBatch: (i4) => Dr$5(u2, i4), cmov: (i4, D2, c2) => c2 ? D2 : i4, toBytes: (i4) => n5 ? Nt$7(i4, s2) : ge(i4, s2), fromBytes: (i4) => {
    if (i4.length !== s2) throw new Error("Field.fromBytes: expected " + s2 + " bytes, got " + i4.length);
    return n5 ? Et$9(i4) : Pn$7(i4);
  } });
  return Object.freeze(u2);
}
const Se$7 = BigInt(0), gt$2 = BigInt(1);
function zt$7(t2, e3) {
  const n5 = e3.negate();
  return t2 ? n5 : e3;
}
function ve$4(t2, e3) {
  if (!Number.isSafeInteger(t2) || t2 <= 0 || t2 > e3) throw new Error("invalid window size, expected [1.." + e3 + "], got W=" + t2);
}
function Mt$7(t2, e3) {
  ve$4(t2, e3);
  const n5 = Math.ceil(e3 / t2) + 1, r3 = 2 ** (t2 - 1);
  return { windows: n5, windowSize: r3 };
}
function dr$7(t2, e3) {
  if (!Array.isArray(t2)) throw new Error("array expected");
  t2.forEach((n5, r3) => {
    if (!(n5 instanceof e3)) throw new Error("invalid point at index " + r3);
  });
}
function hr$7(t2, e3) {
  if (!Array.isArray(t2)) throw new Error("array of scalars expected");
  t2.forEach((n5, r3) => {
    if (!e3.isValid(n5)) throw new Error("invalid scalar at index " + r3);
  });
}
const qt$7 = /* @__PURE__ */ new WeakMap(), Ie$5 = /* @__PURE__ */ new WeakMap();
function $t$4(t2) {
  return Ie$5.get(t2) || 1;
}
function lr$7(t2, e3) {
  return { constTimeNegate: zt$7, hasPrecomputes(n5) {
    return $t$4(n5) !== 1;
  }, unsafeLadder(n5, r3, o3 = t2.ZERO) {
    let s2 = n5;
    for (; r3 > Se$7; ) r3 & gt$2 && (o3 = o3.add(s2)), s2 = s2.double(), r3 >>= gt$2;
    return o3;
  }, precomputeWindow(n5, r3) {
    const { windows: o3, windowSize: s2 } = Mt$7(r3, e3), a2 = [];
    let u2 = n5, i4 = u2;
    for (let D2 = 0; D2 < o3; D2++) {
      i4 = u2, a2.push(i4);
      for (let c2 = 1; c2 < s2; c2++) i4 = i4.add(u2), a2.push(i4);
      u2 = i4.double();
    }
    return a2;
  }, wNAF(n5, r3, o3) {
    const { windows: s2, windowSize: a2 } = Mt$7(n5, e3);
    let u2 = t2.ZERO, i4 = t2.BASE;
    const D2 = BigInt(2 ** n5 - 1), c2 = 2 ** n5, l2 = BigInt(n5);
    for (let p2 = 0; p2 < s2; p2++) {
      const w2 = p2 * a2;
      let h5 = Number(o3 & D2);
      o3 >>= l2, h5 > a2 && (h5 -= c2, o3 += gt$2);
      const g2 = w2, S4 = w2 + Math.abs(h5) - 1, v2 = p2 % 2 !== 0, L4 = h5 < 0;
      h5 === 0 ? i4 = i4.add(zt$7(v2, r3[g2])) : u2 = u2.add(zt$7(L4, r3[S4]));
    }
    return { p: u2, f: i4 };
  }, wNAFUnsafe(n5, r3, o3, s2 = t2.ZERO) {
    const { windows: a2, windowSize: u2 } = Mt$7(n5, e3), i4 = BigInt(2 ** n5 - 1), D2 = 2 ** n5, c2 = BigInt(n5);
    for (let l2 = 0; l2 < a2; l2++) {
      const p2 = l2 * u2;
      if (o3 === Se$7) break;
      let w2 = Number(o3 & i4);
      if (o3 >>= c2, w2 > u2 && (w2 -= D2, o3 += gt$2), w2 === 0) continue;
      let h5 = r3[p2 + Math.abs(w2) - 1];
      w2 < 0 && (h5 = h5.negate()), s2 = s2.add(h5);
    }
    return s2;
  }, getPrecomputes(n5, r3, o3) {
    let s2 = qt$7.get(r3);
    return s2 || (s2 = this.precomputeWindow(r3, n5), n5 !== 1 && qt$7.set(r3, o3(s2))), s2;
  }, wNAFCached(n5, r3, o3) {
    const s2 = $t$4(n5);
    return this.wNAF(s2, this.getPrecomputes(s2, n5, o3), r3);
  }, wNAFCachedUnsafe(n5, r3, o3, s2) {
    const a2 = $t$4(n5);
    return a2 === 1 ? this.unsafeLadder(n5, r3, s2) : this.wNAFUnsafe(a2, this.getPrecomputes(a2, n5, o3), r3, s2);
  }, setWindowSize(n5, r3) {
    ve$4(r3, e3), Ie$5.set(n5, r3), qt$7.delete(n5);
  } };
}
function br$7(t2, e3, n5, r3) {
  if (dr$7(n5, t2), hr$7(r3, e3), n5.length !== r3.length) throw new Error("arrays of points and scalars must have equal length");
  const o3 = t2.ZERO, s2 = tr$7(BigInt(n5.length)), a2 = s2 > 12 ? s2 - 3 : s2 > 4 ? s2 - 2 : s2 ? 2 : 1, u2 = (1 << a2) - 1, i4 = new Array(u2 + 1).fill(o3), D2 = Math.floor((e3.BITS - 1) / a2) * a2;
  let c2 = o3;
  for (let l2 = D2; l2 >= 0; l2 -= a2) {
    i4.fill(o3);
    for (let w2 = 0; w2 < r3.length; w2++) {
      const h5 = r3[w2], g2 = Number(h5 >> BigInt(l2) & BigInt(u2));
      i4[g2] = i4[g2].add(n5[w2]);
    }
    let p2 = o3;
    for (let w2 = i4.length - 1, h5 = o3; w2 > 0; w2--) h5 = h5.add(i4[w2]), p2 = p2.add(h5);
    if (c2 = c2.add(p2), l2 !== 0) for (let w2 = 0; w2 < a2; w2++) c2 = c2.double();
  }
  return c2;
}
function pr$7(t2) {
  return ar$7(t2.Fp), Ot$6(t2, { n: "bigint", h: "bigint", Gx: "field", Gy: "field" }, { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }), Object.freeze({ ...me$2(t2.n, t2.nBitLength), ...t2, p: t2.Fp.ORDER });
}
const G$5 = BigInt(0), j$4 = BigInt(1), yt$4 = BigInt(2), wr$7 = BigInt(8), Er$7 = { zip215: true };
function gr$7(t2) {
  const e3 = pr$7(t2);
  return Ot$6(t2, { hash: "function", a: "bigint", d: "bigint", randomBytes: "function" }, { adjustScalarBytes: "function", domain: "function", uvRatio: "function", mapToCurve: "function" }), Object.freeze({ ...e3 });
}
function yr$7(t2) {
  const e3 = gr$7(t2), { Fp: n5, n: r3, prehash: o3, hash: s2, randomBytes: a2, nByteLength: u2, h: i4 } = e3, D2 = yt$4 << BigInt(u2 * 8) - j$4, c2 = n5.create, l2 = _e$9(e3.n, e3.nBitLength), p2 = e3.uvRatio || ((y4, f6) => {
    try {
      return { isValid: true, value: n5.sqrt(y4 * n5.inv(f6)) };
    } catch {
      return { isValid: false, value: G$5 };
    }
  }), w2 = e3.adjustScalarBytes || ((y4) => y4), h5 = e3.domain || ((y4, f6, b2) => {
    if (Tt$7("phflag", b2), f6.length || b2) throw new Error("Contexts/pre-hash are not supported");
    return y4;
  });
  function g2(y4, f6) {
    ft$6("coordinate " + y4, f6, G$5, D2);
  }
  function S4(y4) {
    if (!(y4 instanceof d4)) throw new Error("ExtendedPoint expected");
  }
  const v2 = xe$7((y4, f6) => {
    const { ex: b2, ey: E2, ez: B3 } = y4, C2 = y4.is0();
    f6 == null && (f6 = C2 ? wr$7 : n5.inv(B3));
    const A2 = c2(b2 * f6), U = c2(E2 * f6), _3 = c2(B3 * f6);
    if (C2) return { x: G$5, y: j$4 };
    if (_3 !== j$4) throw new Error("invZ was invalid");
    return { x: A2, y: U };
  }), L4 = xe$7((y4) => {
    const { a: f6, d: b2 } = e3;
    if (y4.is0()) throw new Error("bad point: ZERO");
    const { ex: E2, ey: B3, ez: C2, et: A2 } = y4, U = c2(E2 * E2), _3 = c2(B3 * B3), T2 = c2(C2 * C2), $2 = c2(T2 * T2), R5 = c2(U * f6), V3 = c2(T2 * c2(R5 + _3)), Y2 = c2($2 + c2(b2 * c2(U * _3)));
    if (V3 !== Y2) throw new Error("bad point: equation left != right (1)");
    const Z3 = c2(E2 * B3), X2 = c2(C2 * A2);
    if (Z3 !== X2) throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class d4 {
    constructor(f6, b2, E2, B3) {
      this.ex = f6, this.ey = b2, this.ez = E2, this.et = B3, g2("x", f6), g2("y", b2), g2("z", E2), g2("t", B3), Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(f6) {
      if (f6 instanceof d4) throw new Error("extended point not allowed");
      const { x: b2, y: E2 } = f6 || {};
      return g2("x", b2), g2("y", E2), new d4(b2, E2, j$4, c2(b2 * E2));
    }
    static normalizeZ(f6) {
      const b2 = n5.invertBatch(f6.map((E2) => E2.ez));
      return f6.map((E2, B3) => E2.toAffine(b2[B3])).map(d4.fromAffine);
    }
    static msm(f6, b2) {
      return br$7(d4, l2, f6, b2);
    }
    _setWindowSize(f6) {
      q2.setWindowSize(this, f6);
    }
    assertValidity() {
      L4(this);
    }
    equals(f6) {
      S4(f6);
      const { ex: b2, ey: E2, ez: B3 } = this, { ex: C2, ey: A2, ez: U } = f6, _3 = c2(b2 * U), T2 = c2(C2 * B3), $2 = c2(E2 * U), R5 = c2(A2 * B3);
      return _3 === T2 && $2 === R5;
    }
    is0() {
      return this.equals(d4.ZERO);
    }
    negate() {
      return new d4(c2(-this.ex), this.ey, this.ez, c2(-this.et));
    }
    double() {
      const { a: f6 } = e3, { ex: b2, ey: E2, ez: B3 } = this, C2 = c2(b2 * b2), A2 = c2(E2 * E2), U = c2(yt$4 * c2(B3 * B3)), _3 = c2(f6 * C2), T2 = b2 + E2, $2 = c2(c2(T2 * T2) - C2 - A2), R5 = _3 + A2, V3 = R5 - U, Y2 = _3 - A2, Z3 = c2($2 * V3), X2 = c2(R5 * Y2), et2 = c2($2 * Y2), pt2 = c2(V3 * R5);
      return new d4(Z3, X2, pt2, et2);
    }
    add(f6) {
      S4(f6);
      const { a: b2, d: E2 } = e3, { ex: B3, ey: C2, ez: A2, et: U } = this, { ex: _3, ey: T2, ez: $2, et: R5 } = f6;
      if (b2 === BigInt(-1)) {
        const re2 = c2((C2 - B3) * (T2 + _3)), oe2 = c2((C2 + B3) * (T2 - _3)), mt2 = c2(oe2 - re2);
        if (mt2 === G$5) return this.double();
        const se2 = c2(A2 * yt$4 * R5), ie2 = c2(U * yt$4 * $2), ue2 = ie2 + se2, ce2 = oe2 + re2, ae2 = ie2 - se2, Dn2 = c2(ue2 * mt2), dn2 = c2(ce2 * ae2), hn2 = c2(ue2 * ae2), ln2 = c2(mt2 * ce2);
        return new d4(Dn2, dn2, ln2, hn2);
      }
      const V3 = c2(B3 * _3), Y2 = c2(C2 * T2), Z3 = c2(U * E2 * R5), X2 = c2(A2 * $2), et2 = c2((B3 + C2) * (_3 + T2) - V3 - Y2), pt2 = X2 - Z3, ee2 = X2 + Z3, ne2 = c2(Y2 - b2 * V3), un2 = c2(et2 * pt2), cn4 = c2(ee2 * ne2), an4 = c2(et2 * ne2), fn2 = c2(pt2 * ee2);
      return new d4(un2, cn4, fn2, an4);
    }
    subtract(f6) {
      return this.add(f6.negate());
    }
    wNAF(f6) {
      return q2.wNAFCached(this, f6, d4.normalizeZ);
    }
    multiply(f6) {
      const b2 = f6;
      ft$6("scalar", b2, j$4, r3);
      const { p: E2, f: B3 } = this.wNAF(b2);
      return d4.normalizeZ([E2, B3])[0];
    }
    multiplyUnsafe(f6, b2 = d4.ZERO) {
      const E2 = f6;
      return ft$6("scalar", E2, G$5, r3), E2 === G$5 ? F2 : this.is0() || E2 === j$4 ? this : q2.wNAFCachedUnsafe(this, E2, d4.normalizeZ, b2);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(i4).is0();
    }
    isTorsionFree() {
      return q2.unsafeLadder(this, r3).is0();
    }
    toAffine(f6) {
      return v2(this, f6);
    }
    clearCofactor() {
      const { h: f6 } = e3;
      return f6 === j$4 ? this : this.multiplyUnsafe(f6);
    }
    static fromHex(f6, b2 = false) {
      const { d: E2, a: B3 } = e3, C2 = n5.BYTES;
      f6 = W$3("pointHex", f6, C2), Tt$7("zip215", b2);
      const A2 = f6.slice(), U = f6[C2 - 1];
      A2[C2 - 1] = U & -129;
      const _3 = Et$9(A2), T2 = b2 ? D2 : n5.ORDER;
      ft$6("pointHex.y", _3, G$5, T2);
      const $2 = c2(_3 * _3), R5 = c2($2 - j$4), V3 = c2(E2 * $2 - B3);
      let { isValid: Y2, value: Z3 } = p2(R5, V3);
      if (!Y2) throw new Error("Point.fromHex: invalid y coordinate");
      const X2 = (Z3 & j$4) === j$4, et2 = (U & 128) !== 0;
      if (!b2 && Z3 === G$5 && et2) throw new Error("Point.fromHex: x=0 and x_0=1");
      return et2 !== X2 && (Z3 = c2(-Z3)), d4.fromAffine({ x: Z3, y: _3 });
    }
    static fromPrivateKey(f6) {
      return O4(f6).point;
    }
    toRawBytes() {
      const { x: f6, y: b2 } = this.toAffine(), E2 = Nt$7(b2, n5.BYTES);
      return E2[E2.length - 1] |= f6 & j$4 ? 128 : 0, E2;
    }
    toHex() {
      return Ft$7(this.toRawBytes());
    }
  }
  d4.BASE = new d4(e3.Gx, e3.Gy, j$4, c2(e3.Gx * e3.Gy)), d4.ZERO = new d4(G$5, j$4, j$4, G$5);
  const { BASE: m4, ZERO: F2 } = d4, q2 = lr$7(d4, u2 * 8);
  function z3(y4) {
    return H$7(y4, r3);
  }
  function I4(y4) {
    return z3(Et$9(y4));
  }
  function O4(y4) {
    const f6 = n5.BYTES;
    y4 = W$3("private key", y4, f6);
    const b2 = W$3("hashed private key", s2(y4), 2 * f6), E2 = w2(b2.slice(0, f6)), B3 = b2.slice(f6, 2 * f6), C2 = I4(E2), A2 = m4.multiply(C2), U = A2.toRawBytes();
    return { head: E2, prefix: B3, scalar: C2, point: A2, pointBytes: U };
  }
  function ot2(y4) {
    return O4(y4).pointBytes;
  }
  function tt2(y4 = new Uint8Array(), ...f6) {
    const b2 = ye$2(...f6);
    return I4(s2(h5(b2, W$3("context", y4), !!o3)));
  }
  function st2(y4, f6, b2 = {}) {
    y4 = W$3("message", y4), o3 && (y4 = o3(y4));
    const { prefix: E2, scalar: B3, pointBytes: C2 } = O4(f6), A2 = tt2(b2.context, E2, y4), U = m4.multiply(A2).toRawBytes(), _3 = tt2(b2.context, U, C2, y4), T2 = z3(A2 + _3 * B3);
    ft$6("signature.s", T2, G$5, r3);
    const $2 = ye$2(U, Nt$7(T2, n5.BYTES));
    return W$3("result", $2, n5.BYTES * 2);
  }
  const at2 = Er$7;
  function Ct2(y4, f6, b2, E2 = at2) {
    const { context: B3, zip215: C2 } = E2, A2 = n5.BYTES;
    y4 = W$3("signature", y4, 2 * A2), f6 = W$3("message", f6), b2 = W$3("publicKey", b2, A2), C2 !== void 0 && Tt$7("zip215", C2), o3 && (f6 = o3(f6));
    const U = Et$9(y4.slice(A2, 2 * A2));
    let _3, T2, $2;
    try {
      _3 = d4.fromHex(b2, C2), T2 = d4.fromHex(y4.slice(0, A2), C2), $2 = m4.multiplyUnsafe(U);
    } catch {
      return false;
    }
    if (!C2 && _3.isSmallOrder()) return false;
    const R5 = tt2(B3, T2.toRawBytes(), _3.toRawBytes(), f6);
    return T2.add(_3.multiplyUnsafe(R5)).subtract($2).clearCofactor().equals(d4.ZERO);
  }
  return m4._setWindowSize(8), { CURVE: e3, getPublicKey: ot2, sign: st2, verify: Ct2, ExtendedPoint: d4, utils: { getExtendedPublicKey: O4, randomPrivateKey: () => a2(n5.BYTES), precompute(y4 = 8, f6 = d4.BASE) {
    return f6._setWindowSize(y4), f6.multiply(BigInt(3)), f6;
  } } };
}
BigInt(0), BigInt(1);
const kt$5 = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"), Ue$9 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt(0);
const xr$7 = BigInt(1), Te$5 = BigInt(2);
BigInt(3);
const Br$5 = BigInt(5), Cr$5 = BigInt(8);
function Ar$7(t2) {
  const e3 = BigInt(10), n5 = BigInt(20), r3 = BigInt(40), o3 = BigInt(80), s2 = kt$5, u2 = t2 * t2 % s2 * t2 % s2, i4 = J$7(u2, Te$5, s2) * u2 % s2, D2 = J$7(i4, xr$7, s2) * t2 % s2, c2 = J$7(D2, Br$5, s2) * D2 % s2, l2 = J$7(c2, e3, s2) * c2 % s2, p2 = J$7(l2, n5, s2) * l2 % s2, w2 = J$7(p2, r3, s2) * p2 % s2, h5 = J$7(w2, o3, s2) * w2 % s2, g2 = J$7(h5, o3, s2) * w2 % s2, S4 = J$7(g2, e3, s2) * c2 % s2;
  return { pow_p_5_8: J$7(S4, Te$5, s2) * t2 % s2, b2: u2 };
}
function mr$8(t2) {
  return t2[0] &= 248, t2[31] &= 127, t2[31] |= 64, t2;
}
function _r$7(t2, e3) {
  const n5 = kt$5, r3 = H$7(e3 * e3 * e3, n5), o3 = H$7(r3 * r3 * e3, n5), s2 = Ar$7(t2 * o3).pow_p_5_8;
  let a2 = H$7(t2 * r3 * s2, n5);
  const u2 = H$7(e3 * a2 * a2, n5), i4 = a2, D2 = H$7(a2 * Ue$9, n5), c2 = u2 === t2, l2 = u2 === H$7(-t2, n5), p2 = u2 === H$7(-t2 * Ue$9, n5);
  return c2 && (a2 = i4), (l2 || p2) && (a2 = D2), ur$7(a2, n5) && (a2 = H$7(-a2, n5)), { isValid: c2 || l2, value: a2 };
}
const Sr$7 = (() => _e$9(kt$5, void 0, true))(), vr$7 = (() => ({ a: BigInt(-1), d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"), Fp: Sr$7, n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"), h: Cr$5, Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"), Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"), hash: Kn$7, randomBytes: he$2, adjustScalarBytes: mr$8, uvRatio: _r$7 }))(), Rt$7 = (() => yr$7(vr$7))(), jt$5 = "EdDSA", Zt$7 = "JWT", ut$7 = ".", Dt$7 = "base64url", Gt$7 = "utf8", xt$7 = "utf8", Vt$7 = ":", Yt$7 = "did", Jt$7 = "key", dt$6 = "base58btc", Kt$7 = "z", Wt$7 = "K36", Ne$7 = 32;
function Xt$7(t2) {
  return globalThis.Buffer != null ? new Uint8Array(t2.buffer, t2.byteOffset, t2.byteLength) : t2;
}
function Le$9(t2 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Xt$7(globalThis.Buffer.allocUnsafe(t2)) : new Uint8Array(t2);
}
function Oe$7(t2, e3) {
  e3 || (e3 = t2.reduce((o3, s2) => o3 + s2.length, 0));
  const n5 = Le$9(e3);
  let r3 = 0;
  for (const o3 of t2) n5.set(o3, r3), r3 += o3.length;
  return Xt$7(n5);
}
function Ir$7(t2, e3) {
  if (t2.length >= 255) throw new TypeError("Alphabet too long");
  for (var n5 = new Uint8Array(256), r3 = 0; r3 < n5.length; r3++) n5[r3] = 255;
  for (var o3 = 0; o3 < t2.length; o3++) {
    var s2 = t2.charAt(o3), a2 = s2.charCodeAt(0);
    if (n5[a2] !== 255) throw new TypeError(s2 + " is ambiguous");
    n5[a2] = o3;
  }
  var u2 = t2.length, i4 = t2.charAt(0), D2 = Math.log(u2) / Math.log(256), c2 = Math.log(256) / Math.log(u2);
  function l2(h5) {
    if (h5 instanceof Uint8Array || (ArrayBuffer.isView(h5) ? h5 = new Uint8Array(h5.buffer, h5.byteOffset, h5.byteLength) : Array.isArray(h5) && (h5 = Uint8Array.from(h5))), !(h5 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (h5.length === 0) return "";
    for (var g2 = 0, S4 = 0, v2 = 0, L4 = h5.length; v2 !== L4 && h5[v2] === 0; ) v2++, g2++;
    for (var d4 = (L4 - v2) * c2 + 1 >>> 0, m4 = new Uint8Array(d4); v2 !== L4; ) {
      for (var F2 = h5[v2], q2 = 0, z3 = d4 - 1; (F2 !== 0 || q2 < S4) && z3 !== -1; z3--, q2++) F2 += 256 * m4[z3] >>> 0, m4[z3] = F2 % u2 >>> 0, F2 = F2 / u2 >>> 0;
      if (F2 !== 0) throw new Error("Non-zero carry");
      S4 = q2, v2++;
    }
    for (var I4 = d4 - S4; I4 !== d4 && m4[I4] === 0; ) I4++;
    for (var O4 = i4.repeat(g2); I4 < d4; ++I4) O4 += t2.charAt(m4[I4]);
    return O4;
  }
  function p2(h5) {
    if (typeof h5 != "string") throw new TypeError("Expected String");
    if (h5.length === 0) return new Uint8Array();
    var g2 = 0;
    if (h5[g2] !== " ") {
      for (var S4 = 0, v2 = 0; h5[g2] === i4; ) S4++, g2++;
      for (var L4 = (h5.length - g2) * D2 + 1 >>> 0, d4 = new Uint8Array(L4); h5[g2]; ) {
        var m4 = n5[h5.charCodeAt(g2)];
        if (m4 === 255) return;
        for (var F2 = 0, q2 = L4 - 1; (m4 !== 0 || F2 < v2) && q2 !== -1; q2--, F2++) m4 += u2 * d4[q2] >>> 0, d4[q2] = m4 % 256 >>> 0, m4 = m4 / 256 >>> 0;
        if (m4 !== 0) throw new Error("Non-zero carry");
        v2 = F2, g2++;
      }
      if (h5[g2] !== " ") {
        for (var z3 = L4 - v2; z3 !== L4 && d4[z3] === 0; ) z3++;
        for (var I4 = new Uint8Array(S4 + (L4 - z3)), O4 = S4; z3 !== L4; ) I4[O4++] = d4[z3++];
        return I4;
      }
    }
  }
  function w2(h5) {
    var g2 = p2(h5);
    if (g2) return g2;
    throw new Error(`Non-${e3} character`);
  }
  return { encode: l2, decodeUnsafe: p2, decode: w2 };
}
var Ur$7 = Ir$7, Tr$7 = Ur$7;
const He$7 = (t2) => {
  if (t2 instanceof Uint8Array && t2.constructor.name === "Uint8Array") return t2;
  if (t2 instanceof ArrayBuffer) return new Uint8Array(t2);
  if (ArrayBuffer.isView(t2)) return new Uint8Array(t2.buffer, t2.byteOffset, t2.byteLength);
  throw new Error("Unknown type, must be binary type");
}, Fr$7 = (t2) => new TextEncoder().encode(t2), Nr$7 = (t2) => new TextDecoder().decode(t2);
let Lr$5 = class Lr2 {
  constructor(e3, n5, r3) {
    this.name = e3, this.prefix = n5, this.baseEncode = r3;
  }
  encode(e3) {
    if (e3 instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e3)}`;
    throw Error("Unknown type, must be binary type");
  }
};
let Or$7 = class Or2 {
  constructor(e3, n5, r3) {
    if (this.name = e3, this.prefix = n5, n5.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = n5.codePointAt(0), this.baseDecode = r3;
  }
  decode(e3) {
    if (typeof e3 == "string") {
      if (e3.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e3)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e3.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e3) {
    return ze$5(this, e3);
  }
};
let Hr$7 = class Hr2 {
  constructor(e3) {
    this.decoders = e3;
  }
  or(e3) {
    return ze$5(this, e3);
  }
  decode(e3) {
    const n5 = e3[0], r3 = this.decoders[n5];
    if (r3) return r3.decode(e3);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e3)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
const ze$5 = (t2, e3) => new Hr$7({ ...t2.decoders || { [t2.prefix]: t2 }, ...e3.decoders || { [e3.prefix]: e3 } });
let zr$7 = class zr2 {
  constructor(e3, n5, r3, o3) {
    this.name = e3, this.prefix = n5, this.baseEncode = r3, this.baseDecode = o3, this.encoder = new Lr$5(e3, n5, r3), this.decoder = new Or$7(e3, n5, o3);
  }
  encode(e3) {
    return this.encoder.encode(e3);
  }
  decode(e3) {
    return this.decoder.decode(e3);
  }
};
const Bt$7 = ({ name: t2, prefix: e3, encode: n5, decode: r3 }) => new zr$7(t2, e3, n5, r3), ht$6 = ({ prefix: t2, name: e3, alphabet: n5 }) => {
  const { encode: r3, decode: o3 } = Tr$7(n5, e3);
  return Bt$7({ prefix: t2, name: e3, encode: r3, decode: (s2) => He$7(o3(s2)) });
}, Mr$7 = (t2, e3, n5, r3) => {
  const o3 = {};
  for (let c2 = 0; c2 < e3.length; ++c2) o3[e3[c2]] = c2;
  let s2 = t2.length;
  for (; t2[s2 - 1] === "="; ) --s2;
  const a2 = new Uint8Array(s2 * n5 / 8 | 0);
  let u2 = 0, i4 = 0, D2 = 0;
  for (let c2 = 0; c2 < s2; ++c2) {
    const l2 = o3[t2[c2]];
    if (l2 === void 0) throw new SyntaxError(`Non-${r3} character`);
    i4 = i4 << n5 | l2, u2 += n5, u2 >= 8 && (u2 -= 8, a2[D2++] = 255 & i4 >> u2);
  }
  if (u2 >= n5 || 255 & i4 << 8 - u2) throw new SyntaxError("Unexpected end of data");
  return a2;
}, qr$7 = (t2, e3, n5) => {
  const r3 = e3[e3.length - 1] === "=", o3 = (1 << n5) - 1;
  let s2 = "", a2 = 0, u2 = 0;
  for (let i4 = 0; i4 < t2.length; ++i4) for (u2 = u2 << 8 | t2[i4], a2 += 8; a2 > n5; ) a2 -= n5, s2 += e3[o3 & u2 >> a2];
  if (a2 && (s2 += e3[o3 & u2 << n5 - a2]), r3) for (; s2.length * n5 & 7; ) s2 += "=";
  return s2;
}, k$4 = ({ name: t2, prefix: e3, bitsPerChar: n5, alphabet: r3 }) => Bt$7({ prefix: e3, name: t2, encode(o3) {
  return qr$7(o3, r3, n5);
}, decode(o3) {
  return Mr$7(o3, r3, n5, t2);
} }), $r$7 = Bt$7({ prefix: "\0", name: "identity", encode: (t2) => Nr$7(t2), decode: (t2) => Fr$7(t2) });
var kr$5 = Object.freeze({ __proto__: null, identity: $r$7 });
const Rr$7 = k$4({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var jr$3 = Object.freeze({ __proto__: null, base2: Rr$7 });
const Zr$7 = k$4({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Gr$7 = Object.freeze({ __proto__: null, base8: Zr$7 });
const Vr$7 = ht$6({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Yr$7 = Object.freeze({ __proto__: null, base10: Vr$7 });
const Jr$7 = k$4({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), Kr$7 = k$4({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Wr$7 = Object.freeze({ __proto__: null, base16: Jr$7, base16upper: Kr$7 });
const Xr$7 = k$4({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), Pr$5 = k$4({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), Qr$7 = k$4({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), to$7 = k$4({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), eo$7 = k$4({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), no$7 = k$4({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), ro$7 = k$4({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), oo$7 = k$4({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), so$7 = k$4({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var io$7 = Object.freeze({ __proto__: null, base32: Xr$7, base32upper: Pr$5, base32pad: Qr$7, base32padupper: to$7, base32hex: eo$7, base32hexupper: no$7, base32hexpad: ro$7, base32hexpadupper: oo$7, base32z: so$7 });
const uo$5 = ht$6({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), co$5 = ht$6({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var ao$7 = Object.freeze({ __proto__: null, base36: uo$5, base36upper: co$5 });
const fo$5 = ht$6({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), Do$5 = ht$6({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var ho$5 = Object.freeze({ __proto__: null, base58btc: fo$5, base58flickr: Do$5 });
const lo$5 = k$4({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), bo$5 = k$4({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), po$5 = k$4({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), wo$5 = k$4({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Eo$5 = Object.freeze({ __proto__: null, base64: lo$5, base64pad: bo$5, base64url: po$5, base64urlpad: wo$5 });
const Me$9 = Array.from(""), go$5 = Me$9.reduce((t2, e3, n5) => (t2[n5] = e3, t2), []), yo$5 = Me$9.reduce((t2, e3, n5) => (t2[e3.codePointAt(0)] = n5, t2), []);
function xo$5(t2) {
  return t2.reduce((e3, n5) => (e3 += go$5[n5], e3), "");
}
function Bo$5(t2) {
  const e3 = [];
  for (const n5 of t2) {
    const r3 = yo$5[n5.codePointAt(0)];
    if (r3 === void 0) throw new Error(`Non-base256emoji character: ${n5}`);
    e3.push(r3);
  }
  return new Uint8Array(e3);
}
const Co$5 = Bt$7({ prefix: "", name: "base256emoji", encode: xo$5, decode: Bo$5 });
var Ao$5 = Object.freeze({ __proto__: null, base256emoji: Co$5 }), mo$5 = $e$8, qe$7 = 128, So$5 = -128, vo$5 = Math.pow(2, 31);
function $e$8(t2, e3, n5) {
  e3 = e3 || [], n5 = n5 || 0;
  for (var r3 = n5; t2 >= vo$5; ) e3[n5++] = t2 & 255 | qe$7, t2 /= 128;
  for (; t2 & So$5; ) e3[n5++] = t2 & 255 | qe$7, t2 >>>= 7;
  return e3[n5] = t2 | 0, $e$8.bytes = n5 - r3 + 1, e3;
}
var Io$5 = Pt$4, Uo$5 = 128, ke$9 = 127;
function Pt$4(t2, r3) {
  var n5 = 0, r3 = r3 || 0, o3 = 0, s2 = r3, a2, u2 = t2.length;
  do {
    if (s2 >= u2) throw Pt$4.bytes = 0, new RangeError("Could not decode varint");
    a2 = t2[s2++], n5 += o3 < 28 ? (a2 & ke$9) << o3 : (a2 & ke$9) * Math.pow(2, o3), o3 += 7;
  } while (a2 >= Uo$5);
  return Pt$4.bytes = s2 - r3, n5;
}
var To$5 = Math.pow(2, 7), Fo$5 = Math.pow(2, 14), No$5 = Math.pow(2, 21), Lo$5 = Math.pow(2, 28), Oo$5 = Math.pow(2, 35), Ho$5 = Math.pow(2, 42), zo$5 = Math.pow(2, 49), Mo$5 = Math.pow(2, 56), qo$5 = Math.pow(2, 63), $o$5 = function(t2) {
  return t2 < To$5 ? 1 : t2 < Fo$5 ? 2 : t2 < No$5 ? 3 : t2 < Lo$5 ? 4 : t2 < Oo$5 ? 5 : t2 < Ho$5 ? 6 : t2 < zo$5 ? 7 : t2 < Mo$5 ? 8 : t2 < qo$5 ? 9 : 10;
}, ko$5 = { encode: mo$5, decode: Io$5, encodingLength: $o$5 }, Re$5 = ko$5;
const je$7 = (t2, e3, n5 = 0) => (Re$5.encode(t2, e3, n5), e3), Ze$5 = (t2) => Re$5.encodingLength(t2), Qt$7 = (t2, e3) => {
  const n5 = e3.byteLength, r3 = Ze$5(t2), o3 = r3 + Ze$5(n5), s2 = new Uint8Array(o3 + n5);
  return je$7(t2, s2, 0), je$7(n5, s2, r3), s2.set(e3, o3), new Ro$5(t2, n5, e3, s2);
};
let Ro$5 = class Ro2 {
  constructor(e3, n5, r3, o3) {
    this.code = e3, this.size = n5, this.digest = r3, this.bytes = o3;
  }
};
const Ge$7 = ({ name: t2, code: e3, encode: n5 }) => new jo$5(t2, e3, n5);
let jo$5 = class jo2 {
  constructor(e3, n5, r3) {
    this.name = e3, this.code = n5, this.encode = r3;
  }
  digest(e3) {
    if (e3 instanceof Uint8Array) {
      const n5 = this.encode(e3);
      return n5 instanceof Uint8Array ? Qt$7(this.code, n5) : n5.then((r3) => Qt$7(this.code, r3));
    } else throw Error("Unknown type, must be binary type");
  }
};
const Ve$7 = (t2) => async (e3) => new Uint8Array(await crypto.subtle.digest(t2, e3)), Zo$5 = Ge$7({ name: "sha2-256", code: 18, encode: Ve$7("SHA-256") }), Go$5 = Ge$7({ name: "sha2-512", code: 19, encode: Ve$7("SHA-512") });
var Vo$5 = Object.freeze({ __proto__: null, sha256: Zo$5, sha512: Go$5 });
const Ye$5 = 0, Yo$5 = "identity", Je$3 = He$7, Jo$5 = (t2) => Qt$7(Ye$5, Je$3(t2)), Ko$5 = { code: Ye$5, name: Yo$5, encode: Je$3, digest: Jo$5 };
var Wo$5 = Object.freeze({ __proto__: null, identity: Ko$5 });
new TextEncoder(), new TextDecoder();
const Ke$9 = { ...kr$5, ...jr$3, ...Gr$7, ...Yr$7, ...Wr$7, ...io$7, ...ao$7, ...ho$5, ...Eo$5, ...Ao$5 };
({ ...Vo$5, ...Wo$5 });
function We$3(t2, e3, n5, r3) {
  return { name: t2, prefix: e3, encoder: { name: t2, prefix: e3, encode: n5 }, decoder: { decode: r3 } };
}
const Xe$5 = We$3("utf8", "u", (t2) => "u" + new TextDecoder("utf8").decode(t2), (t2) => new TextEncoder().encode(t2.substring(1))), te$5 = We$3("ascii", "a", (t2) => {
  let e3 = "a";
  for (let n5 = 0; n5 < t2.length; n5++) e3 += String.fromCharCode(t2[n5]);
  return e3;
}, (t2) => {
  t2 = t2.substring(1);
  const e3 = Le$9(t2.length);
  for (let n5 = 0; n5 < t2.length; n5++) e3[n5] = t2.charCodeAt(n5);
  return e3;
}), Pe$2 = { utf8: Xe$5, "utf-8": Xe$5, hex: Ke$9.base16, latin1: te$5, ascii: te$5, binary: te$5, ...Ke$9 };
function ct$4(t2, e3 = "utf8") {
  const n5 = Pe$2[e3];
  if (!n5) throw new Error(`Unsupported encoding "${e3}"`);
  return (e3 === "utf8" || e3 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t2.buffer, t2.byteOffset, t2.byteLength).toString("utf8") : n5.encoder.encode(t2).substring(1);
}
function rt$5(t2, e3 = "utf8") {
  const n5 = Pe$2[e3];
  if (!n5) throw new Error(`Unsupported encoding "${e3}"`);
  return (e3 === "utf8" || e3 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Xt$7(globalThis.Buffer.from(t2, "utf-8")) : n5.decoder.decode(`${n5.prefix}${t2}`);
}
function lt$4(t2) {
  return safeJsonParse(ct$4(rt$5(t2, Dt$7), Gt$7));
}
function bt$2(t2) {
  return ct$4(rt$5(safeJsonStringify(t2), Gt$7), Dt$7);
}
function Qe$5(t2) {
  const e3 = rt$5(Wt$7, dt$6), n5 = Kt$7 + ct$4(Oe$7([e3, t2]), dt$6);
  return [Yt$7, Jt$7, n5].join(Vt$7);
}
function en$7(t2) {
  return ct$4(t2, Dt$7);
}
function nn$7(t2) {
  return rt$5(t2, Dt$7);
}
function rn$7(t2) {
  return rt$5([bt$2(t2.header), bt$2(t2.payload)].join(ut$7), xt$7);
}
function on$7(t2) {
  return [bt$2(t2.header), bt$2(t2.payload), en$7(t2.signature)].join(ut$7);
}
function sn$7(t2) {
  const e3 = t2.split(ut$7), n5 = lt$4(e3[0]), r3 = lt$4(e3[1]), o3 = nn$7(e3[2]), s2 = rt$5(e3.slice(0, 2).join(ut$7), xt$7);
  return { header: n5, payload: r3, signature: o3, data: s2 };
}
function Po$5(t2 = he$2(Ne$7)) {
  const e3 = Rt$7.getPublicKey(t2);
  return { secretKey: Oe$7([t2, e3]), publicKey: e3 };
}
async function Qo$5(t2, e3, n5, r3, o3 = cjs$3.fromMiliseconds(Date.now())) {
  const s2 = { alg: jt$5, typ: Zt$7 }, a2 = Qe$5(r3.publicKey), u2 = o3 + n5, i4 = { iss: a2, sub: t2, aud: e3, iat: o3, exp: u2 }, D2 = rn$7({ header: s2, payload: i4 }), c2 = Rt$7.sign(D2, r3.secretKey.slice(0, 32));
  return on$7({ header: s2, payload: i4, signature: c2 });
}
var __spreadArray = function(to2, from2, pack2) {
  if (pack2 || arguments.length === 2) for (var i4 = 0, l2 = from2.length, ar2; i4 < l2; i4++) {
    if (ar2 || !(i4 in from2)) {
      if (!ar2) ar2 = Array.prototype.slice.call(from2, 0, i4);
      ar2[i4] = from2[i4];
    }
  }
  return to2.concat(ar2 || Array.prototype.slice.call(from2));
};
var BrowserInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function BrowserInfo2(name, version2, os2) {
      this.name = name;
      this.version = version2;
      this.os = os2;
      this.type = "browser";
    }
    return BrowserInfo2;
  }()
);
var NodeInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function NodeInfo2(version2) {
      this.version = version2;
      this.type = "node";
      this.name = "node";
      this.os = process$1.platform;
    }
    return NodeInfo2;
  }()
);
var SearchBotDeviceInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function SearchBotDeviceInfo2(name, version2, os2, bot) {
      this.name = name;
      this.version = version2;
      this.os = os2;
      this.bot = bot;
      this.type = "bot-device";
    }
    return SearchBotDeviceInfo2;
  }()
);
var BotInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function BotInfo2() {
      this.type = "bot";
      this.bot = true;
      this.name = "bot";
      this.version = null;
      this.os = null;
    }
    return BotInfo2;
  }()
);
var ReactNativeInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function ReactNativeInfo2() {
      this.type = "react-native";
      this.name = "react-native";
      this.version = null;
      this.os = null;
    }
    return ReactNativeInfo2;
  }()
);
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua2) {
  return ua2 !== "" && userAgentRules.reduce(function(matched, _a3) {
    var browser2 = _a3[0], regex2 = _a3[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex2.exec(ua2);
    return !!uaMatch && [browser2, uaMatch];
  }, false);
}
function parseUserAgent(ua2) {
  var matchedRule = matchUserAgent(ua2);
  if (!matchedRule) {
    return null;
  }
  var name = matchedRule[0], match = matchedRule[1];
  if (name === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version2 = versionParts.join(".");
  var os2 = detectOS(ua2);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua2);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name, version2, os2, searchBotMatch[1]);
  }
  return new BrowserInfo(name, version2, os2);
}
function detectOS(ua2) {
  for (var ii2 = 0, count = operatingSystemRules.length; ii2 < count; ii2++) {
    var _a3 = operatingSystemRules[ii2], os2 = _a3[0], regex2 = _a3[1];
    var match = regex2.exec(ua2);
    if (match) {
      return os2;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode = typeof process$1 !== "undefined" && process$1.version;
  return isNode ? new NodeInfo(process$1.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output2 = [];
  for (var ii2 = 0; ii2 < count; ii2++) {
    output2.push("0");
  }
  return output2;
}
var cjs$2 = {};
Object.defineProperty(cjs$2, "__esModule", { value: true });
cjs$2.getLocalStorage = cjs$2.getLocalStorageOrThrow = cjs$2.getCrypto = cjs$2.getCryptoOrThrow = getLocation_1 = cjs$2.getLocation = cjs$2.getLocationOrThrow = getNavigator_1 = cjs$2.getNavigator = cjs$2.getNavigatorOrThrow = getDocument_1 = cjs$2.getDocument = cjs$2.getDocumentOrThrow = cjs$2.getFromWindowOrThrow = cjs$2.getFromWindow = void 0;
function getFromWindow(name) {
  let res = void 0;
  if (typeof window !== "undefined" && typeof window[name] !== "undefined") {
    res = window[name];
  }
  return res;
}
cjs$2.getFromWindow = getFromWindow;
function getFromWindowOrThrow(name) {
  const res = getFromWindow(name);
  if (!res) {
    throw new Error(`${name} is not defined in Window`);
  }
  return res;
}
cjs$2.getFromWindowOrThrow = getFromWindowOrThrow;
function getDocumentOrThrow() {
  return getFromWindowOrThrow("document");
}
cjs$2.getDocumentOrThrow = getDocumentOrThrow;
function getDocument() {
  return getFromWindow("document");
}
var getDocument_1 = cjs$2.getDocument = getDocument;
function getNavigatorOrThrow() {
  return getFromWindowOrThrow("navigator");
}
cjs$2.getNavigatorOrThrow = getNavigatorOrThrow;
function getNavigator() {
  return getFromWindow("navigator");
}
var getNavigator_1 = cjs$2.getNavigator = getNavigator;
function getLocationOrThrow() {
  return getFromWindowOrThrow("location");
}
cjs$2.getLocationOrThrow = getLocationOrThrow;
function getLocation() {
  return getFromWindow("location");
}
var getLocation_1 = cjs$2.getLocation = getLocation;
function getCryptoOrThrow() {
  return getFromWindowOrThrow("crypto");
}
cjs$2.getCryptoOrThrow = getCryptoOrThrow;
function getCrypto() {
  return getFromWindow("crypto");
}
cjs$2.getCrypto = getCrypto;
function getLocalStorageOrThrow() {
  return getFromWindowOrThrow("localStorage");
}
cjs$2.getLocalStorageOrThrow = getLocalStorageOrThrow;
function getLocalStorage() {
  return getFromWindow("localStorage");
}
cjs$2.getLocalStorage = getLocalStorage;
var cjs$1 = {};
Object.defineProperty(cjs$1, "__esModule", { value: true });
var getWindowMetadata_1 = cjs$1.getWindowMetadata = void 0;
const window_getters_1 = cjs$2;
function getWindowMetadata() {
  let doc;
  let loc;
  try {
    doc = window_getters_1.getDocumentOrThrow();
    loc = window_getters_1.getLocationOrThrow();
  } catch (e3) {
    return null;
  }
  function getIcons() {
    const links = doc.getElementsByTagName("link");
    const icons2 = [];
    for (let i4 = 0; i4 < links.length; i4++) {
      const link = links[i4];
      const rel = link.getAttribute("rel");
      if (rel) {
        if (rel.toLowerCase().indexOf("icon") > -1) {
          const href = link.getAttribute("href");
          if (href) {
            if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
              let absoluteHref = loc.protocol + "//" + loc.host;
              if (href.indexOf("/") === 0) {
                absoluteHref += href;
              } else {
                const path = loc.pathname.split("/");
                path.pop();
                const finalPath = path.join("/");
                absoluteHref += finalPath + "/" + href;
              }
              icons2.push(absoluteHref);
            } else if (href.indexOf("//") === 0) {
              const absoluteUrl = loc.protocol + href;
              icons2.push(absoluteUrl);
            } else {
              icons2.push(href);
            }
          }
        }
      }
    }
    return icons2;
  }
  function getWindowMetadataOfAny(...args) {
    const metaTags = doc.getElementsByTagName("meta");
    for (let i4 = 0; i4 < metaTags.length; i4++) {
      const tag = metaTags[i4];
      const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
        if (attr) {
          return args.includes(attr);
        }
        return false;
      });
      if (attributes.length && attributes) {
        const content = tag.getAttribute("content");
        if (content) {
          return content;
        }
      }
    }
    return "";
  }
  function getName() {
    let name2 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
    if (!name2) {
      name2 = doc.title;
    }
    return name2;
  }
  function getDescription() {
    const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
    return description2;
  }
  const name = getName();
  const description = getDescription();
  const url = loc.origin;
  const icons = getIcons();
  const meta = {
    description,
    url,
    icons,
    name
  };
  return meta;
}
getWindowMetadata_1 = cjs$1.getWindowMetadata = getWindowMetadata;
function isHex$1(value, { strict = true } = {}) {
  if (!value)
    return false;
  if (typeof value !== "string")
    return false;
  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
}
function size$2(value) {
  if (isHex$1(value, { strict: false }))
    return Math.ceil((value.length - 2) / 2);
  return value.length;
}
const version$5 = "2.38.6";
let errorConfig$1 = {
  getDocsUrl: ({ docsBaseUrl, docsPath = "", docsSlug }) => docsPath ? `${docsBaseUrl ?? "https://viem.sh"}${docsPath}${docsSlug ? `#${docsSlug}` : ""}` : void 0,
  version: `viem@${version$5}`
};
let BaseError$1 = class BaseError2 extends Error {
  constructor(shortMessage, args = {}) {
    var _a3;
    const details = (() => {
      var _a4;
      if (args.cause instanceof BaseError2)
        return args.cause.details;
      if ((_a4 = args.cause) == null ? void 0 : _a4.message)
        return args.cause.message;
      return args.details;
    })();
    const docsPath = (() => {
      if (args.cause instanceof BaseError2)
        return args.cause.docsPath || args.docsPath;
      return args.docsPath;
    })();
    const docsUrl = (_a3 = errorConfig$1.getDocsUrl) == null ? void 0 : _a3.call(errorConfig$1, { ...args, docsPath });
    const message = [
      shortMessage || "An error occurred.",
      "",
      ...args.metaMessages ? [...args.metaMessages, ""] : [],
      ...docsUrl ? [`Docs: ${docsUrl}`] : [],
      ...details ? [`Details: ${details}`] : [],
      ...errorConfig$1.version ? [`Version: ${errorConfig$1.version}`] : []
    ].join("\n");
    super(message, args.cause ? { cause: args.cause } : void 0);
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "metaMessages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "version", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BaseError"
    });
    this.details = details;
    this.docsPath = docsPath;
    this.metaMessages = args.metaMessages;
    this.name = args.name ?? this.name;
    this.shortMessage = shortMessage;
    this.version = version$5;
  }
  walk(fn2) {
    return walk$1(this, fn2);
  }
};
function walk$1(err, fn2) {
  if (fn2 == null ? void 0 : fn2(err))
    return err;
  if (err && typeof err === "object" && "cause" in err && err.cause !== void 0)
    return walk$1(err.cause, fn2);
  return fn2 ? null : err;
}
let SizeExceedsPaddingSizeError$1 = class SizeExceedsPaddingSizeError2 extends BaseError$1 {
  constructor({ size: size2, targetSize, type: type2 }) {
    super(`${type2.charAt(0).toUpperCase()}${type2.slice(1).toLowerCase()} size (${size2}) exceeds padding size (${targetSize}).`, { name: "SizeExceedsPaddingSizeError" });
  }
};
function pad$1(hexOrBytes, { dir, size: size2 = 32 } = {}) {
  if (typeof hexOrBytes === "string")
    return padHex$1(hexOrBytes, { dir, size: size2 });
  return padBytes$1(hexOrBytes, { dir, size: size2 });
}
function padHex$1(hex_, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return hex_;
  const hex = hex_.replace("0x", "");
  if (hex.length > size2 * 2)
    throw new SizeExceedsPaddingSizeError$1({
      size: Math.ceil(hex.length / 2),
      targetSize: size2,
      type: "hex"
    });
  return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size2 * 2, "0")}`;
}
function padBytes$1(bytes2, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return bytes2;
  if (bytes2.length > size2)
    throw new SizeExceedsPaddingSizeError$1({
      size: bytes2.length,
      targetSize: size2,
      type: "bytes"
    });
  const paddedBytes = new Uint8Array(size2);
  for (let i4 = 0; i4 < size2; i4++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i4 : size2 - i4 - 1] = bytes2[padEnd ? i4 : bytes2.length - i4 - 1];
  }
  return paddedBytes;
}
let IntegerOutOfRangeError$1 = class IntegerOutOfRangeError2 extends BaseError$1 {
  constructor({ max: max2, min: min2, signed: signed2, size: size2, value }) {
    super(`Number "${value}" is not in safe ${size2 ? `${size2 * 8}-bit ${signed2 ? "signed" : "unsigned"} ` : ""}integer range ${max2 ? `(${min2} to ${max2})` : `(above ${min2})`}`, { name: "IntegerOutOfRangeError" });
  }
};
let SizeOverflowError$1 = class SizeOverflowError2 extends BaseError$1 {
  constructor({ givenSize, maxSize }) {
    super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`, { name: "SizeOverflowError" });
  }
};
function assertSize$1(hexOrBytes, { size: size2 }) {
  if (size$2(hexOrBytes) > size2)
    throw new SizeOverflowError$1({
      givenSize: size$2(hexOrBytes),
      maxSize: size2
    });
}
function hexToBigInt$1(hex, opts = {}) {
  const { signed: signed2 } = opts;
  if (opts.size)
    assertSize$1(hex, { size: opts.size });
  const value = BigInt(hex);
  if (!signed2)
    return value;
  const size2 = (hex.length - 2) / 2;
  const max2 = (1n << BigInt(size2) * 8n - 1n) - 1n;
  if (value <= max2)
    return value;
  return value - BigInt(`0x${"f".padStart(size2 * 2, "f")}`) - 1n;
}
function hexToNumber$2(hex, opts = {}) {
  return Number(hexToBigInt$1(hex, opts));
}
const hexes$3 = /* @__PURE__ */ Array.from({ length: 256 }, (_v2, i4) => i4.toString(16).padStart(2, "0"));
function toHex$2(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToHex$1(value, opts);
  if (typeof value === "string") {
    return stringToHex$1(value, opts);
  }
  if (typeof value === "boolean")
    return boolToHex$1(value, opts);
  return bytesToHex$3(value, opts);
}
function boolToHex$1(value, opts = {}) {
  const hex = `0x${Number(value)}`;
  if (typeof opts.size === "number") {
    assertSize$1(hex, { size: opts.size });
    return pad$1(hex, { size: opts.size });
  }
  return hex;
}
function bytesToHex$3(value, opts = {}) {
  let string2 = "";
  for (let i4 = 0; i4 < value.length; i4++) {
    string2 += hexes$3[value[i4]];
  }
  const hex = `0x${string2}`;
  if (typeof opts.size === "number") {
    assertSize$1(hex, { size: opts.size });
    return pad$1(hex, { dir: "right", size: opts.size });
  }
  return hex;
}
function numberToHex$1(value_, opts = {}) {
  const { signed: signed2, size: size2 } = opts;
  const value = BigInt(value_);
  let maxValue2;
  if (size2) {
    if (signed2)
      maxValue2 = (1n << BigInt(size2) * 8n - 1n) - 1n;
    else
      maxValue2 = 2n ** (BigInt(size2) * 8n) - 1n;
  } else if (typeof value_ === "number") {
    maxValue2 = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue2 === "bigint" && signed2 ? -maxValue2 - 1n : 0;
  if (maxValue2 && value > maxValue2 || value < minValue) {
    const suffix = typeof value_ === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError$1({
      max: maxValue2 ? `${maxValue2}${suffix}` : void 0,
      min: `${minValue}${suffix}`,
      signed: signed2,
      size: size2,
      value: `${value_}${suffix}`
    });
  }
  const hex = `0x${(signed2 && value < 0 ? (1n << BigInt(size2 * 8)) + BigInt(value) : value).toString(16)}`;
  if (size2)
    return pad$1(hex, { size: size2 });
  return hex;
}
const encoder$3 = /* @__PURE__ */ new TextEncoder();
function stringToHex$1(value_, opts = {}) {
  const value = encoder$3.encode(value_);
  return bytesToHex$3(value, opts);
}
const encoder$2 = /* @__PURE__ */ new TextEncoder();
function toBytes$3(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToBytes$1(value, opts);
  if (typeof value === "boolean")
    return boolToBytes$1(value, opts);
  if (isHex$1(value))
    return hexToBytes$2(value, opts);
  return stringToBytes$1(value, opts);
}
function boolToBytes$1(value, opts = {}) {
  const bytes2 = new Uint8Array(1);
  bytes2[0] = Number(value);
  if (typeof opts.size === "number") {
    assertSize$1(bytes2, { size: opts.size });
    return pad$1(bytes2, { size: opts.size });
  }
  return bytes2;
}
const charCodeMap$1 = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function charCodeToBase16$1(char) {
  if (char >= charCodeMap$1.zero && char <= charCodeMap$1.nine)
    return char - charCodeMap$1.zero;
  if (char >= charCodeMap$1.A && char <= charCodeMap$1.F)
    return char - (charCodeMap$1.A - 10);
  if (char >= charCodeMap$1.a && char <= charCodeMap$1.f)
    return char - (charCodeMap$1.a - 10);
  return void 0;
}
function hexToBytes$2(hex_, opts = {}) {
  let hex = hex_;
  if (opts.size) {
    assertSize$1(hex, { size: opts.size });
    hex = pad$1(hex, { dir: "right", size: opts.size });
  }
  let hexString = hex.slice(2);
  if (hexString.length % 2)
    hexString = `0${hexString}`;
  const length = hexString.length / 2;
  const bytes2 = new Uint8Array(length);
  for (let index2 = 0, j2 = 0; index2 < length; index2++) {
    const nibbleLeft = charCodeToBase16$1(hexString.charCodeAt(j2++));
    const nibbleRight = charCodeToBase16$1(hexString.charCodeAt(j2++));
    if (nibbleLeft === void 0 || nibbleRight === void 0) {
      throw new BaseError$1(`Invalid byte sequence ("${hexString[j2 - 2]}${hexString[j2 - 1]}" in "${hexString}").`);
    }
    bytes2[index2] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes2;
}
function numberToBytes$1(value, opts) {
  const hex = numberToHex$1(value, opts);
  return hexToBytes$2(hex);
}
function stringToBytes$1(value, opts = {}) {
  const bytes2 = encoder$2.encode(value);
  if (typeof opts.size === "number") {
    assertSize$1(bytes2, { size: opts.size });
    return pad$1(bytes2, { dir: "right", size: opts.size });
  }
  return bytes2;
}
const U32_MASK64$1 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n$1 = /* @__PURE__ */ BigInt(32);
function fromBig$1(n5, le2 = false) {
  if (le2)
    return { h: Number(n5 & U32_MASK64$1), l: Number(n5 >> _32n$1 & U32_MASK64$1) };
  return { h: Number(n5 >> _32n$1 & U32_MASK64$1) | 0, l: Number(n5 & U32_MASK64$1) | 0 };
}
function split$2(lst, le2 = false) {
  const len2 = lst.length;
  let Ah = new Uint32Array(len2);
  let Al = new Uint32Array(len2);
  for (let i4 = 0; i4 < len2; i4++) {
    const { h: h5, l: l2 } = fromBig$1(lst[i4], le2);
    [Ah[i4], Al[i4]] = [h5, l2];
  }
  return [Ah, Al];
}
const rotlSH$1 = (h5, l2, s2) => h5 << s2 | l2 >>> 32 - s2;
const rotlSL$1 = (h5, l2, s2) => l2 << s2 | h5 >>> 32 - s2;
const rotlBH$1 = (h5, l2, s2) => l2 << s2 - 32 | h5 >>> 64 - s2;
const rotlBL$1 = (h5, l2, s2) => h5 << s2 - 32 | l2 >>> 64 - s2;
const crypto$3 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function isBytes(a2) {
  return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
}
function anumber(n5) {
  if (!Number.isSafeInteger(n5) || n5 < 0)
    throw new Error("positive integer expected, got " + n5);
}
function abytes(b2, ...lengths) {
  if (!isBytes(b2))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b2.length);
}
function ahash(h5) {
  if (typeof h5 !== "function" || typeof h5.create !== "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  anumber(h5.outputLen);
  anumber(h5.blockLen);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error("digestInto() expects output buffer of length at least " + min2);
  }
}
function u32$1(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean(...arrays) {
  for (let i4 = 0; i4 < arrays.length; i4++) {
    arrays[i4].fill(0);
  }
}
function createView$1(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr$1(word, shift) {
  return word << 32 - shift | word >>> shift;
}
const isLE$1 = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function byteSwap(word) {
  return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
function byteSwap32(arr) {
  for (let i4 = 0; i4 < arr.length; i4++) {
    arr[i4] = byteSwap(arr[i4]);
  }
  return arr;
}
const swap32IfBE = isLE$1 ? (u2) => u2 : byteSwap32;
const hasHexBuiltin = /* @__PURE__ */ (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
const hexes$2 = /* @__PURE__ */ Array.from({ length: 256 }, (_3, i4) => i4.toString(16).padStart(2, "0"));
function bytesToHex$2(bytes2) {
  abytes(bytes2);
  if (hasHexBuiltin)
    return bytes2.toHex();
  let hex = "";
  for (let i4 = 0; i4 < bytes2.length; i4++) {
    hex += hexes$2[bytes2[i4]];
  }
  return hex;
}
function utf8ToBytes$2(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes$2(data2) {
  if (typeof data2 === "string")
    data2 = utf8ToBytes$2(data2);
  abytes(data2);
  return data2;
}
function concatBytes$2(...arrays) {
  let sum = 0;
  for (let i4 = 0; i4 < arrays.length; i4++) {
    const a2 = arrays[i4];
    abytes(a2);
    sum += a2.length;
  }
  const res = new Uint8Array(sum);
  for (let i4 = 0, pad3 = 0; i4 < arrays.length; i4++) {
    const a2 = arrays[i4];
    res.set(a2, pad3);
    pad3 += a2.length;
  }
  return res;
}
let Hash$1 = class Hash2 {
};
function createHasher(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes$2(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes$1(bytesLength = 32) {
  if (crypto$3 && typeof crypto$3.getRandomValues === "function") {
    return crypto$3.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto$3 && typeof crypto$3.randomBytes === "function") {
    return Uint8Array.from(crypto$3.randomBytes(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
const _0n$5 = BigInt(0);
const _1n$6 = BigInt(1);
const _2n$4 = BigInt(2);
const _7n$1 = BigInt(7);
const _256n$1 = BigInt(256);
const _0x71n$1 = BigInt(113);
const SHA3_PI$1 = [];
const SHA3_ROTL$1 = [];
const _SHA3_IOTA$1 = [];
for (let round2 = 0, R5 = _1n$6, x2 = 1, y4 = 0; round2 < 24; round2++) {
  [x2, y4] = [y4, (2 * x2 + 3 * y4) % 5];
  SHA3_PI$1.push(2 * (5 * y4 + x2));
  SHA3_ROTL$1.push((round2 + 1) * (round2 + 2) / 2 % 64);
  let t2 = _0n$5;
  for (let j2 = 0; j2 < 7; j2++) {
    R5 = (R5 << _1n$6 ^ (R5 >> _7n$1) * _0x71n$1) % _256n$1;
    if (R5 & _2n$4)
      t2 ^= _1n$6 << (_1n$6 << /* @__PURE__ */ BigInt(j2)) - _1n$6;
  }
  _SHA3_IOTA$1.push(t2);
}
const IOTAS = split$2(_SHA3_IOTA$1, true);
const SHA3_IOTA_H$1 = IOTAS[0];
const SHA3_IOTA_L$1 = IOTAS[1];
const rotlH$1 = (h5, l2, s2) => s2 > 32 ? rotlBH$1(h5, l2, s2) : rotlSH$1(h5, l2, s2);
const rotlL$1 = (h5, l2, s2) => s2 > 32 ? rotlBL$1(h5, l2, s2) : rotlSL$1(h5, l2, s2);
function keccakP$1(s2, rounds = 24) {
  const B3 = new Uint32Array(5 * 2);
  for (let round2 = 24 - rounds; round2 < 24; round2++) {
    for (let x2 = 0; x2 < 10; x2++)
      B3[x2] = s2[x2] ^ s2[x2 + 10] ^ s2[x2 + 20] ^ s2[x2 + 30] ^ s2[x2 + 40];
    for (let x2 = 0; x2 < 10; x2 += 2) {
      const idx1 = (x2 + 8) % 10;
      const idx0 = (x2 + 2) % 10;
      const B0 = B3[idx0];
      const B1 = B3[idx0 + 1];
      const Th = rotlH$1(B0, B1, 1) ^ B3[idx1];
      const Tl = rotlL$1(B0, B1, 1) ^ B3[idx1 + 1];
      for (let y4 = 0; y4 < 50; y4 += 10) {
        s2[x2 + y4] ^= Th;
        s2[x2 + y4 + 1] ^= Tl;
      }
    }
    let curH = s2[2];
    let curL = s2[3];
    for (let t2 = 0; t2 < 24; t2++) {
      const shift = SHA3_ROTL$1[t2];
      const Th = rotlH$1(curH, curL, shift);
      const Tl = rotlL$1(curH, curL, shift);
      const PI = SHA3_PI$1[t2];
      curH = s2[PI];
      curL = s2[PI + 1];
      s2[PI] = Th;
      s2[PI + 1] = Tl;
    }
    for (let y4 = 0; y4 < 50; y4 += 10) {
      for (let x2 = 0; x2 < 10; x2++)
        B3[x2] = s2[y4 + x2];
      for (let x2 = 0; x2 < 10; x2++)
        s2[y4 + x2] ^= ~B3[(x2 + 2) % 10] & B3[(x2 + 4) % 10];
    }
    s2[0] ^= SHA3_IOTA_H$1[round2];
    s2[1] ^= SHA3_IOTA_L$1[round2];
  }
  clean(B3);
}
let Keccak$1 = class Keccak2 extends Hash$1 {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    this.enableXOF = false;
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    anumber(outputLen);
    if (!(0 < blockLen && blockLen < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200);
    this.state32 = u32$1(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    swap32IfBE(this.state32);
    keccakP$1(this.state32, this.rounds);
    swap32IfBE(this.state32);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data2) {
    aexists(this);
    data2 = toBytes$2(data2);
    abytes(data2);
    const { blockLen, state: state2 } = this;
    const len2 = data2.length;
    for (let pos = 0; pos < len2; ) {
      const take = Math.min(blockLen - this.pos, len2 - pos);
      for (let i4 = 0; i4 < take; i4++)
        state2[this.pos++] ^= data2[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state: state2, suffix, pos, blockLen } = this;
    state2[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state2[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    aexists(this, false);
    abytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len2 = out.length; pos < len2; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len2 - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    anumber(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    aoutput(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    clean(this.state);
  }
  _cloneInto(to2) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to2 || (to2 = new Keccak2(blockLen, suffix, outputLen, enableXOF, rounds));
    to2.state32.set(this.state32);
    to2.pos = this.pos;
    to2.posOut = this.posOut;
    to2.finished = this.finished;
    to2.rounds = rounds;
    to2.suffix = suffix;
    to2.outputLen = outputLen;
    to2.enableXOF = enableXOF;
    to2.destroyed = this.destroyed;
    return to2;
  }
};
const gen$1 = (suffix, blockLen, outputLen) => createHasher(() => new Keccak$1(blockLen, suffix, outputLen));
const keccak_256$1 = /* @__PURE__ */ (() => gen$1(1, 136, 256 / 8))();
function keccak256$2(value, to_) {
  const to2 = to_ || "hex";
  const bytes2 = keccak_256$1(isHex$1(value, { strict: false }) ? toBytes$3(value) : value);
  if (to2 === "bytes")
    return bytes2;
  return toHex$2(bytes2);
}
let LruMap$1 = class LruMap2 extends Map {
  constructor(size2) {
    super();
    Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxSize = size2;
  }
  get(key2) {
    const value = super.get(key2);
    if (super.has(key2) && value !== void 0) {
      this.delete(key2);
      super.set(key2, value);
    }
    return value;
  }
  set(key2, value) {
    super.set(key2, value);
    if (this.maxSize && this.size > this.maxSize) {
      const firstKey = this.keys().next().value;
      if (firstKey)
        this.delete(firstKey);
    }
    return this;
  }
};
const checksumAddressCache$1 = /* @__PURE__ */ new LruMap$1(8192);
function checksumAddress$1(address_, chainId) {
  if (checksumAddressCache$1.has(`${address_}.${chainId}`))
    return checksumAddressCache$1.get(`${address_}.${chainId}`);
  const hexAddress = address_.substring(2).toLowerCase();
  const hash3 = keccak256$2(stringToBytes$1(hexAddress), "bytes");
  const address = hexAddress.split("");
  for (let i4 = 0; i4 < 40; i4 += 2) {
    if (hash3[i4 >> 1] >> 4 >= 8 && address[i4]) {
      address[i4] = address[i4].toUpperCase();
    }
    if ((hash3[i4 >> 1] & 15) >= 8 && address[i4 + 1]) {
      address[i4 + 1] = address[i4 + 1].toUpperCase();
    }
  }
  const result = `0x${address.join("")}`;
  checksumAddressCache$1.set(`${address_}.${chainId}`, result);
  return result;
}
const stringify$1 = (value, replacer, space) => JSON.stringify(value, (key2, value_) => {
  const value2 = typeof value_ === "bigint" ? value_.toString() : value_;
  return value2;
}, space);
function formatUnits$1(value, decimals) {
  let display = value.toString();
  const negative = display.startsWith("-");
  if (negative)
    display = display.slice(1);
  display = display.padStart(decimals, "0");
  let [integer, fraction] = [
    display.slice(0, display.length - decimals),
    display.slice(display.length - decimals)
  ];
  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
}
const getUrl = (url) => url;
class HttpRequestError extends BaseError$1 {
  constructor({ body, cause, details, headers, status, url }) {
    super("HTTP request failed.", {
      cause,
      details,
      metaMessages: [
        status && `Status: ${status}`,
        `URL: ${getUrl(url)}`,
        body && `Request body: ${stringify$1(body)}`
      ].filter(Boolean),
      name: "HttpRequestError"
    });
    Object.defineProperty(this, "body", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "headers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "status", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "url", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.body = body;
    this.headers = headers;
    this.status = status;
    this.url = url;
  }
}
class RpcRequestError extends BaseError$1 {
  constructor({ body, error, url }) {
    super("RPC Request failed.", {
      cause: error,
      details: error.message,
      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify$1(body)}`],
      name: "RpcRequestError"
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.code = error.code;
    this.data = error.data;
  }
}
class TimeoutError extends BaseError$1 {
  constructor({ body, url }) {
    super("The request took too long to respond.", {
      details: "The request timed out.",
      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify$1(body)}`],
      name: "TimeoutError"
    });
  }
}
const unknownErrorCode = -1;
class RpcError extends BaseError$1 {
  constructor(cause, { code: code2, docsPath, metaMessages, name, shortMessage }) {
    super(shortMessage, {
      cause,
      docsPath,
      metaMessages: metaMessages || (cause == null ? void 0 : cause.metaMessages),
      name: name || "RpcError"
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = name || cause.name;
    this.code = cause instanceof RpcRequestError ? cause.code : code2 ?? unknownErrorCode;
  }
}
class ProviderRpcError extends RpcError {
  constructor(cause, options) {
    super(cause, options);
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.data = options.data;
  }
}
class ParseRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: ParseRpcError.code,
      name: "ParseRpcError",
      shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    });
  }
}
Object.defineProperty(ParseRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32700
});
class InvalidRequestRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InvalidRequestRpcError.code,
      name: "InvalidRequestRpcError",
      shortMessage: "JSON is not a valid request object."
    });
  }
}
Object.defineProperty(InvalidRequestRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32600
});
class MethodNotFoundRpcError extends RpcError {
  constructor(cause, { method } = {}) {
    super(cause, {
      code: MethodNotFoundRpcError.code,
      name: "MethodNotFoundRpcError",
      shortMessage: `The method${method ? ` "${method}"` : ""} does not exist / is not available.`
    });
  }
}
Object.defineProperty(MethodNotFoundRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32601
});
class InvalidParamsRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InvalidParamsRpcError.code,
      name: "InvalidParamsRpcError",
      shortMessage: [
        "Invalid parameters were provided to the RPC method.",
        "Double check you have provided the correct parameters."
      ].join("\n")
    });
  }
}
Object.defineProperty(InvalidParamsRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32602
});
class InternalRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InternalRpcError.code,
      name: "InternalRpcError",
      shortMessage: "An internal error was received."
    });
  }
}
Object.defineProperty(InternalRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32603
});
class InvalidInputRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InvalidInputRpcError.code,
      name: "InvalidInputRpcError",
      shortMessage: [
        "Missing or invalid parameters.",
        "Double check you have provided the correct parameters."
      ].join("\n")
    });
  }
}
Object.defineProperty(InvalidInputRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32e3
});
class ResourceNotFoundRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: ResourceNotFoundRpcError.code,
      name: "ResourceNotFoundRpcError",
      shortMessage: "Requested resource not found."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ResourceNotFoundRpcError"
    });
  }
}
Object.defineProperty(ResourceNotFoundRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32001
});
class ResourceUnavailableRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: ResourceUnavailableRpcError.code,
      name: "ResourceUnavailableRpcError",
      shortMessage: "Requested resource not available."
    });
  }
}
Object.defineProperty(ResourceUnavailableRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32002
});
class TransactionRejectedRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: TransactionRejectedRpcError.code,
      name: "TransactionRejectedRpcError",
      shortMessage: "Transaction creation failed."
    });
  }
}
Object.defineProperty(TransactionRejectedRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32003
});
class MethodNotSupportedRpcError extends RpcError {
  constructor(cause, { method } = {}) {
    super(cause, {
      code: MethodNotSupportedRpcError.code,
      name: "MethodNotSupportedRpcError",
      shortMessage: `Method${method ? ` "${method}"` : ""} is not supported.`
    });
  }
}
Object.defineProperty(MethodNotSupportedRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32004
});
class LimitExceededRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: LimitExceededRpcError.code,
      name: "LimitExceededRpcError",
      shortMessage: "Request exceeds defined limit."
    });
  }
}
Object.defineProperty(LimitExceededRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32005
});
class JsonRpcVersionUnsupportedError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: JsonRpcVersionUnsupportedError.code,
      name: "JsonRpcVersionUnsupportedError",
      shortMessage: "Version of JSON-RPC protocol is not supported."
    });
  }
}
Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32006
});
class UserRejectedRequestError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: UserRejectedRequestError.code,
      name: "UserRejectedRequestError",
      shortMessage: "User rejected the request."
    });
  }
}
Object.defineProperty(UserRejectedRequestError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4001
});
class UnauthorizedProviderError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: UnauthorizedProviderError.code,
      name: "UnauthorizedProviderError",
      shortMessage: "The requested method and/or account has not been authorized by the user."
    });
  }
}
Object.defineProperty(UnauthorizedProviderError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4100
});
class UnsupportedProviderMethodError extends ProviderRpcError {
  constructor(cause, { method } = {}) {
    super(cause, {
      code: UnsupportedProviderMethodError.code,
      name: "UnsupportedProviderMethodError",
      shortMessage: `The Provider does not support the requested method${method ? ` " ${method}"` : ""}.`
    });
  }
}
Object.defineProperty(UnsupportedProviderMethodError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4200
});
class ProviderDisconnectedError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: ProviderDisconnectedError.code,
      name: "ProviderDisconnectedError",
      shortMessage: "The Provider is disconnected from all chains."
    });
  }
}
Object.defineProperty(ProviderDisconnectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4900
});
class ChainDisconnectedError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: ChainDisconnectedError.code,
      name: "ChainDisconnectedError",
      shortMessage: "The Provider is not connected to the requested chain."
    });
  }
}
Object.defineProperty(ChainDisconnectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4901
});
class SwitchChainError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: SwitchChainError.code,
      name: "SwitchChainError",
      shortMessage: "An error occurred when attempting to switch chain."
    });
  }
}
Object.defineProperty(SwitchChainError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4902
});
class UnsupportedNonOptionalCapabilityError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: UnsupportedNonOptionalCapabilityError.code,
      name: "UnsupportedNonOptionalCapabilityError",
      shortMessage: "This Wallet does not support a capability that was not marked as optional."
    });
  }
}
Object.defineProperty(UnsupportedNonOptionalCapabilityError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5700
});
class UnsupportedChainIdError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: UnsupportedChainIdError.code,
      name: "UnsupportedChainIdError",
      shortMessage: "This Wallet does not support the requested chain ID."
    });
  }
}
Object.defineProperty(UnsupportedChainIdError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5710
});
class DuplicateIdError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: DuplicateIdError.code,
      name: "DuplicateIdError",
      shortMessage: "There is already a bundle submitted with this ID."
    });
  }
}
Object.defineProperty(DuplicateIdError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5720
});
class UnknownBundleIdError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: UnknownBundleIdError.code,
      name: "UnknownBundleIdError",
      shortMessage: "This bundle id is unknown / has not been submitted"
    });
  }
}
Object.defineProperty(UnknownBundleIdError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5730
});
class BundleTooLargeError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: BundleTooLargeError.code,
      name: "BundleTooLargeError",
      shortMessage: "The call bundle is too large for the Wallet to process."
    });
  }
}
Object.defineProperty(BundleTooLargeError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5740
});
class AtomicReadyWalletRejectedUpgradeError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: AtomicReadyWalletRejectedUpgradeError.code,
      name: "AtomicReadyWalletRejectedUpgradeError",
      shortMessage: "The Wallet can support atomicity after an upgrade, but the user rejected the upgrade."
    });
  }
}
Object.defineProperty(AtomicReadyWalletRejectedUpgradeError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5750
});
class AtomicityNotSupportedError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: AtomicityNotSupportedError.code,
      name: "AtomicityNotSupportedError",
      shortMessage: "The wallet does not support atomic execution but the request requires it."
    });
  }
}
Object.defineProperty(AtomicityNotSupportedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5760
});
class UnknownRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      name: "UnknownRpcError",
      shortMessage: "An unknown RPC error occurred."
    });
  }
}
function publicKeyToAddress$1(publicKey) {
  const address = keccak256$2(`0x${publicKey.substring(4)}`).substring(26);
  return checksumAddress$1(`0x${address}`);
}
async function recoverPublicKey$1({ hash: hash3, signature: signature2 }) {
  const hashHex = isHex$1(hash3) ? hash3 : toHex$2(hash3);
  const { secp256k1: secp256k12 } = await import("./secp256k1-7ladhD05.js");
  const signature_ = (() => {
    if (typeof signature2 === "object" && "r" in signature2 && "s" in signature2) {
      const { r: r3, s: s2, v: v2, yParity } = signature2;
      const yParityOrV2 = Number(yParity ?? v2);
      const recoveryBit2 = toRecoveryBit$1(yParityOrV2);
      return new secp256k12.Signature(hexToBigInt$1(r3), hexToBigInt$1(s2)).addRecoveryBit(recoveryBit2);
    }
    const signatureHex = isHex$1(signature2) ? signature2 : toHex$2(signature2);
    if (size$2(signatureHex) !== 65)
      throw new Error("invalid signature length");
    const yParityOrV = hexToNumber$2(`0x${signatureHex.slice(130)}`);
    const recoveryBit = toRecoveryBit$1(yParityOrV);
    return secp256k12.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
  })();
  const publicKey = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);
  return `0x${publicKey}`;
}
function toRecoveryBit$1(yParityOrV) {
  if (yParityOrV === 0 || yParityOrV === 1)
    return yParityOrV;
  if (yParityOrV === 27)
    return 0;
  if (yParityOrV === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}
async function recoverAddress$2({ hash: hash3, signature: signature2 }) {
  return publicKeyToAddress$1(await recoverPublicKey$1({ hash: hash3, signature: signature2 }));
}
class ExecutionRevertedError extends BaseError$1 {
  constructor({ cause, message } = {}) {
    var _a3;
    const reason = (_a3 = message == null ? void 0 : message.replace("execution reverted: ", "")) == null ? void 0 : _a3.replace("execution reverted", "");
    super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
      cause,
      name: "ExecutionRevertedError"
    });
  }
}
Object.defineProperty(ExecutionRevertedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 3
});
Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /execution reverted/
});
function withResolvers() {
  let resolve = () => void 0;
  let reject = () => void 0;
  const promise = new Promise((resolve_, reject_) => {
    resolve = resolve_;
    reject = reject_;
  });
  return { promise, resolve, reject };
}
const schedulerCache = /* @__PURE__ */ new Map();
function createBatchScheduler({ fn: fn2, id: id2, shouldSplitBatch, wait: wait2 = 0, sort }) {
  const exec = async () => {
    const scheduler = getScheduler();
    flush();
    const args = scheduler.map(({ args: args2 }) => args2);
    if (args.length === 0)
      return;
    fn2(args).then((data2) => {
      if (sort && Array.isArray(data2))
        data2.sort(sort);
      for (let i4 = 0; i4 < scheduler.length; i4++) {
        const { resolve } = scheduler[i4];
        resolve == null ? void 0 : resolve([data2[i4], data2]);
      }
    }).catch((err) => {
      for (let i4 = 0; i4 < scheduler.length; i4++) {
        const { reject } = scheduler[i4];
        reject == null ? void 0 : reject(err);
      }
    });
  };
  const flush = () => schedulerCache.delete(id2);
  const getBatchedArgs = () => getScheduler().map(({ args }) => args);
  const getScheduler = () => schedulerCache.get(id2) || [];
  const setScheduler = (item) => schedulerCache.set(id2, [...getScheduler(), item]);
  return {
    flush,
    async schedule(args) {
      const { promise, resolve, reject } = withResolvers();
      const split2 = shouldSplitBatch == null ? void 0 : shouldSplitBatch([...getBatchedArgs(), args]);
      if (split2)
        exec();
      const hasActiveScheduler = getScheduler().length > 0;
      if (hasActiveScheduler) {
        setScheduler({ args, resolve, reject });
        return promise;
      }
      setScheduler({ args, resolve, reject });
      setTimeout(exec, wait2);
      return promise;
    }
  };
}
async function wait$1(time2) {
  return new Promise((res) => setTimeout(res, time2));
}
function withRetry(fn2, { delay: delay_ = 100, retryCount = 2, shouldRetry: shouldRetry2 = () => true } = {}) {
  return new Promise((resolve, reject) => {
    const attemptRetry = async ({ count = 0 } = {}) => {
      const retry = async ({ error }) => {
        const delay2 = typeof delay_ === "function" ? delay_({ count, error }) : delay_;
        if (delay2)
          await wait$1(delay2);
        attemptRetry({ count: count + 1 });
      };
      try {
        const data2 = await fn2();
        resolve(data2);
      } catch (err) {
        if (count < retryCount && await shouldRetry2({ count, error: err }))
          return retry({ error: err });
        reject(err);
      }
    };
    attemptRetry();
  });
}
const size$1 = 256;
let index$1 = size$1;
let buffer$1;
function uid(length = 11) {
  if (!buffer$1 || index$1 + length > size$1 * 2) {
    buffer$1 = "";
    index$1 = 0;
    for (let i4 = 0; i4 < size$1; i4++) {
      buffer$1 += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer$1.substring(index$1, index$1++ + length);
}
const promiseCache = /* @__PURE__ */ new LruMap$1(8192);
function withDedupe(fn2, { enabled = true, id: id2 }) {
  if (!enabled || !id2)
    return fn2();
  if (promiseCache.get(id2))
    return promiseCache.get(id2);
  const promise = fn2().finally(() => promiseCache.delete(id2));
  promiseCache.set(id2, promise);
  return promise;
}
function buildRequest(request, options = {}) {
  return async (args, overrideOptions = {}) => {
    var _a3;
    const { dedupe = false, methods, retryDelay = 150, retryCount = 3, uid: uid2 } = {
      ...options,
      ...overrideOptions
    };
    const { method } = args;
    if ((_a3 = methods == null ? void 0 : methods.exclude) == null ? void 0 : _a3.includes(method))
      throw new MethodNotSupportedRpcError(new Error("method not supported"), {
        method
      });
    if ((methods == null ? void 0 : methods.include) && !methods.include.includes(method))
      throw new MethodNotSupportedRpcError(new Error("method not supported"), {
        method
      });
    const requestId = dedupe ? stringToHex$1(`${uid2}.${stringify$1(args)}`) : void 0;
    return withDedupe(() => withRetry(async () => {
      try {
        return await request(args);
      } catch (err_) {
        const err = err_;
        switch (err.code) {
          case ParseRpcError.code:
            throw new ParseRpcError(err);
          case InvalidRequestRpcError.code:
            throw new InvalidRequestRpcError(err);
          case MethodNotFoundRpcError.code:
            throw new MethodNotFoundRpcError(err, { method: args.method });
          case InvalidParamsRpcError.code:
            throw new InvalidParamsRpcError(err);
          case InternalRpcError.code:
            throw new InternalRpcError(err);
          case InvalidInputRpcError.code:
            throw new InvalidInputRpcError(err);
          case ResourceNotFoundRpcError.code:
            throw new ResourceNotFoundRpcError(err);
          case ResourceUnavailableRpcError.code:
            throw new ResourceUnavailableRpcError(err);
          case TransactionRejectedRpcError.code:
            throw new TransactionRejectedRpcError(err);
          case MethodNotSupportedRpcError.code:
            throw new MethodNotSupportedRpcError(err, {
              method: args.method
            });
          case LimitExceededRpcError.code:
            throw new LimitExceededRpcError(err);
          case JsonRpcVersionUnsupportedError.code:
            throw new JsonRpcVersionUnsupportedError(err);
          case UserRejectedRequestError.code:
            throw new UserRejectedRequestError(err);
          case UnauthorizedProviderError.code:
            throw new UnauthorizedProviderError(err);
          case UnsupportedProviderMethodError.code:
            throw new UnsupportedProviderMethodError(err);
          case ProviderDisconnectedError.code:
            throw new ProviderDisconnectedError(err);
          case ChainDisconnectedError.code:
            throw new ChainDisconnectedError(err);
          case SwitchChainError.code:
            throw new SwitchChainError(err);
          case UnsupportedNonOptionalCapabilityError.code:
            throw new UnsupportedNonOptionalCapabilityError(err);
          case UnsupportedChainIdError.code:
            throw new UnsupportedChainIdError(err);
          case DuplicateIdError.code:
            throw new DuplicateIdError(err);
          case UnknownBundleIdError.code:
            throw new UnknownBundleIdError(err);
          case BundleTooLargeError.code:
            throw new BundleTooLargeError(err);
          case AtomicReadyWalletRejectedUpgradeError.code:
            throw new AtomicReadyWalletRejectedUpgradeError(err);
          case AtomicityNotSupportedError.code:
            throw new AtomicityNotSupportedError(err);
          case 5e3:
            throw new UserRejectedRequestError(err);
          default:
            if (err_ instanceof BaseError$1)
              throw err_;
            throw new UnknownRpcError(err);
        }
      }
    }, {
      delay: ({ count, error }) => {
        var _a4;
        if (error && error instanceof HttpRequestError) {
          const retryAfter = (_a4 = error == null ? void 0 : error.headers) == null ? void 0 : _a4.get("Retry-After");
          if (retryAfter == null ? void 0 : retryAfter.match(/\d/))
            return Number.parseInt(retryAfter, 10) * 1e3;
        }
        return ~~(1 << count) * retryDelay;
      },
      retryCount,
      shouldRetry: ({ error }) => shouldRetry(error)
    }), { enabled: dedupe, id: requestId });
  };
}
function shouldRetry(error) {
  if ("code" in error && typeof error.code === "number") {
    if (error.code === -1)
      return true;
    if (error.code === LimitExceededRpcError.code)
      return true;
    if (error.code === InternalRpcError.code)
      return true;
    return false;
  }
  if (error instanceof HttpRequestError && error.status) {
    if (error.status === 403)
      return true;
    if (error.status === 408)
      return true;
    if (error.status === 413)
      return true;
    if (error.status === 429)
      return true;
    if (error.status === 500)
      return true;
    if (error.status === 502)
      return true;
    if (error.status === 503)
      return true;
    if (error.status === 504)
      return true;
    return false;
  }
  return true;
}
function withTimeout(fn2, { errorInstance = new Error("timed out"), timeout, signal }) {
  return new Promise((resolve, reject) => {
    (async () => {
      let timeoutId;
      try {
        const controller = new AbortController();
        if (timeout > 0) {
          timeoutId = setTimeout(() => {
            if (signal) {
              controller.abort();
            }
          }, timeout);
        }
        resolve(await fn2({ signal: (controller == null ? void 0 : controller.signal) || null }));
      } catch (err) {
        if ((err == null ? void 0 : err.name) === "AbortError")
          reject(errorInstance);
        reject(err);
      } finally {
        clearTimeout(timeoutId);
      }
    })();
  });
}
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
const idCache = /* @__PURE__ */ createIdStore();
function getHttpRpcClient(url, options = {}) {
  return {
    async request(params) {
      var _a3;
      const { body, fetchFn = options.fetchFn ?? fetch, onRequest = options.onRequest, onResponse = options.onResponse, timeout = options.timeout ?? 1e4 } = params;
      const fetchOptions = {
        ...options.fetchOptions ?? {},
        ...params.fetchOptions ?? {}
      };
      const { headers, method, signal: signal_ } = fetchOptions;
      try {
        const response = await withTimeout(async ({ signal }) => {
          const init4 = {
            ...fetchOptions,
            body: Array.isArray(body) ? stringify$1(body.map((body2) => ({
              jsonrpc: "2.0",
              id: body2.id ?? idCache.take(),
              ...body2
            }))) : stringify$1({
              jsonrpc: "2.0",
              id: body.id ?? idCache.take(),
              ...body
            }),
            headers: {
              "Content-Type": "application/json",
              ...headers
            },
            method: method || "POST",
            signal: signal_ || (timeout > 0 ? signal : null)
          };
          const request = new Request(url, init4);
          const args = await (onRequest == null ? void 0 : onRequest(request, init4)) ?? { ...init4, url };
          const response2 = await fetchFn(args.url ?? url, args);
          return response2;
        }, {
          errorInstance: new TimeoutError({ body, url }),
          timeout,
          signal: true
        });
        if (onResponse)
          await onResponse(response);
        let data2;
        if ((_a3 = response.headers.get("Content-Type")) == null ? void 0 : _a3.startsWith("application/json"))
          data2 = await response.json();
        else {
          data2 = await response.text();
          try {
            data2 = JSON.parse(data2 || "{}");
          } catch (err) {
            if (response.ok)
              throw err;
            data2 = { error: data2 };
          }
        }
        if (!response.ok) {
          throw new HttpRequestError({
            body,
            details: stringify$1(data2.error) || response.statusText,
            headers: response.headers,
            status: response.status,
            url
          });
        }
        return data2;
      } catch (err) {
        if (err instanceof HttpRequestError)
          throw err;
        if (err instanceof TimeoutError)
          throw err;
        throw new HttpRequestError({
          body,
          cause: err,
          url
        });
      }
    }
  };
}
function createTransport({ key: key2, methods, name, request, retryCount = 3, retryDelay = 150, timeout, type: type2 }, value) {
  const uid$1 = uid();
  return {
    config: {
      key: key2,
      methods,
      name,
      request,
      retryCount,
      retryDelay,
      timeout,
      type: type2
    },
    request: buildRequest(request, { methods, retryCount, retryDelay, uid: uid$1 }),
    value
  };
}
function fallback(transports_, config = {}) {
  const { key: key2 = "fallback", name = "Fallback", rank = false, shouldThrow: shouldThrow_ = shouldThrow, retryCount, retryDelay } = config;
  return ({ chain, pollingInterval = 4e3, timeout, ...rest }) => {
    let transports = transports_;
    let onResponse = () => {
    };
    const transport = createTransport({
      key: key2,
      name,
      async request({ method, params }) {
        let includes;
        const fetch2 = async (i4 = 0) => {
          const transport2 = transports[i4]({
            ...rest,
            chain,
            retryCount: 0,
            timeout
          });
          try {
            const response = await transport2.request({
              method,
              params
            });
            onResponse({
              method,
              params,
              response,
              transport: transport2,
              status: "success"
            });
            return response;
          } catch (err) {
            onResponse({
              error: err,
              method,
              params,
              transport: transport2,
              status: "error"
            });
            if (shouldThrow_(err))
              throw err;
            if (i4 === transports.length - 1)
              throw err;
            includes ?? (includes = transports.slice(i4 + 1).some((transport3) => {
              const { include, exclude } = transport3({ chain }).config.methods || {};
              if (include)
                return include.includes(method);
              if (exclude)
                return !exclude.includes(method);
              return true;
            }));
            if (!includes)
              throw err;
            return fetch2(i4 + 1);
          }
        };
        return fetch2();
      },
      retryCount,
      retryDelay,
      type: "fallback"
    }, {
      onResponse: (fn2) => onResponse = fn2,
      transports: transports.map((fn2) => fn2({ chain, retryCount: 0 }))
    });
    if (rank) {
      const rankOptions = typeof rank === "object" ? rank : {};
      rankTransports({
        chain,
        interval: rankOptions.interval ?? pollingInterval,
        onTransports: (transports_2) => transports = transports_2,
        ping: rankOptions.ping,
        sampleCount: rankOptions.sampleCount,
        timeout: rankOptions.timeout,
        transports,
        weights: rankOptions.weights
      });
    }
    return transport;
  };
}
function shouldThrow(error) {
  if ("code" in error && typeof error.code === "number") {
    if (error.code === TransactionRejectedRpcError.code || error.code === UserRejectedRequestError.code || ExecutionRevertedError.nodeMessage.test(error.message) || error.code === 5e3)
      return true;
  }
  return false;
}
function rankTransports({ chain, interval = 4e3, onTransports, ping, sampleCount = 10, timeout = 1e3, transports, weights = {} }) {
  const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } = weights;
  const samples = [];
  const rankTransports_ = async () => {
    const sample = await Promise.all(transports.map(async (transport) => {
      const transport_ = transport({ chain, retryCount: 0, timeout });
      const start = Date.now();
      let end;
      let success;
      try {
        await (ping ? ping({ transport: transport_ }) : transport_.request({ method: "net_listening" }));
        success = 1;
      } catch {
        success = 0;
      } finally {
        end = Date.now();
      }
      const latency = end - start;
      return { latency, success };
    }));
    samples.push(sample);
    if (samples.length > sampleCount)
      samples.shift();
    const maxLatency = Math.max(...samples.map((sample2) => Math.max(...sample2.map(({ latency }) => latency))));
    const scores = transports.map((_3, i4) => {
      const latencies = samples.map((sample2) => sample2[i4].latency);
      const meanLatency = latencies.reduce((acc, latency) => acc + latency, 0) / latencies.length;
      const latencyScore = 1 - meanLatency / maxLatency;
      const successes = samples.map((sample2) => sample2[i4].success);
      const stabilityScore = successes.reduce((acc, success) => acc + success, 0) / successes.length;
      if (stabilityScore === 0)
        return [0, i4];
      return [
        latencyWeight * latencyScore + stabilityWeight * stabilityScore,
        i4
      ];
    }).sort((a2, b2) => b2[0] - a2[0]);
    onTransports(scores.map(([, i4]) => transports[i4]));
    await wait$1(interval);
    rankTransports_();
  };
  rankTransports_();
}
class UrlRequiredError extends BaseError$1 {
  constructor() {
    super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
      docsPath: "/docs/clients/intro",
      name: "UrlRequiredError"
    });
  }
}
function http(url, config = {}) {
  const { batch, fetchFn, fetchOptions, key: key2 = "http", methods, name = "HTTP JSON-RPC", onFetchRequest, onFetchResponse, retryDelay, raw } = config;
  return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
    const { batchSize = 1e3, wait: wait2 = 0 } = typeof batch === "object" ? batch : {};
    const retryCount = config.retryCount ?? retryCount_;
    const timeout = timeout_ ?? config.timeout ?? 1e4;
    const url_ = url || (chain == null ? void 0 : chain.rpcUrls.default.http[0]);
    if (!url_)
      throw new UrlRequiredError();
    const rpcClient = getHttpRpcClient(url_, {
      fetchFn,
      fetchOptions,
      onRequest: onFetchRequest,
      onResponse: onFetchResponse,
      timeout
    });
    return createTransport({
      key: key2,
      methods,
      name,
      async request({ method, params }) {
        const body = { method, params };
        const { schedule } = createBatchScheduler({
          id: url_,
          wait: wait2,
          shouldSplitBatch(requests) {
            return requests.length > batchSize;
          },
          fn: (body2) => rpcClient.request({
            body: body2
          }),
          sort: (a2, b2) => a2.id - b2.id
        });
        const fn2 = async (body2) => batch ? schedule(body2) : [
          await rpcClient.request({
            body: body2
          })
        ];
        const [{ error, result }] = await fn2(body);
        if (raw)
          return { error, result };
        if (error)
          throw new RpcRequestError({
            body,
            error,
            url: url_
          });
        return result;
      },
      retryCount,
      retryDelay,
      timeout,
      type: "http"
    }, {
      fetchOptions,
      url: url_
    });
  };
}
function allocUnsafe(size2 = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return globalThis.Buffer.allocUnsafe(size2);
  }
  return new Uint8Array(size2);
}
function concat$1(arrays, length) {
  if (!length) {
    length = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output2 = allocUnsafe(length);
  let offset = 0;
  for (const arr of arrays) {
    output2.set(arr, offset);
    offset += arr.length;
  }
  return output2;
}
function base$4(ALPHABET2, name) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
    BASE_MAP[j2] = 255;
  }
  for (var i4 = 0; i4 < ALPHABET2.length; i4++) {
    var x2 = ALPHABET2.charAt(i4);
    var xc3 = x2.charCodeAt(0);
    if (BASE_MAP[xc3] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc3] = i4;
  }
  var BASE = ALPHABET2.length;
  var LEADER = ALPHABET2.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode4(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size2 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size2);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i5 = 0;
      for (var it1 = size2 - 1; (carry !== 0 || i5 < length) && it1 !== -1; it1--, i5++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i5;
      pbegin++;
    }
    var it22 = size2 - length;
    while (it22 !== size2 && b58[it22] === 0) {
      it22++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it22 < size2; ++it22) {
      str += ALPHABET2.charAt(b58[it22]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size2 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size2);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i5 = 0;
      for (var it32 = size2 - 1; (carry !== 0 || i5 < length) && it32 !== -1; it32--, i5++) {
        carry += BASE * b256[it32] >>> 0;
        b256[it32] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i5;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size2 - length;
    while (it4 !== size2 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size2 - it4));
    var j3 = zeroes;
    while (it4 !== size2) {
      vch[j3++] = b256[it4++];
    }
    return vch;
  }
  function decode2(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name} character`);
  }
  return {
    encode: encode4,
    decodeUnsafe,
    decode: decode2
  };
}
var src = base$4;
var _brrp__multiformats_scope_baseX = src;
const coerce = (o3) => {
  if (o3 instanceof Uint8Array && o3.constructor.name === "Uint8Array")
    return o3;
  if (o3 instanceof ArrayBuffer)
    return new Uint8Array(o3);
  if (ArrayBuffer.isView(o3)) {
    return new Uint8Array(o3.buffer, o3.byteOffset, o3.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
const fromString$1 = (str) => new TextEncoder().encode(str);
const toString$2 = (b2) => new TextDecoder().decode(b2);
class Encoder {
  constructor(name, prefix, baseEncode) {
    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
class Decoder {
  constructor(name, prefix, baseDecode) {
    this.name = name;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or$7(this, decoder);
  }
}
class ComposedDecoder {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or$7(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
}
const or$7 = (left, right) => new ComposedDecoder({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
class Codec {
  constructor(name, prefix, baseEncode, baseDecode) {
    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name, prefix, baseEncode);
    this.decoder = new Decoder(name, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
}
const from = ({ name, prefix, encode: encode4, decode: decode2 }) => new Codec(name, prefix, encode4, decode2);
const baseX = ({ prefix, name, alphabet: alphabet2 }) => {
  const { encode: encode4, decode: decode2 } = _brrp__multiformats_scope_baseX(alphabet2, name);
  return from({
    prefix,
    name,
    encode: encode4,
    decode: (text) => coerce(decode2(text))
  });
};
const decode$1 = (string2, alphabet2, bitsPerChar, name) => {
  const codes = {};
  for (let i4 = 0; i4 < alphabet2.length; ++i4) {
    codes[alphabet2[i4]] = i4;
  }
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i4 = 0; i4 < end; ++i4) {
    const value = codes[string2[i4]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
const encode$1 = (data2, alphabet2, bitsPerChar) => {
  const pad3 = alphabet2[alphabet2.length - 1] === "=";
  const mask2 = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i4 = 0; i4 < data2.length; ++i4) {
    buffer2 = buffer2 << 8 | data2[i4];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask2 & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask2 & buffer2 << bitsPerChar - bits];
  }
  if (pad3) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
const rfc4648 = ({ name, prefix, bitsPerChar, alphabet: alphabet2 }) => {
  return from({
    prefix,
    name,
    encode(input) {
      return encode$1(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode$1(input, alphabet2, bitsPerChar, name);
    }
  });
};
const identity = from({
  prefix: "\0",
  name: "identity",
  encode: (buf) => toString$2(buf),
  decode: (str) => fromString$1(str)
});
const identityBase = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity
}, Symbol.toStringTag, { value: "Module" }));
const base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});
const base2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2
}, Symbol.toStringTag, { value: "Module" }));
const base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});
const base8$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8
}, Symbol.toStringTag, { value: "Module" }));
const base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});
const base10$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10
}, Symbol.toStringTag, { value: "Module" }));
const base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
const base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});
const base16$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16,
  base16upper
}, Symbol.toStringTag, { value: "Module" }));
const base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
const base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
const base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
const base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
const base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
const base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
const base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
const base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
const base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});
const base32$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32,
  base32hex,
  base32hexpad,
  base32hexpadupper,
  base32hexupper,
  base32pad,
  base32padupper,
  base32upper,
  base32z
}, Symbol.toStringTag, { value: "Module" }));
const base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
const base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});
const base36$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36,
  base36upper
}, Symbol.toStringTag, { value: "Module" }));
const base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
const base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
const base58 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc,
  base58flickr
}, Symbol.toStringTag, { value: "Module" }));
const base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
const base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
const base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
const base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});
const base64$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64,
  base64pad,
  base64url,
  base64urlpad
}, Symbol.toStringTag, { value: "Module" }));
const alphabet = Array.from("");
const alphabetBytesToChars = alphabet.reduce((p2, c2, i4) => {
  p2[i4] = c2;
  return p2;
}, []);
const alphabetCharsToBytes = alphabet.reduce((p2, c2, i4) => {
  p2[c2.codePointAt(0)] = i4;
  return p2;
}, []);
function encode(data2) {
  return data2.reduce((p2, c2) => {
    p2 += alphabetBytesToChars[c2];
    return p2;
  }, "");
}
function decode(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
const base256emoji = from({
  prefix: "",
  name: "base256emoji",
  encode,
  decode
});
const base256emoji$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const bases = {
  ...identityBase,
  ...base2$1,
  ...base8$1,
  ...base10$1,
  ...base16$1,
  ...base32$1,
  ...base36$1,
  ...base58,
  ...base64$1,
  ...base256emoji$1
};
function createCodec(name, prefix, encode4, decode2) {
  return {
    name,
    prefix,
    encoder: {
      name,
      prefix,
      encode: encode4
    },
    decoder: { decode: decode2 }
  };
}
const string = createCodec("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
const ascii = createCodec("ascii", "a", (buf) => {
  let string2 = "a";
  for (let i4 = 0; i4 < buf.length; i4++) {
    string2 += String.fromCharCode(buf[i4]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe(str.length);
  for (let i4 = 0; i4 < str.length; i4++) {
    buf[i4] = str.charCodeAt(i4);
  }
  return buf;
});
const BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
function fromString(string2, encoding = "utf8") {
  const base3 = BASES[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(string2, "utf8");
  }
  return base3.decoder.decode(`${base3.prefix}${string2}`);
}
function toString$1(array, encoding = "utf8") {
  const base3 = BASES[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base3.encoder.encode(array).substring(1);
}
var elliptic$1 = {};
const version$4 = "6.6.1";
const require$$0$1 = {
  version: version$4
};
var utils$p = {};
var bn$8 = { exports: {} };
const require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(dist);
bn$8.exports;
(function(module) {
  (function(module2, exports2) {
    function assert2(val, msg) {
      if (!val) throw new Error(msg || "Assertion failed");
    }
    function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN2(number2, base3, endian) {
      if (BN2.isBN(number2)) {
        return number2;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number2 !== null) {
        if (base3 === "le" || base3 === "be") {
          endian = base3;
          base3 = 10;
        }
        this._init(number2 || 0, base3 || 10, endian || "be");
      }
    }
    if (typeof module2 === "object") {
      module2.exports = BN2;
    } else {
      exports2.BN = BN2;
    }
    BN2.BN = BN2;
    BN2.wordSize = 26;
    var Buffer2;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer2 = window.Buffer;
      } else {
        Buffer2 = require$$1$2.Buffer;
      }
    } catch (e3) {
    }
    BN2.isBN = function isBN(num) {
      if (num instanceof BN2) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
    };
    BN2.max = function max2(left, right) {
      if (left.cmp(right) > 0) return left;
      return right;
    };
    BN2.min = function min2(left, right) {
      if (left.cmp(right) < 0) return left;
      return right;
    };
    BN2.prototype._init = function init4(number2, base3, endian) {
      if (typeof number2 === "number") {
        return this._initNumber(number2, base3, endian);
      }
      if (typeof number2 === "object") {
        return this._initArray(number2, base3, endian);
      }
      if (base3 === "hex") {
        base3 = 16;
      }
      assert2(base3 === (base3 | 0) && base3 >= 2 && base3 <= 36);
      number2 = number2.toString().replace(/\s+/g, "");
      var start = 0;
      if (number2[0] === "-") {
        start++;
        this.negative = 1;
      }
      if (start < number2.length) {
        if (base3 === 16) {
          this._parseHex(number2, start, endian);
        } else {
          this._parseBase(number2, base3, start);
          if (endian === "le") {
            this._initArray(this.toArray(), base3, endian);
          }
        }
      }
    };
    BN2.prototype._initNumber = function _initNumber(number2, base3, endian) {
      if (number2 < 0) {
        this.negative = 1;
        number2 = -number2;
      }
      if (number2 < 67108864) {
        this.words = [number2 & 67108863];
        this.length = 1;
      } else if (number2 < 4503599627370496) {
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert2(number2 < 9007199254740992);
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le") return;
      this._initArray(this.toArray(), base3, endian);
    };
    BN2.prototype._initArray = function _initArray(number2, base3, endian) {
      assert2(typeof number2.length === "number");
      if (number2.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number2.length / 3);
      this.words = new Array(this.length);
      for (var i4 = 0; i4 < this.length; i4++) {
        this.words[i4] = 0;
      }
      var j2, w2;
      var off = 0;
      if (endian === "be") {
        for (i4 = number2.length - 1, j2 = 0; i4 >= 0; i4 -= 3) {
          w2 = number2[i4] | number2[i4 - 1] << 8 | number2[i4 - 2] << 16;
          this.words[j2] |= w2 << off & 67108863;
          this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j2++;
          }
        }
      } else if (endian === "le") {
        for (i4 = 0, j2 = 0; i4 < number2.length; i4 += 3) {
          w2 = number2[i4] | number2[i4 + 1] << 8 | number2[i4 + 2] << 16;
          this.words[j2] |= w2 << off & 67108863;
          this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j2++;
          }
        }
      }
      return this.strip();
    };
    function parseHex4Bits(string2, index2) {
      var c2 = string2.charCodeAt(index2);
      if (c2 >= 65 && c2 <= 70) {
        return c2 - 55;
      } else if (c2 >= 97 && c2 <= 102) {
        return c2 - 87;
      } else {
        return c2 - 48 & 15;
      }
    }
    function parseHexByte(string2, lowerBound, index2) {
      var r3 = parseHex4Bits(string2, index2);
      if (index2 - 1 >= lowerBound) {
        r3 |= parseHex4Bits(string2, index2 - 1) << 4;
      }
      return r3;
    }
    BN2.prototype._parseHex = function _parseHex(number2, start, endian) {
      this.length = Math.ceil((number2.length - start) / 6);
      this.words = new Array(this.length);
      for (var i4 = 0; i4 < this.length; i4++) {
        this.words[i4] = 0;
      }
      var off = 0;
      var j2 = 0;
      var w2;
      if (endian === "be") {
        for (i4 = number2.length - 1; i4 >= start; i4 -= 2) {
          w2 = parseHexByte(number2, start, i4) << off;
          this.words[j2] |= w2 & 67108863;
          if (off >= 18) {
            off -= 18;
            j2 += 1;
            this.words[j2] |= w2 >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number2.length - start;
        for (i4 = parseLength % 2 === 0 ? start + 1 : start; i4 < number2.length; i4 += 2) {
          w2 = parseHexByte(number2, start, i4) << off;
          this.words[j2] |= w2 & 67108863;
          if (off >= 18) {
            off -= 18;
            j2 += 1;
            this.words[j2] |= w2 >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this.strip();
    };
    function parseBase(str, start, end, mul6) {
      var r3 = 0;
      var len2 = Math.min(str.length, end);
      for (var i4 = start; i4 < len2; i4++) {
        var c2 = str.charCodeAt(i4) - 48;
        r3 *= mul6;
        if (c2 >= 49) {
          r3 += c2 - 49 + 10;
        } else if (c2 >= 17) {
          r3 += c2 - 17 + 10;
        } else {
          r3 += c2;
        }
      }
      return r3;
    }
    BN2.prototype._parseBase = function _parseBase(number2, base3, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base3) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base3 | 0;
      var total = number2.length - start;
      var mod2 = total % limbLen;
      var end = Math.min(total, total - mod2) + start;
      var word = 0;
      for (var i4 = start; i4 < end; i4 += limbLen) {
        word = parseBase(number2, i4, i4 + limbLen, base3);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod2 !== 0) {
        var pow3 = 1;
        word = parseBase(number2, i4, number2.length, base3);
        for (i4 = 0; i4 < mod2; i4++) {
          pow3 *= base3;
        }
        this.imuln(pow3);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this.strip();
    };
    BN2.prototype.copy = function copy2(dest) {
      dest.words = new Array(this.length);
      for (var i4 = 0; i4 < this.length; i4++) {
        dest.words[i4] = this.words[i4];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    BN2.prototype.clone = function clone() {
      var r3 = new BN2(null);
      this.copy(r3);
      return r3;
    };
    BN2.prototype._expand = function _expand(size2) {
      while (this.length < size2) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN2.prototype.strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN2.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    BN2.prototype.inspect = function inspect6() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var zeros2 = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN2.prototype.toString = function toString2(base3, padding2) {
      base3 = base3 || 10;
      padding2 = padding2 | 0 || 1;
      var out;
      if (base3 === 16 || base3 === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var w2 = this.words[i4];
          var word = ((w2 << off | carry) & 16777215).toString(16);
          carry = w2 >>> 24 - off & 16777215;
          off += 2;
          if (off >= 26) {
            off -= 26;
            i4--;
          }
          if (carry !== 0 || i4 !== this.length - 1) {
            out = zeros2[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base3 === (base3 | 0) && base3 >= 2 && base3 <= 36) {
        var groupSize = groupSizes[base3];
        var groupBase = groupBases[base3];
        out = "";
        var c2 = this.clone();
        c2.negative = 0;
        while (!c2.isZero()) {
          var r3 = c2.modn(groupBase).toString(base3);
          c2 = c2.idivn(groupBase);
          if (!c2.isZero()) {
            out = zeros2[groupSize - r3.length] + r3 + out;
          } else {
            out = r3 + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert2(false, "Base should be between 2 and 36");
    };
    BN2.prototype.toNumber = function toNumber2() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN2.prototype.toJSON = function toJSON2() {
      return this.toString(16);
    };
    BN2.prototype.toBuffer = function toBuffer2(endian, length) {
      assert2(typeof Buffer2 !== "undefined");
      return this.toArrayLike(Buffer2, endian, length);
    };
    BN2.prototype.toArray = function toArray2(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };
    BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      var byteLength2 = this.byteLength();
      var reqLength = length || Math.max(1, byteLength2);
      assert2(byteLength2 <= reqLength, "byte array longer than desired length");
      assert2(reqLength > 0, "Requested array length <= 0");
      this.strip();
      var littleEndian = endian === "le";
      var res = new ArrayType(reqLength);
      var b2, i4;
      var q2 = this.clone();
      if (!littleEndian) {
        for (i4 = 0; i4 < reqLength - byteLength2; i4++) {
          res[i4] = 0;
        }
        for (i4 = 0; !q2.isZero(); i4++) {
          b2 = q2.andln(255);
          q2.iushrn(8);
          res[reqLength - i4 - 1] = b2;
        }
      } else {
        for (i4 = 0; !q2.isZero(); i4++) {
          b2 = q2.andln(255);
          q2.iushrn(8);
          res[i4] = b2;
        }
        for (; i4 < reqLength; i4++) {
          res[i4] = 0;
        }
      }
      return res;
    };
    if (Math.clz32) {
      BN2.prototype._countBits = function _countBits(w2) {
        return 32 - Math.clz32(w2);
      };
    } else {
      BN2.prototype._countBits = function _countBits(w2) {
        var t2 = w2;
        var r3 = 0;
        if (t2 >= 4096) {
          r3 += 13;
          t2 >>>= 13;
        }
        if (t2 >= 64) {
          r3 += 7;
          t2 >>>= 7;
        }
        if (t2 >= 8) {
          r3 += 4;
          t2 >>>= 4;
        }
        if (t2 >= 2) {
          r3 += 2;
          t2 >>>= 2;
        }
        return r3 + t2;
      };
    }
    BN2.prototype._zeroBits = function _zeroBits(w2) {
      if (w2 === 0) return 26;
      var t2 = w2;
      var r3 = 0;
      if ((t2 & 8191) === 0) {
        r3 += 13;
        t2 >>>= 13;
      }
      if ((t2 & 127) === 0) {
        r3 += 7;
        t2 >>>= 7;
      }
      if ((t2 & 15) === 0) {
        r3 += 4;
        t2 >>>= 4;
      }
      if ((t2 & 3) === 0) {
        r3 += 2;
        t2 >>>= 2;
      }
      if ((t2 & 1) === 0) {
        r3++;
      }
      return r3;
    };
    BN2.prototype.bitLength = function bitLength() {
      var w2 = this.words[this.length - 1];
      var hi2 = this._countBits(w2);
      return (this.length - 1) * 26 + hi2;
    };
    function toBitArray(num) {
      var w2 = new Array(num.bitLength());
      for (var bit = 0; bit < w2.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w2[bit] = (num.words[off] & 1 << wbit) >>> wbit;
      }
      return w2;
    }
    BN2.prototype.zeroBits = function zeroBits() {
      if (this.isZero()) return 0;
      var r3 = 0;
      for (var i4 = 0; i4 < this.length; i4++) {
        var b2 = this._zeroBits(this.words[i4]);
        r3 += b2;
        if (b2 !== 26) break;
      }
      return r3;
    };
    BN2.prototype.byteLength = function byteLength2() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN2.prototype.toTwos = function toTwos2(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN2.prototype.fromTwos = function fromTwos2(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN2.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN2.prototype.neg = function neg4() {
      return this.clone().ineg();
    };
    BN2.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN2.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i4 = 0; i4 < num.length; i4++) {
        this.words[i4] = this.words[i4] | num.words[i4];
      }
      return this.strip();
    };
    BN2.prototype.ior = function ior(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN2.prototype.or = function or2(num) {
      if (this.length > num.length) return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN2.prototype.uor = function uor(num) {
      if (this.length > num.length) return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN2.prototype.iuand = function iuand(num) {
      var b2;
      if (this.length > num.length) {
        b2 = num;
      } else {
        b2 = this;
      }
      for (var i4 = 0; i4 < b2.length; i4++) {
        this.words[i4] = this.words[i4] & num.words[i4];
      }
      this.length = b2.length;
      return this.strip();
    };
    BN2.prototype.iand = function iand(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN2.prototype.and = function and(num) {
      if (this.length > num.length) return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN2.prototype.uand = function uand(num) {
      if (this.length > num.length) return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN2.prototype.iuxor = function iuxor(num) {
      var a2;
      var b2;
      if (this.length > num.length) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      for (var i4 = 0; i4 < b2.length; i4++) {
        this.words[i4] = a2.words[i4] ^ b2.words[i4];
      }
      if (this !== a2) {
        for (; i4 < a2.length; i4++) {
          this.words[i4] = a2.words[i4];
        }
      }
      this.length = a2.length;
      return this.strip();
    };
    BN2.prototype.ixor = function ixor(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN2.prototype.xor = function xor2(num) {
      if (this.length > num.length) return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN2.prototype.uxor = function uxor(num) {
      if (this.length > num.length) return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN2.prototype.inotn = function inotn(width) {
      assert2(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i4 = 0; i4 < bytesNeeded; i4++) {
        this.words[i4] = ~this.words[i4] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i4] = ~this.words[i4] & 67108863 >> 26 - bitsLeft;
      }
      return this.strip();
    };
    BN2.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN2.prototype.setn = function setn(bit, val) {
      assert2(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this.strip();
    };
    BN2.prototype.iadd = function iadd(num) {
      var r3;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r3 = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r3 = this.isub(num);
        num.negative = 1;
        return r3._normSign();
      }
      var a2, b2;
      if (this.length > num.length) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      var carry = 0;
      for (var i4 = 0; i4 < b2.length; i4++) {
        r3 = (a2.words[i4] | 0) + (b2.words[i4] | 0) + carry;
        this.words[i4] = r3 & 67108863;
        carry = r3 >>> 26;
      }
      for (; carry !== 0 && i4 < a2.length; i4++) {
        r3 = (a2.words[i4] | 0) + carry;
        this.words[i4] = r3 & 67108863;
        carry = r3 >>> 26;
      }
      this.length = a2.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a2 !== this) {
        for (; i4 < a2.length; i4++) {
          this.words[i4] = a2.words[i4];
        }
      }
      return this;
    };
    BN2.prototype.add = function add6(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length) return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN2.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r3 = this.iadd(num);
        num.negative = 1;
        return r3._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a2, b2;
      if (cmp > 0) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      var carry = 0;
      for (var i4 = 0; i4 < b2.length; i4++) {
        r3 = (a2.words[i4] | 0) - (b2.words[i4] | 0) + carry;
        carry = r3 >> 26;
        this.words[i4] = r3 & 67108863;
      }
      for (; carry !== 0 && i4 < a2.length; i4++) {
        r3 = (a2.words[i4] | 0) + carry;
        carry = r3 >> 26;
        this.words[i4] = r3 & 67108863;
      }
      if (carry === 0 && i4 < a2.length && a2 !== this) {
        for (; i4 < a2.length; i4++) {
          this.words[i4] = a2.words[i4];
        }
      }
      this.length = Math.max(this.length, i4);
      if (a2 !== this) {
        this.negative = 1;
      }
      return this.strip();
    };
    BN2.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len2 = self2.length + num.length | 0;
      out.length = len2;
      len2 = len2 - 1 | 0;
      var a2 = self2.words[0] | 0;
      var b2 = num.words[0] | 0;
      var r3 = a2 * b2;
      var lo2 = r3 & 67108863;
      var carry = r3 / 67108864 | 0;
      out.words[0] = lo2;
      for (var k3 = 1; k3 < len2; k3++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k3, num.length - 1);
        for (var j2 = Math.max(0, k3 - self2.length + 1); j2 <= maxJ; j2++) {
          var i4 = k3 - j2 | 0;
          a2 = self2.words[i4] | 0;
          b2 = num.words[j2] | 0;
          r3 = a2 * b2 + rword;
          ncarry += r3 / 67108864 | 0;
          rword = r3 & 67108863;
        }
        out.words[k3] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k3] = carry | 0;
      } else {
        out.length--;
      }
      return out.strip();
    }
    var comb10MulTo = function comb10MulTo2(self2, num, out) {
      var a2 = self2.words;
      var b2 = num.words;
      var o3 = out.words;
      var c2 = 0;
      var lo2;
      var mid;
      var hi2;
      var a0 = a2[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a2[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a22 = a2[2] | 0;
      var al2 = a22 & 8191;
      var ah2 = a22 >>> 13;
      var a3 = a2[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a2[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a2[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a2[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a2[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a2[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a2[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b2[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b2[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b22 = b2[2] | 0;
      var bl2 = b22 & 8191;
      var bh2 = b22 >>> 13;
      var b3 = b2[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b2[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b2[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b2[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b2[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b2[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b2[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo2 = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi2 = Math.imul(ah0, bh0);
      var w0 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo2 = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi2 = Math.imul(ah1, bh0);
      lo2 = lo2 + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi2 = hi2 + Math.imul(ah0, bh1) | 0;
      var w1 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo2 = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi2 = Math.imul(ah2, bh0);
      lo2 = lo2 + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi2 = hi2 + Math.imul(ah1, bh1) | 0;
      lo2 = lo2 + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi2 = hi2 + Math.imul(ah0, bh2) | 0;
      var w2 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo2 = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi2 = Math.imul(ah3, bh0);
      lo2 = lo2 + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi2 = hi2 + Math.imul(ah2, bh1) | 0;
      lo2 = lo2 + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi2 = hi2 + Math.imul(ah1, bh2) | 0;
      lo2 = lo2 + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi2 = hi2 + Math.imul(ah0, bh3) | 0;
      var w3 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo2 = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi2 = Math.imul(ah4, bh0);
      lo2 = lo2 + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi2 = hi2 + Math.imul(ah3, bh1) | 0;
      lo2 = lo2 + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi2 = hi2 + Math.imul(ah2, bh2) | 0;
      lo2 = lo2 + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi2 = hi2 + Math.imul(ah1, bh3) | 0;
      lo2 = lo2 + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi2 = hi2 + Math.imul(ah0, bh4) | 0;
      var w4 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo2 = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi2 = Math.imul(ah5, bh0);
      lo2 = lo2 + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi2 = hi2 + Math.imul(ah4, bh1) | 0;
      lo2 = lo2 + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi2 = hi2 + Math.imul(ah3, bh2) | 0;
      lo2 = lo2 + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi2 = hi2 + Math.imul(ah2, bh3) | 0;
      lo2 = lo2 + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi2 = hi2 + Math.imul(ah1, bh4) | 0;
      lo2 = lo2 + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi2 = hi2 + Math.imul(ah0, bh5) | 0;
      var w5 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo2 = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi2 = Math.imul(ah6, bh0);
      lo2 = lo2 + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi2 = hi2 + Math.imul(ah5, bh1) | 0;
      lo2 = lo2 + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi2 = hi2 + Math.imul(ah4, bh2) | 0;
      lo2 = lo2 + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi2 = hi2 + Math.imul(ah3, bh3) | 0;
      lo2 = lo2 + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi2 = hi2 + Math.imul(ah2, bh4) | 0;
      lo2 = lo2 + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi2 = hi2 + Math.imul(ah1, bh5) | 0;
      lo2 = lo2 + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi2 = hi2 + Math.imul(ah0, bh6) | 0;
      var w6 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo2 = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi2 = Math.imul(ah7, bh0);
      lo2 = lo2 + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi2 = hi2 + Math.imul(ah6, bh1) | 0;
      lo2 = lo2 + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi2 = hi2 + Math.imul(ah5, bh2) | 0;
      lo2 = lo2 + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi2 = hi2 + Math.imul(ah4, bh3) | 0;
      lo2 = lo2 + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi2 = hi2 + Math.imul(ah3, bh4) | 0;
      lo2 = lo2 + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi2 = hi2 + Math.imul(ah2, bh5) | 0;
      lo2 = lo2 + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi2 = hi2 + Math.imul(ah1, bh6) | 0;
      lo2 = lo2 + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi2 = hi2 + Math.imul(ah0, bh7) | 0;
      var w7 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo2 = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi2 = Math.imul(ah8, bh0);
      lo2 = lo2 + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi2 = hi2 + Math.imul(ah7, bh1) | 0;
      lo2 = lo2 + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi2 = hi2 + Math.imul(ah6, bh2) | 0;
      lo2 = lo2 + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi2 = hi2 + Math.imul(ah5, bh3) | 0;
      lo2 = lo2 + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi2 = hi2 + Math.imul(ah4, bh4) | 0;
      lo2 = lo2 + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi2 = hi2 + Math.imul(ah3, bh5) | 0;
      lo2 = lo2 + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi2 = hi2 + Math.imul(ah2, bh6) | 0;
      lo2 = lo2 + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi2 = hi2 + Math.imul(ah1, bh7) | 0;
      lo2 = lo2 + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi2 = hi2 + Math.imul(ah0, bh8) | 0;
      var w8 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo2 = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi2 = Math.imul(ah9, bh0);
      lo2 = lo2 + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi2 = hi2 + Math.imul(ah8, bh1) | 0;
      lo2 = lo2 + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi2 = hi2 + Math.imul(ah7, bh2) | 0;
      lo2 = lo2 + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi2 = hi2 + Math.imul(ah6, bh3) | 0;
      lo2 = lo2 + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi2 = hi2 + Math.imul(ah5, bh4) | 0;
      lo2 = lo2 + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi2 = hi2 + Math.imul(ah4, bh5) | 0;
      lo2 = lo2 + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi2 = hi2 + Math.imul(ah3, bh6) | 0;
      lo2 = lo2 + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi2 = hi2 + Math.imul(ah2, bh7) | 0;
      lo2 = lo2 + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi2 = hi2 + Math.imul(ah1, bh8) | 0;
      lo2 = lo2 + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi2 = hi2 + Math.imul(ah0, bh9) | 0;
      var w9 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo2 = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi2 = Math.imul(ah9, bh1);
      lo2 = lo2 + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi2 = hi2 + Math.imul(ah8, bh2) | 0;
      lo2 = lo2 + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi2 = hi2 + Math.imul(ah7, bh3) | 0;
      lo2 = lo2 + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi2 = hi2 + Math.imul(ah6, bh4) | 0;
      lo2 = lo2 + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi2 = hi2 + Math.imul(ah5, bh5) | 0;
      lo2 = lo2 + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi2 = hi2 + Math.imul(ah4, bh6) | 0;
      lo2 = lo2 + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi2 = hi2 + Math.imul(ah3, bh7) | 0;
      lo2 = lo2 + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi2 = hi2 + Math.imul(ah2, bh8) | 0;
      lo2 = lo2 + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi2 = hi2 + Math.imul(ah1, bh9) | 0;
      var w10 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo2 = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi2 = Math.imul(ah9, bh2);
      lo2 = lo2 + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi2 = hi2 + Math.imul(ah8, bh3) | 0;
      lo2 = lo2 + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi2 = hi2 + Math.imul(ah7, bh4) | 0;
      lo2 = lo2 + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi2 = hi2 + Math.imul(ah6, bh5) | 0;
      lo2 = lo2 + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi2 = hi2 + Math.imul(ah5, bh6) | 0;
      lo2 = lo2 + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi2 = hi2 + Math.imul(ah4, bh7) | 0;
      lo2 = lo2 + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi2 = hi2 + Math.imul(ah3, bh8) | 0;
      lo2 = lo2 + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi2 = hi2 + Math.imul(ah2, bh9) | 0;
      var w11 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo2 = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi2 = Math.imul(ah9, bh3);
      lo2 = lo2 + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi2 = hi2 + Math.imul(ah8, bh4) | 0;
      lo2 = lo2 + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi2 = hi2 + Math.imul(ah7, bh5) | 0;
      lo2 = lo2 + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi2 = hi2 + Math.imul(ah6, bh6) | 0;
      lo2 = lo2 + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi2 = hi2 + Math.imul(ah5, bh7) | 0;
      lo2 = lo2 + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi2 = hi2 + Math.imul(ah4, bh8) | 0;
      lo2 = lo2 + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi2 = hi2 + Math.imul(ah3, bh9) | 0;
      var w12 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo2 = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi2 = Math.imul(ah9, bh4);
      lo2 = lo2 + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi2 = hi2 + Math.imul(ah8, bh5) | 0;
      lo2 = lo2 + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi2 = hi2 + Math.imul(ah7, bh6) | 0;
      lo2 = lo2 + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi2 = hi2 + Math.imul(ah6, bh7) | 0;
      lo2 = lo2 + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi2 = hi2 + Math.imul(ah5, bh8) | 0;
      lo2 = lo2 + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi2 = hi2 + Math.imul(ah4, bh9) | 0;
      var w13 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo2 = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi2 = Math.imul(ah9, bh5);
      lo2 = lo2 + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi2 = hi2 + Math.imul(ah8, bh6) | 0;
      lo2 = lo2 + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi2 = hi2 + Math.imul(ah7, bh7) | 0;
      lo2 = lo2 + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi2 = hi2 + Math.imul(ah6, bh8) | 0;
      lo2 = lo2 + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi2 = hi2 + Math.imul(ah5, bh9) | 0;
      var w14 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo2 = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi2 = Math.imul(ah9, bh6);
      lo2 = lo2 + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi2 = hi2 + Math.imul(ah8, bh7) | 0;
      lo2 = lo2 + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi2 = hi2 + Math.imul(ah7, bh8) | 0;
      lo2 = lo2 + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi2 = hi2 + Math.imul(ah6, bh9) | 0;
      var w15 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo2 = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi2 = Math.imul(ah9, bh7);
      lo2 = lo2 + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi2 = hi2 + Math.imul(ah8, bh8) | 0;
      lo2 = lo2 + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi2 = hi2 + Math.imul(ah7, bh9) | 0;
      var w16 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo2 = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi2 = Math.imul(ah9, bh8);
      lo2 = lo2 + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi2 = hi2 + Math.imul(ah8, bh9) | 0;
      var w17 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo2 = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi2 = Math.imul(ah9, bh9);
      var w18 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o3[0] = w0;
      o3[1] = w1;
      o3[2] = w2;
      o3[3] = w3;
      o3[4] = w4;
      o3[5] = w5;
      o3[6] = w6;
      o3[7] = w7;
      o3[8] = w8;
      o3[9] = w9;
      o3[10] = w10;
      o3[11] = w11;
      o3[12] = w12;
      o3[13] = w13;
      o3[14] = w14;
      o3[15] = w15;
      o3[16] = w16;
      o3[17] = w17;
      o3[18] = w18;
      if (c2 !== 0) {
        o3[19] = c2;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k3 = 0; k3 < out.length - 1; k3++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k3, num.length - 1);
        for (var j2 = Math.max(0, k3 - self2.length + 1); j2 <= maxJ; j2++) {
          var i4 = k3 - j2;
          var a2 = self2.words[i4] | 0;
          var b2 = num.words[j2] | 0;
          var r3 = a2 * b2;
          var lo2 = r3 & 67108863;
          ncarry = ncarry + (r3 / 67108864 | 0) | 0;
          lo2 = lo2 + rword | 0;
          rword = lo2 & 67108863;
          ncarry = ncarry + (lo2 >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k3] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k3] = carry;
      } else {
        out.length--;
      }
      return out.strip();
    }
    function jumboMulTo(self2, num, out) {
      var fftm = new FFTM();
      return fftm.mulp(self2, num, out);
    }
    BN2.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len2 = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len2 < 63) {
        res = smallMulTo(this, num, out);
      } else if (len2 < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    function FFTM(x2, y4) {
      this.x = x2;
      this.y = y4;
    }
    FFTM.prototype.makeRBT = function makeRBT(N3) {
      var t2 = new Array(N3);
      var l2 = BN2.prototype._countBits(N3) - 1;
      for (var i4 = 0; i4 < N3; i4++) {
        t2[i4] = this.revBin(i4, l2, N3);
      }
      return t2;
    };
    FFTM.prototype.revBin = function revBin(x2, l2, N3) {
      if (x2 === 0 || x2 === N3 - 1) return x2;
      var rb = 0;
      for (var i4 = 0; i4 < l2; i4++) {
        rb |= (x2 & 1) << l2 - i4 - 1;
        x2 >>= 1;
      }
      return rb;
    };
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N3) {
      for (var i4 = 0; i4 < N3; i4++) {
        rtws[i4] = rws[rbt[i4]];
        itws[i4] = iws[rbt[i4]];
      }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N3, rbt) {
      this.permute(rbt, rws, iws, rtws, itws, N3);
      for (var s2 = 1; s2 < N3; s2 <<= 1) {
        var l2 = s2 << 1;
        var rtwdf = Math.cos(2 * Math.PI / l2);
        var itwdf = Math.sin(2 * Math.PI / l2);
        for (var p2 = 0; p2 < N3; p2 += l2) {
          var rtwdf_ = rtwdf;
          var itwdf_ = itwdf;
          for (var j2 = 0; j2 < s2; j2++) {
            var re2 = rtws[p2 + j2];
            var ie2 = itws[p2 + j2];
            var ro2 = rtws[p2 + j2 + s2];
            var io2 = itws[p2 + j2 + s2];
            var rx = rtwdf_ * ro2 - itwdf_ * io2;
            io2 = rtwdf_ * io2 + itwdf_ * ro2;
            ro2 = rx;
            rtws[p2 + j2] = re2 + ro2;
            itws[p2 + j2] = ie2 + io2;
            rtws[p2 + j2 + s2] = re2 - ro2;
            itws[p2 + j2 + s2] = ie2 - io2;
            if (j2 !== l2) {
              rx = rtwdf * rtwdf_ - itwdf * itwdf_;
              itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
              rtwdf_ = rx;
            }
          }
        }
      }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n5, m4) {
      var N3 = Math.max(m4, n5) | 1;
      var odd = N3 & 1;
      var i4 = 0;
      for (N3 = N3 / 2 | 0; N3; N3 = N3 >>> 1) {
        i4++;
      }
      return 1 << i4 + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N3) {
      if (N3 <= 1) return;
      for (var i4 = 0; i4 < N3 / 2; i4++) {
        var t2 = rws[i4];
        rws[i4] = rws[N3 - i4 - 1];
        rws[N3 - i4 - 1] = t2;
        t2 = iws[i4];
        iws[i4] = -iws[N3 - i4 - 1];
        iws[N3 - i4 - 1] = -t2;
      }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws2, N3) {
      var carry = 0;
      for (var i4 = 0; i4 < N3 / 2; i4++) {
        var w2 = Math.round(ws2[2 * i4 + 1] / N3) * 8192 + Math.round(ws2[2 * i4] / N3) + carry;
        ws2[i4] = w2 & 67108863;
        if (w2 < 67108864) {
          carry = 0;
        } else {
          carry = w2 / 67108864 | 0;
        }
      }
      return ws2;
    };
    FFTM.prototype.convert13b = function convert13b(ws2, len2, rws, N3) {
      var carry = 0;
      for (var i4 = 0; i4 < len2; i4++) {
        carry = carry + (ws2[i4] | 0);
        rws[2 * i4] = carry & 8191;
        carry = carry >>> 13;
        rws[2 * i4 + 1] = carry & 8191;
        carry = carry >>> 13;
      }
      for (i4 = 2 * len2; i4 < N3; ++i4) {
        rws[i4] = 0;
      }
      assert2(carry === 0);
      assert2((carry & -8192) === 0);
    };
    FFTM.prototype.stub = function stub(N3) {
      var ph = new Array(N3);
      for (var i4 = 0; i4 < N3; i4++) {
        ph[i4] = 0;
      }
      return ph;
    };
    FFTM.prototype.mulp = function mulp(x2, y4, out) {
      var N3 = 2 * this.guessLen13b(x2.length, y4.length);
      var rbt = this.makeRBT(N3);
      var _3 = this.stub(N3);
      var rws = new Array(N3);
      var rwst = new Array(N3);
      var iwst = new Array(N3);
      var nrws = new Array(N3);
      var nrwst = new Array(N3);
      var niwst = new Array(N3);
      var rmws = out.words;
      rmws.length = N3;
      this.convert13b(x2.words, x2.length, rws, N3);
      this.convert13b(y4.words, y4.length, nrws, N3);
      this.transform(rws, _3, rwst, iwst, N3, rbt);
      this.transform(nrws, _3, nrwst, niwst, N3, rbt);
      for (var i4 = 0; i4 < N3; i4++) {
        var rx = rwst[i4] * nrwst[i4] - iwst[i4] * niwst[i4];
        iwst[i4] = rwst[i4] * niwst[i4] + iwst[i4] * nrwst[i4];
        rwst[i4] = rx;
      }
      this.conjugate(rwst, iwst, N3);
      this.transform(rwst, iwst, rmws, _3, N3, rbt);
      this.conjugate(rmws, _3, N3);
      this.normalize13b(rmws, N3);
      out.negative = x2.negative ^ y4.negative;
      out.length = x2.length + y4.length;
      return out.strip();
    };
    BN2.prototype.mul = function mul6(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN2.prototype.mulf = function mulf(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN2.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN2.prototype.imuln = function imuln(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      var carry = 0;
      for (var i4 = 0; i4 < this.length; i4++) {
        var w2 = (this.words[i4] | 0) * num;
        var lo2 = (w2 & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w2 / 67108864 | 0;
        carry += lo2 >>> 26;
        this.words[i4] = lo2 & 67108863;
      }
      if (carry !== 0) {
        this.words[i4] = carry;
        this.length++;
      }
      this.length = num === 0 ? 1 : this.length;
      return this;
    };
    BN2.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN2.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN2.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN2.prototype.pow = function pow3(num) {
      var w2 = toBitArray(num);
      if (w2.length === 0) return new BN2(1);
      var res = this;
      for (var i4 = 0; i4 < w2.length; i4++, res = res.sqr()) {
        if (w2[i4] !== 0) break;
      }
      if (++i4 < w2.length) {
        for (var q2 = res.sqr(); i4 < w2.length; i4++, q2 = q2.sqr()) {
          if (w2[i4] === 0) continue;
          res = res.mul(q2);
        }
      }
      return res;
    };
    BN2.prototype.iushln = function iushln(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r3 = bits % 26;
      var s2 = (bits - r3) / 26;
      var carryMask = 67108863 >>> 26 - r3 << 26 - r3;
      var i4;
      if (r3 !== 0) {
        var carry = 0;
        for (i4 = 0; i4 < this.length; i4++) {
          var newCarry = this.words[i4] & carryMask;
          var c2 = (this.words[i4] | 0) - newCarry << r3;
          this.words[i4] = c2 | carry;
          carry = newCarry >>> 26 - r3;
        }
        if (carry) {
          this.words[i4] = carry;
          this.length++;
        }
      }
      if (s2 !== 0) {
        for (i4 = this.length - 1; i4 >= 0; i4--) {
          this.words[i4 + s2] = this.words[i4];
        }
        for (i4 = 0; i4 < s2; i4++) {
          this.words[i4] = 0;
        }
        this.length += s2;
      }
      return this.strip();
    };
    BN2.prototype.ishln = function ishln(bits) {
      assert2(this.negative === 0);
      return this.iushln(bits);
    };
    BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert2(typeof bits === "number" && bits >= 0);
      var h5;
      if (hint) {
        h5 = (hint - hint % 26) / 26;
      } else {
        h5 = 0;
      }
      var r3 = bits % 26;
      var s2 = Math.min((bits - r3) / 26, this.length);
      var mask2 = 67108863 ^ 67108863 >>> r3 << r3;
      var maskedWords = extended;
      h5 -= s2;
      h5 = Math.max(0, h5);
      if (maskedWords) {
        for (var i4 = 0; i4 < s2; i4++) {
          maskedWords.words[i4] = this.words[i4];
        }
        maskedWords.length = s2;
      }
      if (s2 === 0) ;
      else if (this.length > s2) {
        this.length -= s2;
        for (i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = this.words[i4 + s2];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i4 = this.length - 1; i4 >= 0 && (carry !== 0 || i4 >= h5); i4--) {
        var word = this.words[i4] | 0;
        this.words[i4] = carry << 26 - r3 | word >>> r3;
        carry = word & mask2;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this.strip();
    };
    BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert2(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN2.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN2.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN2.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN2.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN2.prototype.testn = function testn(bit) {
      assert2(typeof bit === "number" && bit >= 0);
      var r3 = bit % 26;
      var s2 = (bit - r3) / 26;
      var q2 = 1 << r3;
      if (this.length <= s2) return false;
      var w2 = this.words[s2];
      return !!(w2 & q2);
    };
    BN2.prototype.imaskn = function imaskn(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r3 = bits % 26;
      var s2 = (bits - r3) / 26;
      assert2(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s2) {
        return this;
      }
      if (r3 !== 0) {
        s2++;
      }
      this.length = Math.min(s2, this.length);
      if (r3 !== 0) {
        var mask2 = 67108863 ^ 67108863 >>> r3 << r3;
        this.words[this.length - 1] &= mask2;
      }
      return this.strip();
    };
    BN2.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN2.prototype.iaddn = function iaddn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0) return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) < num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN2.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i4 = 0; i4 < this.length && this.words[i4] >= 67108864; i4++) {
        this.words[i4] -= 67108864;
        if (i4 === this.length - 1) {
          this.words[i4 + 1] = 1;
        } else {
          this.words[i4 + 1]++;
        }
      }
      this.length = Math.max(this.length, i4 + 1);
      return this;
    };
    BN2.prototype.isubn = function isubn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0) return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i4 = 0; i4 < this.length && this.words[i4] < 0; i4++) {
          this.words[i4] += 67108864;
          this.words[i4 + 1] -= 1;
        }
      }
      return this.strip();
    };
    BN2.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN2.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN2.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN2.prototype.abs = function abs2() {
      return this.clone().iabs();
    };
    BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul6, shift) {
      var len2 = num.length + shift;
      var i4;
      this._expand(len2);
      var w2;
      var carry = 0;
      for (i4 = 0; i4 < num.length; i4++) {
        w2 = (this.words[i4 + shift] | 0) + carry;
        var right = (num.words[i4] | 0) * mul6;
        w2 -= right & 67108863;
        carry = (w2 >> 26) - (right / 67108864 | 0);
        this.words[i4 + shift] = w2 & 67108863;
      }
      for (; i4 < this.length - shift; i4++) {
        w2 = (this.words[i4 + shift] | 0) + carry;
        carry = w2 >> 26;
        this.words[i4 + shift] = w2 & 67108863;
      }
      if (carry === 0) return this.strip();
      assert2(carry === -1);
      carry = 0;
      for (i4 = 0; i4 < this.length; i4++) {
        w2 = -(this.words[i4] | 0) + carry;
        carry = w2 >> 26;
        this.words[i4] = w2 & 67108863;
      }
      this.negative = 1;
      return this.strip();
    };
    BN2.prototype._wordDiv = function _wordDiv(num, mode2) {
      var shift = this.length - num.length;
      var a2 = this.clone();
      var b2 = num;
      var bhi = b2.words[b2.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b2 = b2.ushln(shift);
        a2.iushln(shift);
        bhi = b2.words[b2.length - 1] | 0;
      }
      var m4 = a2.length - b2.length;
      var q2;
      if (mode2 !== "mod") {
        q2 = new BN2(null);
        q2.length = m4 + 1;
        q2.words = new Array(q2.length);
        for (var i4 = 0; i4 < q2.length; i4++) {
          q2.words[i4] = 0;
        }
      }
      var diff = a2.clone()._ishlnsubmul(b2, 1, m4);
      if (diff.negative === 0) {
        a2 = diff;
        if (q2) {
          q2.words[m4] = 1;
        }
      }
      for (var j2 = m4 - 1; j2 >= 0; j2--) {
        var qj = (a2.words[b2.length + j2] | 0) * 67108864 + (a2.words[b2.length + j2 - 1] | 0);
        qj = Math.min(qj / bhi | 0, 67108863);
        a2._ishlnsubmul(b2, qj, j2);
        while (a2.negative !== 0) {
          qj--;
          a2.negative = 0;
          a2._ishlnsubmul(b2, 1, j2);
          if (!a2.isZero()) {
            a2.negative ^= 1;
          }
        }
        if (q2) {
          q2.words[j2] = qj;
        }
      }
      if (q2) {
        q2.strip();
      }
      a2.strip();
      if (mode2 !== "div" && shift !== 0) {
        a2.iushrn(shift);
      }
      return {
        div: q2 || null,
        mod: a2
      };
    };
    BN2.prototype.divmod = function divmod(num, mode2, positive) {
      assert2(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN2(0),
          mod: new BN2(0)
        };
      }
      var div, mod2, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode2);
        if (mode2 !== "mod") {
          div = res.div.neg();
        }
        if (mode2 !== "div") {
          mod2 = res.mod.neg();
          if (positive && mod2.negative !== 0) {
            mod2.iadd(num);
          }
        }
        return {
          div,
          mod: mod2
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode2);
        if (mode2 !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode2);
        if (mode2 !== "div") {
          mod2 = res.mod.neg();
          if (positive && mod2.negative !== 0) {
            mod2.isub(num);
          }
        }
        return {
          div: res.div,
          mod: mod2
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN2(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode2 === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode2 === "mod") {
          return {
            div: null,
            mod: new BN2(this.modn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN2(this.modn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode2);
    };
    BN2.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN2.prototype.mod = function mod2(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN2.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN2.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero()) return dm.div;
      var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r22 = num.andln(1);
      var cmp = mod2.cmp(half);
      if (cmp < 0 || r22 === 1 && cmp === 0) return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN2.prototype.modn = function modn(num) {
      assert2(num <= 67108863);
      var p2 = (1 << 26) % num;
      var acc = 0;
      for (var i4 = this.length - 1; i4 >= 0; i4--) {
        acc = (p2 * acc + (this.words[i4] | 0)) % num;
      }
      return acc;
    };
    BN2.prototype.idivn = function idivn(num) {
      assert2(num <= 67108863);
      var carry = 0;
      for (var i4 = this.length - 1; i4 >= 0; i4--) {
        var w2 = (this.words[i4] | 0) + carry * 67108864;
        this.words[i4] = w2 / num | 0;
        carry = w2 % num;
      }
      return this.strip();
    };
    BN2.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN2.prototype.egcd = function egcd(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var x2 = this;
      var y4 = p2.clone();
      if (x2.negative !== 0) {
        x2 = x2.umod(p2);
      } else {
        x2 = x2.clone();
      }
      var A2 = new BN2(1);
      var B3 = new BN2(0);
      var C2 = new BN2(0);
      var D2 = new BN2(1);
      var g2 = 0;
      while (x2.isEven() && y4.isEven()) {
        x2.iushrn(1);
        y4.iushrn(1);
        ++g2;
      }
      var yp = y4.clone();
      var xp = x2.clone();
      while (!x2.isZero()) {
        for (var i4 = 0, im = 1; (x2.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1) ;
        if (i4 > 0) {
          x2.iushrn(i4);
          while (i4-- > 0) {
            if (A2.isOdd() || B3.isOdd()) {
              A2.iadd(yp);
              B3.isub(xp);
            }
            A2.iushrn(1);
            B3.iushrn(1);
          }
        }
        for (var j2 = 0, jm = 1; (y4.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1) ;
        if (j2 > 0) {
          y4.iushrn(j2);
          while (j2-- > 0) {
            if (C2.isOdd() || D2.isOdd()) {
              C2.iadd(yp);
              D2.isub(xp);
            }
            C2.iushrn(1);
            D2.iushrn(1);
          }
        }
        if (x2.cmp(y4) >= 0) {
          x2.isub(y4);
          A2.isub(C2);
          B3.isub(D2);
        } else {
          y4.isub(x2);
          C2.isub(A2);
          D2.isub(B3);
        }
      }
      return {
        a: C2,
        b: D2,
        gcd: y4.iushln(g2)
      };
    };
    BN2.prototype._invmp = function _invmp(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var a2 = this;
      var b2 = p2.clone();
      if (a2.negative !== 0) {
        a2 = a2.umod(p2);
      } else {
        a2 = a2.clone();
      }
      var x1 = new BN2(1);
      var x2 = new BN2(0);
      var delta = b2.clone();
      while (a2.cmpn(1) > 0 && b2.cmpn(1) > 0) {
        for (var i4 = 0, im = 1; (a2.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1) ;
        if (i4 > 0) {
          a2.iushrn(i4);
          while (i4-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j2 = 0, jm = 1; (b2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1) ;
        if (j2 > 0) {
          b2.iushrn(j2);
          while (j2-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a2.cmp(b2) >= 0) {
          a2.isub(b2);
          x1.isub(x2);
        } else {
          b2.isub(a2);
          x2.isub(x1);
        }
      }
      var res;
      if (a2.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p2);
      }
      return res;
    };
    BN2.prototype.gcd = function gcd(num) {
      if (this.isZero()) return num.abs();
      if (num.isZero()) return this.abs();
      var a2 = this.clone();
      var b2 = num.clone();
      a2.negative = 0;
      b2.negative = 0;
      for (var shift = 0; a2.isEven() && b2.isEven(); shift++) {
        a2.iushrn(1);
        b2.iushrn(1);
      }
      do {
        while (a2.isEven()) {
          a2.iushrn(1);
        }
        while (b2.isEven()) {
          b2.iushrn(1);
        }
        var r3 = a2.cmp(b2);
        if (r3 < 0) {
          var t2 = a2;
          a2 = b2;
          b2 = t2;
        } else if (r3 === 0 || b2.cmpn(1) === 0) {
          break;
        }
        a2.isub(b2);
      } while (true);
      return b2.iushln(shift);
    };
    BN2.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN2.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN2.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN2.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN2.prototype.bincn = function bincn(bit) {
      assert2(typeof bit === "number");
      var r3 = bit % 26;
      var s2 = (bit - r3) / 26;
      var q2 = 1 << r3;
      if (this.length <= s2) {
        this._expand(s2 + 1);
        this.words[s2] |= q2;
        return this;
      }
      var carry = q2;
      for (var i4 = s2; carry !== 0 && i4 < this.length; i4++) {
        var w2 = this.words[i4] | 0;
        w2 += carry;
        carry = w2 >>> 26;
        w2 &= 67108863;
        this.words[i4] = w2;
      }
      if (carry !== 0) {
        this.words[i4] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN2.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative) return -1;
      if (this.negative === 0 && negative) return 1;
      this.strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert2(num <= 67108863, "Number is too big");
        var w2 = this.words[0] | 0;
        res = w2 === num ? 0 : w2 < num ? -1 : 1;
      }
      if (this.negative !== 0) return -res | 0;
      return res;
    };
    BN2.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0) return -1;
      if (this.negative === 0 && num.negative !== 0) return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0) return -res | 0;
      return res;
    };
    BN2.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length) return 1;
      if (this.length < num.length) return -1;
      var res = 0;
      for (var i4 = this.length - 1; i4 >= 0; i4--) {
        var a2 = this.words[i4] | 0;
        var b2 = num.words[i4] | 0;
        if (a2 === b2) continue;
        if (a2 < b2) {
          res = -1;
        } else if (a2 > b2) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN2.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN2.prototype.gt = function gt2(num) {
      return this.cmp(num) === 1;
    };
    BN2.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN2.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN2.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN2.prototype.lt = function lt2(num) {
      return this.cmp(num) === -1;
    };
    BN2.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN2.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN2.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN2.prototype.eq = function eq6(num) {
      return this.cmp(num) === 0;
    };
    BN2.red = function red(num) {
      return new Red(num);
    };
    BN2.prototype.toRed = function toRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      assert2(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN2.prototype.fromRed = function fromRed() {
      assert2(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN2.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN2.prototype.forceRed = function forceRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN2.prototype.redAdd = function redAdd(num) {
      assert2(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN2.prototype.redIAdd = function redIAdd(num) {
      assert2(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN2.prototype.redSub = function redSub(num) {
      assert2(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN2.prototype.redISub = function redISub(num) {
      assert2(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN2.prototype.redShl = function redShl(num) {
      assert2(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN2.prototype.redMul = function redMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN2.prototype.redIMul = function redIMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN2.prototype.redSqr = function redSqr() {
      assert2(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN2.prototype.redISqr = function redISqr() {
      assert2(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN2.prototype.redSqrt = function redSqrt() {
      assert2(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN2.prototype.redInvm = function redInvm() {
      assert2(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN2.prototype.redNeg = function redNeg() {
      assert2(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN2.prototype.redPow = function redPow(num) {
      assert2(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name, p2) {
      this.name = name;
      this.p = new BN2(p2, 16);
      this.n = this.p.bitLength();
      this.k = new BN2(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN2(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r3 = num;
      var rlen;
      do {
        this.split(r3, this.tmp);
        r3 = this.imulK(r3);
        r3 = r3.iadd(this.tmp);
        rlen = r3.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r3.ucmp(this.p);
      if (cmp === 0) {
        r3.words[0] = 0;
        r3.length = 1;
      } else if (cmp > 0) {
        r3.isub(this.p);
      } else {
        if (r3.strip !== void 0) {
          r3.strip();
        } else {
          r3._strip();
        }
      }
      return r3;
    };
    MPrime.prototype.split = function split2(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    inherits2(K256, MPrime);
    K256.prototype.split = function split2(input, output2) {
      var mask2 = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i4 = 0; i4 < outLen; i4++) {
        output2.words[i4] = input.words[i4];
      }
      output2.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output2.words[output2.length++] = prev & mask2;
      for (i4 = 10; i4 < input.length; i4++) {
        var next = input.words[i4] | 0;
        input.words[i4 - 10] = (next & mask2) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i4 - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo2 = 0;
      for (var i4 = 0; i4 < num.length; i4++) {
        var w2 = num.words[i4] | 0;
        lo2 += w2 * 977;
        num.words[i4] = lo2 & 67108863;
        lo2 = w2 * 64 + (lo2 / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    inherits2(P224, MPrime);
    function P192() {
      MPrime.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    inherits2(P192, MPrime);
    function P25519() {
      MPrime.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    inherits2(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i4 = 0; i4 < num.length; i4++) {
        var hi2 = (num.words[i4] | 0) * 19 + carry;
        var lo2 = hi2 & 67108863;
        hi2 >>>= 26;
        num.words[i4] = lo2;
        carry = hi2;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN2._prime = function prime(name) {
      if (primes[name]) return primes[name];
      var prime2;
      if (name === "k256") {
        prime2 = new K256();
      } else if (name === "p224") {
        prime2 = new P224();
      } else if (name === "p192") {
        prime2 = new P192();
      } else if (name === "p25519") {
        prime2 = new P25519();
      } else {
        throw new Error("Unknown prime " + name);
      }
      primes[name] = prime2;
      return prime2;
    };
    function Red(m4) {
      if (typeof m4 === "string") {
        var prime = BN2._prime(m4);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert2(m4.gtn(1), "modulus must be greater than 1");
        this.m = m4;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a2) {
      assert2(a2.negative === 0, "red works only with positives");
      assert2(a2.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a2, b2) {
      assert2((a2.negative | b2.negative) === 0, "red works only with positives");
      assert2(
        a2.red && a2.red === b2.red,
        "red works only with red numbers"
      );
    };
    Red.prototype.imod = function imod(a2) {
      if (this.prime) return this.prime.ireduce(a2)._forceRed(this);
      return a2.umod(this.m)._forceRed(this);
    };
    Red.prototype.neg = function neg4(a2) {
      if (a2.isZero()) {
        return a2.clone();
      }
      return this.m.sub(a2)._forceRed(this);
    };
    Red.prototype.add = function add6(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.add(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.iadd(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.sub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.isub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a2, num) {
      this._verify1(a2);
      return this.imod(a2.ushln(num));
    };
    Red.prototype.imul = function imul(a2, b2) {
      this._verify2(a2, b2);
      return this.imod(a2.imul(b2));
    };
    Red.prototype.mul = function mul6(a2, b2) {
      this._verify2(a2, b2);
      return this.imod(a2.mul(b2));
    };
    Red.prototype.isqr = function isqr(a2) {
      return this.imul(a2, a2.clone());
    };
    Red.prototype.sqr = function sqr(a2) {
      return this.mul(a2, a2);
    };
    Red.prototype.sqrt = function sqrt(a2) {
      if (a2.isZero()) return a2.clone();
      var mod3 = this.m.andln(3);
      assert2(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow3 = this.m.add(new BN2(1)).iushrn(2);
        return this.pow(a2, pow3);
      }
      var q2 = this.m.subn(1);
      var s2 = 0;
      while (!q2.isZero() && q2.andln(1) === 0) {
        s2++;
        q2.iushrn(1);
      }
      assert2(!q2.isZero());
      var one = new BN2(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z3 = this.m.bitLength();
      z3 = new BN2(2 * z3 * z3).toRed(this);
      while (this.pow(z3, lpow).cmp(nOne) !== 0) {
        z3.redIAdd(nOne);
      }
      var c2 = this.pow(z3, q2);
      var r3 = this.pow(a2, q2.addn(1).iushrn(1));
      var t2 = this.pow(a2, q2);
      var m4 = s2;
      while (t2.cmp(one) !== 0) {
        var tmp = t2;
        for (var i4 = 0; tmp.cmp(one) !== 0; i4++) {
          tmp = tmp.redSqr();
        }
        assert2(i4 < m4);
        var b2 = this.pow(c2, new BN2(1).iushln(m4 - i4 - 1));
        r3 = r3.redMul(b2);
        c2 = b2.redSqr();
        t2 = t2.redMul(c2);
        m4 = i4;
      }
      return r3;
    };
    Red.prototype.invm = function invm(a2) {
      var inv = a2._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow3(a2, num) {
      if (num.isZero()) return new BN2(1).toRed(this);
      if (num.cmpn(1) === 0) return a2.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN2(1).toRed(this);
      wnd[1] = a2;
      for (var i4 = 2; i4 < wnd.length; i4++) {
        wnd[i4] = this.mul(wnd[i4 - 1], a2);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i4 = num.length - 1; i4 >= 0; i4--) {
        var word = num.words[i4];
        for (var j2 = start - 1; j2 >= 0; j2--) {
          var bit = word >> j2 & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i4 !== 0 || j2 !== 0)) continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r3 = num.umod(this.m);
      return r3 === num ? r3.clone() : r3;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN2.mont = function mont2(num) {
      return new Mont(num);
    };
    function Mont(m4) {
      Red.call(this, m4);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN2(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits2(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r3 = this.imod(num.mul(this.rinv));
      r3.red = null;
      return r3;
    };
    Mont.prototype.imul = function imul(a2, b2) {
      if (a2.isZero() || b2.isZero()) {
        a2.words[0] = 0;
        a2.length = 1;
        return a2;
      }
      var t2 = a2.imul(b2);
      var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c2).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul6(a2, b2) {
      if (a2.isZero() || b2.isZero()) return new BN2(0)._forceRed(this);
      var t2 = a2.mul(b2);
      var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c2).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a2) {
      var res = this.imod(a2._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(module, commonjsGlobal);
})(bn$8);
var bnExports = bn$8.exports;
var minimalisticAssert = assert$f;
function assert$f(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert$f.equal = function assertEqual(l2, r3, msg) {
  if (l2 != r3)
    throw new Error(msg || "Assertion failed: " + l2 + " != " + r3);
};
var utils$o = {};
(function(exports2) {
  var utils2 = exports2;
  function toArray2(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i4 = 0; i4 < msg.length; i4++)
        res[i4] = msg[i4] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i4 = 0; i4 < msg.length; i4 += 2)
        res.push(parseInt(msg[i4] + msg[i4 + 1], 16));
    } else {
      for (var i4 = 0; i4 < msg.length; i4++) {
        var c2 = msg.charCodeAt(i4);
        var hi2 = c2 >> 8;
        var lo2 = c2 & 255;
        if (hi2)
          res.push(hi2, lo2);
        else
          res.push(lo2);
      }
    }
    return res;
  }
  utils2.toArray = toArray2;
  function zero22(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils2.zero2 = zero22;
  function toHex3(msg) {
    var res = "";
    for (var i4 = 0; i4 < msg.length; i4++)
      res += zero22(msg[i4].toString(16));
    return res;
  }
  utils2.toHex = toHex3;
  utils2.encode = function encode4(arr, enc) {
    if (enc === "hex")
      return toHex3(arr);
    else
      return arr;
  };
})(utils$o);
(function(exports2) {
  var utils2 = exports2;
  var BN2 = bnExports;
  var minAssert = minimalisticAssert;
  var minUtils = utils$o;
  utils2.assert = minAssert;
  utils2.toArray = minUtils.toArray;
  utils2.zero2 = minUtils.zero2;
  utils2.toHex = minUtils.toHex;
  utils2.encode = minUtils.encode;
  function getNAF2(num, w2, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    var i4;
    for (i4 = 0; i4 < naf.length; i4 += 1) {
      naf[i4] = 0;
    }
    var ws2 = 1 << w2 + 1;
    var k3 = num.clone();
    for (i4 = 0; i4 < naf.length; i4++) {
      var z3;
      var mod2 = k3.andln(ws2 - 1);
      if (k3.isOdd()) {
        if (mod2 > (ws2 >> 1) - 1)
          z3 = (ws2 >> 1) - mod2;
        else
          z3 = mod2;
        k3.isubn(z3);
      } else {
        z3 = 0;
      }
      naf[i4] = z3;
      k3.iushrn(1);
    }
    return naf;
  }
  utils2.getNAF = getNAF2;
  function getJSF2(k1, k22) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k22 = k22.clone();
    var d1 = 0;
    var d22 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k22.cmpn(-d22) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k22.andln(3) + d22 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k22.andln(7) + d22 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d22 === u2 + 1)
        d22 = 1 - d22;
      k1.iushrn(1);
      k22.iushrn(1);
    }
    return jsf;
  }
  utils2.getJSF = getJSF2;
  function cachedProperty2(obj, name, computer) {
    var key2 = "_" + name;
    obj.prototype[name] = function cachedProperty3() {
      return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
    };
  }
  utils2.cachedProperty = cachedProperty2;
  function parseBytes2(bytes2) {
    return typeof bytes2 === "string" ? utils2.toArray(bytes2, "hex") : bytes2;
  }
  utils2.parseBytes = parseBytes2;
  function intFromLE(bytes2) {
    return new BN2(bytes2, "hex", "le");
  }
  utils2.intFromLE = intFromLE;
})(utils$p);
var brorand = { exports: {} };
var cryptoBrowserify = {};
var browser$c = { exports: {} };
var safeBuffer$1 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer$1;
function requireSafeBuffer$1() {
  if (hasRequiredSafeBuffer$1) return safeBuffer$1.exports;
  hasRequiredSafeBuffer$1 = 1;
  (function(module, exports2) {
    var buffer2 = require$$1$2;
    var Buffer2 = buffer2.Buffer;
    function copyProps(src2, dst) {
      for (var key2 in src2) {
        dst[key2] = src2[key2];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer2;
    } else {
      copyProps(buffer2, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size2, fill, encoding) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size2);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size2) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size2);
    };
    SafeBuffer.allocUnsafeSlow = function(size2) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size2);
    };
  })(safeBuffer$1, safeBuffer$1.exports);
  return safeBuffer$1.exports;
}
var hasRequiredBrowser$b;
function requireBrowser$b() {
  if (hasRequiredBrowser$b) return browser$c.exports;
  hasRequiredBrowser$b = 1;
  var MAX_BYTES = 65536;
  var MAX_UINT32 = 4294967295;
  function oldBrowser() {
    throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
  }
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var crypto2 = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
  if (crypto2 && crypto2.getRandomValues) {
    browser$c.exports = randomBytes2;
  } else {
    browser$c.exports = oldBrowser;
  }
  function randomBytes2(size2, cb) {
    if (size2 > MAX_UINT32) throw new RangeError("requested too many random bytes");
    var bytes2 = Buffer2.allocUnsafe(size2);
    if (size2 > 0) {
      if (size2 > MAX_BYTES) {
        for (var generated = 0; generated < size2; generated += MAX_BYTES) {
          crypto2.getRandomValues(bytes2.slice(generated, generated + MAX_BYTES));
        }
      } else {
        crypto2.getRandomValues(bytes2);
      }
    }
    if (typeof cb === "function") {
      return process$1.nextTick(function() {
        cb(null, bytes2);
      });
    }
    return bytes2;
  }
  return browser$c.exports;
}
var inherits_browser = { exports: {} };
if (typeof Object.create === "function") {
  inherits_browser.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  inherits_browser.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
var inherits_browserExports = inherits_browser.exports;
var isarray$1;
var hasRequiredIsarray$1;
function requireIsarray$1() {
  if (hasRequiredIsarray$1) return isarray$1;
  hasRequiredIsarray$1 = 1;
  var toString2 = {}.toString;
  isarray$1 = Array.isArray || function(arr) {
    return toString2.call(arr) == "[object Array]";
  };
  return isarray$1;
}
var type;
var hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;
  type = TypeError;
  return type;
}
var esObjectAtoms;
var hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
  if (hasRequiredEsObjectAtoms) return esObjectAtoms;
  hasRequiredEsObjectAtoms = 1;
  esObjectAtoms = Object;
  return esObjectAtoms;
}
var esErrors;
var hasRequiredEsErrors;
function requireEsErrors() {
  if (hasRequiredEsErrors) return esErrors;
  hasRequiredEsErrors = 1;
  esErrors = Error;
  return esErrors;
}
var _eval;
var hasRequired_eval;
function require_eval() {
  if (hasRequired_eval) return _eval;
  hasRequired_eval = 1;
  _eval = EvalError;
  return _eval;
}
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  range = RangeError;
  return range;
}
var ref;
var hasRequiredRef;
function requireRef() {
  if (hasRequiredRef) return ref;
  hasRequiredRef = 1;
  ref = ReferenceError;
  return ref;
}
var syntax;
var hasRequiredSyntax;
function requireSyntax() {
  if (hasRequiredSyntax) return syntax;
  hasRequiredSyntax = 1;
  syntax = SyntaxError;
  return syntax;
}
var uri;
var hasRequiredUri;
function requireUri() {
  if (hasRequiredUri) return uri;
  hasRequiredUri = 1;
  uri = URIError;
  return uri;
}
var abs;
var hasRequiredAbs;
function requireAbs() {
  if (hasRequiredAbs) return abs;
  hasRequiredAbs = 1;
  abs = Math.abs;
  return abs;
}
var floor;
var hasRequiredFloor;
function requireFloor() {
  if (hasRequiredFloor) return floor;
  hasRequiredFloor = 1;
  floor = Math.floor;
  return floor;
}
var max;
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax) return max;
  hasRequiredMax = 1;
  max = Math.max;
  return max;
}
var min;
var hasRequiredMin;
function requireMin() {
  if (hasRequiredMin) return min;
  hasRequiredMin = 1;
  min = Math.min;
  return min;
}
var pow$1;
var hasRequiredPow;
function requirePow() {
  if (hasRequiredPow) return pow$1;
  hasRequiredPow = 1;
  pow$1 = Math.pow;
  return pow$1;
}
var round;
var hasRequiredRound;
function requireRound() {
  if (hasRequiredRound) return round;
  hasRequiredRound = 1;
  round = Math.round;
  return round;
}
var _isNaN;
var hasRequired_isNaN;
function require_isNaN() {
  if (hasRequired_isNaN) return _isNaN;
  hasRequired_isNaN = 1;
  _isNaN = Number.isNaN || function isNaN2(a2) {
    return a2 !== a2;
  };
  return _isNaN;
}
var sign$1;
var hasRequiredSign$1;
function requireSign$1() {
  if (hasRequiredSign$1) return sign$1;
  hasRequiredSign$1 = 1;
  var $isNaN = require_isNaN();
  sign$1 = function sign5(number2) {
    if ($isNaN(number2) || number2 === 0) {
      return number2;
    }
    return number2 < 0 ? -1 : 1;
  };
  return sign$1;
}
var gOPD;
var hasRequiredGOPD;
function requireGOPD() {
  if (hasRequiredGOPD) return gOPD;
  hasRequiredGOPD = 1;
  gOPD = Object.getOwnPropertyDescriptor;
  return gOPD;
}
var gopd;
var hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var $gOPD = requireGOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e3) {
      $gOPD = null;
    }
  }
  gopd = $gOPD;
  return gopd;
}
var esDefineProperty;
var hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e3) {
      $defineProperty = false;
    }
  }
  esDefineProperty = $defineProperty;
  return esDefineProperty;
}
var shams$1;
var hasRequiredShams$1;
function requireShams$1() {
  if (hasRequiredShams$1) return shams$1;
  hasRequiredShams$1 = 1;
  shams$1 = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _3 in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(obj, sym)
      );
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams$1;
}
var hasSymbols;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams$1();
  hasSymbols = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols;
}
var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;
  hasRequiredReflect_getPrototypeOf = 1;
  Reflect_getPrototypeOf = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  return Reflect_getPrototypeOf;
}
var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var $Object = requireEsObjectAtoms();
  Object_getPrototypeOf = $Object.getPrototypeOf || null;
  return Object_getPrototypeOf;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max2 = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a2, b2) {
    var arr = [];
    for (var i4 = 0; i4 < a2.length; i4 += 1) {
      arr[i4] = a2[i4];
    }
    for (var j2 = 0; j2 < b2.length; j2 += 1) {
      arr[j2 + a2.length] = b2[j2];
    }
    return arr;
  };
  var slicy = function slicy2(arrLike, offset) {
    var arr = [];
    for (var i4 = offset, j2 = 0; i4 < arrLike.length; i4 += 1, j2 += 1) {
      arr[j2] = arrLike[i4];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i4 = 0; i4 < arr.length; i4 += 1) {
      str += arr[i4];
      if (i4 + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  implementation = function bind2(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(
          this,
          concatty(args, arguments)
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(
        that,
        concatty(args, arguments)
      );
    };
    var boundLength = max2(0, target.length - args.length);
    var boundArgs = [];
    for (var i4 = 0; i4 < boundLength; i4++) {
      boundArgs[i4] = "$" + i4;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty2 = function Empty3() {
      };
      Empty2.prototype = target.prototype;
      bound.prototype = new Empty2();
      Empty2.prototype = null;
    }
    return bound;
  };
  return implementation;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation2 = requireImplementation();
  functionBind = Function.prototype.bind || implementation2;
  return functionBind;
}
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;
  functionCall = Function.prototype.call;
  return functionCall;
}
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply) return functionApply;
  hasRequiredFunctionApply = 1;
  functionApply = Function.prototype.apply;
  return functionApply;
}
var reflectApply;
var hasRequiredReflectApply;
function requireReflectApply() {
  if (hasRequiredReflectApply) return reflectApply;
  hasRequiredReflectApply = 1;
  reflectApply = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  return reflectApply;
}
var actualApply;
var hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var bind2 = requireFunctionBind();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var $reflectApply = requireReflectApply();
  actualApply = $reflectApply || bind2.call($call, $apply);
  return actualApply;
}
var callBindApplyHelpers;
var hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var bind2 = requireFunctionBind();
  var $TypeError = requireType();
  var $call = requireFunctionCall();
  var $actualApply = requireActualApply();
  callBindApplyHelpers = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind2, $call, args);
  };
  return callBindApplyHelpers;
}
var get;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var callBind2 = requireCallBindApplyHelpers();
  var gOPD2 = requireGopd();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (e3) {
    if (!e3 || typeof e3 !== "object" || !("code" in e3) || e3.code !== "ERR_PROTO_ACCESS") {
      throw e3;
    }
  }
  var desc = !!hasProtoAccessor && gOPD2 && gOPD2(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  );
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  get = desc && typeof desc.get === "function" ? callBind2([desc.get]) : typeof $getPrototypeOf === "function" ? (
    /** @type {import('./get')} */
    function getDunder(value) {
      return $getPrototypeOf(value == null ? value : $Object(value));
    }
  ) : false;
  return get;
}
var getProto;
var hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto;
  hasRequiredGetProto = 1;
  var reflectGetProto = requireReflect_getPrototypeOf();
  var originalGetProto = requireObject_getPrototypeOf();
  var getDunderProto = requireGet();
  getProto = reflectGetProto ? function getProto2(O4) {
    return reflectGetProto(O4);
  } : originalGetProto ? function getProto2(O4) {
    if (!O4 || typeof O4 !== "object" && typeof O4 !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O4);
  } : getDunderProto ? function getProto2(O4) {
    return getDunderProto(O4);
  } : null;
  return getProto;
}
var hasown;
var hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind2 = requireFunctionBind();
  hasown = bind2.call(call, $hasOwn);
  return hasown;
}
var getIntrinsic;
var hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var undefined$1;
  var $Object = requireEsObjectAtoms();
  var $Error = requireEsErrors();
  var $EvalError = require_eval();
  var $RangeError = requireRange();
  var $ReferenceError = requireRef();
  var $SyntaxError = requireSyntax();
  var $TypeError = requireType();
  var $URIError = requireUri();
  var abs2 = requireAbs();
  var floor2 = requireFloor();
  var max2 = requireMax();
  var min2 = requireMin();
  var pow3 = requirePow();
  var round2 = requireRound();
  var sign5 = requireSign$1();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e3) {
    }
  };
  var $gOPD = requireGopd();
  var $defineProperty = requireEsDefineProperty();
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols2 = requireHasSymbols()();
  var getProto2 = requireGetProto();
  var $ObjectGPO = requireObject_getPrototypeOf();
  var $ReflectGPO = requireReflect_getPrototypeOf();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto2 ? undefined$1 : getProto2(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": $EvalError,
    "%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Object.getPrototypeOf%": $ObjectGPO,
    "%Math.abs%": abs2,
    "%Math.floor%": floor2,
    "%Math.max%": max2,
    "%Math.min%": min2,
    "%Math.pow%": pow3,
    "%Math.round%": round2,
    "%Math.sign%": sign5,
    "%Reflect.getPrototypeOf%": $ReflectGPO
  };
  if (getProto2) {
    try {
      null.error;
    } catch (e3) {
      var errorProto = getProto2(getProto2(e3));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var doEval = function doEval2(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn2 = doEval2("%AsyncGeneratorFunction%");
      if (fn2) {
        value = fn2.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen2 = doEval2("%AsyncGenerator%");
      if (gen2 && getProto2) {
        value = getProto2(gen2.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind2 = requireFunctionBind();
  var hasOwn = requireHasown();
  var $concat = bind2.call($call, Array.prototype.concat);
  var $spliceApply = bind2.call($apply, Array.prototype.splice);
  var $replace = bind2.call($call, String.prototype.replace);
  var $strSlice = bind2.call($call, String.prototype.slice);
  var $exec = bind2.call($call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string2) {
    var first = $strSlice(string2, 0, 1);
    var last = $strSlice(string2, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string2, rePropName, function(match, number2, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number2 || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  getIntrinsic = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i4 = 1, isOwn = true; i4 < parts.length; i4 += 1) {
      var part = parts[i4];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return void 0;
        }
        if ($gOPD && i4 + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  return getIntrinsic;
}
var callBound;
var hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var callBindBasic = requireCallBindApplyHelpers();
  var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
  callBound = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = (
      /** @type {(this: unknown, ...args: unknown[]) => unknown} */
      GetIntrinsic(name, !!allowMissing)
    );
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBindBasic(
        /** @type {const} */
        [intrinsic]
      );
    }
    return intrinsic;
  };
  return callBound;
}
var isCallable;
var hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable) return isCallable;
  hasRequiredIsCallable = 1;
  var fnToStr = Function.prototype.toString;
  var reflectApply2 = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
  var badArrayLike;
  var isCallableMarker;
  if (typeof reflectApply2 === "function" && typeof Object.defineProperty === "function") {
    try {
      badArrayLike = Object.defineProperty({}, "length", {
        get: function() {
          throw isCallableMarker;
        }
      });
      isCallableMarker = {};
      reflectApply2(function() {
        throw 42;
      }, null, badArrayLike);
    } catch (_3) {
      if (_3 !== isCallableMarker) {
        reflectApply2 = null;
      }
    }
  } else {
    reflectApply2 = null;
  }
  var constructorRegex = /^\s*class\b/;
  var isES6ClassFn = function isES6ClassFunction(value) {
    try {
      var fnStr = fnToStr.call(value);
      return constructorRegex.test(fnStr);
    } catch (e3) {
      return false;
    }
  };
  var tryFunctionObject = function tryFunctionToStr(value) {
    try {
      if (isES6ClassFn(value)) {
        return false;
      }
      fnToStr.call(value);
      return true;
    } catch (e3) {
      return false;
    }
  };
  var toStr = Object.prototype.toString;
  var objectClass = "[object Object]";
  var fnClass = "[object Function]";
  var genClass = "[object GeneratorFunction]";
  var ddaClass = "[object HTMLAllCollection]";
  var ddaClass2 = "[object HTML document.all class]";
  var ddaClass3 = "[object HTMLCollection]";
  var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
  var isIE68 = !(0 in [,]);
  var isDDA = function isDocumentDotAll() {
    return false;
  };
  if (typeof document === "object") {
    var all = document.all;
    if (toStr.call(all) === toStr.call(document.all)) {
      isDDA = function isDocumentDotAll(value) {
        if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
          try {
            var str = toStr.call(value);
            return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
          } catch (e3) {
          }
        }
        return false;
      };
    }
  }
  isCallable = reflectApply2 ? function isCallable2(value) {
    if (isDDA(value)) {
      return true;
    }
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    try {
      reflectApply2(value, null, badArrayLike);
    } catch (e3) {
      if (e3 !== isCallableMarker) {
        return false;
      }
    }
    return !isES6ClassFn(value) && tryFunctionObject(value);
  } : function isCallable2(value) {
    if (isDDA(value)) {
      return true;
    }
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    if (hasToStringTag) {
      return tryFunctionObject(value);
    }
    if (isES6ClassFn(value)) {
      return false;
    }
    var strClass = toStr.call(value);
    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
      return false;
    }
    return tryFunctionObject(value);
  };
  return isCallable;
}
var forEach;
var hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach) return forEach;
  hasRequiredForEach = 1;
  var isCallable2 = requireIsCallable();
  var toStr = Object.prototype.toString;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var forEachArray = function forEachArray2(array, iterator, receiver) {
    for (var i4 = 0, len2 = array.length; i4 < len2; i4++) {
      if (hasOwnProperty.call(array, i4)) {
        if (receiver == null) {
          iterator(array[i4], i4, array);
        } else {
          iterator.call(receiver, array[i4], i4, array);
        }
      }
    }
  };
  var forEachString = function forEachString2(string2, iterator, receiver) {
    for (var i4 = 0, len2 = string2.length; i4 < len2; i4++) {
      if (receiver == null) {
        iterator(string2.charAt(i4), i4, string2);
      } else {
        iterator.call(receiver, string2.charAt(i4), i4, string2);
      }
    }
  };
  var forEachObject = function forEachObject2(object2, iterator, receiver) {
    for (var k3 in object2) {
      if (hasOwnProperty.call(object2, k3)) {
        if (receiver == null) {
          iterator(object2[k3], k3, object2);
        } else {
          iterator.call(receiver, object2[k3], k3, object2);
        }
      }
    }
  };
  function isArray(x2) {
    return toStr.call(x2) === "[object Array]";
  }
  forEach = function forEach2(list, iterator, thisArg) {
    if (!isCallable2(iterator)) {
      throw new TypeError("iterator must be a function");
    }
    var receiver;
    if (arguments.length >= 3) {
      receiver = thisArg;
    }
    if (isArray(list)) {
      forEachArray(list, iterator, receiver);
    } else if (typeof list === "string") {
      forEachString(list, iterator, receiver);
    } else {
      forEachObject(list, iterator, receiver);
    }
  };
  return forEach;
}
var possibleTypedArrayNames;
var hasRequiredPossibleTypedArrayNames;
function requirePossibleTypedArrayNames() {
  if (hasRequiredPossibleTypedArrayNames) return possibleTypedArrayNames;
  hasRequiredPossibleTypedArrayNames = 1;
  possibleTypedArrayNames = [
    "Float16Array",
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ];
  return possibleTypedArrayNames;
}
var availableTypedArrays;
var hasRequiredAvailableTypedArrays;
function requireAvailableTypedArrays() {
  if (hasRequiredAvailableTypedArrays) return availableTypedArrays;
  hasRequiredAvailableTypedArrays = 1;
  var possibleNames = requirePossibleTypedArrayNames();
  var g2 = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
  availableTypedArrays = function availableTypedArrays2() {
    var out = [];
    for (var i4 = 0; i4 < possibleNames.length; i4++) {
      if (typeof g2[possibleNames[i4]] === "function") {
        out[out.length] = possibleNames[i4];
      }
    }
    return out;
  };
  return availableTypedArrays;
}
var callBind = { exports: {} };
var defineDataProperty;
var hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty) return defineDataProperty;
  hasRequiredDefineDataProperty = 1;
  var $defineProperty = requireEsDefineProperty();
  var $SyntaxError = requireSyntax();
  var $TypeError = requireType();
  var gopd2 = requireGopd();
  defineDataProperty = function defineDataProperty2(obj, property, value) {
    if (!obj || typeof obj !== "object" && typeof obj !== "function") {
      throw new $TypeError("`obj` must be an object or a function`");
    }
    if (typeof property !== "string" && typeof property !== "symbol") {
      throw new $TypeError("`property` must be a string or a symbol`");
    }
    if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
      throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
      throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
      throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
      throw new $TypeError("`loose`, if provided, must be a boolean");
    }
    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
    var nonWritable = arguments.length > 4 ? arguments[4] : null;
    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
    var loose = arguments.length > 6 ? arguments[6] : false;
    var desc = !!gopd2 && gopd2(obj, property);
    if ($defineProperty) {
      $defineProperty(obj, property, {
        configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
        enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
        value,
        writable: nonWritable === null && desc ? desc.writable : !nonWritable
      });
    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
      obj[property] = value;
    } else {
      throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
    }
  };
  return defineDataProperty;
}
var hasPropertyDescriptors_1;
var hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var $defineProperty = requireEsDefineProperty();
  var hasPropertyDescriptors = function hasPropertyDescriptors2() {
    return !!$defineProperty;
  };
  hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    if (!$defineProperty) {
      return null;
    }
    try {
      return $defineProperty([], "length", { value: 1 }).length !== 1;
    } catch (e3) {
      return true;
    }
  };
  hasPropertyDescriptors_1 = hasPropertyDescriptors;
  return hasPropertyDescriptors_1;
}
var setFunctionLength;
var hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength) return setFunctionLength;
  hasRequiredSetFunctionLength = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var define = requireDefineDataProperty();
  var hasDescriptors = requireHasPropertyDescriptors()();
  var gOPD2 = requireGopd();
  var $TypeError = requireType();
  var $floor = GetIntrinsic("%Math.floor%");
  setFunctionLength = function setFunctionLength2(fn2, length) {
    if (typeof fn2 !== "function") {
      throw new $TypeError("`fn` is not a function");
    }
    if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
      throw new $TypeError("`length` must be a positive 32-bit integer");
    }
    var loose = arguments.length > 2 && !!arguments[2];
    var functionLengthIsConfigurable = true;
    var functionLengthIsWritable = true;
    if ("length" in fn2 && gOPD2) {
      var desc = gOPD2(fn2, "length");
      if (desc && !desc.configurable) {
        functionLengthIsConfigurable = false;
      }
      if (desc && !desc.writable) {
        functionLengthIsWritable = false;
      }
    }
    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
      if (hasDescriptors) {
        define(
          /** @type {Parameters<define>[0]} */
          fn2,
          "length",
          length,
          true,
          true
        );
      } else {
        define(
          /** @type {Parameters<define>[0]} */
          fn2,
          "length",
          length
        );
      }
    }
    return fn2;
  };
  return setFunctionLength;
}
var applyBind;
var hasRequiredApplyBind;
function requireApplyBind() {
  if (hasRequiredApplyBind) return applyBind;
  hasRequiredApplyBind = 1;
  var bind2 = requireFunctionBind();
  var $apply = requireFunctionApply();
  var actualApply2 = requireActualApply();
  applyBind = function applyBind2() {
    return actualApply2(bind2, $apply, arguments);
  };
  return applyBind;
}
var hasRequiredCallBind;
function requireCallBind() {
  if (hasRequiredCallBind) return callBind.exports;
  hasRequiredCallBind = 1;
  (function(module) {
    var setFunctionLength2 = requireSetFunctionLength();
    var $defineProperty = requireEsDefineProperty();
    var callBindBasic = requireCallBindApplyHelpers();
    var applyBind2 = requireApplyBind();
    module.exports = function callBind2(originalFunction) {
      var func = callBindBasic(arguments);
      var adjustedLength = originalFunction.length - (arguments.length - 1);
      return setFunctionLength2(
        func,
        1 + (adjustedLength > 0 ? adjustedLength : 0),
        true
      );
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind2 });
    } else {
      module.exports.apply = applyBind2;
    }
  })(callBind);
  return callBind.exports;
}
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  var hasSymbols2 = requireShams$1();
  shams = function hasToStringTagShams() {
    return hasSymbols2() && !!Symbol.toStringTag;
  };
  return shams;
}
var whichTypedArray;
var hasRequiredWhichTypedArray;
function requireWhichTypedArray() {
  if (hasRequiredWhichTypedArray) return whichTypedArray;
  hasRequiredWhichTypedArray = 1;
  var forEach2 = requireForEach();
  var availableTypedArrays2 = requireAvailableTypedArrays();
  var callBind2 = requireCallBind();
  var callBound2 = requireCallBound();
  var gOPD2 = requireGopd();
  var getProto2 = requireGetProto();
  var $toString = callBound2("Object.prototype.toString");
  var hasToStringTag = requireShams()();
  var g2 = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
  var typedArrays = availableTypedArrays2();
  var $slice = callBound2("String.prototype.slice");
  var $indexOf = callBound2("Array.prototype.indexOf", true) || function indexOf2(array, value) {
    for (var i4 = 0; i4 < array.length; i4 += 1) {
      if (array[i4] === value) {
        return i4;
      }
    }
    return -1;
  };
  var cache = { __proto__: null };
  if (hasToStringTag && gOPD2 && getProto2) {
    forEach2(typedArrays, function(typedArray) {
      var arr = new g2[typedArray]();
      if (Symbol.toStringTag in arr && getProto2) {
        var proto = getProto2(arr);
        var descriptor = gOPD2(proto, Symbol.toStringTag);
        if (!descriptor && proto) {
          var superProto = getProto2(proto);
          descriptor = gOPD2(superProto, Symbol.toStringTag);
        }
        cache["$" + typedArray] = callBind2(descriptor.get);
      }
    });
  } else {
    forEach2(typedArrays, function(typedArray) {
      var arr = new g2[typedArray]();
      var fn2 = arr.slice || arr.set;
      if (fn2) {
        cache[
          /** @type {`$${import('.').TypedArrayName}`} */
          "$" + typedArray
        ] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
        // @ts-expect-error TODO FIXME
        callBind2(fn2);
      }
    });
  }
  var tryTypedArrays = function tryAllTypedArrays(value) {
    var found = false;
    forEach2(
      /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
      cache,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(getter, typedArray) {
        if (!found) {
          try {
            if ("$" + getter(value) === typedArray) {
              found = /** @type {import('.').TypedArrayName} */
              $slice(typedArray, 1);
            }
          } catch (e3) {
          }
        }
      }
    );
    return found;
  };
  var trySlices = function tryAllSlices(value) {
    var found = false;
    forEach2(
      /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
      cache,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(getter, name) {
        if (!found) {
          try {
            getter(value);
            found = /** @type {import('.').TypedArrayName} */
            $slice(name, 1);
          } catch (e3) {
          }
        }
      }
    );
    return found;
  };
  whichTypedArray = function whichTypedArray2(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    if (!hasToStringTag) {
      var tag = $slice($toString(value), 8, -1);
      if ($indexOf(typedArrays, tag) > -1) {
        return tag;
      }
      if (tag !== "Object") {
        return false;
      }
      return trySlices(value);
    }
    if (!gOPD2) {
      return null;
    }
    return tryTypedArrays(value);
  };
  return whichTypedArray;
}
var isTypedArray;
var hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray) return isTypedArray;
  hasRequiredIsTypedArray = 1;
  var whichTypedArray2 = requireWhichTypedArray();
  isTypedArray = function isTypedArray2(value) {
    return !!whichTypedArray2(value);
  };
  return isTypedArray;
}
var typedArrayBuffer;
var hasRequiredTypedArrayBuffer;
function requireTypedArrayBuffer() {
  if (hasRequiredTypedArrayBuffer) return typedArrayBuffer;
  hasRequiredTypedArrayBuffer = 1;
  var $TypeError = requireType();
  var callBound2 = requireCallBound();
  var $typedArrayBuffer = callBound2("TypedArray.prototype.buffer", true);
  var isTypedArray2 = requireIsTypedArray();
  typedArrayBuffer = $typedArrayBuffer || function typedArrayBuffer2(x2) {
    if (!isTypedArray2(x2)) {
      throw new $TypeError("Not a Typed Array");
    }
    return x2.buffer;
  };
  return typedArrayBuffer;
}
var toBuffer;
var hasRequiredToBuffer$2;
function requireToBuffer$2() {
  if (hasRequiredToBuffer$2) return toBuffer;
  hasRequiredToBuffer$2 = 1;
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var isArray = requireIsarray$1();
  var typedArrayBuffer2 = requireTypedArrayBuffer();
  var isView = ArrayBuffer.isView || function isView2(obj) {
    try {
      typedArrayBuffer2(obj);
      return true;
    } catch (e3) {
      return false;
    }
  };
  var useUint8Array = typeof Uint8Array !== "undefined";
  var useArrayBuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
  var useFromArrayBuffer = useArrayBuffer && (Buffer2.prototype instanceof Uint8Array || Buffer2.TYPED_ARRAY_SUPPORT);
  toBuffer = function toBuffer2(data2, encoding) {
    if (Buffer2.isBuffer(data2)) {
      if (data2.constructor && !("isBuffer" in data2)) {
        return Buffer2.from(data2);
      }
      return data2;
    }
    if (typeof data2 === "string") {
      return Buffer2.from(data2, encoding);
    }
    if (useArrayBuffer && isView(data2)) {
      if (data2.byteLength === 0) {
        return Buffer2.alloc(0);
      }
      if (useFromArrayBuffer) {
        var res = Buffer2.from(data2.buffer, data2.byteOffset, data2.byteLength);
        if (res.byteLength === data2.byteLength) {
          return res;
        }
      }
      var uint8 = data2 instanceof Uint8Array ? data2 : new Uint8Array(data2.buffer, data2.byteOffset, data2.byteLength);
      var result = Buffer2.from(uint8);
      if (result.length === data2.byteLength) {
        return result;
      }
    }
    if (useUint8Array && data2 instanceof Uint8Array) {
      return Buffer2.from(data2);
    }
    var isArr = isArray(data2);
    if (isArr) {
      for (var i4 = 0; i4 < data2.length; i4 += 1) {
        var x2 = data2[i4];
        if (typeof x2 !== "number" || x2 < 0 || x2 > 255 || ~~x2 !== x2) {
          throw new RangeError("Array items must be numbers in the range 0-255.");
        }
      }
    }
    if (isArr || Buffer2.isBuffer(data2) && data2.constructor && typeof data2.constructor.isBuffer === "function" && data2.constructor.isBuffer(data2)) {
      return Buffer2.from(data2);
    }
    throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.');
  };
  return toBuffer;
}
var toBuffer_1$1;
var hasRequiredToBuffer$1;
function requireToBuffer$1() {
  if (hasRequiredToBuffer$1) return toBuffer_1$1;
  hasRequiredToBuffer$1 = 1;
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var toBuffer2 = requireToBuffer$2();
  var useUint8Array = typeof Uint8Array !== "undefined";
  var useArrayBuffer = useUint8Array && typeof ArrayBuffer !== "undefined";
  var isView = useArrayBuffer && ArrayBuffer.isView;
  toBuffer_1$1 = function(thing, encoding) {
    if (typeof thing === "string" || Buffer2.isBuffer(thing) || useUint8Array && thing instanceof Uint8Array || isView && isView(thing)) {
      return toBuffer2(thing, encoding);
    }
    throw new TypeError('The "data" argument must be a string, a Buffer, a Uint8Array, or a DataView');
  };
  return toBuffer_1$1;
}
var readableBrowser = { exports: {} };
var processNextickArgs = { exports: {} };
var hasRequiredProcessNextickArgs;
function requireProcessNextickArgs() {
  if (hasRequiredProcessNextickArgs) return processNextickArgs.exports;
  hasRequiredProcessNextickArgs = 1;
  if (typeof process$1 === "undefined" || !process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0) {
    processNextickArgs.exports = { nextTick };
  } else {
    processNextickArgs.exports = process$1;
  }
  function nextTick(fn2, arg1, arg2, arg3) {
    if (typeof fn2 !== "function") {
      throw new TypeError('"callback" argument must be a function');
    }
    var len2 = arguments.length;
    var args, i4;
    switch (len2) {
      case 0:
      case 1:
        return process$1.nextTick(fn2);
      case 2:
        return process$1.nextTick(function afterTickOne() {
          fn2.call(null, arg1);
        });
      case 3:
        return process$1.nextTick(function afterTickTwo() {
          fn2.call(null, arg1, arg2);
        });
      case 4:
        return process$1.nextTick(function afterTickThree() {
          fn2.call(null, arg1, arg2, arg3);
        });
      default:
        args = new Array(len2 - 1);
        i4 = 0;
        while (i4 < args.length) {
          args[i4++] = arguments[i4];
        }
        return process$1.nextTick(function afterTick() {
          fn2.apply(null, args);
        });
    }
  }
  return processNextickArgs.exports;
}
var isarray;
var hasRequiredIsarray;
function requireIsarray() {
  if (hasRequiredIsarray) return isarray;
  hasRequiredIsarray = 1;
  var toString2 = {}.toString;
  isarray = Array.isArray || function(arr) {
    return toString2.call(arr) == "[object Array]";
  };
  return isarray;
}
var streamBrowser$1;
var hasRequiredStreamBrowser$1;
function requireStreamBrowser$1() {
  if (hasRequiredStreamBrowser$1) return streamBrowser$1;
  hasRequiredStreamBrowser$1 = 1;
  streamBrowser$1 = eventsExports.EventEmitter;
  return streamBrowser$1;
}
var safeBuffer = { exports: {} };
var hasRequiredSafeBuffer;
function requireSafeBuffer() {
  if (hasRequiredSafeBuffer) return safeBuffer.exports;
  hasRequiredSafeBuffer = 1;
  (function(module, exports2) {
    var buffer2 = require$$1$2;
    var Buffer2 = buffer2.Buffer;
    function copyProps(src2, dst) {
      for (var key2 in src2) {
        dst[key2] = src2[key2];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer2;
    } else {
      copyProps(buffer2, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size2, fill, encoding) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size2);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size2) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size2);
    };
    SafeBuffer.allocUnsafeSlow = function(size2) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size2);
    };
  })(safeBuffer, safeBuffer.exports);
  return safeBuffer.exports;
}
var util$1 = {};
var hasRequiredUtil$1;
function requireUtil$1() {
  if (hasRequiredUtil$1) return util$1;
  hasRequiredUtil$1 = 1;
  function isArray(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString(arg) === "[object Array]";
  }
  util$1.isArray = isArray;
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  util$1.isBoolean = isBoolean;
  function isNull(arg) {
    return arg === null;
  }
  util$1.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  util$1.isNullOrUndefined = isNullOrUndefined;
  function isNumber(arg) {
    return typeof arg === "number";
  }
  util$1.isNumber = isNumber;
  function isString(arg) {
    return typeof arg === "string";
  }
  util$1.isString = isString;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  util$1.isSymbol = isSymbol;
  function isUndefined(arg) {
    return arg === void 0;
  }
  util$1.isUndefined = isUndefined;
  function isRegExp(re2) {
    return objectToString(re2) === "[object RegExp]";
  }
  util$1.isRegExp = isRegExp;
  function isObject2(arg) {
    return typeof arg === "object" && arg !== null;
  }
  util$1.isObject = isObject2;
  function isDate(d4) {
    return objectToString(d4) === "[object Date]";
  }
  util$1.isDate = isDate;
  function isError2(e3) {
    return objectToString(e3) === "[object Error]" || e3 instanceof Error;
  }
  util$1.isError = isError2;
  function isFunction(arg) {
    return typeof arg === "function";
  }
  util$1.isFunction = isFunction;
  function isPrimitive2(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
    typeof arg === "undefined";
  }
  util$1.isPrimitive = isPrimitive2;
  util$1.isBuffer = require$$1$2.Buffer.isBuffer;
  function objectToString(o3) {
    return Object.prototype.toString.call(o3);
  }
  return util$1;
}
var util = {};
var types = {};
var isArguments;
var hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments;
  hasRequiredIsArguments = 1;
  var hasToStringTag = requireShams()();
  var callBound2 = requireCallBound();
  var $toString = callBound2("Object.prototype.toString");
  var isStandardArguments = function isArguments2(value) {
    if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
      return false;
    }
    return $toString(value) === "[object Arguments]";
  };
  var isLegacyArguments = function isArguments2(value) {
    if (isStandardArguments(value)) {
      return true;
    }
    return value !== null && typeof value === "object" && "length" in value && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && "callee" in value && $toString(value.callee) === "[object Function]";
  };
  var supportsStandardArguments = function() {
    return isStandardArguments(arguments);
  }();
  isStandardArguments.isLegacyArguments = isLegacyArguments;
  isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  return isArguments;
}
var isRegex;
var hasRequiredIsRegex;
function requireIsRegex() {
  if (hasRequiredIsRegex) return isRegex;
  hasRequiredIsRegex = 1;
  var callBound2 = requireCallBound();
  var hasToStringTag = requireShams()();
  var hasOwn = requireHasown();
  var gOPD2 = requireGopd();
  var fn2;
  if (hasToStringTag) {
    var $exec = callBound2("RegExp.prototype.exec");
    var isRegexMarker = {};
    var throwRegexMarker = function() {
      throw isRegexMarker;
    };
    var badStringifier = {
      toString: throwRegexMarker,
      valueOf: throwRegexMarker
    };
    if (typeof Symbol.toPrimitive === "symbol") {
      badStringifier[Symbol.toPrimitive] = throwRegexMarker;
    }
    fn2 = function isRegex2(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      var descriptor = (
        /** @type {NonNullable<typeof gOPD>} */
        gOPD2(
          /** @type {{ lastIndex?: unknown }} */
          value,
          "lastIndex"
        )
      );
      var hasLastIndexDataProperty = descriptor && hasOwn(descriptor, "value");
      if (!hasLastIndexDataProperty) {
        return false;
      }
      try {
        $exec(
          value,
          /** @type {string} */
          /** @type {unknown} */
          badStringifier
        );
      } catch (e3) {
        return e3 === isRegexMarker;
      }
    };
  } else {
    var $toString = callBound2("Object.prototype.toString");
    var regexClass = "[object RegExp]";
    fn2 = function isRegex2(value) {
      if (!value || typeof value !== "object" && typeof value !== "function") {
        return false;
      }
      return $toString(value) === regexClass;
    };
  }
  isRegex = fn2;
  return isRegex;
}
var safeRegexTest;
var hasRequiredSafeRegexTest;
function requireSafeRegexTest() {
  if (hasRequiredSafeRegexTest) return safeRegexTest;
  hasRequiredSafeRegexTest = 1;
  var callBound2 = requireCallBound();
  var isRegex2 = requireIsRegex();
  var $exec = callBound2("RegExp.prototype.exec");
  var $TypeError = requireType();
  safeRegexTest = function regexTester(regex2) {
    if (!isRegex2(regex2)) {
      throw new $TypeError("`regex` must be a RegExp");
    }
    return function test(s2) {
      return $exec(regex2, s2) !== null;
    };
  };
  return safeRegexTest;
}
var generatorFunction;
var hasRequiredGeneratorFunction;
function requireGeneratorFunction() {
  if (hasRequiredGeneratorFunction) return generatorFunction;
  hasRequiredGeneratorFunction = 1;
  const cached = (
    /** @type {GeneratorFunctionConstructor} */
    (function* () {
    }).constructor
  );
  generatorFunction = () => cached;
  return generatorFunction;
}
var isGeneratorFunction;
var hasRequiredIsGeneratorFunction;
function requireIsGeneratorFunction() {
  if (hasRequiredIsGeneratorFunction) return isGeneratorFunction;
  hasRequiredIsGeneratorFunction = 1;
  var callBound2 = requireCallBound();
  var safeRegexTest2 = requireSafeRegexTest();
  var isFnRegex = safeRegexTest2(/^\s*(?:function)?\*/);
  var hasToStringTag = requireShams()();
  var getProto2 = requireGetProto();
  var toStr = callBound2("Object.prototype.toString");
  var fnToStr = callBound2("Function.prototype.toString");
  var getGeneratorFunction = requireGeneratorFunction();
  isGeneratorFunction = function isGeneratorFunction2(fn2) {
    if (typeof fn2 !== "function") {
      return false;
    }
    if (isFnRegex(fnToStr(fn2))) {
      return true;
    }
    if (!hasToStringTag) {
      var str = toStr(fn2);
      return str === "[object GeneratorFunction]";
    }
    if (!getProto2) {
      return false;
    }
    var GeneratorFunction = getGeneratorFunction();
    return GeneratorFunction && getProto2(fn2) === GeneratorFunction.prototype;
  };
  return isGeneratorFunction;
}
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types;
  hasRequiredTypes = 1;
  (function(exports2) {
    var isArgumentsObject = requireIsArguments();
    var isGeneratorFunction2 = requireIsGeneratorFunction();
    var whichTypedArray2 = requireWhichTypedArray();
    var isTypedArray2 = requireIsTypedArray();
    function uncurryThis(f6) {
      return f6.call.bind(f6);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    if (SymbolSupported) {
      var symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e3) {
        return false;
      }
    }
    exports2.isArgumentsObject = isArgumentsObject;
    exports2.isGeneratorFunction = isGeneratorFunction2;
    exports2.isTypedArray = isTypedArray2;
    function isPromise2(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports2.isPromise = isPromise2;
    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray2(value) || isDataView(value);
    }
    exports2.isArrayBufferView = isArrayBufferView;
    function isUint8Array(value) {
      return whichTypedArray2(value) === "Uint8Array";
    }
    exports2.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value) {
      return whichTypedArray2(value) === "Uint8ClampedArray";
    }
    exports2.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray2(value) === "Uint16Array";
    }
    exports2.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray2(value) === "Uint32Array";
    }
    exports2.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray2(value) === "Int8Array";
    }
    exports2.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray2(value) === "Int16Array";
    }
    exports2.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray2(value) === "Int32Array";
    }
    exports2.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray2(value) === "Float32Array";
    }
    exports2.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray2(value) === "Float64Array";
    }
    exports2.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray2(value) === "BigInt64Array";
    }
    exports2.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray2(value) === "BigUint64Array";
    }
    exports2.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports2.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports2.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports2.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports2.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports2.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports2.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports2.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports2.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports2.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports2.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports2.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports2.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports2.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports2.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports2.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports2.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports2.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports2.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
    }
    exports2.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports2, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
  })(types);
  return types;
}
var isBufferBrowser;
var hasRequiredIsBufferBrowser;
function requireIsBufferBrowser() {
  if (hasRequiredIsBufferBrowser) return isBufferBrowser;
  hasRequiredIsBufferBrowser = 1;
  isBufferBrowser = function isBuffer(arg) {
    return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
  };
  return isBufferBrowser;
}
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  (function(exports2) {
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys2 = Object.keys(obj);
      var descriptors = {};
      for (var i4 = 0; i4 < keys2.length; i4++) {
        descriptors[keys2[i4]] = Object.getOwnPropertyDescriptor(obj, keys2[i4]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports2.format = function(f6) {
      if (!isString(f6)) {
        var objects = [];
        for (var i4 = 0; i4 < arguments.length; i4++) {
          objects.push(inspect6(arguments[i4]));
        }
        return objects.join(" ");
      }
      var i4 = 1;
      var args = arguments;
      var len2 = args.length;
      var str = String(f6).replace(formatRegExp, function(x3) {
        if (x3 === "%%") return "%";
        if (i4 >= len2) return x3;
        switch (x3) {
          case "%s":
            return String(args[i4++]);
          case "%d":
            return Number(args[i4++]);
          case "%j":
            try {
              return JSON.stringify(args[i4++]);
            } catch (_3) {
              return "[Circular]";
            }
          default:
            return x3;
        }
      });
      for (var x2 = args[i4]; i4 < len2; x2 = args[++i4]) {
        if (isNull(x2) || !isObject2(x2)) {
          str += " " + x2;
        } else {
          str += " " + inspect6(x2);
        }
      }
      return str;
    };
    exports2.deprecate = function(fn2, msg) {
      if (typeof process$1 !== "undefined" && process$1.noDeprecation === true) {
        return fn2;
      }
      if (typeof process$1 === "undefined") {
        return function() {
          return exports2.deprecate(fn2, msg).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process$1.throwDeprecation) {
            throw new Error(msg);
          } else if (process$1.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn2.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (process$1.env.NODE_DEBUG) {
      var debugEnv = process$1.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    exports2.debuglog = function(set2) {
      set2 = set2.toUpperCase();
      if (!debugs[set2]) {
        if (debugEnvRegex.test(set2)) {
          var pid = process$1.pid;
          debugs[set2] = function() {
            var msg = exports2.format.apply(exports2, arguments);
            console.error("%s %d: %s", set2, pid, msg);
          };
        } else {
          debugs[set2] = function() {
          };
        }
      }
      return debugs[set2];
    };
    function inspect6(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports2._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports2.inspect = inspect6;
    inspect6.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect6.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect6.styles[styleType];
      if (style) {
        return "\x1B[" + inspect6.colors[style][0] + "m" + str + "\x1B[" + inspect6.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash3 = {};
      array.forEach(function(val, idx) {
        hash3[val] = true;
      });
      return hash3;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
      value.inspect !== exports2.inspect && // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys2 = Object.keys(value);
      var visibleKeys = arrayToHash(keys2);
      if (ctx.showHidden) {
        keys2 = Object.getOwnPropertyNames(value);
      }
      if (isError2(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys2.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name + "]", "special");
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError2(value)) {
          return formatError(value);
        }
      }
      var base3 = "", array = false, braces = ["{", "}"];
      if (isArray(value)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction(value)) {
        var n5 = value.name ? ": " + value.name : "";
        base3 = " [Function" + n5 + "]";
      }
      if (isRegExp(value)) {
        base3 = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base3 = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError2(value)) {
        base3 = " " + formatError(value);
      }
      if (keys2.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base3 + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output2;
      if (array) {
        output2 = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
      } else {
        output2 = keys2.map(function(key2) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key2, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output2, base3, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize("undefined", "undefined");
      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
      var output2 = [];
      for (var i4 = 0, l2 = value.length; i4 < l2; ++i4) {
        if (hasOwnProperty(value, String(i4))) {
          output2.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            String(i4),
            true
          ));
        } else {
          output2.push("");
        }
      }
      keys2.forEach(function(key2) {
        if (!key2.match(/^\d+$/)) {
          output2.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            key2,
            true
          ));
        }
      });
      return output2;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key2, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key2) || { value: value[key2] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty(visibleKeys, key2)) {
        name = "[" + key2 + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").slice(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined(name)) {
        if (array && key2.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify("" + key2);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.slice(1, -1);
          name = ctx.stylize(name, "name");
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, "string");
        }
      }
      return name + ": " + str;
    }
    function reduceToSingleString(output2, base3, braces) {
      var length = output2.reduce(function(prev, cur) {
        if (cur.indexOf("\n") >= 0) ;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base3 === "" ? "" : base3 + "\n ") + " " + output2.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base3 + " " + output2.join(", ") + " " + braces[1];
    }
    exports2.types = requireTypes();
    function isArray(ar2) {
      return Array.isArray(ar2);
    }
    exports2.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re2) {
      return isObject2(re2) && objectToString(re2) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    exports2.types.isRegExp = isRegExp;
    function isObject2(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject2;
    function isDate(d4) {
      return isObject2(d4) && objectToString(d4) === "[object Date]";
    }
    exports2.isDate = isDate;
    exports2.types.isDate = isDate;
    function isError2(e3) {
      return isObject2(e3) && (objectToString(e3) === "[object Error]" || e3 instanceof Error);
    }
    exports2.isError = isError2;
    exports2.types.isNativeError = isError2;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive2(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive2;
    exports2.isBuffer = requireIsBufferBrowser();
    function objectToString(o3) {
      return Object.prototype.toString.call(o3);
    }
    function pad3(n5) {
      return n5 < 10 ? "0" + n5.toString(10) : n5.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d4 = /* @__PURE__ */ new Date();
      var time2 = [
        pad3(d4.getHours()),
        pad3(d4.getMinutes()),
        pad3(d4.getSeconds())
      ].join(":");
      return [d4.getDate(), months[d4.getMonth()], time2].join(" ");
    }
    exports2.log = function() {
      console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
    };
    exports2.inherits = inherits_browserExports;
    exports2._extend = function(origin, add6) {
      if (!add6 || !isObject2(add6)) return origin;
      var keys2 = Object.keys(add6);
      var i4 = keys2.length;
      while (i4--) {
        origin[keys2[i4]] = add6[keys2[i4]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    exports2.promisify = function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn2 = original[kCustomPromisifiedSymbol];
        if (typeof fn2 !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn2, kCustomPromisifiedSymbol, {
          value: fn2,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn2;
      }
      function fn2() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });
        var args = [];
        for (var i4 = 0; i4 < arguments.length; i4++) {
          args.push(arguments[i4]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn2, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol) Object.defineProperty(fn2, kCustomPromisifiedSymbol, {
        value: fn2,
        enumerable: false,
        writable: false,
        configurable: true
      });
      return Object.defineProperties(
        fn2,
        getOwnPropertyDescriptors(original)
      );
    };
    exports2.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i4 = 0; i4 < arguments.length; i4++) {
          args.push(arguments[i4]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this, args).then(
          function(ret) {
            process$1.nextTick(cb.bind(null, null, ret));
          },
          function(rej) {
            process$1.nextTick(callbackifyOnRejected.bind(null, rej, cb));
          }
        );
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(
        callbackified,
        getOwnPropertyDescriptors(original)
      );
      return callbackified;
    }
    exports2.callbackify = callbackify;
  })(util);
  return util;
}
var BufferList = { exports: {} };
var hasRequiredBufferList;
function requireBufferList() {
  if (hasRequiredBufferList) return BufferList.exports;
  hasRequiredBufferList = 1;
  (function(module) {
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = requireSafeBuffer().Buffer;
    var util2 = requireUtil();
    function copyBuffer(src2, target, offset) {
      src2.copy(target, offset);
    }
    module.exports = function() {
      function BufferList2() {
        _classCallCheck(this, BufferList2);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList2.prototype.push = function push(v2) {
        var entry = { data: v2, next: null };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList2.prototype.unshift = function unshift(v2) {
        var entry = { data: v2, next: this.head };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList2.prototype.shift = function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList2.prototype.clear = function clear2() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList2.prototype.join = function join(s2) {
        if (this.length === 0) return "";
        var p2 = this.head;
        var ret = "" + p2.data;
        while (p2 = p2.next) {
          ret += s2 + p2.data;
        }
        return ret;
      };
      BufferList2.prototype.concat = function concat2(n5) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n5 >>> 0);
        var p2 = this.head;
        var i4 = 0;
        while (p2) {
          copyBuffer(p2.data, ret, i4);
          i4 += p2.data.length;
          p2 = p2.next;
        }
        return ret;
      };
      return BufferList2;
    }();
    if (util2 && util2.inspect && util2.inspect.custom) {
      module.exports.prototype[util2.inspect.custom] = function() {
        var obj = util2.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  })(BufferList);
  return BufferList.exports;
}
var destroy_1$1;
var hasRequiredDestroy$1;
function requireDestroy$1() {
  if (hasRequiredDestroy$1) return destroy_1$1;
  hasRequiredDestroy$1 = 1;
  var pna = requireProcessNextickArgs();
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          pna.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          pna.nextTick(emitErrorNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, _this, err2);
        }
      } else if (cb) {
        cb(err2);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  destroy_1$1 = {
    destroy,
    undestroy
  };
  return destroy_1$1;
}
var browser$b;
var hasRequiredBrowser$a;
function requireBrowser$a() {
  if (hasRequiredBrowser$a) return browser$b;
  hasRequiredBrowser$a = 1;
  browser$b = deprecate;
  function deprecate(fn2, msg) {
    if (config("noDeprecation")) {
      return fn2;
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (config("throwDeprecation")) {
          throw new Error(msg);
        } else if (config("traceDeprecation")) {
          console.trace(msg);
        } else {
          console.warn(msg);
        }
        warned = true;
      }
      return fn2.apply(this, arguments);
    }
    return deprecated;
  }
  function config(name) {
    try {
      if (!commonjsGlobal.localStorage) return false;
    } catch (_3) {
      return false;
    }
    var val = commonjsGlobal.localStorage[name];
    if (null == val) return false;
    return String(val).toLowerCase() === "true";
  }
  return browser$b;
}
var _stream_writable$1;
var hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1) return _stream_writable$1;
  hasRequired_stream_writable$1 = 1;
  var pna = requireProcessNextickArgs();
  _stream_writable$1 = Writable;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var asyncWrite = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable.WritableState = WritableState;
  var util2 = Object.create(requireUtil$1());
  util2.inherits = inherits_browserExports;
  var internalUtil = {
    deprecate: requireBrowser$a()
  };
  var Stream = requireStreamBrowser$1();
  var Buffer2 = requireSafeBuffer().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy$1();
  util2.inherits(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream) {
    Duplex = Duplex || require_stream_duplex$1();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er4) {
      onwrite(stream, er4);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_3) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function(object2) {
        if (realHasInstance.call(this, object2)) return true;
        if (this !== Writable) return false;
        return object2 && object2._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object2) {
      return object2 instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require_stream_duplex$1();
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
      return new Writable(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.final === "function") this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream, cb) {
    var er4 = new Error("write after end");
    stream.emit("error", er4);
    pna.nextTick(cb, er4);
  }
  function validChunk(stream, state2, chunk, cb) {
    var valid = true;
    var er4 = false;
    if (chunk === null) {
      er4 = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er4 = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er4) {
      stream.emit("error", er4);
      pna.nextTick(cb, er4);
      valid = false;
    }
    return valid;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state2.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state2.ended) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    var state2 = this._writableState;
    state2.corked++;
  };
  Writable.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len2 = state2.objectMode ? 1 : chunk.length;
    state2.length += len2;
    var ret = state2.length < state2.highWaterMark;
    if (!ret) state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state2, false, len2, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state2, writev, len2, chunk, encoding, cb) {
    state2.writelen = len2;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (writev) stream._writev(chunk, state2.onwrite);
    else stream._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream, state2, sync, er4, cb) {
    --state2.pendingcb;
    if (sync) {
      pna.nextTick(cb, er4);
      pna.nextTick(finishMaybe, stream, state2);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er4);
    } else {
      cb(er4);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er4);
      finishMaybe(stream, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream, er4) {
    var state2 = stream._writableState;
    var sync = state2.sync;
    var cb = state2.writecb;
    onwriteStateUpdate(state2);
    if (er4) onwriteError(stream, state2, sync, er4, cb);
    else {
      var finished = needFinish(state2);
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream, state2);
      }
      if (sync) {
        asyncWrite(afterWrite, stream, state2, finished, cb);
      } else {
        afterWrite(stream, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream, state2, finished, cb) {
    if (!finished) onwriteDrain(stream, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream, state2);
  }
  function onwriteDrain(stream, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l2 = state2.bufferedRequestCount;
      var buffer2 = new Array(l2);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream, state2, true, state2.length, buffer2, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len2 = state2.objectMode ? 1 : chunk.length;
        doWrite(stream, state2, false, len2, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null) state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending) endWritable(this, state2, cb);
  };
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream, state2) {
    stream._final(function(err) {
      state2.pendingcb--;
      if (err) {
        stream.emit("error", err);
      }
      state2.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state2);
    });
  }
  function prefinish(stream, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream._final === "function") {
        state2.pendingcb++;
        state2.finalCalled = true;
        pna.nextTick(callFinal, stream, state2);
      } else {
        state2.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream, state2, cb) {
    state2.ending = true;
    finishMaybe(stream, state2);
    if (cb) {
      if (state2.finished) pna.nextTick(cb);
      else stream.once("finish", cb);
    }
    state2.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    get: function() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
  };
  return _stream_writable$1;
}
var _stream_duplex$1;
var hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1) return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var pna = requireProcessNextickArgs();
  var objectKeys = Object.keys || function(obj) {
    var keys3 = [];
    for (var key2 in obj) {
      keys3.push(key2);
    }
    return keys3;
  };
  _stream_duplex$1 = Duplex;
  var util2 = Object.create(requireUtil$1());
  util2.inherits = inherits_browserExports;
  var Readable = require_stream_readable$1();
  var Writable = require_stream_writable$1();
  util2.inherits(Duplex, Readable);
  {
    var keys2 = objectKeys(Writable.prototype);
    for (var v2 = 0; v2 < keys2.length; v2++) {
      var method = keys2[v2];
      if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false) this.readable = false;
    if (options && options.writable === false) this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended) return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
  };
  return _stream_duplex$1;
}
var string_decoder = {};
var hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried) return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r3;
    var i4;
    if (this.lastNeed) {
      r3 = this.fillLast(buf);
      if (r3 === void 0) return "";
      i4 = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i4 = 0;
    }
    if (i4 < buf.length) return r3 ? r3 + this.text(buf, i4) : this.text(buf, i4);
    return r3 || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte2) {
    if (byte2 <= 127) return 0;
    else if (byte2 >> 5 === 6) return 2;
    else if (byte2 >> 4 === 14) return 3;
    else if (byte2 >> 3 === 30) return 4;
    return byte2 >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i4) {
    var j2 = buf.length - 1;
    if (j2 < i4) return 0;
    var nb = utf8CheckByte(buf[j2]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j2 < i4 || nb === -2) return 0;
    nb = utf8CheckByte(buf[j2]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j2 < i4 || nb === -2) return 0;
    nb = utf8CheckByte(buf[j2]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;
        else self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p2) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p2 = this.lastTotal - this.lastNeed;
    var r3 = utf8CheckExtraBytes(this, buf);
    if (r3 !== void 0) return r3;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p2, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p2, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i4) {
    var total = utf8CheckIncomplete(this, buf, i4);
    if (!this.lastNeed) return buf.toString("utf8", i4);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i4, end);
  }
  function utf8End(buf) {
    var r3 = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r3 + "";
    return r3;
  }
  function utf16Text(buf, i4) {
    if ((buf.length - i4) % 2 === 0) {
      var r3 = buf.toString("utf16le", i4);
      if (r3) {
        var c2 = r3.charCodeAt(r3.length - 1);
        if (c2 >= 55296 && c2 <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r3.slice(0, -1);
        }
      }
      return r3;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i4, buf.length - 1);
  }
  function utf16End(buf) {
    var r3 = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r3 + this.lastChar.toString("utf16le", 0, end);
    }
    return r3;
  }
  function base64Text(buf, i4) {
    var n5 = (buf.length - i4) % 3;
    if (n5 === 0) return buf.toString("base64", i4);
    this.lastNeed = 3 - n5;
    this.lastTotal = 3;
    if (n5 === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i4, buf.length - n5);
  }
  function base64End(buf) {
    var r3 = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r3 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r3;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder;
}
var _stream_readable$1;
var hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1) return _stream_readable$1;
  hasRequired_stream_readable$1 = 1;
  var pna = requireProcessNextickArgs();
  _stream_readable$1 = Readable;
  var isArray = requireIsarray();
  var Duplex;
  Readable.ReadableState = ReadableState;
  eventsExports.EventEmitter;
  var EElistenerCount = function(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream = requireStreamBrowser$1();
  var Buffer2 = requireSafeBuffer().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var util2 = Object.create(requireUtil$1());
  util2.inherits = inherits_browserExports;
  var debugUtil = requireUtil();
  var debug = void 0;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function() {
    };
  }
  var BufferList2 = requireBufferList();
  var destroyImpl = requireDestroy$1();
  var StringDecoder;
  util2.inherits(Readable, Stream);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener2(emitter, event, fn2) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn2);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn2);
    else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn2);
    else emitter._events[event] = [fn2, emitter._events[event]];
  }
  function ReadableState(options, stream) {
    Duplex = Duplex || require_stream_duplex$1();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList2();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require_stream_duplex$1();
    if (!(this instanceof Readable)) return new Readable(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function") this._read = options.read;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    var state2 = stream._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream, state2);
    } else {
      var er4;
      if (!skipChunkCheck) er4 = chunkInvalid(state2, chunk);
      if (er4) {
        stream.emit("error", er4);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted) stream.emit("error", new Error("stream.unshift() after end event"));
          else addChunk(stream, state2, chunk, true);
        } else if (state2.ended) {
          stream.emit("error", new Error("stream.push() after EOF"));
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0) addChunk(stream, state2, chunk, false);
            else maybeReadMore(stream, state2);
          } else {
            addChunk(stream, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
      }
    }
    return needMoreData(state2);
  }
  function addChunk(stream, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      stream.emit("data", chunk);
      stream.read(0);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront) state2.buffer.unshift(chunk);
      else state2.buffer.push(chunk);
      if (state2.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er4;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er4 = new TypeError("Invalid non-string/buffer chunk");
    }
    return er4;
  }
  function needMoreData(state2) {
    return !state2.ended && (state2.needReadable || state2.length < state2.highWaterMark || state2.length === 0);
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n5) {
    if (n5 >= MAX_HWM) {
      n5 = MAX_HWM;
    } else {
      n5--;
      n5 |= n5 >>> 1;
      n5 |= n5 >>> 2;
      n5 |= n5 >>> 4;
      n5 |= n5 >>> 8;
      n5 |= n5 >>> 16;
      n5++;
    }
    return n5;
  }
  function howMuchToRead(n5, state2) {
    if (n5 <= 0 || state2.length === 0 && state2.ended) return 0;
    if (state2.objectMode) return 1;
    if (n5 !== n5) {
      if (state2.flowing && state2.length) return state2.buffer.head.data.length;
      else return state2.length;
    }
    if (n5 > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n5);
    if (n5 <= state2.length) return n5;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable.prototype.read = function(n5) {
    debug("read", n5);
    n5 = parseInt(n5, 10);
    var state2 = this._readableState;
    var nOrig = n5;
    if (n5 !== 0) state2.emittedReadable = false;
    if (n5 === 0 && state2.needReadable && (state2.length >= state2.highWaterMark || state2.ended)) {
      debug("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n5 = howMuchToRead(n5, state2);
    if (n5 === 0 && state2.ended) {
      if (state2.length === 0) endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug("need readable", doRead);
    if (state2.length === 0 || state2.length - n5 < state2.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0) state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading) n5 = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n5 > 0) ret = fromList(n5, state2);
    else ret = null;
    if (ret === null) {
      state2.needReadable = true;
      n5 = 0;
    } else {
      state2.length -= n5;
    }
    if (state2.length === 0) {
      if (!state2.ended) state2.needReadable = true;
      if (nOrig !== n5 && state2.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state2) {
    if (state2.ended) return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    emitReadable(stream);
  }
  function emitReadable(stream) {
    var state2 = stream._readableState;
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      if (state2.sync) pna.nextTick(emitReadable_, stream);
      else emitReadable_(stream);
    }
  }
  function emitReadable_(stream) {
    debug("emit readable");
    stream.emit("readable");
    flow(stream);
  }
  function maybeReadMore(stream, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      pna.nextTick(maybeReadMore_, stream, state2);
    }
  }
  function maybeReadMore_(stream, state2) {
    var len2 = state2.length;
    while (!state2.reading && !state2.flowing && !state2.ended && state2.length < state2.highWaterMark) {
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len2 === state2.length)
        break;
      else len2 = state2.length;
    }
    state2.readingMore = false;
  }
  Readable.prototype._read = function(n5) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src2 = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted) pna.nextTick(endFn);
    else src2.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src2) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src2);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src2.removeListener("end", onend);
      src2.removeListener("end", unpipe);
      src2.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    var increasedAwaitDrain = false;
    src2.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (false === ret && !increasedAwaitDrain) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf2(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src2.pause();
      }
    }
    function onerror(er4) {
      debug("onerror", er4);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) dest.emit("error", er4);
    }
    prependListener2(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src2.unpipe(dest);
    }
    dest.emit("pipe", src2);
    if (!state2.flowing) {
      debug("pipe resume");
      src2.resume();
    }
    return dest;
  };
  function pipeOnDrain(src2) {
    return function() {
      var state2 = src2._readableState;
      debug("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain) state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src2, "data")) {
        state2.flowing = true;
        flow(src2);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = { hasUnpiped: false };
    if (state2.pipesCount === 0) return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes) return this;
      if (!dest) dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len2 = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i4 = 0; i4 < len2; i4++) {
        dests[i4].emit("unpipe", this, { hasUnpiped: false });
      }
      return this;
    }
    var index2 = indexOf2(state2.pipes, dest);
    if (index2 === -1) return this;
    state2.pipes.splice(index2, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn2) {
    var res = Stream.prototype.on.call(this, ev, fn2);
    if (ev === "data") {
      if (this._readableState.flowing !== false) this.resume();
    } else if (ev === "readable") {
      var state2 = this._readableState;
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.emittedReadable = false;
        if (!state2.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state2.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug("resume");
      state2.flowing = true;
      resume(this, state2);
    }
    return this;
  };
  function resume(stream, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      pna.nextTick(resume_, stream, state2);
    }
  }
  function resume_(stream, state2) {
    if (!state2.reading) {
      debug("resume read 0");
      stream.read(0);
    }
    state2.resumeScheduled = false;
    state2.awaitDrain = 0;
    stream.emit("resume");
    flow(stream);
    if (state2.flowing && !state2.reading) stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (false !== this._readableState.flowing) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream) {
    var state2 = stream._readableState;
    debug("flow", state2.flowing);
    while (state2.flowing && stream.read() !== null) {
    }
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state2.decoder) chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state2.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i4 in stream) {
      if (this[i4] === void 0 && typeof stream[i4] === "function") {
        this[i4] = /* @__PURE__ */ function(method) {
          return function() {
            return stream[method].apply(stream, arguments);
          };
        }(i4);
      }
    }
    for (var n5 = 0; n5 < kProxyEvents.length; n5++) {
      stream.on(kProxyEvents[n5], this.emit.bind(this, kProxyEvents[n5]));
    }
    this._read = function(n6) {
      debug("wrapped _read", n6);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable._fromList = fromList;
  function fromList(n5, state2) {
    if (state2.length === 0) return null;
    var ret;
    if (state2.objectMode) ret = state2.buffer.shift();
    else if (!n5 || n5 >= state2.length) {
      if (state2.decoder) ret = state2.buffer.join("");
      else if (state2.buffer.length === 1) ret = state2.buffer.head.data;
      else ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = fromListPartial(n5, state2.buffer, state2.decoder);
    }
    return ret;
  }
  function fromListPartial(n5, list, hasStrings) {
    var ret;
    if (n5 < list.head.data.length) {
      ret = list.head.data.slice(0, n5);
      list.head.data = list.head.data.slice(n5);
    } else if (n5 === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n5, list) : copyFromBuffer(n5, list);
    }
    return ret;
  }
  function copyFromBufferString(n5, list) {
    var p2 = list.head;
    var c2 = 1;
    var ret = p2.data;
    n5 -= ret.length;
    while (p2 = p2.next) {
      var str = p2.data;
      var nb = n5 > str.length ? str.length : n5;
      if (nb === str.length) ret += str;
      else ret += str.slice(0, n5);
      n5 -= nb;
      if (n5 === 0) {
        if (nb === str.length) {
          ++c2;
          if (p2.next) list.head = p2.next;
          else list.head = list.tail = null;
        } else {
          list.head = p2;
          p2.data = str.slice(nb);
        }
        break;
      }
      ++c2;
    }
    list.length -= c2;
    return ret;
  }
  function copyFromBuffer(n5, list) {
    var ret = Buffer2.allocUnsafe(n5);
    var p2 = list.head;
    var c2 = 1;
    p2.data.copy(ret);
    n5 -= p2.data.length;
    while (p2 = p2.next) {
      var buf = p2.data;
      var nb = n5 > buf.length ? buf.length : n5;
      buf.copy(ret, ret.length - n5, 0, nb);
      n5 -= nb;
      if (n5 === 0) {
        if (nb === buf.length) {
          ++c2;
          if (p2.next) list.head = p2.next;
          else list.head = list.tail = null;
        } else {
          list.head = p2;
          p2.data = buf.slice(nb);
        }
        break;
      }
      ++c2;
    }
    list.length -= c2;
    return ret;
  }
  function endReadable(stream) {
    var state2 = stream._readableState;
    if (state2.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    if (!state2.endEmitted) {
      state2.ended = true;
      pna.nextTick(endReadableNT, state2, stream);
    }
  }
  function endReadableNT(state2, stream) {
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
    }
  }
  function indexOf2(xs2, x2) {
    for (var i4 = 0, l2 = xs2.length; i4 < l2; i4++) {
      if (xs2[i4] === x2) return i4;
    }
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1;
var hasRequired_stream_transform$1;
function require_stream_transform$1() {
  if (hasRequired_stream_transform$1) return _stream_transform$1;
  hasRequired_stream_transform$1 = 1;
  _stream_transform$1 = Transform;
  var Duplex = require_stream_duplex$1();
  var util2 = Object.create(requireUtil$1());
  util2.inherits = inherits_browserExports;
  util2.inherits(Transform, Duplex);
  function afterTransform(er4, data2) {
    var ts2 = this._transformState;
    ts2.transforming = false;
    var cb = ts2.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts2.writechunk = null;
    ts2.writecb = null;
    if (data2 != null)
      this.push(data2);
    cb(er4);
    var rs2 = this._readableState;
    rs2.reading = false;
    if (rs2.needReadable || rs2.length < rs2.highWaterMark) {
      this._read(rs2.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er4, data2) {
        done(_this, er4, data2);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts2 = this._transformState;
    ts2.writecb = cb;
    ts2.writechunk = chunk;
    ts2.writeencoding = encoding;
    if (!ts2.transforming) {
      var rs2 = this._readableState;
      if (ts2.needTransform || rs2.needReadable || rs2.length < rs2.highWaterMark) this._read(rs2.highWaterMark);
    }
  };
  Transform.prototype._read = function(n5) {
    var ts2 = this._transformState;
    if (ts2.writechunk !== null && ts2.writecb && !ts2.transforming) {
      ts2.transforming = true;
      this._transform(ts2.writechunk, ts2.writeencoding, ts2.afterTransform);
    } else {
      ts2.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
      _this2.emit("close");
    });
  };
  function done(stream, er4, data2) {
    if (er4) return stream.emit("error", er4);
    if (data2 != null)
      stream.push(data2);
    if (stream._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (stream._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return stream.push(null);
  }
  return _stream_transform$1;
}
var _stream_passthrough$1;
var hasRequired_stream_passthrough$1;
function require_stream_passthrough$1() {
  if (hasRequired_stream_passthrough$1) return _stream_passthrough$1;
  hasRequired_stream_passthrough$1 = 1;
  _stream_passthrough$1 = PassThrough;
  var Transform = require_stream_transform$1();
  var util2 = Object.create(requireUtil$1());
  util2.inherits = inherits_browserExports;
  util2.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough$1;
}
var hasRequiredReadableBrowser;
function requireReadableBrowser() {
  if (hasRequiredReadableBrowser) return readableBrowser.exports;
  hasRequiredReadableBrowser = 1;
  (function(module, exports2) {
    exports2 = module.exports = require_stream_readable$1();
    exports2.Stream = exports2;
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable$1();
    exports2.Duplex = require_stream_duplex$1();
    exports2.Transform = require_stream_transform$1();
    exports2.PassThrough = require_stream_passthrough$1();
  })(readableBrowser, readableBrowser.exports);
  return readableBrowser.exports;
}
var hashBase;
var hasRequiredHashBase;
function requireHashBase() {
  if (hasRequiredHashBase) return hashBase;
  hasRequiredHashBase = 1;
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var toBuffer2 = requireToBuffer$1();
  var Transform = requireReadableBrowser().Transform;
  var inherits2 = inherits_browserExports;
  function HashBase(blockSize) {
    Transform.call(this);
    this._block = Buffer2.allocUnsafe(blockSize);
    this._blockSize = blockSize;
    this._blockOffset = 0;
    this._length = [0, 0, 0, 0];
    this._finalized = false;
  }
  inherits2(HashBase, Transform);
  HashBase.prototype._transform = function(chunk, encoding, callback) {
    var error = null;
    try {
      this.update(chunk, encoding);
    } catch (err) {
      error = err;
    }
    callback(error);
  };
  HashBase.prototype._flush = function(callback) {
    var error = null;
    try {
      this.push(this.digest());
    } catch (err) {
      error = err;
    }
    callback(error);
  };
  HashBase.prototype.update = function(data2, encoding) {
    if (this._finalized) {
      throw new Error("Digest already called");
    }
    var dataBuffer = toBuffer2(data2, encoding);
    var block = this._block;
    var offset = 0;
    while (this._blockOffset + dataBuffer.length - offset >= this._blockSize) {
      for (var i4 = this._blockOffset; i4 < this._blockSize; ) {
        block[i4] = dataBuffer[offset];
        i4 += 1;
        offset += 1;
      }
      this._update();
      this._blockOffset = 0;
    }
    while (offset < dataBuffer.length) {
      block[this._blockOffset] = dataBuffer[offset];
      this._blockOffset += 1;
      offset += 1;
    }
    for (var j2 = 0, carry = dataBuffer.length * 8; carry > 0; ++j2) {
      this._length[j2] += carry;
      carry = this._length[j2] / 4294967296 | 0;
      if (carry > 0) {
        this._length[j2] -= 4294967296 * carry;
      }
    }
    return this;
  };
  HashBase.prototype._update = function() {
    throw new Error("_update is not implemented");
  };
  HashBase.prototype.digest = function(encoding) {
    if (this._finalized) {
      throw new Error("Digest already called");
    }
    this._finalized = true;
    var digest9 = this._digest();
    if (encoding !== void 0) {
      digest9 = digest9.toString(encoding);
    }
    this._block.fill(0);
    this._blockOffset = 0;
    for (var i4 = 0; i4 < 4; ++i4) {
      this._length[i4] = 0;
    }
    return digest9;
  };
  HashBase.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  };
  hashBase = HashBase;
  return hashBase;
}
var md5_js;
var hasRequiredMd5_js;
function requireMd5_js() {
  if (hasRequiredMd5_js) return md5_js;
  hasRequiredMd5_js = 1;
  var inherits2 = inherits_browserExports;
  var HashBase = requireHashBase();
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var ARRAY16 = new Array(16);
  function MD5() {
    HashBase.call(this, 64);
    this._a = 1732584193;
    this._b = 4023233417;
    this._c = 2562383102;
    this._d = 271733878;
  }
  inherits2(MD5, HashBase);
  MD5.prototype._update = function() {
    var M4 = ARRAY16;
    for (var i4 = 0; i4 < 16; ++i4) M4[i4] = this._block.readInt32LE(i4 * 4);
    var a2 = this._a;
    var b2 = this._b;
    var c2 = this._c;
    var d4 = this._d;
    a2 = fnF(a2, b2, c2, d4, M4[0], 3614090360, 7);
    d4 = fnF(d4, a2, b2, c2, M4[1], 3905402710, 12);
    c2 = fnF(c2, d4, a2, b2, M4[2], 606105819, 17);
    b2 = fnF(b2, c2, d4, a2, M4[3], 3250441966, 22);
    a2 = fnF(a2, b2, c2, d4, M4[4], 4118548399, 7);
    d4 = fnF(d4, a2, b2, c2, M4[5], 1200080426, 12);
    c2 = fnF(c2, d4, a2, b2, M4[6], 2821735955, 17);
    b2 = fnF(b2, c2, d4, a2, M4[7], 4249261313, 22);
    a2 = fnF(a2, b2, c2, d4, M4[8], 1770035416, 7);
    d4 = fnF(d4, a2, b2, c2, M4[9], 2336552879, 12);
    c2 = fnF(c2, d4, a2, b2, M4[10], 4294925233, 17);
    b2 = fnF(b2, c2, d4, a2, M4[11], 2304563134, 22);
    a2 = fnF(a2, b2, c2, d4, M4[12], 1804603682, 7);
    d4 = fnF(d4, a2, b2, c2, M4[13], 4254626195, 12);
    c2 = fnF(c2, d4, a2, b2, M4[14], 2792965006, 17);
    b2 = fnF(b2, c2, d4, a2, M4[15], 1236535329, 22);
    a2 = fnG(a2, b2, c2, d4, M4[1], 4129170786, 5);
    d4 = fnG(d4, a2, b2, c2, M4[6], 3225465664, 9);
    c2 = fnG(c2, d4, a2, b2, M4[11], 643717713, 14);
    b2 = fnG(b2, c2, d4, a2, M4[0], 3921069994, 20);
    a2 = fnG(a2, b2, c2, d4, M4[5], 3593408605, 5);
    d4 = fnG(d4, a2, b2, c2, M4[10], 38016083, 9);
    c2 = fnG(c2, d4, a2, b2, M4[15], 3634488961, 14);
    b2 = fnG(b2, c2, d4, a2, M4[4], 3889429448, 20);
    a2 = fnG(a2, b2, c2, d4, M4[9], 568446438, 5);
    d4 = fnG(d4, a2, b2, c2, M4[14], 3275163606, 9);
    c2 = fnG(c2, d4, a2, b2, M4[3], 4107603335, 14);
    b2 = fnG(b2, c2, d4, a2, M4[8], 1163531501, 20);
    a2 = fnG(a2, b2, c2, d4, M4[13], 2850285829, 5);
    d4 = fnG(d4, a2, b2, c2, M4[2], 4243563512, 9);
    c2 = fnG(c2, d4, a2, b2, M4[7], 1735328473, 14);
    b2 = fnG(b2, c2, d4, a2, M4[12], 2368359562, 20);
    a2 = fnH(a2, b2, c2, d4, M4[5], 4294588738, 4);
    d4 = fnH(d4, a2, b2, c2, M4[8], 2272392833, 11);
    c2 = fnH(c2, d4, a2, b2, M4[11], 1839030562, 16);
    b2 = fnH(b2, c2, d4, a2, M4[14], 4259657740, 23);
    a2 = fnH(a2, b2, c2, d4, M4[1], 2763975236, 4);
    d4 = fnH(d4, a2, b2, c2, M4[4], 1272893353, 11);
    c2 = fnH(c2, d4, a2, b2, M4[7], 4139469664, 16);
    b2 = fnH(b2, c2, d4, a2, M4[10], 3200236656, 23);
    a2 = fnH(a2, b2, c2, d4, M4[13], 681279174, 4);
    d4 = fnH(d4, a2, b2, c2, M4[0], 3936430074, 11);
    c2 = fnH(c2, d4, a2, b2, M4[3], 3572445317, 16);
    b2 = fnH(b2, c2, d4, a2, M4[6], 76029189, 23);
    a2 = fnH(a2, b2, c2, d4, M4[9], 3654602809, 4);
    d4 = fnH(d4, a2, b2, c2, M4[12], 3873151461, 11);
    c2 = fnH(c2, d4, a2, b2, M4[15], 530742520, 16);
    b2 = fnH(b2, c2, d4, a2, M4[2], 3299628645, 23);
    a2 = fnI(a2, b2, c2, d4, M4[0], 4096336452, 6);
    d4 = fnI(d4, a2, b2, c2, M4[7], 1126891415, 10);
    c2 = fnI(c2, d4, a2, b2, M4[14], 2878612391, 15);
    b2 = fnI(b2, c2, d4, a2, M4[5], 4237533241, 21);
    a2 = fnI(a2, b2, c2, d4, M4[12], 1700485571, 6);
    d4 = fnI(d4, a2, b2, c2, M4[3], 2399980690, 10);
    c2 = fnI(c2, d4, a2, b2, M4[10], 4293915773, 15);
    b2 = fnI(b2, c2, d4, a2, M4[1], 2240044497, 21);
    a2 = fnI(a2, b2, c2, d4, M4[8], 1873313359, 6);
    d4 = fnI(d4, a2, b2, c2, M4[15], 4264355552, 10);
    c2 = fnI(c2, d4, a2, b2, M4[6], 2734768916, 15);
    b2 = fnI(b2, c2, d4, a2, M4[13], 1309151649, 21);
    a2 = fnI(a2, b2, c2, d4, M4[4], 4149444226, 6);
    d4 = fnI(d4, a2, b2, c2, M4[11], 3174756917, 10);
    c2 = fnI(c2, d4, a2, b2, M4[2], 718787259, 15);
    b2 = fnI(b2, c2, d4, a2, M4[9], 3951481745, 21);
    this._a = this._a + a2 | 0;
    this._b = this._b + b2 | 0;
    this._c = this._c + c2 | 0;
    this._d = this._d + d4 | 0;
  };
  MD5.prototype._digest = function() {
    this._block[this._blockOffset++] = 128;
    if (this._blockOffset > 56) {
      this._block.fill(0, this._blockOffset, 64);
      this._update();
      this._blockOffset = 0;
    }
    this._block.fill(0, this._blockOffset, 56);
    this._block.writeUInt32LE(this._length[0], 56);
    this._block.writeUInt32LE(this._length[1], 60);
    this._update();
    var buffer2 = Buffer2.allocUnsafe(16);
    buffer2.writeInt32LE(this._a, 0);
    buffer2.writeInt32LE(this._b, 4);
    buffer2.writeInt32LE(this._c, 8);
    buffer2.writeInt32LE(this._d, 12);
    return buffer2;
  };
  function rotl(x2, n5) {
    return x2 << n5 | x2 >>> 32 - n5;
  }
  function fnF(a2, b2, c2, d4, m4, k3, s2) {
    return rotl(a2 + (b2 & c2 | ~b2 & d4) + m4 + k3 | 0, s2) + b2 | 0;
  }
  function fnG(a2, b2, c2, d4, m4, k3, s2) {
    return rotl(a2 + (b2 & d4 | c2 & ~d4) + m4 + k3 | 0, s2) + b2 | 0;
  }
  function fnH(a2, b2, c2, d4, m4, k3, s2) {
    return rotl(a2 + (b2 ^ c2 ^ d4) + m4 + k3 | 0, s2) + b2 | 0;
  }
  function fnI(a2, b2, c2, d4, m4, k3, s2) {
    return rotl(a2 + (c2 ^ (b2 | ~d4)) + m4 + k3 | 0, s2) + b2 | 0;
  }
  md5_js = MD5;
  return md5_js;
}
var ripemd160;
var hasRequiredRipemd160;
function requireRipemd160() {
  if (hasRequiredRipemd160) return ripemd160;
  hasRequiredRipemd160 = 1;
  var Buffer2 = require$$1$2.Buffer;
  var inherits2 = inherits_browserExports;
  var HashBase = requireHashBase();
  var ARRAY16 = new Array(16);
  var zl = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ];
  var zr3 = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ];
  var sl = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ];
  var sr2 = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  var hl = [0, 1518500249, 1859775393, 2400959708, 2840853838];
  var hr2 = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function rotl(x2, n5) {
    return x2 << n5 | x2 >>> 32 - n5;
  }
  function fn1(a2, b2, c2, d4, e3, m4, k3, s2) {
    return rotl(a2 + (b2 ^ c2 ^ d4) + m4 + k3 | 0, s2) + e3 | 0;
  }
  function fn2(a2, b2, c2, d4, e3, m4, k3, s2) {
    return rotl(a2 + (b2 & c2 | ~b2 & d4) + m4 + k3 | 0, s2) + e3 | 0;
  }
  function fn3(a2, b2, c2, d4, e3, m4, k3, s2) {
    return rotl(a2 + ((b2 | ~c2) ^ d4) + m4 + k3 | 0, s2) + e3 | 0;
  }
  function fn4(a2, b2, c2, d4, e3, m4, k3, s2) {
    return rotl(a2 + (b2 & d4 | c2 & ~d4) + m4 + k3 | 0, s2) + e3 | 0;
  }
  function fn5(a2, b2, c2, d4, e3, m4, k3, s2) {
    return rotl(a2 + (b2 ^ (c2 | ~d4)) + m4 + k3 | 0, s2) + e3 | 0;
  }
  function RIPEMD1602() {
    HashBase.call(this, 64);
    this._a = 1732584193;
    this._b = 4023233417;
    this._c = 2562383102;
    this._d = 271733878;
    this._e = 3285377520;
  }
  inherits2(RIPEMD1602, HashBase);
  RIPEMD1602.prototype._update = function() {
    var words = ARRAY16;
    for (var j2 = 0; j2 < 16; ++j2) {
      words[j2] = this._block.readInt32LE(j2 * 4);
    }
    var al = this._a | 0;
    var bl = this._b | 0;
    var cl = this._c | 0;
    var dl = this._d | 0;
    var el = this._e | 0;
    var ar2 = this._a | 0;
    var br2 = this._b | 0;
    var cr2 = this._c | 0;
    var dr2 = this._d | 0;
    var er4 = this._e | 0;
    for (var i4 = 0; i4 < 80; i4 += 1) {
      var tl;
      var tr4;
      if (i4 < 16) {
        tl = fn1(al, bl, cl, dl, el, words[zl[i4]], hl[0], sl[i4]);
        tr4 = fn5(ar2, br2, cr2, dr2, er4, words[zr3[i4]], hr2[0], sr2[i4]);
      } else if (i4 < 32) {
        tl = fn2(al, bl, cl, dl, el, words[zl[i4]], hl[1], sl[i4]);
        tr4 = fn4(ar2, br2, cr2, dr2, er4, words[zr3[i4]], hr2[1], sr2[i4]);
      } else if (i4 < 48) {
        tl = fn3(al, bl, cl, dl, el, words[zl[i4]], hl[2], sl[i4]);
        tr4 = fn3(ar2, br2, cr2, dr2, er4, words[zr3[i4]], hr2[2], sr2[i4]);
      } else if (i4 < 64) {
        tl = fn4(al, bl, cl, dl, el, words[zl[i4]], hl[3], sl[i4]);
        tr4 = fn2(ar2, br2, cr2, dr2, er4, words[zr3[i4]], hr2[3], sr2[i4]);
      } else {
        tl = fn5(al, bl, cl, dl, el, words[zl[i4]], hl[4], sl[i4]);
        tr4 = fn1(ar2, br2, cr2, dr2, er4, words[zr3[i4]], hr2[4], sr2[i4]);
      }
      al = el;
      el = dl;
      dl = rotl(cl, 10);
      cl = bl;
      bl = tl;
      ar2 = er4;
      er4 = dr2;
      dr2 = rotl(cr2, 10);
      cr2 = br2;
      br2 = tr4;
    }
    var t2 = this._b + cl + dr2 | 0;
    this._b = this._c + dl + er4 | 0;
    this._c = this._d + el + ar2 | 0;
    this._d = this._e + al + br2 | 0;
    this._e = this._a + bl + cr2 | 0;
    this._a = t2;
  };
  RIPEMD1602.prototype._digest = function() {
    this._block[this._blockOffset] = 128;
    this._blockOffset += 1;
    if (this._blockOffset > 56) {
      this._block.fill(0, this._blockOffset, 64);
      this._update();
      this._blockOffset = 0;
    }
    this._block.fill(0, this._blockOffset, 56);
    this._block.writeUInt32LE(this._length[0], 56);
    this._block.writeUInt32LE(this._length[1], 60);
    this._update();
    var buffer2 = Buffer2.alloc ? Buffer2.alloc(20) : new Buffer2(20);
    buffer2.writeInt32LE(this._a, 0);
    buffer2.writeInt32LE(this._b, 4);
    buffer2.writeInt32LE(this._c, 8);
    buffer2.writeInt32LE(this._d, 12);
    buffer2.writeInt32LE(this._e, 16);
    return buffer2;
  };
  ripemd160 = RIPEMD1602;
  return ripemd160;
}
var sha_js = { exports: {} };
var hash$4;
var hasRequiredHash;
function requireHash() {
  if (hasRequiredHash) return hash$4;
  hasRequiredHash = 1;
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var toBuffer2 = requireToBuffer$2();
  function Hash3(blockSize, finalSize) {
    this._block = Buffer2.alloc(blockSize);
    this._finalSize = finalSize;
    this._blockSize = blockSize;
    this._len = 0;
  }
  Hash3.prototype.update = function(data2, enc) {
    data2 = toBuffer2(data2, enc || "utf8");
    var block = this._block;
    var blockSize = this._blockSize;
    var length = data2.length;
    var accum = this._len;
    for (var offset = 0; offset < length; ) {
      var assigned = accum % blockSize;
      var remainder = Math.min(length - offset, blockSize - assigned);
      for (var i4 = 0; i4 < remainder; i4++) {
        block[assigned + i4] = data2[offset + i4];
      }
      accum += remainder;
      offset += remainder;
      if (accum % blockSize === 0) {
        this._update(block);
      }
    }
    this._len += length;
    return this;
  };
  Hash3.prototype.digest = function(enc) {
    var rem = this._len % this._blockSize;
    this._block[rem] = 128;
    this._block.fill(0, rem + 1);
    if (rem >= this._finalSize) {
      this._update(this._block);
      this._block.fill(0);
    }
    var bits = this._len * 8;
    if (bits <= 4294967295) {
      this._block.writeUInt32BE(bits, this._blockSize - 4);
    } else {
      var lowBits = (bits & 4294967295) >>> 0;
      var highBits = (bits - lowBits) / 4294967296;
      this._block.writeUInt32BE(highBits, this._blockSize - 8);
      this._block.writeUInt32BE(lowBits, this._blockSize - 4);
    }
    this._update(this._block);
    var hash3 = this._hash();
    return enc ? hash3.toString(enc) : hash3;
  };
  Hash3.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  };
  hash$4 = Hash3;
  return hash$4;
}
var sha$1;
var hasRequiredSha;
function requireSha() {
  if (hasRequiredSha) return sha$1;
  hasRequiredSha = 1;
  var inherits2 = inherits_browserExports;
  var Hash3 = requireHash();
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var K3 = [
    1518500249,
    1859775393,
    2400959708 | 0,
    3395469782 | 0
  ];
  var W2 = new Array(80);
  function Sha() {
    this.init();
    this._w = W2;
    Hash3.call(this, 64, 56);
  }
  inherits2(Sha, Hash3);
  Sha.prototype.init = function() {
    this._a = 1732584193;
    this._b = 4023233417;
    this._c = 2562383102;
    this._d = 271733878;
    this._e = 3285377520;
    return this;
  };
  function rotl5(num) {
    return num << 5 | num >>> 27;
  }
  function rotl30(num) {
    return num << 30 | num >>> 2;
  }
  function ft3(s2, b2, c2, d4) {
    if (s2 === 0) {
      return b2 & c2 | ~b2 & d4;
    }
    if (s2 === 2) {
      return b2 & c2 | b2 & d4 | c2 & d4;
    }
    return b2 ^ c2 ^ d4;
  }
  Sha.prototype._update = function(M4) {
    var w2 = this._w;
    var a2 = this._a | 0;
    var b2 = this._b | 0;
    var c2 = this._c | 0;
    var d4 = this._d | 0;
    var e3 = this._e | 0;
    for (var i4 = 0; i4 < 16; ++i4) {
      w2[i4] = M4.readInt32BE(i4 * 4);
    }
    for (; i4 < 80; ++i4) {
      w2[i4] = w2[i4 - 3] ^ w2[i4 - 8] ^ w2[i4 - 14] ^ w2[i4 - 16];
    }
    for (var j2 = 0; j2 < 80; ++j2) {
      var s2 = ~~(j2 / 20);
      var t2 = rotl5(a2) + ft3(s2, b2, c2, d4) + e3 + w2[j2] + K3[s2] | 0;
      e3 = d4;
      d4 = c2;
      c2 = rotl30(b2);
      b2 = a2;
      a2 = t2;
    }
    this._a = a2 + this._a | 0;
    this._b = b2 + this._b | 0;
    this._c = c2 + this._c | 0;
    this._d = d4 + this._d | 0;
    this._e = e3 + this._e | 0;
  };
  Sha.prototype._hash = function() {
    var H3 = Buffer2.allocUnsafe(20);
    H3.writeInt32BE(this._a | 0, 0);
    H3.writeInt32BE(this._b | 0, 4);
    H3.writeInt32BE(this._c | 0, 8);
    H3.writeInt32BE(this._d | 0, 12);
    H3.writeInt32BE(this._e | 0, 16);
    return H3;
  };
  sha$1 = Sha;
  return sha$1;
}
var sha1;
var hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1) return sha1;
  hasRequiredSha1 = 1;
  var inherits2 = inherits_browserExports;
  var Hash3 = requireHash();
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var K3 = [
    1518500249,
    1859775393,
    2400959708 | 0,
    3395469782 | 0
  ];
  var W2 = new Array(80);
  function Sha1() {
    this.init();
    this._w = W2;
    Hash3.call(this, 64, 56);
  }
  inherits2(Sha1, Hash3);
  Sha1.prototype.init = function() {
    this._a = 1732584193;
    this._b = 4023233417;
    this._c = 2562383102;
    this._d = 271733878;
    this._e = 3285377520;
    return this;
  };
  function rotl1(num) {
    return num << 1 | num >>> 31;
  }
  function rotl5(num) {
    return num << 5 | num >>> 27;
  }
  function rotl30(num) {
    return num << 30 | num >>> 2;
  }
  function ft3(s2, b2, c2, d4) {
    if (s2 === 0) {
      return b2 & c2 | ~b2 & d4;
    }
    if (s2 === 2) {
      return b2 & c2 | b2 & d4 | c2 & d4;
    }
    return b2 ^ c2 ^ d4;
  }
  Sha1.prototype._update = function(M4) {
    var w2 = this._w;
    var a2 = this._a | 0;
    var b2 = this._b | 0;
    var c2 = this._c | 0;
    var d4 = this._d | 0;
    var e3 = this._e | 0;
    for (var i4 = 0; i4 < 16; ++i4) {
      w2[i4] = M4.readInt32BE(i4 * 4);
    }
    for (; i4 < 80; ++i4) {
      w2[i4] = rotl1(w2[i4 - 3] ^ w2[i4 - 8] ^ w2[i4 - 14] ^ w2[i4 - 16]);
    }
    for (var j2 = 0; j2 < 80; ++j2) {
      var s2 = ~~(j2 / 20);
      var t2 = rotl5(a2) + ft3(s2, b2, c2, d4) + e3 + w2[j2] + K3[s2] | 0;
      e3 = d4;
      d4 = c2;
      c2 = rotl30(b2);
      b2 = a2;
      a2 = t2;
    }
    this._a = a2 + this._a | 0;
    this._b = b2 + this._b | 0;
    this._c = c2 + this._c | 0;
    this._d = d4 + this._d | 0;
    this._e = e3 + this._e | 0;
  };
  Sha1.prototype._hash = function() {
    var H3 = Buffer2.allocUnsafe(20);
    H3.writeInt32BE(this._a | 0, 0);
    H3.writeInt32BE(this._b | 0, 4);
    H3.writeInt32BE(this._c | 0, 8);
    H3.writeInt32BE(this._d | 0, 12);
    H3.writeInt32BE(this._e | 0, 16);
    return H3;
  };
  sha1 = Sha1;
  return sha1;
}
var sha256$3;
var hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256) return sha256$3;
  hasRequiredSha256 = 1;
  var inherits2 = inherits_browserExports;
  var Hash3 = requireHash();
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var K3 = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  var W2 = new Array(64);
  function Sha256() {
    this.init();
    this._w = W2;
    Hash3.call(this, 64, 56);
  }
  inherits2(Sha256, Hash3);
  Sha256.prototype.init = function() {
    this._a = 1779033703;
    this._b = 3144134277;
    this._c = 1013904242;
    this._d = 2773480762;
    this._e = 1359893119;
    this._f = 2600822924;
    this._g = 528734635;
    this._h = 1541459225;
    return this;
  };
  function ch(x2, y4, z3) {
    return z3 ^ x2 & (y4 ^ z3);
  }
  function maj(x2, y4, z3) {
    return x2 & y4 | z3 & (x2 | y4);
  }
  function sigma0(x2) {
    return (x2 >>> 2 | x2 << 30) ^ (x2 >>> 13 | x2 << 19) ^ (x2 >>> 22 | x2 << 10);
  }
  function sigma1(x2) {
    return (x2 >>> 6 | x2 << 26) ^ (x2 >>> 11 | x2 << 21) ^ (x2 >>> 25 | x2 << 7);
  }
  function gamma0(x2) {
    return (x2 >>> 7 | x2 << 25) ^ (x2 >>> 18 | x2 << 14) ^ x2 >>> 3;
  }
  function gamma1(x2) {
    return (x2 >>> 17 | x2 << 15) ^ (x2 >>> 19 | x2 << 13) ^ x2 >>> 10;
  }
  Sha256.prototype._update = function(M4) {
    var w2 = this._w;
    var a2 = this._a | 0;
    var b2 = this._b | 0;
    var c2 = this._c | 0;
    var d4 = this._d | 0;
    var e3 = this._e | 0;
    var f6 = this._f | 0;
    var g2 = this._g | 0;
    var h5 = this._h | 0;
    for (var i4 = 0; i4 < 16; ++i4) {
      w2[i4] = M4.readInt32BE(i4 * 4);
    }
    for (; i4 < 64; ++i4) {
      w2[i4] = gamma1(w2[i4 - 2]) + w2[i4 - 7] + gamma0(w2[i4 - 15]) + w2[i4 - 16] | 0;
    }
    for (var j2 = 0; j2 < 64; ++j2) {
      var T12 = h5 + sigma1(e3) + ch(e3, f6, g2) + K3[j2] + w2[j2] | 0;
      var T2 = sigma0(a2) + maj(a2, b2, c2) | 0;
      h5 = g2;
      g2 = f6;
      f6 = e3;
      e3 = d4 + T12 | 0;
      d4 = c2;
      c2 = b2;
      b2 = a2;
      a2 = T12 + T2 | 0;
    }
    this._a = a2 + this._a | 0;
    this._b = b2 + this._b | 0;
    this._c = c2 + this._c | 0;
    this._d = d4 + this._d | 0;
    this._e = e3 + this._e | 0;
    this._f = f6 + this._f | 0;
    this._g = g2 + this._g | 0;
    this._h = h5 + this._h | 0;
  };
  Sha256.prototype._hash = function() {
    var H3 = Buffer2.allocUnsafe(32);
    H3.writeInt32BE(this._a, 0);
    H3.writeInt32BE(this._b, 4);
    H3.writeInt32BE(this._c, 8);
    H3.writeInt32BE(this._d, 12);
    H3.writeInt32BE(this._e, 16);
    H3.writeInt32BE(this._f, 20);
    H3.writeInt32BE(this._g, 24);
    H3.writeInt32BE(this._h, 28);
    return H3;
  };
  sha256$3 = Sha256;
  return sha256$3;
}
var sha224$1;
var hasRequiredSha224;
function requireSha224() {
  if (hasRequiredSha224) return sha224$1;
  hasRequiredSha224 = 1;
  var inherits2 = inherits_browserExports;
  var Sha256 = requireSha256();
  var Hash3 = requireHash();
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var W2 = new Array(64);
  function Sha224() {
    this.init();
    this._w = W2;
    Hash3.call(this, 64, 56);
  }
  inherits2(Sha224, Sha256);
  Sha224.prototype.init = function() {
    this._a = 3238371032;
    this._b = 914150663;
    this._c = 812702999;
    this._d = 4144912697;
    this._e = 4290775857;
    this._f = 1750603025;
    this._g = 1694076839;
    this._h = 3204075428;
    return this;
  };
  Sha224.prototype._hash = function() {
    var H3 = Buffer2.allocUnsafe(28);
    H3.writeInt32BE(this._a, 0);
    H3.writeInt32BE(this._b, 4);
    H3.writeInt32BE(this._c, 8);
    H3.writeInt32BE(this._d, 12);
    H3.writeInt32BE(this._e, 16);
    H3.writeInt32BE(this._f, 20);
    H3.writeInt32BE(this._g, 24);
    return H3;
  };
  sha224$1 = Sha224;
  return sha224$1;
}
var sha512$2;
var hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512) return sha512$2;
  hasRequiredSha512 = 1;
  var inherits2 = inherits_browserExports;
  var Hash3 = requireHash();
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var K3 = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  var W2 = new Array(160);
  function Sha512() {
    this.init();
    this._w = W2;
    Hash3.call(this, 128, 112);
  }
  inherits2(Sha512, Hash3);
  Sha512.prototype.init = function() {
    this._ah = 1779033703;
    this._bh = 3144134277;
    this._ch = 1013904242;
    this._dh = 2773480762;
    this._eh = 1359893119;
    this._fh = 2600822924;
    this._gh = 528734635;
    this._hh = 1541459225;
    this._al = 4089235720;
    this._bl = 2227873595;
    this._cl = 4271175723;
    this._dl = 1595750129;
    this._el = 2917565137;
    this._fl = 725511199;
    this._gl = 4215389547;
    this._hl = 327033209;
    return this;
  };
  function Ch(x2, y4, z3) {
    return z3 ^ x2 & (y4 ^ z3);
  }
  function maj(x2, y4, z3) {
    return x2 & y4 | z3 & (x2 | y4);
  }
  function sigma0(x2, xl) {
    return (x2 >>> 28 | xl << 4) ^ (xl >>> 2 | x2 << 30) ^ (xl >>> 7 | x2 << 25);
  }
  function sigma1(x2, xl) {
    return (x2 >>> 14 | xl << 18) ^ (x2 >>> 18 | xl << 14) ^ (xl >>> 9 | x2 << 23);
  }
  function Gamma0(x2, xl) {
    return (x2 >>> 1 | xl << 31) ^ (x2 >>> 8 | xl << 24) ^ x2 >>> 7;
  }
  function Gamma0l(x2, xl) {
    return (x2 >>> 1 | xl << 31) ^ (x2 >>> 8 | xl << 24) ^ (x2 >>> 7 | xl << 25);
  }
  function Gamma1(x2, xl) {
    return (x2 >>> 19 | xl << 13) ^ (xl >>> 29 | x2 << 3) ^ x2 >>> 6;
  }
  function Gamma1l(x2, xl) {
    return (x2 >>> 19 | xl << 13) ^ (xl >>> 29 | x2 << 3) ^ (x2 >>> 6 | xl << 26);
  }
  function getCarry(a2, b2) {
    return a2 >>> 0 < b2 >>> 0 ? 1 : 0;
  }
  Sha512.prototype._update = function(M4) {
    var w2 = this._w;
    var ah2 = this._ah | 0;
    var bh = this._bh | 0;
    var ch = this._ch | 0;
    var dh2 = this._dh | 0;
    var eh2 = this._eh | 0;
    var fh = this._fh | 0;
    var gh = this._gh | 0;
    var hh = this._hh | 0;
    var al = this._al | 0;
    var bl = this._bl | 0;
    var cl = this._cl | 0;
    var dl = this._dl | 0;
    var el = this._el | 0;
    var fl = this._fl | 0;
    var gl = this._gl | 0;
    var hl = this._hl | 0;
    for (var i4 = 0; i4 < 32; i4 += 2) {
      w2[i4] = M4.readInt32BE(i4 * 4);
      w2[i4 + 1] = M4.readInt32BE(i4 * 4 + 4);
    }
    for (; i4 < 160; i4 += 2) {
      var xh = w2[i4 - 15 * 2];
      var xl = w2[i4 - 15 * 2 + 1];
      var gamma0 = Gamma0(xh, xl);
      var gamma0l = Gamma0l(xl, xh);
      xh = w2[i4 - 2 * 2];
      xl = w2[i4 - 2 * 2 + 1];
      var gamma1 = Gamma1(xh, xl);
      var gamma1l = Gamma1l(xl, xh);
      var Wi7h = w2[i4 - 7 * 2];
      var Wi7l = w2[i4 - 7 * 2 + 1];
      var Wi16h = w2[i4 - 16 * 2];
      var Wi16l = w2[i4 - 16 * 2 + 1];
      var Wil = gamma0l + Wi7l | 0;
      var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
      Wil = Wil + gamma1l | 0;
      Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
      Wil = Wil + Wi16l | 0;
      Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
      w2[i4] = Wih;
      w2[i4 + 1] = Wil;
    }
    for (var j2 = 0; j2 < 160; j2 += 2) {
      Wih = w2[j2];
      Wil = w2[j2 + 1];
      var majh = maj(ah2, bh, ch);
      var majl = maj(al, bl, cl);
      var sigma0h = sigma0(ah2, al);
      var sigma0l = sigma0(al, ah2);
      var sigma1h = sigma1(eh2, el);
      var sigma1l = sigma1(el, eh2);
      var Kih = K3[j2];
      var Kil = K3[j2 + 1];
      var chh = Ch(eh2, fh, gh);
      var chl = Ch(el, fl, gl);
      var t1l = hl + sigma1l | 0;
      var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
      t1l = t1l + chl | 0;
      t1h = t1h + chh + getCarry(t1l, chl) | 0;
      t1l = t1l + Kil | 0;
      t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
      t1l = t1l + Wil | 0;
      t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
      var t2l = sigma0l + majl | 0;
      var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
      hh = gh;
      hl = gl;
      gh = fh;
      gl = fl;
      fh = eh2;
      fl = el;
      el = dl + t1l | 0;
      eh2 = dh2 + t1h + getCarry(el, dl) | 0;
      dh2 = ch;
      dl = cl;
      ch = bh;
      cl = bl;
      bh = ah2;
      bl = al;
      al = t1l + t2l | 0;
      ah2 = t1h + t2h + getCarry(al, t1l) | 0;
    }
    this._al = this._al + al | 0;
    this._bl = this._bl + bl | 0;
    this._cl = this._cl + cl | 0;
    this._dl = this._dl + dl | 0;
    this._el = this._el + el | 0;
    this._fl = this._fl + fl | 0;
    this._gl = this._gl + gl | 0;
    this._hl = this._hl + hl | 0;
    this._ah = this._ah + ah2 + getCarry(this._al, al) | 0;
    this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
    this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
    this._dh = this._dh + dh2 + getCarry(this._dl, dl) | 0;
    this._eh = this._eh + eh2 + getCarry(this._el, el) | 0;
    this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
    this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
    this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
  };
  Sha512.prototype._hash = function() {
    var H3 = Buffer2.allocUnsafe(64);
    function writeInt64BE(h5, l2, offset) {
      H3.writeInt32BE(h5, offset);
      H3.writeInt32BE(l2, offset + 4);
    }
    writeInt64BE(this._ah, this._al, 0);
    writeInt64BE(this._bh, this._bl, 8);
    writeInt64BE(this._ch, this._cl, 16);
    writeInt64BE(this._dh, this._dl, 24);
    writeInt64BE(this._eh, this._el, 32);
    writeInt64BE(this._fh, this._fl, 40);
    writeInt64BE(this._gh, this._gl, 48);
    writeInt64BE(this._hh, this._hl, 56);
    return H3;
  };
  sha512$2 = Sha512;
  return sha512$2;
}
var sha384$1;
var hasRequiredSha384;
function requireSha384() {
  if (hasRequiredSha384) return sha384$1;
  hasRequiredSha384 = 1;
  var inherits2 = inherits_browserExports;
  var SHA5122 = requireSha512();
  var Hash3 = requireHash();
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var W2 = new Array(160);
  function Sha384() {
    this.init();
    this._w = W2;
    Hash3.call(this, 128, 112);
  }
  inherits2(Sha384, SHA5122);
  Sha384.prototype.init = function() {
    this._ah = 3418070365;
    this._bh = 1654270250;
    this._ch = 2438529370;
    this._dh = 355462360;
    this._eh = 1731405415;
    this._fh = 2394180231;
    this._gh = 3675008525;
    this._hh = 1203062813;
    this._al = 3238371032;
    this._bl = 914150663;
    this._cl = 812702999;
    this._dl = 4144912697;
    this._el = 4290775857;
    this._fl = 1750603025;
    this._gl = 1694076839;
    this._hl = 3204075428;
    return this;
  };
  Sha384.prototype._hash = function() {
    var H3 = Buffer2.allocUnsafe(48);
    function writeInt64BE(h5, l2, offset) {
      H3.writeInt32BE(h5, offset);
      H3.writeInt32BE(l2, offset + 4);
    }
    writeInt64BE(this._ah, this._al, 0);
    writeInt64BE(this._bh, this._bl, 8);
    writeInt64BE(this._ch, this._cl, 16);
    writeInt64BE(this._dh, this._dl, 24);
    writeInt64BE(this._eh, this._el, 32);
    writeInt64BE(this._fh, this._fl, 40);
    return H3;
  };
  sha384$1 = Sha384;
  return sha384$1;
}
var hasRequiredSha_js;
function requireSha_js() {
  if (hasRequiredSha_js) return sha_js.exports;
  hasRequiredSha_js = 1;
  (function(module) {
    module.exports = function SHA(algorithm) {
      var alg = algorithm.toLowerCase();
      var Algorithm = module.exports[alg];
      if (!Algorithm) {
        throw new Error(alg + " is not supported (we accept pull requests)");
      }
      return new Algorithm();
    };
    module.exports.sha = requireSha();
    module.exports.sha1 = requireSha1();
    module.exports.sha224 = requireSha224();
    module.exports.sha256 = requireSha256();
    module.exports.sha384 = requireSha384();
    module.exports.sha512 = requireSha512();
  })(sha_js);
  return sha_js.exports;
}
var streamBrowser;
var hasRequiredStreamBrowser;
function requireStreamBrowser() {
  if (hasRequiredStreamBrowser) return streamBrowser;
  hasRequiredStreamBrowser = 1;
  streamBrowser = eventsExports.EventEmitter;
  return streamBrowser;
}
var buffer_list;
var hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function ownKeys(object2, enumerableOnly) {
    var keys2 = Object.keys(object2);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object2);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread(target) {
    for (var i4 = 1; i4 < arguments.length; i4++) {
      var source = null != arguments[i4] ? arguments[i4] : {};
      i4 % 2 ? ownKeys(Object(source), true).forEach(function(key2) {
        _defineProperty(target, key2, source[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
    return target;
  }
  function _defineProperty(obj, key2, value) {
    key2 = _toPropertyKey(key2);
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i4 = 0; i4 < props.length; i4++) {
      var descriptor = props[i4];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _toPropertyKey(arg) {
    var key2 = _toPrimitive(arg, "string");
    return typeof key2 === "symbol" ? key2 : String(key2);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint);
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(input);
  }
  var _require = require$$1$2, Buffer2 = _require.Buffer;
  var _require2 = requireUtil(), inspect6 = _require2.inspect;
  var custom2 = inspect6 && inspect6.custom || "inspect";
  function copyBuffer(src2, target, offset) {
    Buffer2.prototype.copy.call(src2, target, offset);
  }
  buffer_list = /* @__PURE__ */ function() {
    function BufferList2() {
      _classCallCheck(this, BufferList2);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList2, [{
      key: "push",
      value: function push(v2) {
        var entry = {
          data: v2,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v2) {
        var entry = {
          data: v2,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear2() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s2) {
        if (this.length === 0) return "";
        var p2 = this.head;
        var ret = "" + p2.data;
        while (p2 = p2.next) ret += s2 + p2.data;
        return ret;
      }
    }, {
      key: "concat",
      value: function concat2(n5) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n5 >>> 0);
        var p2 = this.head;
        var i4 = 0;
        while (p2) {
          copyBuffer(p2.data, ret, i4);
          i4 += p2.data.length;
          p2 = p2.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume(n5, hasStrings) {
        var ret;
        if (n5 < this.head.data.length) {
          ret = this.head.data.slice(0, n5);
          this.head.data = this.head.data.slice(n5);
        } else if (n5 === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n5) : this._getBuffer(n5);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n5) {
        var p2 = this.head;
        var c2 = 1;
        var ret = p2.data;
        n5 -= ret.length;
        while (p2 = p2.next) {
          var str = p2.data;
          var nb = n5 > str.length ? str.length : n5;
          if (nb === str.length) ret += str;
          else ret += str.slice(0, n5);
          n5 -= nb;
          if (n5 === 0) {
            if (nb === str.length) {
              ++c2;
              if (p2.next) this.head = p2.next;
              else this.head = this.tail = null;
            } else {
              this.head = p2;
              p2.data = str.slice(nb);
            }
            break;
          }
          ++c2;
        }
        this.length -= c2;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n5) {
        var ret = Buffer2.allocUnsafe(n5);
        var p2 = this.head;
        var c2 = 1;
        p2.data.copy(ret);
        n5 -= p2.data.length;
        while (p2 = p2.next) {
          var buf = p2.data;
          var nb = n5 > buf.length ? buf.length : n5;
          buf.copy(ret, ret.length - n5, 0, nb);
          n5 -= nb;
          if (n5 === 0) {
            if (nb === buf.length) {
              ++c2;
              if (p2.next) this.head = p2.next;
              else this.head = this.tail = null;
            } else {
              this.head = p2;
              p2.data = buf.slice(nb);
            }
            break;
          }
          ++c2;
        }
        this.length -= c2;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom2,
      value: function value(_3, options) {
        return inspect6(this, _objectSpread(_objectSpread({}, options), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList2;
  }();
  return buffer_list;
}
var destroy_1;
var hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process$1.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process$1.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process$1.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process$1.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose) return;
    if (self2._readableState && !self2._readableState.emitClose) return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream, err) {
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
    else stream.emit("error", err);
  }
  destroy_1 = {
    destroy,
    undestroy,
    errorOrDestroy
  };
  return destroy_1;
}
var errorsBrowser = {};
var hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser) return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var codes = {};
  function createErrorType(code2, message, Base2) {
    if (!Base2) {
      Base2 = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }
    var NodeError = /* @__PURE__ */ function(_Base) {
      _inheritsLoose(NodeError2, _Base);
      function NodeError2(arg1, arg2, arg3) {
        return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
      }
      return NodeError2;
    }(Base2);
    NodeError.prototype.name = Base2.name;
    NodeError.prototype.code = code2;
    codes[code2] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      var len2 = expected.length;
      expected = expected.map(function(i4) {
        return String(i4);
      });
      if (len2 > 2) {
        return "one of ".concat(thing, " ").concat(expected.slice(0, len2 - 1).join(", "), ", or ") + expected[len2 - 1];
      } else if (len2 === 2) {
        return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
      } else {
        return "of ".concat(thing, " ").concat(expected[0]);
      }
    } else {
      return "of ".concat(thing, " ").concat(String(expected));
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(0, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    var determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    var msg;
    if (endsWith(name, " argument")) {
      msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    } else {
      var type2 = includes(name, ".") ? "property" : "argument";
      msg = 'The "'.concat(name, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    }
    msg += ". Received type ".concat(typeof actual);
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  errorsBrowser.codes = codes;
  return errorsBrowser;
}
var state$n;
var hasRequiredState;
function requireState() {
  if (hasRequiredState) return state$n;
  hasRequiredState = 1;
  var ERR_INVALID_OPT_VALUE = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state2, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }
      return Math.floor(hwm);
    }
    return state2.objectMode ? 16 : 16 * 1024;
  }
  state$n = {
    getHighWaterMark
  };
  return state$n;
}
var _stream_writable;
var hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  _stream_writable = Writable;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var Duplex;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: requireBrowser$a()
  };
  var Stream = requireStreamBrowser();
  var Buffer2 = require$$1$2.Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy();
  var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = requireErrorsBrowser().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  inherits_browserExports(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er4) {
      onwrite(stream, er4);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_3) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object2) {
        if (realHasInstance.call(this, object2)) return true;
        if (this !== Writable) return false;
        return object2 && object2._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object2) {
      return object2 instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require_stream_duplex();
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.final === "function") this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream, cb) {
    var er4 = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy(stream, er4);
    process$1.nextTick(cb, er4);
  }
  function validChunk(stream, state2, chunk, cb) {
    var er4;
    if (chunk === null) {
      er4 = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state2.objectMode) {
      er4 = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er4) {
      errorOrDestroy(stream, er4);
      process$1.nextTick(cb, er4);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state2.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state2.ending) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len2 = state2.objectMode ? 1 : chunk.length;
    state2.length += len2;
    var ret = state2.length < state2.highWaterMark;
    if (!ret) state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state2, false, len2, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state2, writev, len2, chunk, encoding, cb) {
    state2.writelen = len2;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (state2.destroyed) state2.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev) stream._writev(chunk, state2.onwrite);
    else stream._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream, state2, sync, er4, cb) {
    --state2.pendingcb;
    if (sync) {
      process$1.nextTick(cb, er4);
      process$1.nextTick(finishMaybe, stream, state2);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er4);
    } else {
      cb(er4);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er4);
      finishMaybe(stream, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream, er4) {
    var state2 = stream._writableState;
    var sync = state2.sync;
    var cb = state2.writecb;
    if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state2);
    if (er4) onwriteError(stream, state2, sync, er4, cb);
    else {
      var finished = needFinish(state2) || stream.destroyed;
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream, state2);
      }
      if (sync) {
        process$1.nextTick(afterWrite, stream, state2, finished, cb);
      } else {
        afterWrite(stream, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream, state2, finished, cb) {
    if (!finished) onwriteDrain(stream, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream, state2);
  }
  function onwriteDrain(stream, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l2 = state2.bufferedRequestCount;
      var buffer2 = new Array(l2);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream, state2, true, state2.length, buffer2, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len2 = state2.objectMode ? 1 : chunk.length;
        doWrite(stream, state2, false, len2, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null) state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending) endWritable(this, state2, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream, state2) {
    stream._final(function(err) {
      state2.pendingcb--;
      if (err) {
        errorOrDestroy(stream, err);
      }
      state2.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state2);
    });
  }
  function prefinish(stream, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream._final === "function" && !state2.destroyed) {
        state2.pendingcb++;
        state2.finalCalled = true;
        process$1.nextTick(callFinal, stream, state2);
      } else {
        state2.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream.emit("finish");
        if (state2.autoDestroy) {
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream, state2, cb) {
    state2.ending = true;
    finishMaybe(stream, state2);
    if (cb) {
      if (state2.finished) process$1.nextTick(cb);
      else stream.once("finish", cb);
    }
    state2.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set2(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  return _stream_writable;
}
var _stream_duplex;
var hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var objectKeys = Object.keys || function(obj) {
    var keys3 = [];
    for (var key2 in obj) keys3.push(key2);
    return keys3;
  };
  _stream_duplex = Duplex;
  var Readable = require_stream_readable();
  var Writable = require_stream_writable();
  inherits_browserExports(Duplex, Readable);
  {
    var keys2 = objectKeys(Writable.prototype);
    for (var v2 = 0; v2 < keys2.length; v2++) {
      var method = keys2[v2];
      if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false) this.readable = false;
      if (options.writable === false) this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended) return;
    process$1.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set2(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return _stream_duplex;
}
var endOfStream;
var hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var ERR_STREAM_PREMATURE_CLOSE = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once3(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop2() {
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function eos(stream, opts, callback) {
    if (typeof opts === "function") return eos(stream, null, opts);
    if (!opts) opts = {};
    callback = once3(callback || noop2);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish2() {
      if (!stream.writable) onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish2() {
      writable = false;
      writableEnded = true;
      if (!readable) callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend2() {
      readable = false;
      readableEnded = true;
      if (!writable) callback.call(stream);
    };
    var onerror = function onerror2(err) {
      callback.call(stream, err);
    };
    var onclose = function onclose2() {
      var err;
      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
    };
    var onrequest = function onrequest2() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req) onrequest();
      else stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req) stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  }
  endOfStream = eos;
  return endOfStream;
}
var async_iterator;
var hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var _Object$setPrototypeO;
  function _defineProperty(obj, key2, value) {
    key2 = _toPropertyKey(key2);
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key2 = _toPrimitive(arg, "string");
    return typeof key2 === "symbol" ? key2 : String(key2);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint);
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var finished = requireEndOfStream();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
      var data2 = iter[kStream].read();
      if (data2 !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data2, false));
      }
    }
  }
  function onReadable(iter) {
    process$1.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve(createIterResult(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve, reject) {
          process$1.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve(createIterResult(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data2 = this[kStream].read();
        if (data2 !== null) {
          return Promise.resolve(createIterResult(data2, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve(createIterResult(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve, reject) {
        var data2 = iterator[kStream].read();
        if (data2) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(data2, false));
        } else {
          iterator[kLastResolve] = resolve;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve = iterator[kLastResolve];
      if (resolve !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  async_iterator = createReadableStreamAsyncIterator;
  return async_iterator;
}
var fromBrowser;
var hasRequiredFromBrowser;
function requireFromBrowser() {
  if (hasRequiredFromBrowser) return fromBrowser;
  hasRequiredFromBrowser = 1;
  fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  };
  return fromBrowser;
}
var _stream_readable;
var hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  _stream_readable = Readable;
  var Duplex;
  Readable.ReadableState = ReadableState;
  eventsExports.EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream = requireStreamBrowser();
  var Buffer2 = require$$1$2.Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = requireUtil();
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function debug2() {
    };
  }
  var BufferList2 = requireBuffer_list();
  var destroyImpl = requireDestroy();
  var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = requireErrorsBrowser().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from2;
  inherits_browserExports(Readable, Stream);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener2(emitter, event, fn2) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn2);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn2);
    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn2);
    else emitter._events[event] = [fn2, emitter._events[event]];
  }
  function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList2();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!(this instanceof Readable)) return new Readable(options);
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function") this._read = options.read;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set2(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state2 = stream._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream, state2);
    } else {
      var er4;
      if (!skipChunkCheck) er4 = chunkInvalid(state2, chunk);
      if (er4) {
        errorOrDestroy(stream, er4);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else addChunk(stream, state2, chunk, true);
        } else if (state2.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state2.destroyed) {
          return false;
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0) addChunk(stream, state2, chunk, false);
            else maybeReadMore(stream, state2);
          } else {
            addChunk(stream, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
        maybeReadMore(stream, state2);
      }
    }
    return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
  }
  function addChunk(stream, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      state2.awaitDrain = 0;
      stream.emit("data", chunk);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront) state2.buffer.unshift(chunk);
      else state2.buffer.push(chunk);
      if (state2.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er4;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er4 = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er4;
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p2 = this._readableState.buffer.head;
    var content = "";
    while (p2 !== null) {
      content += decoder.write(p2.data);
      p2 = p2.next;
    }
    this._readableState.buffer.clear();
    if (content !== "") this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n5) {
    if (n5 >= MAX_HWM) {
      n5 = MAX_HWM;
    } else {
      n5--;
      n5 |= n5 >>> 1;
      n5 |= n5 >>> 2;
      n5 |= n5 >>> 4;
      n5 |= n5 >>> 8;
      n5 |= n5 >>> 16;
      n5++;
    }
    return n5;
  }
  function howMuchToRead(n5, state2) {
    if (n5 <= 0 || state2.length === 0 && state2.ended) return 0;
    if (state2.objectMode) return 1;
    if (n5 !== n5) {
      if (state2.flowing && state2.length) return state2.buffer.head.data.length;
      else return state2.length;
    }
    if (n5 > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n5);
    if (n5 <= state2.length) return n5;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable.prototype.read = function(n5) {
    debug("read", n5);
    n5 = parseInt(n5, 10);
    var state2 = this._readableState;
    var nOrig = n5;
    if (n5 !== 0) state2.emittedReadable = false;
    if (n5 === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
      debug("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n5 = howMuchToRead(n5, state2);
    if (n5 === 0 && state2.ended) {
      if (state2.length === 0) endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug("need readable", doRead);
    if (state2.length === 0 || state2.length - n5 < state2.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0) state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading) n5 = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n5 > 0) ret = fromList(n5, state2);
    else ret = null;
    if (ret === null) {
      state2.needReadable = state2.length <= state2.highWaterMark;
      n5 = 0;
    } else {
      state2.length -= n5;
      state2.awaitDrain = 0;
    }
    if (state2.length === 0) {
      if (!state2.ended) state2.needReadable = true;
      if (nOrig !== n5 && state2.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state2) {
    debug("onEofChunk");
    if (state2.ended) return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    if (state2.sync) {
      emitReadable(stream);
    } else {
      state2.needReadable = false;
      if (!state2.emittedReadable) {
        state2.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  }
  function emitReadable(stream) {
    var state2 = stream._readableState;
    debug("emitReadable", state2.needReadable, state2.emittedReadable);
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      process$1.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    var state2 = stream._readableState;
    debug("emitReadable_", state2.destroyed, state2.length, state2.ended);
    if (!state2.destroyed && (state2.length || state2.ended)) {
      stream.emit("readable");
      state2.emittedReadable = false;
    }
    state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      process$1.nextTick(maybeReadMore_, stream, state2);
    }
  }
  function maybeReadMore_(stream, state2) {
    while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
      var len2 = state2.length;
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len2 === state2.length)
        break;
    }
    state2.readingMore = false;
  }
  Readable.prototype._read = function(n5) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src2 = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted) process$1.nextTick(endFn);
    else src2.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src2) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src2);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src2.removeListener("end", onend);
      src2.removeListener("end", unpipe);
      src2.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    src2.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf2(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
        }
        src2.pause();
      }
    }
    function onerror(er4) {
      debug("onerror", er4);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er4);
    }
    prependListener2(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src2.unpipe(dest);
    }
    dest.emit("pipe", src2);
    if (!state2.flowing) {
      debug("pipe resume");
      src2.resume();
    }
    return dest;
  };
  function pipeOnDrain(src2) {
    return function pipeOnDrainFunctionResult() {
      var state2 = src2._readableState;
      debug("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain) state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src2, "data")) {
        state2.flowing = true;
        flow(src2);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state2.pipesCount === 0) return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes) return this;
      if (!dest) dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len2 = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i4 = 0; i4 < len2; i4++) dests[i4].emit("unpipe", this, {
        hasUnpiped: false
      });
      return this;
    }
    var index2 = indexOf2(state2.pipes, dest);
    if (index2 === -1) return this;
    state2.pipes.splice(index2, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn2) {
    var res = Stream.prototype.on.call(this, ev, fn2);
    var state2 = this._readableState;
    if (ev === "data") {
      state2.readableListening = this.listenerCount("readable") > 0;
      if (state2.flowing !== false) this.resume();
    } else if (ev === "readable") {
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.flowing = false;
        state2.emittedReadable = false;
        debug("on readable", state2.length, state2.reading);
        if (state2.length) {
          emitReadable(this);
        } else if (!state2.reading) {
          process$1.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn2) {
    var res = Stream.prototype.removeListener.call(this, ev, fn2);
    if (ev === "readable") {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state2 = self2._readableState;
    state2.readableListening = self2.listenerCount("readable") > 0;
    if (state2.resumeScheduled && !state2.paused) {
      state2.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug("resume");
      state2.flowing = !state2.readableListening;
      resume(this, state2);
    }
    state2.paused = false;
    return this;
  };
  function resume(stream, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      process$1.nextTick(resume_, stream, state2);
    }
  }
  function resume_(stream, state2) {
    debug("resume", state2.reading);
    if (!state2.reading) {
      stream.read(0);
    }
    state2.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state2.flowing && !state2.reading) stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream) {
    var state2 = stream._readableState;
    debug("flow", state2.flowing);
    while (state2.flowing && stream.read() !== null) ;
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state2.decoder) chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state2.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i4 in stream) {
      if (this[i4] === void 0 && typeof stream[i4] === "function") {
        this[i4] = /* @__PURE__ */ function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        }(i4);
      }
    }
    for (var n5 = 0; n5 < kProxyEvents.length; n5++) {
      stream.on(kProxyEvents[n5], this.emit.bind(this, kProxyEvents[n5]));
    }
    this._read = function(n6) {
      debug("wrapped _read", n6);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = requireAsync_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.flowing;
    },
    set: function set2(state2) {
      if (this._readableState) {
        this._readableState.flowing = state2;
      }
    }
  });
  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.length;
    }
  });
  function fromList(n5, state2) {
    if (state2.length === 0) return null;
    var ret;
    if (state2.objectMode) ret = state2.buffer.shift();
    else if (!n5 || n5 >= state2.length) {
      if (state2.decoder) ret = state2.buffer.join("");
      else if (state2.buffer.length === 1) ret = state2.buffer.first();
      else ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = state2.buffer.consume(n5, state2.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    var state2 = stream._readableState;
    debug("endReadable", state2.endEmitted);
    if (!state2.endEmitted) {
      state2.ended = true;
      process$1.nextTick(endReadableNT, state2, stream);
    }
  }
  function endReadableNT(state2, stream) {
    debug("endReadableNT", state2.endEmitted, state2.length);
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
      if (state2.autoDestroy) {
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable.from = function(iterable, opts) {
      if (from2 === void 0) {
        from2 = requireFromBrowser();
      }
      return from2(Readable, iterable, opts);
    };
  }
  function indexOf2(xs2, x2) {
    for (var i4 = 0, l2 = xs2.length; i4 < l2; i4++) {
      if (xs2[i4] === x2) return i4;
    }
    return -1;
  }
  return _stream_readable;
}
var _stream_transform;
var hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform;
  hasRequired_stream_transform = 1;
  _stream_transform = Transform;
  var _require$codes = requireErrorsBrowser().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex = require_stream_duplex();
  inherits_browserExports(Transform, Duplex);
  function afterTransform(er4, data2) {
    var ts2 = this._transformState;
    ts2.transforming = false;
    var cb = ts2.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    }
    ts2.writechunk = null;
    ts2.writecb = null;
    if (data2 != null)
      this.push(data2);
    cb(er4);
    var rs2 = this._readableState;
    rs2.reading = false;
    if (rs2.needReadable || rs2.length < rs2.highWaterMark) {
      this._read(rs2.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er4, data2) {
        done(_this, er4, data2);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts2 = this._transformState;
    ts2.writecb = cb;
    ts2.writechunk = chunk;
    ts2.writeencoding = encoding;
    if (!ts2.transforming) {
      var rs2 = this._readableState;
      if (ts2.needTransform || rs2.needReadable || rs2.length < rs2.highWaterMark) this._read(rs2.highWaterMark);
    }
  };
  Transform.prototype._read = function(n5) {
    var ts2 = this._transformState;
    if (ts2.writechunk !== null && !ts2.transforming) {
      ts2.transforming = true;
      this._transform(ts2.writechunk, ts2.writeencoding, ts2.afterTransform);
    } else {
      ts2.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream, er4, data2) {
    if (er4) return stream.emit("error", er4);
    if (data2 != null)
      stream.push(data2);
    if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough;
var hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1;
  _stream_passthrough = PassThrough;
  var Transform = require_stream_transform();
  inherits_browserExports(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough;
}
var pipeline_1;
var hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var eos;
  function once3(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }
  var _require$codes = requireErrorsBrowser().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop2(err) {
    if (err) throw err;
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function destroyer(stream, reading, writing, callback) {
    callback = once3(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    if (eos === void 0) eos = requireEndOfStream();
    eos(stream, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err) return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed) return;
      if (destroyed) return;
      destroyed = true;
      if (isRequest(stream)) return stream.abort();
      if (typeof stream.destroy === "function") return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call(fn2) {
    fn2();
  }
  function pipe(from2, to2) {
    return from2.pipe(to2);
  }
  function popCallback(streams) {
    if (!streams.length) return noop2;
    if (typeof streams[streams.length - 1] !== "function") return noop2;
    return streams.pop();
  }
  function pipeline() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error;
    var destroys = streams.map(function(stream, i4) {
      var reading = i4 < streams.length - 1;
      var writing = i4 > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error) error = err;
        if (err) destroys.forEach(call);
        if (reading) return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }
  pipeline_1 = pipeline;
  return pipeline_1;
}
var streamBrowserify;
var hasRequiredStreamBrowserify;
function requireStreamBrowserify() {
  if (hasRequiredStreamBrowserify) return streamBrowserify;
  hasRequiredStreamBrowserify = 1;
  streamBrowserify = Stream;
  var EE = eventsExports.EventEmitter;
  var inherits2 = inherits_browserExports;
  inherits2(Stream, EE);
  Stream.Readable = require_stream_readable();
  Stream.Writable = require_stream_writable();
  Stream.Duplex = require_stream_duplex();
  Stream.Transform = require_stream_transform();
  Stream.PassThrough = require_stream_passthrough();
  Stream.finished = requireEndOfStream();
  Stream.pipeline = requirePipeline();
  Stream.Stream = Stream;
  function Stream() {
    EE.call(this);
  }
  Stream.prototype.pipe = function(dest, options) {
    var source = this;
    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }
    source.on("data", ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on("end", onend);
      source.on("close", onclose);
    }
    var didOnEnd = false;
    function onend() {
      if (didOnEnd) return;
      didOnEnd = true;
      dest.end();
    }
    function onclose() {
      if (didOnEnd) return;
      didOnEnd = true;
      if (typeof dest.destroy === "function") dest.destroy();
    }
    function onerror(er4) {
      cleanup();
      if (EE.listenerCount(this, "error") === 0) {
        throw er4;
      }
    }
    source.on("error", onerror);
    dest.on("error", onerror);
    function cleanup() {
      source.removeListener("data", ondata);
      dest.removeListener("drain", ondrain);
      source.removeListener("end", onend);
      source.removeListener("close", onclose);
      source.removeListener("error", onerror);
      dest.removeListener("error", onerror);
      source.removeListener("end", cleanup);
      source.removeListener("close", cleanup);
      dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
  };
  return streamBrowserify;
}
var cipherBase;
var hasRequiredCipherBase;
function requireCipherBase() {
  if (hasRequiredCipherBase) return cipherBase;
  hasRequiredCipherBase = 1;
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var Transform = requireStreamBrowserify().Transform;
  var StringDecoder = requireString_decoder().StringDecoder;
  var inherits2 = inherits_browserExports;
  var toBuffer2 = requireToBuffer$2();
  function CipherBase(hashMode) {
    Transform.call(this);
    this.hashMode = typeof hashMode === "string";
    if (this.hashMode) {
      this[hashMode] = this._finalOrDigest;
    } else {
      this["final"] = this._finalOrDigest;
    }
    if (this._final) {
      this.__final = this._final;
      this._final = null;
    }
    this._decoder = null;
    this._encoding = null;
  }
  inherits2(CipherBase, Transform);
  CipherBase.prototype.update = function(data2, inputEnc, outputEnc) {
    var bufferData = toBuffer2(data2, inputEnc);
    var outData = this._update(bufferData);
    if (this.hashMode) {
      return this;
    }
    if (outputEnc) {
      outData = this._toString(outData, outputEnc);
    }
    return outData;
  };
  CipherBase.prototype.setAutoPadding = function() {
  };
  CipherBase.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  };
  CipherBase.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  };
  CipherBase.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  };
  CipherBase.prototype._transform = function(data2, _3, next) {
    var err;
    try {
      if (this.hashMode) {
        this._update(data2);
      } else {
        this.push(this._update(data2));
      }
    } catch (e3) {
      err = e3;
    } finally {
      next(err);
    }
  };
  CipherBase.prototype._flush = function(done) {
    var err;
    try {
      this.push(this.__final());
    } catch (e3) {
      err = e3;
    }
    done(err);
  };
  CipherBase.prototype._finalOrDigest = function(outputEnc) {
    var outData = this.__final() || Buffer2.alloc(0);
    if (outputEnc) {
      outData = this._toString(outData, outputEnc, true);
    }
    return outData;
  };
  CipherBase.prototype._toString = function(value, enc, fin) {
    if (!this._decoder) {
      this._decoder = new StringDecoder(enc);
      this._encoding = enc;
    }
    if (this._encoding !== enc) {
      throw new Error("cant switch encodings");
    }
    var out = this._decoder.write(value);
    if (fin) {
      out += this._decoder.end();
    }
    return out;
  };
  cipherBase = CipherBase;
  return cipherBase;
}
var browser$a;
var hasRequiredBrowser$9;
function requireBrowser$9() {
  if (hasRequiredBrowser$9) return browser$a;
  hasRequiredBrowser$9 = 1;
  var inherits2 = inherits_browserExports;
  var MD5 = requireMd5_js();
  var RIPEMD1602 = requireRipemd160();
  var sha2 = requireSha_js();
  var Base2 = requireCipherBase();
  function Hash3(hash3) {
    Base2.call(this, "digest");
    this._hash = hash3;
  }
  inherits2(Hash3, Base2);
  Hash3.prototype._update = function(data2) {
    this._hash.update(data2);
  };
  Hash3.prototype._final = function() {
    return this._hash.digest();
  };
  browser$a = function createHash2(alg) {
    alg = alg.toLowerCase();
    if (alg === "md5") return new MD5();
    if (alg === "rmd160" || alg === "ripemd160") return new RIPEMD1602();
    return new Hash3(sha2(alg));
  };
  return browser$a;
}
var legacy;
var hasRequiredLegacy;
function requireLegacy() {
  if (hasRequiredLegacy) return legacy;
  hasRequiredLegacy = 1;
  var inherits2 = inherits_browserExports;
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var Base2 = requireCipherBase();
  var ZEROS = Buffer2.alloc(128);
  var blocksize = 64;
  function Hmac2(alg, key2) {
    Base2.call(this, "digest");
    if (typeof key2 === "string") {
      key2 = Buffer2.from(key2);
    }
    this._alg = alg;
    this._key = key2;
    if (key2.length > blocksize) {
      key2 = alg(key2);
    } else if (key2.length < blocksize) {
      key2 = Buffer2.concat([key2, ZEROS], blocksize);
    }
    var ipad = this._ipad = Buffer2.allocUnsafe(blocksize);
    var opad = this._opad = Buffer2.allocUnsafe(blocksize);
    for (var i4 = 0; i4 < blocksize; i4++) {
      ipad[i4] = key2[i4] ^ 54;
      opad[i4] = key2[i4] ^ 92;
    }
    this._hash = [ipad];
  }
  inherits2(Hmac2, Base2);
  Hmac2.prototype._update = function(data2) {
    this._hash.push(data2);
  };
  Hmac2.prototype._final = function() {
    var h5 = this._alg(Buffer2.concat(this._hash));
    return this._alg(Buffer2.concat([this._opad, h5]));
  };
  legacy = Hmac2;
  return legacy;
}
var md5;
var hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5) return md5;
  hasRequiredMd5 = 1;
  var MD5 = requireMd5_js();
  md5 = function(buffer2) {
    return new MD5().update(buffer2).digest();
  };
  return md5;
}
var browser$9;
var hasRequiredBrowser$8;
function requireBrowser$8() {
  if (hasRequiredBrowser$8) return browser$9;
  hasRequiredBrowser$8 = 1;
  var inherits2 = inherits_browserExports;
  var Legacy = requireLegacy();
  var Base2 = requireCipherBase();
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var md52 = requireMd5();
  var RIPEMD1602 = requireRipemd160();
  var sha2 = requireSha_js();
  var ZEROS = Buffer2.alloc(128);
  function Hmac2(alg, key2) {
    Base2.call(this, "digest");
    if (typeof key2 === "string") {
      key2 = Buffer2.from(key2);
    }
    var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
    this._alg = alg;
    this._key = key2;
    if (key2.length > blocksize) {
      var hash3 = alg === "rmd160" ? new RIPEMD1602() : sha2(alg);
      key2 = hash3.update(key2).digest();
    } else if (key2.length < blocksize) {
      key2 = Buffer2.concat([key2, ZEROS], blocksize);
    }
    var ipad = this._ipad = Buffer2.allocUnsafe(blocksize);
    var opad = this._opad = Buffer2.allocUnsafe(blocksize);
    for (var i4 = 0; i4 < blocksize; i4++) {
      ipad[i4] = key2[i4] ^ 54;
      opad[i4] = key2[i4] ^ 92;
    }
    this._hash = alg === "rmd160" ? new RIPEMD1602() : sha2(alg);
    this._hash.update(ipad);
  }
  inherits2(Hmac2, Base2);
  Hmac2.prototype._update = function(data2) {
    this._hash.update(data2);
  };
  Hmac2.prototype._final = function() {
    var h5 = this._hash.digest();
    var hash3 = this._alg === "rmd160" ? new RIPEMD1602() : sha2(this._alg);
    return hash3.update(this._opad).update(h5).digest();
  };
  browser$9 = function createHmac(alg, key2) {
    alg = alg.toLowerCase();
    if (alg === "rmd160" || alg === "ripemd160") {
      return new Hmac2("rmd160", key2);
    }
    if (alg === "md5") {
      return new Legacy(md52, key2);
    }
    return new Hmac2(alg, key2);
  };
  return browser$9;
}
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
};
const sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
};
const sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
};
const sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
};
const sha256$2 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
};
const sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
};
const sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
};
const sha512$1 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
};
const DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
};
const ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
};
const md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
};
const require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: sha256$2,
  sha224,
  sha384,
  sha512: sha512$1,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos;
var hasRequiredAlgos;
function requireAlgos() {
  if (hasRequiredAlgos) return algos;
  hasRequiredAlgos = 1;
  algos = require$$6;
  return algos;
}
var browser$8 = {};
var precondition;
var hasRequiredPrecondition;
function requirePrecondition() {
  if (hasRequiredPrecondition) return precondition;
  hasRequiredPrecondition = 1;
  var $isFinite = isFinite;
  var MAX_ALLOC = Math.pow(2, 30) - 1;
  precondition = function(iterations, keylen) {
    if (typeof iterations !== "number") {
      throw new TypeError("Iterations not a number");
    }
    if (iterations < 0 || !$isFinite(iterations)) {
      throw new TypeError("Bad iterations");
    }
    if (typeof keylen !== "number") {
      throw new TypeError("Key length not a number");
    }
    if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) {
      throw new TypeError("Bad key length");
    }
  };
  return precondition;
}
var defaultEncoding_1;
var hasRequiredDefaultEncoding;
function requireDefaultEncoding() {
  if (hasRequiredDefaultEncoding) return defaultEncoding_1;
  hasRequiredDefaultEncoding = 1;
  var defaultEncoding;
  if (commonjsGlobal.process && commonjsGlobal.process.browser) {
    defaultEncoding = "utf-8";
  } else if (commonjsGlobal.process && commonjsGlobal.process.version) {
    var pVersionMajor = parseInt(process$1.version.split(".")[0].slice(1), 10);
    defaultEncoding = pVersionMajor >= 6 ? "utf-8" : "binary";
  } else {
    defaultEncoding = "utf-8";
  }
  defaultEncoding_1 = defaultEncoding;
  return defaultEncoding_1;
}
var toBuffer_1;
var hasRequiredToBuffer;
function requireToBuffer() {
  if (hasRequiredToBuffer) return toBuffer_1;
  hasRequiredToBuffer = 1;
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var toBuffer2 = requireToBuffer$2();
  var useUint8Array = typeof Uint8Array !== "undefined";
  var useArrayBuffer = useUint8Array && typeof ArrayBuffer !== "undefined";
  var isView = useArrayBuffer && ArrayBuffer.isView;
  toBuffer_1 = function(thing, encoding, name) {
    if (typeof thing === "string" || Buffer2.isBuffer(thing) || useUint8Array && thing instanceof Uint8Array || isView && isView(thing)) {
      return toBuffer2(thing, encoding);
    }
    throw new TypeError(name + " must be a string, a Buffer, a Uint8Array, or a DataView");
  };
  return toBuffer_1;
}
var syncBrowser;
var hasRequiredSyncBrowser;
function requireSyncBrowser() {
  if (hasRequiredSyncBrowser) return syncBrowser;
  hasRequiredSyncBrowser = 1;
  var md52 = requireMd5();
  var RIPEMD1602 = requireRipemd160();
  var sha2 = requireSha_js();
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var checkParameters = requirePrecondition();
  var defaultEncoding = requireDefaultEncoding();
  var toBuffer2 = requireToBuffer();
  var ZEROS = Buffer2.alloc(128);
  var sizes = {
    __proto__: null,
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    "sha512-256": 32,
    ripemd160: 20,
    rmd160: 20
  };
  var mapping = {
    __proto__: null,
    "sha-1": "sha1",
    "sha-224": "sha224",
    "sha-256": "sha256",
    "sha-384": "sha384",
    "sha-512": "sha512",
    "ripemd-160": "ripemd160"
  };
  function rmd160Func(data2) {
    return new RIPEMD1602().update(data2).digest();
  }
  function getDigest(alg) {
    function shaFunc(data2) {
      return sha2(alg).update(data2).digest();
    }
    if (alg === "rmd160" || alg === "ripemd160") {
      return rmd160Func;
    }
    if (alg === "md5") {
      return md52;
    }
    return shaFunc;
  }
  function Hmac2(alg, key2, saltLen) {
    var hash3 = getDigest(alg);
    var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
    if (key2.length > blocksize) {
      key2 = hash3(key2);
    } else if (key2.length < blocksize) {
      key2 = Buffer2.concat([key2, ZEROS], blocksize);
    }
    var ipad = Buffer2.allocUnsafe(blocksize + sizes[alg]);
    var opad = Buffer2.allocUnsafe(blocksize + sizes[alg]);
    for (var i4 = 0; i4 < blocksize; i4++) {
      ipad[i4] = key2[i4] ^ 54;
      opad[i4] = key2[i4] ^ 92;
    }
    var ipad1 = Buffer2.allocUnsafe(blocksize + saltLen + 4);
    ipad.copy(ipad1, 0, 0, blocksize);
    this.ipad1 = ipad1;
    this.ipad2 = ipad;
    this.opad = opad;
    this.alg = alg;
    this.blocksize = blocksize;
    this.hash = hash3;
    this.size = sizes[alg];
  }
  Hmac2.prototype.run = function(data2, ipad) {
    data2.copy(ipad, this.blocksize);
    var h5 = this.hash(ipad);
    h5.copy(this.opad, this.blocksize);
    return this.hash(this.opad);
  };
  function pbkdf2(password, salt, iterations, keylen, digest9) {
    checkParameters(iterations, keylen);
    password = toBuffer2(password, defaultEncoding, "Password");
    salt = toBuffer2(salt, defaultEncoding, "Salt");
    var lowerDigest = (digest9 || "sha1").toLowerCase();
    var mappedDigest = mapping[lowerDigest] || lowerDigest;
    var size2 = sizes[mappedDigest];
    if (typeof size2 !== "number" || !size2) {
      throw new TypeError("Digest algorithm not supported: " + digest9);
    }
    var hmac3 = new Hmac2(mappedDigest, password, salt.length);
    var DK = Buffer2.allocUnsafe(keylen);
    var block1 = Buffer2.allocUnsafe(salt.length + 4);
    salt.copy(block1, 0, 0, salt.length);
    var destPos = 0;
    var hLen = size2;
    var l2 = Math.ceil(keylen / hLen);
    for (var i4 = 1; i4 <= l2; i4++) {
      block1.writeUInt32BE(i4, salt.length);
      var T2 = hmac3.run(block1, hmac3.ipad1);
      var U = T2;
      for (var j2 = 1; j2 < iterations; j2++) {
        U = hmac3.run(U, hmac3.ipad2);
        for (var k3 = 0; k3 < hLen; k3++) {
          T2[k3] ^= U[k3];
        }
      }
      T2.copy(DK, destPos);
      destPos += hLen;
    }
    return DK;
  }
  syncBrowser = pbkdf2;
  return syncBrowser;
}
var async;
var hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async;
  hasRequiredAsync = 1;
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var checkParameters = requirePrecondition();
  var defaultEncoding = requireDefaultEncoding();
  var sync = requireSyncBrowser();
  var toBuffer2 = requireToBuffer();
  var ZERO_BUF;
  var subtle = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle;
  var toBrowser = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  };
  var checks = [];
  var nextTick;
  function getNextTick() {
    if (nextTick) {
      return nextTick;
    }
    if (commonjsGlobal.process && commonjsGlobal.process.nextTick) {
      nextTick = commonjsGlobal.process.nextTick;
    } else if (commonjsGlobal.queueMicrotask) {
      nextTick = commonjsGlobal.queueMicrotask;
    } else if (commonjsGlobal.setImmediate) {
      nextTick = commonjsGlobal.setImmediate;
    } else {
      nextTick = commonjsGlobal.setTimeout;
    }
    return nextTick;
  }
  function browserPbkdf2(password, salt, iterations, length, algo) {
    return subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveBits"]).then(function(key2) {
      return subtle.deriveBits({
        name: "PBKDF2",
        salt,
        iterations,
        hash: {
          name: algo
        }
      }, key2, length << 3);
    }).then(function(res) {
      return Buffer2.from(res);
    });
  }
  function checkNative(algo) {
    if (commonjsGlobal.process && !commonjsGlobal.process.browser) {
      return Promise.resolve(false);
    }
    if (!subtle || !subtle.importKey || !subtle.deriveBits) {
      return Promise.resolve(false);
    }
    if (checks[algo] !== void 0) {
      return checks[algo];
    }
    ZERO_BUF = ZERO_BUF || Buffer2.alloc(8);
    var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo).then(
      function() {
        return true;
      },
      function() {
        return false;
      }
    );
    checks[algo] = prom;
    return prom;
  }
  function resolvePromise(promise, callback) {
    promise.then(function(out) {
      getNextTick()(function() {
        callback(null, out);
      });
    }, function(e3) {
      getNextTick()(function() {
        callback(e3);
      });
    });
  }
  async = function(password, salt, iterations, keylen, digest9, callback) {
    if (typeof digest9 === "function") {
      callback = digest9;
      digest9 = void 0;
    }
    checkParameters(iterations, keylen);
    password = toBuffer2(password, defaultEncoding, "Password");
    salt = toBuffer2(salt, defaultEncoding, "Salt");
    if (typeof callback !== "function") {
      throw new Error("No callback provided to pbkdf2");
    }
    digest9 = digest9 || "sha1";
    var algo = toBrowser[digest9.toLowerCase()];
    if (!algo || typeof commonjsGlobal.Promise !== "function") {
      getNextTick()(function() {
        var out;
        try {
          out = sync(password, salt, iterations, keylen, digest9);
        } catch (e3) {
          callback(e3);
          return;
        }
        callback(null, out);
      });
      return;
    }
    resolvePromise(checkNative(algo).then(function(resp) {
      if (resp) {
        return browserPbkdf2(password, salt, iterations, keylen, algo);
      }
      return sync(password, salt, iterations, keylen, digest9);
    }), callback);
  };
  return async;
}
var hasRequiredBrowser$7;
function requireBrowser$7() {
  if (hasRequiredBrowser$7) return browser$8;
  hasRequiredBrowser$7 = 1;
  browser$8.pbkdf2 = requireAsync();
  browser$8.pbkdf2Sync = requireSyncBrowser();
  return browser$8;
}
var browser$7 = {};
var des$1 = {};
var utils$n = {};
var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$n;
  hasRequiredUtils$1 = 1;
  utils$n.readUInt32BE = function readUInt32BE(bytes2, off) {
    var res = bytes2[0 + off] << 24 | bytes2[1 + off] << 16 | bytes2[2 + off] << 8 | bytes2[3 + off];
    return res >>> 0;
  };
  utils$n.writeUInt32BE = function writeUInt32BE(bytes2, value, off) {
    bytes2[0 + off] = value >>> 24;
    bytes2[1 + off] = value >>> 16 & 255;
    bytes2[2 + off] = value >>> 8 & 255;
    bytes2[3 + off] = value & 255;
  };
  utils$n.ip = function ip(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;
    for (var i4 = 6; i4 >= 0; i4 -= 2) {
      for (var j2 = 0; j2 <= 24; j2 += 8) {
        outL <<= 1;
        outL |= inR >>> j2 + i4 & 1;
      }
      for (var j2 = 0; j2 <= 24; j2 += 8) {
        outL <<= 1;
        outL |= inL >>> j2 + i4 & 1;
      }
    }
    for (var i4 = 6; i4 >= 0; i4 -= 2) {
      for (var j2 = 1; j2 <= 25; j2 += 8) {
        outR <<= 1;
        outR |= inR >>> j2 + i4 & 1;
      }
      for (var j2 = 1; j2 <= 25; j2 += 8) {
        outR <<= 1;
        outR |= inL >>> j2 + i4 & 1;
      }
    }
    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };
  utils$n.rip = function rip(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;
    for (var i4 = 0; i4 < 4; i4++) {
      for (var j2 = 24; j2 >= 0; j2 -= 8) {
        outL <<= 1;
        outL |= inR >>> j2 + i4 & 1;
        outL <<= 1;
        outL |= inL >>> j2 + i4 & 1;
      }
    }
    for (var i4 = 4; i4 < 8; i4++) {
      for (var j2 = 24; j2 >= 0; j2 -= 8) {
        outR <<= 1;
        outR |= inR >>> j2 + i4 & 1;
        outR <<= 1;
        outR |= inL >>> j2 + i4 & 1;
      }
    }
    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };
  utils$n.pc1 = function pc1(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;
    for (var i4 = 7; i4 >= 5; i4--) {
      for (var j2 = 0; j2 <= 24; j2 += 8) {
        outL <<= 1;
        outL |= inR >> j2 + i4 & 1;
      }
      for (var j2 = 0; j2 <= 24; j2 += 8) {
        outL <<= 1;
        outL |= inL >> j2 + i4 & 1;
      }
    }
    for (var j2 = 0; j2 <= 24; j2 += 8) {
      outL <<= 1;
      outL |= inR >> j2 + i4 & 1;
    }
    for (var i4 = 1; i4 <= 3; i4++) {
      for (var j2 = 0; j2 <= 24; j2 += 8) {
        outR <<= 1;
        outR |= inR >> j2 + i4 & 1;
      }
      for (var j2 = 0; j2 <= 24; j2 += 8) {
        outR <<= 1;
        outR |= inL >> j2 + i4 & 1;
      }
    }
    for (var j2 = 0; j2 <= 24; j2 += 8) {
      outR <<= 1;
      outR |= inL >> j2 + i4 & 1;
    }
    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };
  utils$n.r28shl = function r28shl(num, shift) {
    return num << shift & 268435455 | num >>> 28 - shift;
  };
  var pc2table = [
    // inL => outL
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    // inR => outR
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
  ];
  utils$n.pc2 = function pc2(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;
    var len2 = pc2table.length >>> 1;
    for (var i4 = 0; i4 < len2; i4++) {
      outL <<= 1;
      outL |= inL >>> pc2table[i4] & 1;
    }
    for (var i4 = len2; i4 < pc2table.length; i4++) {
      outR <<= 1;
      outR |= inR >>> pc2table[i4] & 1;
    }
    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };
  utils$n.expand = function expand(r3, out, off) {
    var outL = 0;
    var outR = 0;
    outL = (r3 & 1) << 5 | r3 >>> 27;
    for (var i4 = 23; i4 >= 15; i4 -= 4) {
      outL <<= 6;
      outL |= r3 >>> i4 & 63;
    }
    for (var i4 = 11; i4 >= 3; i4 -= 4) {
      outR |= r3 >>> i4 & 63;
      outR <<= 6;
    }
    outR |= (r3 & 31) << 1 | r3 >>> 31;
    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };
  var sTable = [
    14,
    0,
    4,
    15,
    13,
    7,
    1,
    4,
    2,
    14,
    15,
    2,
    11,
    13,
    8,
    1,
    3,
    10,
    10,
    6,
    6,
    12,
    12,
    11,
    5,
    9,
    9,
    5,
    0,
    3,
    7,
    8,
    4,
    15,
    1,
    12,
    14,
    8,
    8,
    2,
    13,
    4,
    6,
    9,
    2,
    1,
    11,
    7,
    15,
    5,
    12,
    11,
    9,
    3,
    7,
    14,
    3,
    10,
    10,
    0,
    5,
    6,
    0,
    13,
    15,
    3,
    1,
    13,
    8,
    4,
    14,
    7,
    6,
    15,
    11,
    2,
    3,
    8,
    4,
    14,
    9,
    12,
    7,
    0,
    2,
    1,
    13,
    10,
    12,
    6,
    0,
    9,
    5,
    11,
    10,
    5,
    0,
    13,
    14,
    8,
    7,
    10,
    11,
    1,
    10,
    3,
    4,
    15,
    13,
    4,
    1,
    2,
    5,
    11,
    8,
    6,
    12,
    7,
    6,
    12,
    9,
    0,
    3,
    5,
    2,
    14,
    15,
    9,
    10,
    13,
    0,
    7,
    9,
    0,
    14,
    9,
    6,
    3,
    3,
    4,
    15,
    6,
    5,
    10,
    1,
    2,
    13,
    8,
    12,
    5,
    7,
    14,
    11,
    12,
    4,
    11,
    2,
    15,
    8,
    1,
    13,
    1,
    6,
    10,
    4,
    13,
    9,
    0,
    8,
    6,
    15,
    9,
    3,
    8,
    0,
    7,
    11,
    4,
    1,
    15,
    2,
    14,
    12,
    3,
    5,
    11,
    10,
    5,
    14,
    2,
    7,
    12,
    7,
    13,
    13,
    8,
    14,
    11,
    3,
    5,
    0,
    6,
    6,
    15,
    9,
    0,
    10,
    3,
    1,
    4,
    2,
    7,
    8,
    2,
    5,
    12,
    11,
    1,
    12,
    10,
    4,
    14,
    15,
    9,
    10,
    3,
    6,
    15,
    9,
    0,
    0,
    6,
    12,
    10,
    11,
    1,
    7,
    13,
    13,
    8,
    15,
    9,
    1,
    4,
    3,
    5,
    14,
    11,
    5,
    12,
    2,
    7,
    8,
    2,
    4,
    14,
    2,
    14,
    12,
    11,
    4,
    2,
    1,
    12,
    7,
    4,
    10,
    7,
    11,
    13,
    6,
    1,
    8,
    5,
    5,
    0,
    3,
    15,
    15,
    10,
    13,
    3,
    0,
    9,
    14,
    8,
    9,
    6,
    4,
    11,
    2,
    8,
    1,
    12,
    11,
    7,
    10,
    1,
    13,
    14,
    7,
    2,
    8,
    13,
    15,
    6,
    9,
    15,
    12,
    0,
    5,
    9,
    6,
    10,
    3,
    4,
    0,
    5,
    14,
    3,
    12,
    10,
    1,
    15,
    10,
    4,
    15,
    2,
    9,
    7,
    2,
    12,
    6,
    9,
    8,
    5,
    0,
    6,
    13,
    1,
    3,
    13,
    4,
    14,
    14,
    0,
    7,
    11,
    5,
    3,
    11,
    8,
    9,
    4,
    14,
    3,
    15,
    2,
    5,
    12,
    2,
    9,
    8,
    5,
    12,
    15,
    3,
    10,
    7,
    11,
    0,
    14,
    4,
    1,
    10,
    7,
    1,
    6,
    13,
    0,
    11,
    8,
    6,
    13,
    4,
    13,
    11,
    0,
    2,
    11,
    14,
    7,
    15,
    4,
    0,
    9,
    8,
    1,
    13,
    10,
    3,
    14,
    12,
    3,
    9,
    5,
    7,
    12,
    5,
    2,
    10,
    15,
    6,
    8,
    1,
    6,
    1,
    6,
    4,
    11,
    11,
    13,
    13,
    8,
    12,
    1,
    3,
    4,
    7,
    10,
    14,
    7,
    10,
    9,
    15,
    5,
    6,
    0,
    8,
    15,
    0,
    14,
    5,
    2,
    9,
    3,
    2,
    12,
    13,
    1,
    2,
    15,
    8,
    13,
    4,
    8,
    6,
    10,
    15,
    3,
    11,
    7,
    1,
    4,
    10,
    12,
    9,
    5,
    3,
    6,
    14,
    11,
    5,
    0,
    0,
    14,
    12,
    9,
    7,
    2,
    7,
    2,
    11,
    1,
    4,
    14,
    1,
    7,
    9,
    4,
    12,
    10,
    14,
    8,
    2,
    13,
    0,
    15,
    6,
    12,
    10,
    9,
    13,
    0,
    15,
    3,
    3,
    5,
    5,
    6,
    8,
    11
  ];
  utils$n.substitute = function substitute(inL, inR) {
    var out = 0;
    for (var i4 = 0; i4 < 4; i4++) {
      var b2 = inL >>> 18 - i4 * 6 & 63;
      var sb = sTable[i4 * 64 + b2];
      out <<= 4;
      out |= sb;
    }
    for (var i4 = 0; i4 < 4; i4++) {
      var b2 = inR >>> 18 - i4 * 6 & 63;
      var sb = sTable[4 * 64 + i4 * 64 + b2];
      out <<= 4;
      out |= sb;
    }
    return out >>> 0;
  };
  var permuteTable = [
    16,
    25,
    12,
    11,
    3,
    20,
    4,
    15,
    31,
    17,
    9,
    6,
    27,
    14,
    1,
    22,
    30,
    24,
    8,
    18,
    0,
    5,
    29,
    23,
    13,
    19,
    2,
    26,
    10,
    21,
    28,
    7
  ];
  utils$n.permute = function permute(num) {
    var out = 0;
    for (var i4 = 0; i4 < permuteTable.length; i4++) {
      out <<= 1;
      out |= num >>> permuteTable[i4] & 1;
    }
    return out >>> 0;
  };
  utils$n.padSplit = function padSplit(num, size2, group) {
    var str = num.toString(2);
    while (str.length < size2)
      str = "0" + str;
    var out = [];
    for (var i4 = 0; i4 < size2; i4 += group)
      out.push(str.slice(i4, i4 + group));
    return out.join(" ");
  };
  return utils$n;
}
var cipher;
var hasRequiredCipher;
function requireCipher() {
  if (hasRequiredCipher) return cipher;
  hasRequiredCipher = 1;
  var assert2 = minimalisticAssert;
  function Cipher(options) {
    this.options = options;
    this.type = this.options.type;
    this.blockSize = 8;
    this._init();
    this.buffer = new Array(this.blockSize);
    this.bufferOff = 0;
    this.padding = options.padding !== false;
  }
  cipher = Cipher;
  Cipher.prototype._init = function _init() {
  };
  Cipher.prototype.update = function update5(data2) {
    if (data2.length === 0)
      return [];
    if (this.type === "decrypt")
      return this._updateDecrypt(data2);
    else
      return this._updateEncrypt(data2);
  };
  Cipher.prototype._buffer = function _buffer(data2, off) {
    var min2 = Math.min(this.buffer.length - this.bufferOff, data2.length - off);
    for (var i4 = 0; i4 < min2; i4++)
      this.buffer[this.bufferOff + i4] = data2[off + i4];
    this.bufferOff += min2;
    return min2;
  };
  Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
    this._update(this.buffer, 0, out, off);
    this.bufferOff = 0;
    return this.blockSize;
  };
  Cipher.prototype._updateEncrypt = function _updateEncrypt(data2) {
    var inputOff = 0;
    var outputOff = 0;
    var count = (this.bufferOff + data2.length) / this.blockSize | 0;
    var out = new Array(count * this.blockSize);
    if (this.bufferOff !== 0) {
      inputOff += this._buffer(data2, inputOff);
      if (this.bufferOff === this.buffer.length)
        outputOff += this._flushBuffer(out, outputOff);
    }
    var max2 = data2.length - (data2.length - inputOff) % this.blockSize;
    for (; inputOff < max2; inputOff += this.blockSize) {
      this._update(data2, inputOff, out, outputOff);
      outputOff += this.blockSize;
    }
    for (; inputOff < data2.length; inputOff++, this.bufferOff++)
      this.buffer[this.bufferOff] = data2[inputOff];
    return out;
  };
  Cipher.prototype._updateDecrypt = function _updateDecrypt(data2) {
    var inputOff = 0;
    var outputOff = 0;
    var count = Math.ceil((this.bufferOff + data2.length) / this.blockSize) - 1;
    var out = new Array(count * this.blockSize);
    for (; count > 0; count--) {
      inputOff += this._buffer(data2, inputOff);
      outputOff += this._flushBuffer(out, outputOff);
    }
    inputOff += this._buffer(data2, inputOff);
    return out;
  };
  Cipher.prototype.final = function final(buffer2) {
    var first;
    if (buffer2)
      first = this.update(buffer2);
    var last;
    if (this.type === "encrypt")
      last = this._finalEncrypt();
    else
      last = this._finalDecrypt();
    if (first)
      return first.concat(last);
    else
      return last;
  };
  Cipher.prototype._pad = function _pad(buffer2, off) {
    if (off === 0)
      return false;
    while (off < buffer2.length)
      buffer2[off++] = 0;
    return true;
  };
  Cipher.prototype._finalEncrypt = function _finalEncrypt() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var out = new Array(this.blockSize);
    this._update(this.buffer, 0, out, 0);
    return out;
  };
  Cipher.prototype._unpad = function _unpad(buffer2) {
    return buffer2;
  };
  Cipher.prototype._finalDecrypt = function _finalDecrypt() {
    assert2.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var out = new Array(this.blockSize);
    this._flushBuffer(out, 0);
    return this._unpad(out);
  };
  return cipher;
}
var des;
var hasRequiredDes$1;
function requireDes$1() {
  if (hasRequiredDes$1) return des;
  hasRequiredDes$1 = 1;
  var assert2 = minimalisticAssert;
  var inherits2 = inherits_browserExports;
  var utils2 = requireUtils$1();
  var Cipher = requireCipher();
  function DESState() {
    this.tmp = new Array(2);
    this.keys = null;
  }
  function DES(options) {
    Cipher.call(this, options);
    var state2 = new DESState();
    this._desState = state2;
    this.deriveKeys(state2, options.key);
  }
  inherits2(DES, Cipher);
  des = DES;
  DES.create = function create2(options) {
    return new DES(options);
  };
  var shiftTable = [
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1
  ];
  DES.prototype.deriveKeys = function deriveKeys(state2, key2) {
    state2.keys = new Array(16 * 2);
    assert2.equal(key2.length, this.blockSize, "Invalid key length");
    var kL = utils2.readUInt32BE(key2, 0);
    var kR = utils2.readUInt32BE(key2, 4);
    utils2.pc1(kL, kR, state2.tmp, 0);
    kL = state2.tmp[0];
    kR = state2.tmp[1];
    for (var i4 = 0; i4 < state2.keys.length; i4 += 2) {
      var shift = shiftTable[i4 >>> 1];
      kL = utils2.r28shl(kL, shift);
      kR = utils2.r28shl(kR, shift);
      utils2.pc2(kL, kR, state2.keys, i4);
    }
  };
  DES.prototype._update = function _update4(inp, inOff, out, outOff) {
    var state2 = this._desState;
    var l2 = utils2.readUInt32BE(inp, inOff);
    var r3 = utils2.readUInt32BE(inp, inOff + 4);
    utils2.ip(l2, r3, state2.tmp, 0);
    l2 = state2.tmp[0];
    r3 = state2.tmp[1];
    if (this.type === "encrypt")
      this._encrypt(state2, l2, r3, state2.tmp, 0);
    else
      this._decrypt(state2, l2, r3, state2.tmp, 0);
    l2 = state2.tmp[0];
    r3 = state2.tmp[1];
    utils2.writeUInt32BE(out, l2, outOff);
    utils2.writeUInt32BE(out, r3, outOff + 4);
  };
  DES.prototype._pad = function _pad(buffer2, off) {
    if (this.padding === false) {
      return false;
    }
    var value = buffer2.length - off;
    for (var i4 = off; i4 < buffer2.length; i4++)
      buffer2[i4] = value;
    return true;
  };
  DES.prototype._unpad = function _unpad(buffer2) {
    if (this.padding === false) {
      return buffer2;
    }
    var pad3 = buffer2[buffer2.length - 1];
    for (var i4 = buffer2.length - pad3; i4 < buffer2.length; i4++)
      assert2.equal(buffer2[i4], pad3);
    return buffer2.slice(0, buffer2.length - pad3);
  };
  DES.prototype._encrypt = function _encrypt(state2, lStart, rStart, out, off) {
    var l2 = lStart;
    var r3 = rStart;
    for (var i4 = 0; i4 < state2.keys.length; i4 += 2) {
      var keyL = state2.keys[i4];
      var keyR = state2.keys[i4 + 1];
      utils2.expand(r3, state2.tmp, 0);
      keyL ^= state2.tmp[0];
      keyR ^= state2.tmp[1];
      var s2 = utils2.substitute(keyL, keyR);
      var f6 = utils2.permute(s2);
      var t2 = r3;
      r3 = (l2 ^ f6) >>> 0;
      l2 = t2;
    }
    utils2.rip(r3, l2, out, off);
  };
  DES.prototype._decrypt = function _decrypt(state2, lStart, rStart, out, off) {
    var l2 = rStart;
    var r3 = lStart;
    for (var i4 = state2.keys.length - 2; i4 >= 0; i4 -= 2) {
      var keyL = state2.keys[i4];
      var keyR = state2.keys[i4 + 1];
      utils2.expand(l2, state2.tmp, 0);
      keyL ^= state2.tmp[0];
      keyR ^= state2.tmp[1];
      var s2 = utils2.substitute(keyL, keyR);
      var f6 = utils2.permute(s2);
      var t2 = l2;
      l2 = (r3 ^ f6) >>> 0;
      r3 = t2;
    }
    utils2.rip(l2, r3, out, off);
  };
  return des;
}
var cbc$1 = {};
var hasRequiredCbc$1;
function requireCbc$1() {
  if (hasRequiredCbc$1) return cbc$1;
  hasRequiredCbc$1 = 1;
  var assert2 = minimalisticAssert;
  var inherits2 = inherits_browserExports;
  var proto = {};
  function CBCState(iv) {
    assert2.equal(iv.length, 8, "Invalid IV length");
    this.iv = new Array(8);
    for (var i4 = 0; i4 < this.iv.length; i4++)
      this.iv[i4] = iv[i4];
  }
  function instantiate(Base2) {
    function CBC(options) {
      Base2.call(this, options);
      this._cbcInit();
    }
    inherits2(CBC, Base2);
    var keys2 = Object.keys(proto);
    for (var i4 = 0; i4 < keys2.length; i4++) {
      var key2 = keys2[i4];
      CBC.prototype[key2] = proto[key2];
    }
    CBC.create = function create2(options) {
      return new CBC(options);
    };
    return CBC;
  }
  cbc$1.instantiate = instantiate;
  proto._cbcInit = function _cbcInit() {
    var state2 = new CBCState(this.options.iv);
    this._cbcState = state2;
  };
  proto._update = function _update4(inp, inOff, out, outOff) {
    var state2 = this._cbcState;
    var superProto = this.constructor.super_.prototype;
    var iv = state2.iv;
    if (this.type === "encrypt") {
      for (var i4 = 0; i4 < this.blockSize; i4++)
        iv[i4] ^= inp[inOff + i4];
      superProto._update.call(this, iv, 0, out, outOff);
      for (var i4 = 0; i4 < this.blockSize; i4++)
        iv[i4] = out[outOff + i4];
    } else {
      superProto._update.call(this, inp, inOff, out, outOff);
      for (var i4 = 0; i4 < this.blockSize; i4++)
        out[outOff + i4] ^= iv[i4];
      for (var i4 = 0; i4 < this.blockSize; i4++)
        iv[i4] = inp[inOff + i4];
    }
  };
  return cbc$1;
}
var ede;
var hasRequiredEde;
function requireEde() {
  if (hasRequiredEde) return ede;
  hasRequiredEde = 1;
  var assert2 = minimalisticAssert;
  var inherits2 = inherits_browserExports;
  var Cipher = requireCipher();
  var DES = requireDes$1();
  function EDEState(type2, key2) {
    assert2.equal(key2.length, 24, "Invalid key length");
    var k1 = key2.slice(0, 8);
    var k22 = key2.slice(8, 16);
    var k3 = key2.slice(16, 24);
    if (type2 === "encrypt") {
      this.ciphers = [
        DES.create({ type: "encrypt", key: k1 }),
        DES.create({ type: "decrypt", key: k22 }),
        DES.create({ type: "encrypt", key: k3 })
      ];
    } else {
      this.ciphers = [
        DES.create({ type: "decrypt", key: k3 }),
        DES.create({ type: "encrypt", key: k22 }),
        DES.create({ type: "decrypt", key: k1 })
      ];
    }
  }
  function EDE(options) {
    Cipher.call(this, options);
    var state2 = new EDEState(this.type, this.options.key);
    this._edeState = state2;
  }
  inherits2(EDE, Cipher);
  ede = EDE;
  EDE.create = function create2(options) {
    return new EDE(options);
  };
  EDE.prototype._update = function _update4(inp, inOff, out, outOff) {
    var state2 = this._edeState;
    state2.ciphers[0]._update(inp, inOff, out, outOff);
    state2.ciphers[1]._update(out, outOff, out, outOff);
    state2.ciphers[2]._update(out, outOff, out, outOff);
  };
  EDE.prototype._pad = DES.prototype._pad;
  EDE.prototype._unpad = DES.prototype._unpad;
  return ede;
}
var hasRequiredDes;
function requireDes() {
  if (hasRequiredDes) return des$1;
  hasRequiredDes = 1;
  des$1.utils = requireUtils$1();
  des$1.Cipher = requireCipher();
  des$1.DES = requireDes$1();
  des$1.CBC = requireCbc$1();
  des$1.EDE = requireEde();
  return des$1;
}
var browserifyDes;
var hasRequiredBrowserifyDes;
function requireBrowserifyDes() {
  if (hasRequiredBrowserifyDes) return browserifyDes;
  hasRequiredBrowserifyDes = 1;
  var CipherBase = requireCipherBase();
  var des2 = requireDes();
  var inherits2 = inherits_browserExports;
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var modes2 = {
    "des-ede3-cbc": des2.CBC.instantiate(des2.EDE),
    "des-ede3": des2.EDE,
    "des-ede-cbc": des2.CBC.instantiate(des2.EDE),
    "des-ede": des2.EDE,
    "des-cbc": des2.CBC.instantiate(des2.DES),
    "des-ecb": des2.DES
  };
  modes2.des = modes2["des-cbc"];
  modes2.des3 = modes2["des-ede3-cbc"];
  browserifyDes = DES;
  inherits2(DES, CipherBase);
  function DES(opts) {
    CipherBase.call(this);
    var modeName = opts.mode.toLowerCase();
    var mode2 = modes2[modeName];
    var type2;
    if (opts.decrypt) {
      type2 = "decrypt";
    } else {
      type2 = "encrypt";
    }
    var key2 = opts.key;
    if (!Buffer2.isBuffer(key2)) {
      key2 = Buffer2.from(key2);
    }
    if (modeName === "des-ede" || modeName === "des-ede-cbc") {
      key2 = Buffer2.concat([key2, key2.slice(0, 8)]);
    }
    var iv = opts.iv;
    if (!Buffer2.isBuffer(iv)) {
      iv = Buffer2.from(iv);
    }
    this._des = mode2.create({
      key: key2,
      iv,
      type: type2
    });
  }
  DES.prototype._update = function(data2) {
    return Buffer2.from(this._des.update(data2));
  };
  DES.prototype._final = function() {
    return Buffer2.from(this._des.final());
  };
  return browserifyDes;
}
var browser$6 = {};
var encrypter = {};
var ecb = {};
var hasRequiredEcb;
function requireEcb() {
  if (hasRequiredEcb) return ecb;
  hasRequiredEcb = 1;
  ecb.encrypt = function(self2, block) {
    return self2._cipher.encryptBlock(block);
  };
  ecb.decrypt = function(self2, block) {
    return self2._cipher.decryptBlock(block);
  };
  return ecb;
}
var cbc = {};
var bufferXor;
var hasRequiredBufferXor;
function requireBufferXor() {
  if (hasRequiredBufferXor) return bufferXor;
  hasRequiredBufferXor = 1;
  bufferXor = function xor2(a2, b2) {
    var length = Math.min(a2.length, b2.length);
    var buffer2 = new Buffer(length);
    for (var i4 = 0; i4 < length; ++i4) {
      buffer2[i4] = a2[i4] ^ b2[i4];
    }
    return buffer2;
  };
  return bufferXor;
}
var hasRequiredCbc;
function requireCbc() {
  if (hasRequiredCbc) return cbc;
  hasRequiredCbc = 1;
  var xor2 = requireBufferXor();
  cbc.encrypt = function(self2, block) {
    var data2 = xor2(block, self2._prev);
    self2._prev = self2._cipher.encryptBlock(data2);
    return self2._prev;
  };
  cbc.decrypt = function(self2, block) {
    var pad3 = self2._prev;
    self2._prev = block;
    var out = self2._cipher.decryptBlock(block);
    return xor2(out, pad3);
  };
  return cbc;
}
var cfb = {};
var hasRequiredCfb;
function requireCfb() {
  if (hasRequiredCfb) return cfb;
  hasRequiredCfb = 1;
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var xor2 = requireBufferXor();
  function encryptStart(self2, data2, decrypt) {
    var len2 = data2.length;
    var out = xor2(data2, self2._cache);
    self2._cache = self2._cache.slice(len2);
    self2._prev = Buffer2.concat([self2._prev, decrypt ? data2 : out]);
    return out;
  }
  cfb.encrypt = function(self2, data2, decrypt) {
    var out = Buffer2.allocUnsafe(0);
    var len2;
    while (data2.length) {
      if (self2._cache.length === 0) {
        self2._cache = self2._cipher.encryptBlock(self2._prev);
        self2._prev = Buffer2.allocUnsafe(0);
      }
      if (self2._cache.length <= data2.length) {
        len2 = self2._cache.length;
        out = Buffer2.concat([out, encryptStart(self2, data2.slice(0, len2), decrypt)]);
        data2 = data2.slice(len2);
      } else {
        out = Buffer2.concat([out, encryptStart(self2, data2, decrypt)]);
        break;
      }
    }
    return out;
  };
  return cfb;
}
var cfb8 = {};
var hasRequiredCfb8;
function requireCfb8() {
  if (hasRequiredCfb8) return cfb8;
  hasRequiredCfb8 = 1;
  var Buffer2 = requireSafeBuffer$1().Buffer;
  function encryptByte(self2, byteParam, decrypt) {
    var pad3 = self2._cipher.encryptBlock(self2._prev);
    var out = pad3[0] ^ byteParam;
    self2._prev = Buffer2.concat([
      self2._prev.slice(1),
      Buffer2.from([decrypt ? byteParam : out])
    ]);
    return out;
  }
  cfb8.encrypt = function(self2, chunk, decrypt) {
    var len2 = chunk.length;
    var out = Buffer2.allocUnsafe(len2);
    var i4 = -1;
    while (++i4 < len2) {
      out[i4] = encryptByte(self2, chunk[i4], decrypt);
    }
    return out;
  };
  return cfb8;
}
var cfb1 = {};
var hasRequiredCfb1;
function requireCfb1() {
  if (hasRequiredCfb1) return cfb1;
  hasRequiredCfb1 = 1;
  var Buffer2 = requireSafeBuffer$1().Buffer;
  function encryptByte(self2, byteParam, decrypt) {
    var pad3;
    var i4 = -1;
    var len2 = 8;
    var out = 0;
    var bit, value;
    while (++i4 < len2) {
      pad3 = self2._cipher.encryptBlock(self2._prev);
      bit = byteParam & 1 << 7 - i4 ? 128 : 0;
      value = pad3[0] ^ bit;
      out += (value & 128) >> i4 % 8;
      self2._prev = shiftIn(self2._prev, decrypt ? bit : value);
    }
    return out;
  }
  function shiftIn(buffer2, value) {
    var len2 = buffer2.length;
    var i4 = -1;
    var out = Buffer2.allocUnsafe(buffer2.length);
    buffer2 = Buffer2.concat([buffer2, Buffer2.from([value])]);
    while (++i4 < len2) {
      out[i4] = buffer2[i4] << 1 | buffer2[i4 + 1] >> 7;
    }
    return out;
  }
  cfb1.encrypt = function(self2, chunk, decrypt) {
    var len2 = chunk.length;
    var out = Buffer2.allocUnsafe(len2);
    var i4 = -1;
    while (++i4 < len2) {
      out[i4] = encryptByte(self2, chunk[i4], decrypt);
    }
    return out;
  };
  return cfb1;
}
var ofb = {};
var hasRequiredOfb;
function requireOfb() {
  if (hasRequiredOfb) return ofb;
  hasRequiredOfb = 1;
  var xor2 = requireBufferXor();
  function getBlock(self2) {
    self2._prev = self2._cipher.encryptBlock(self2._prev);
    return self2._prev;
  }
  ofb.encrypt = function(self2, chunk) {
    while (self2._cache.length < chunk.length) {
      self2._cache = Buffer.concat([self2._cache, getBlock(self2)]);
    }
    var pad3 = self2._cache.slice(0, chunk.length);
    self2._cache = self2._cache.slice(chunk.length);
    return xor2(chunk, pad3);
  };
  return ofb;
}
var ctr = {};
var incr32_1;
var hasRequiredIncr32;
function requireIncr32() {
  if (hasRequiredIncr32) return incr32_1;
  hasRequiredIncr32 = 1;
  function incr32(iv) {
    var len2 = iv.length;
    var item;
    while (len2--) {
      item = iv.readUInt8(len2);
      if (item === 255) {
        iv.writeUInt8(0, len2);
      } else {
        item++;
        iv.writeUInt8(item, len2);
        break;
      }
    }
  }
  incr32_1 = incr32;
  return incr32_1;
}
var hasRequiredCtr;
function requireCtr() {
  if (hasRequiredCtr) return ctr;
  hasRequiredCtr = 1;
  var xor2 = requireBufferXor();
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var incr32 = requireIncr32();
  function getBlock(self2) {
    var out = self2._cipher.encryptBlockRaw(self2._prev);
    incr32(self2._prev);
    return out;
  }
  var blockSize = 16;
  ctr.encrypt = function(self2, chunk) {
    var chunkNum = Math.ceil(chunk.length / blockSize);
    var start = self2._cache.length;
    self2._cache = Buffer2.concat([
      self2._cache,
      Buffer2.allocUnsafe(chunkNum * blockSize)
    ]);
    for (var i4 = 0; i4 < chunkNum; i4++) {
      var out = getBlock(self2);
      var offset = start + i4 * blockSize;
      self2._cache.writeUInt32BE(out[0], offset + 0);
      self2._cache.writeUInt32BE(out[1], offset + 4);
      self2._cache.writeUInt32BE(out[2], offset + 8);
      self2._cache.writeUInt32BE(out[3], offset + 12);
    }
    var pad3 = self2._cache.slice(0, chunk.length);
    self2._cache = self2._cache.slice(chunk.length);
    return xor2(chunk, pad3);
  };
  return ctr;
}
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
};
const aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
};
const aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
};
const require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modes_1;
var hasRequiredModes$1;
function requireModes$1() {
  if (hasRequiredModes$1) return modes_1;
  hasRequiredModes$1 = 1;
  var modeModules = {
    ECB: requireEcb(),
    CBC: requireCbc(),
    CFB: requireCfb(),
    CFB8: requireCfb8(),
    CFB1: requireCfb1(),
    OFB: requireOfb(),
    CTR: requireCtr(),
    GCM: requireCtr()
  };
  var modes2 = require$$2;
  for (var key2 in modes2) {
    modes2[key2].module = modeModules[modes2[key2].mode];
  }
  modes_1 = modes2;
  return modes_1;
}
var aes = {};
var hasRequiredAes;
function requireAes() {
  if (hasRequiredAes) return aes;
  hasRequiredAes = 1;
  var Buffer2 = requireSafeBuffer$1().Buffer;
  function asUInt32Array(buf) {
    if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
    var len2 = buf.length / 4 | 0;
    var out = new Array(len2);
    for (var i4 = 0; i4 < len2; i4++) {
      out[i4] = buf.readUInt32BE(i4 * 4);
    }
    return out;
  }
  function scrubVec(v2) {
    for (var i4 = 0; i4 < v2.length; v2++) {
      v2[i4] = 0;
    }
  }
  function cryptBlock(M4, keySchedule, SUB_MIX, SBOX, nRounds) {
    var SUB_MIX0 = SUB_MIX[0];
    var SUB_MIX1 = SUB_MIX[1];
    var SUB_MIX2 = SUB_MIX[2];
    var SUB_MIX3 = SUB_MIX[3];
    var s0 = M4[0] ^ keySchedule[0];
    var s1 = M4[1] ^ keySchedule[1];
    var s2 = M4[2] ^ keySchedule[2];
    var s3 = M4[3] ^ keySchedule[3];
    var t0, t1, t2, t3;
    var ksRow = 4;
    for (var round2 = 1; round2 < nRounds; round2++) {
      t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 255] ^ SUB_MIX2[s2 >>> 8 & 255] ^ SUB_MIX3[s3 & 255] ^ keySchedule[ksRow++];
      t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s2 >>> 16 & 255] ^ SUB_MIX2[s3 >>> 8 & 255] ^ SUB_MIX3[s0 & 255] ^ keySchedule[ksRow++];
      t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[s3 >>> 16 & 255] ^ SUB_MIX2[s0 >>> 8 & 255] ^ SUB_MIX3[s1 & 255] ^ keySchedule[ksRow++];
      t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 255] ^ SUB_MIX2[s1 >>> 8 & 255] ^ SUB_MIX3[s2 & 255] ^ keySchedule[ksRow++];
      s0 = t0;
      s1 = t1;
      s2 = t2;
      s3 = t3;
    }
    t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 | SBOX[s2 >>> 8 & 255] << 8 | SBOX[s3 & 255]) ^ keySchedule[ksRow++];
    t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 255] << 16 | SBOX[s3 >>> 8 & 255] << 8 | SBOX[s0 & 255]) ^ keySchedule[ksRow++];
    t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 255] << 16 | SBOX[s0 >>> 8 & 255] << 8 | SBOX[s1 & 255]) ^ keySchedule[ksRow++];
    t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 | SBOX[s1 >>> 8 & 255] << 8 | SBOX[s2 & 255]) ^ keySchedule[ksRow++];
    t0 = t0 >>> 0;
    t1 = t1 >>> 0;
    t2 = t2 >>> 0;
    t3 = t3 >>> 0;
    return [t0, t1, t2, t3];
  }
  var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
  var G2 = function() {
    var d4 = new Array(256);
    for (var j2 = 0; j2 < 256; j2++) {
      if (j2 < 128) {
        d4[j2] = j2 << 1;
      } else {
        d4[j2] = j2 << 1 ^ 283;
      }
    }
    var SBOX = [];
    var INV_SBOX = [];
    var SUB_MIX = [[], [], [], []];
    var INV_SUB_MIX = [[], [], [], []];
    var x2 = 0;
    var xi4 = 0;
    for (var i4 = 0; i4 < 256; ++i4) {
      var sx = xi4 ^ xi4 << 1 ^ xi4 << 2 ^ xi4 << 3 ^ xi4 << 4;
      sx = sx >>> 8 ^ sx & 255 ^ 99;
      SBOX[x2] = sx;
      INV_SBOX[sx] = x2;
      var x22 = d4[x2];
      var x4 = d4[x22];
      var x8 = d4[x4];
      var t2 = d4[sx] * 257 ^ sx * 16843008;
      SUB_MIX[0][x2] = t2 << 24 | t2 >>> 8;
      SUB_MIX[1][x2] = t2 << 16 | t2 >>> 16;
      SUB_MIX[2][x2] = t2 << 8 | t2 >>> 24;
      SUB_MIX[3][x2] = t2;
      t2 = x8 * 16843009 ^ x4 * 65537 ^ x22 * 257 ^ x2 * 16843008;
      INV_SUB_MIX[0][sx] = t2 << 24 | t2 >>> 8;
      INV_SUB_MIX[1][sx] = t2 << 16 | t2 >>> 16;
      INV_SUB_MIX[2][sx] = t2 << 8 | t2 >>> 24;
      INV_SUB_MIX[3][sx] = t2;
      if (x2 === 0) {
        x2 = xi4 = 1;
      } else {
        x2 = x22 ^ d4[d4[d4[x8 ^ x22]]];
        xi4 ^= d4[d4[xi4]];
      }
    }
    return {
      SBOX,
      INV_SBOX,
      SUB_MIX,
      INV_SUB_MIX
    };
  }();
  function AES(key2) {
    this._key = asUInt32Array(key2);
    this._reset();
  }
  AES.blockSize = 4 * 4;
  AES.keySize = 256 / 8;
  AES.prototype.blockSize = AES.blockSize;
  AES.prototype.keySize = AES.keySize;
  AES.prototype._reset = function() {
    var keyWords = this._key;
    var keySize = keyWords.length;
    var nRounds = keySize + 6;
    var ksRows = (nRounds + 1) * 4;
    var keySchedule = [];
    for (var k3 = 0; k3 < keySize; k3++) {
      keySchedule[k3] = keyWords[k3];
    }
    for (k3 = keySize; k3 < ksRows; k3++) {
      var t2 = keySchedule[k3 - 1];
      if (k3 % keySize === 0) {
        t2 = t2 << 8 | t2 >>> 24;
        t2 = G2.SBOX[t2 >>> 24] << 24 | G2.SBOX[t2 >>> 16 & 255] << 16 | G2.SBOX[t2 >>> 8 & 255] << 8 | G2.SBOX[t2 & 255];
        t2 ^= RCON[k3 / keySize | 0] << 24;
      } else if (keySize > 6 && k3 % keySize === 4) {
        t2 = G2.SBOX[t2 >>> 24] << 24 | G2.SBOX[t2 >>> 16 & 255] << 16 | G2.SBOX[t2 >>> 8 & 255] << 8 | G2.SBOX[t2 & 255];
      }
      keySchedule[k3] = keySchedule[k3 - keySize] ^ t2;
    }
    var invKeySchedule = [];
    for (var ik = 0; ik < ksRows; ik++) {
      var ksR = ksRows - ik;
      var tt2 = keySchedule[ksR - (ik % 4 ? 0 : 4)];
      if (ik < 4 || ksR <= 4) {
        invKeySchedule[ik] = tt2;
      } else {
        invKeySchedule[ik] = G2.INV_SUB_MIX[0][G2.SBOX[tt2 >>> 24]] ^ G2.INV_SUB_MIX[1][G2.SBOX[tt2 >>> 16 & 255]] ^ G2.INV_SUB_MIX[2][G2.SBOX[tt2 >>> 8 & 255]] ^ G2.INV_SUB_MIX[3][G2.SBOX[tt2 & 255]];
      }
    }
    this._nRounds = nRounds;
    this._keySchedule = keySchedule;
    this._invKeySchedule = invKeySchedule;
  };
  AES.prototype.encryptBlockRaw = function(M4) {
    M4 = asUInt32Array(M4);
    return cryptBlock(M4, this._keySchedule, G2.SUB_MIX, G2.SBOX, this._nRounds);
  };
  AES.prototype.encryptBlock = function(M4) {
    var out = this.encryptBlockRaw(M4);
    var buf = Buffer2.allocUnsafe(16);
    buf.writeUInt32BE(out[0], 0);
    buf.writeUInt32BE(out[1], 4);
    buf.writeUInt32BE(out[2], 8);
    buf.writeUInt32BE(out[3], 12);
    return buf;
  };
  AES.prototype.decryptBlock = function(M4) {
    M4 = asUInt32Array(M4);
    var m1 = M4[1];
    M4[1] = M4[3];
    M4[3] = m1;
    var out = cryptBlock(M4, this._invKeySchedule, G2.INV_SUB_MIX, G2.INV_SBOX, this._nRounds);
    var buf = Buffer2.allocUnsafe(16);
    buf.writeUInt32BE(out[0], 0);
    buf.writeUInt32BE(out[3], 4);
    buf.writeUInt32BE(out[2], 8);
    buf.writeUInt32BE(out[1], 12);
    return buf;
  };
  AES.prototype.scrub = function() {
    scrubVec(this._keySchedule);
    scrubVec(this._invKeySchedule);
    scrubVec(this._key);
  };
  aes.AES = AES;
  return aes;
}
var ghash;
var hasRequiredGhash;
function requireGhash() {
  if (hasRequiredGhash) return ghash;
  hasRequiredGhash = 1;
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var ZEROES = Buffer2.alloc(16, 0);
  function toArray2(buf) {
    return [
      buf.readUInt32BE(0),
      buf.readUInt32BE(4),
      buf.readUInt32BE(8),
      buf.readUInt32BE(12)
    ];
  }
  function fromArray(out) {
    var buf = Buffer2.allocUnsafe(16);
    buf.writeUInt32BE(out[0] >>> 0, 0);
    buf.writeUInt32BE(out[1] >>> 0, 4);
    buf.writeUInt32BE(out[2] >>> 0, 8);
    buf.writeUInt32BE(out[3] >>> 0, 12);
    return buf;
  }
  function GHASH(key2) {
    this.h = key2;
    this.state = Buffer2.alloc(16, 0);
    this.cache = Buffer2.allocUnsafe(0);
  }
  GHASH.prototype.ghash = function(block) {
    var i4 = -1;
    while (++i4 < block.length) {
      this.state[i4] ^= block[i4];
    }
    this._multiply();
  };
  GHASH.prototype._multiply = function() {
    var Vi2 = toArray2(this.h);
    var Zi4 = [0, 0, 0, 0];
    var j2, xi4, lsbVi;
    var i4 = -1;
    while (++i4 < 128) {
      xi4 = (this.state[~~(i4 / 8)] & 1 << 7 - i4 % 8) !== 0;
      if (xi4) {
        Zi4[0] ^= Vi2[0];
        Zi4[1] ^= Vi2[1];
        Zi4[2] ^= Vi2[2];
        Zi4[3] ^= Vi2[3];
      }
      lsbVi = (Vi2[3] & 1) !== 0;
      for (j2 = 3; j2 > 0; j2--) {
        Vi2[j2] = Vi2[j2] >>> 1 | (Vi2[j2 - 1] & 1) << 31;
      }
      Vi2[0] = Vi2[0] >>> 1;
      if (lsbVi) {
        Vi2[0] = Vi2[0] ^ 225 << 24;
      }
    }
    this.state = fromArray(Zi4);
  };
  GHASH.prototype.update = function(buf) {
    this.cache = Buffer2.concat([this.cache, buf]);
    var chunk;
    while (this.cache.length >= 16) {
      chunk = this.cache.slice(0, 16);
      this.cache = this.cache.slice(16);
      this.ghash(chunk);
    }
  };
  GHASH.prototype.final = function(abl, bl) {
    if (this.cache.length) {
      this.ghash(Buffer2.concat([this.cache, ZEROES], 16));
    }
    this.ghash(fromArray([0, abl, 0, bl]));
    return this.state;
  };
  ghash = GHASH;
  return ghash;
}
var authCipher;
var hasRequiredAuthCipher;
function requireAuthCipher() {
  if (hasRequiredAuthCipher) return authCipher;
  hasRequiredAuthCipher = 1;
  var aes2 = requireAes();
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var Transform = requireCipherBase();
  var inherits2 = inherits_browserExports;
  var GHASH = requireGhash();
  var xor2 = requireBufferXor();
  var incr32 = requireIncr32();
  function xorTest(a2, b2) {
    var out = 0;
    if (a2.length !== b2.length) out++;
    var len2 = Math.min(a2.length, b2.length);
    for (var i4 = 0; i4 < len2; ++i4) {
      out += a2[i4] ^ b2[i4];
    }
    return out;
  }
  function calcIv(self2, iv, ck) {
    if (iv.length === 12) {
      self2._finID = Buffer2.concat([iv, Buffer2.from([0, 0, 0, 1])]);
      return Buffer2.concat([iv, Buffer2.from([0, 0, 0, 2])]);
    }
    var ghash2 = new GHASH(ck);
    var len2 = iv.length;
    var toPad = len2 % 16;
    ghash2.update(iv);
    if (toPad) {
      toPad = 16 - toPad;
      ghash2.update(Buffer2.alloc(toPad, 0));
    }
    ghash2.update(Buffer2.alloc(8, 0));
    var ivBits = len2 * 8;
    var tail = Buffer2.alloc(8);
    tail.writeUIntBE(ivBits, 0, 8);
    ghash2.update(tail);
    self2._finID = ghash2.state;
    var out = Buffer2.from(self2._finID);
    incr32(out);
    return out;
  }
  function StreamCipher(mode2, key2, iv, decrypt) {
    Transform.call(this);
    var h5 = Buffer2.alloc(4, 0);
    this._cipher = new aes2.AES(key2);
    var ck = this._cipher.encryptBlock(h5);
    this._ghash = new GHASH(ck);
    iv = calcIv(this, iv, ck);
    this._prev = Buffer2.from(iv);
    this._cache = Buffer2.allocUnsafe(0);
    this._secCache = Buffer2.allocUnsafe(0);
    this._decrypt = decrypt;
    this._alen = 0;
    this._len = 0;
    this._mode = mode2;
    this._authTag = null;
    this._called = false;
  }
  inherits2(StreamCipher, Transform);
  StreamCipher.prototype._update = function(chunk) {
    if (!this._called && this._alen) {
      var rump = 16 - this._alen % 16;
      if (rump < 16) {
        rump = Buffer2.alloc(rump, 0);
        this._ghash.update(rump);
      }
    }
    this._called = true;
    var out = this._mode.encrypt(this, chunk);
    if (this._decrypt) {
      this._ghash.update(chunk);
    } else {
      this._ghash.update(out);
    }
    this._len += chunk.length;
    return out;
  };
  StreamCipher.prototype._final = function() {
    if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
    var tag = xor2(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && xorTest(tag, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = tag;
    this._cipher.scrub();
  };
  StreamCipher.prototype.getAuthTag = function getAuthTag() {
    if (this._decrypt || !Buffer2.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  };
  StreamCipher.prototype.setAuthTag = function setAuthTag(tag) {
    if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = tag;
  };
  StreamCipher.prototype.setAAD = function setAAD(buf) {
    if (this._called) throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(buf);
    this._alen += buf.length;
  };
  authCipher = StreamCipher;
  return authCipher;
}
var streamCipher;
var hasRequiredStreamCipher;
function requireStreamCipher() {
  if (hasRequiredStreamCipher) return streamCipher;
  hasRequiredStreamCipher = 1;
  var aes2 = requireAes();
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var Transform = requireCipherBase();
  var inherits2 = inherits_browserExports;
  function StreamCipher(mode2, key2, iv, decrypt) {
    Transform.call(this);
    this._cipher = new aes2.AES(key2);
    this._prev = Buffer2.from(iv);
    this._cache = Buffer2.allocUnsafe(0);
    this._secCache = Buffer2.allocUnsafe(0);
    this._decrypt = decrypt;
    this._mode = mode2;
  }
  inherits2(StreamCipher, Transform);
  StreamCipher.prototype._update = function(chunk) {
    return this._mode.encrypt(this, chunk, this._decrypt);
  };
  StreamCipher.prototype._final = function() {
    this._cipher.scrub();
  };
  streamCipher = StreamCipher;
  return streamCipher;
}
var evp_bytestokey;
var hasRequiredEvp_bytestokey;
function requireEvp_bytestokey() {
  if (hasRequiredEvp_bytestokey) return evp_bytestokey;
  hasRequiredEvp_bytestokey = 1;
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var MD5 = requireMd5_js();
  function EVP_BytesToKey(password, salt, keyBits, ivLen) {
    if (!Buffer2.isBuffer(password)) password = Buffer2.from(password, "binary");
    if (salt) {
      if (!Buffer2.isBuffer(salt)) salt = Buffer2.from(salt, "binary");
      if (salt.length !== 8) throw new RangeError("salt should be Buffer with 8 byte length");
    }
    var keyLen = keyBits / 8;
    var key2 = Buffer2.alloc(keyLen);
    var iv = Buffer2.alloc(ivLen || 0);
    var tmp = Buffer2.alloc(0);
    while (keyLen > 0 || ivLen > 0) {
      var hash3 = new MD5();
      hash3.update(tmp);
      hash3.update(password);
      if (salt) hash3.update(salt);
      tmp = hash3.digest();
      var used = 0;
      if (keyLen > 0) {
        var keyStart = key2.length - keyLen;
        used = Math.min(keyLen, tmp.length);
        tmp.copy(key2, keyStart, 0, used);
        keyLen -= used;
      }
      if (used < tmp.length && ivLen > 0) {
        var ivStart = iv.length - ivLen;
        var length = Math.min(ivLen, tmp.length - used);
        tmp.copy(iv, ivStart, used, used + length);
        ivLen -= length;
      }
    }
    tmp.fill(0);
    return { key: key2, iv };
  }
  evp_bytestokey = EVP_BytesToKey;
  return evp_bytestokey;
}
var hasRequiredEncrypter;
function requireEncrypter() {
  if (hasRequiredEncrypter) return encrypter;
  hasRequiredEncrypter = 1;
  var MODES = requireModes$1();
  var AuthCipher = requireAuthCipher();
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var StreamCipher = requireStreamCipher();
  var Transform = requireCipherBase();
  var aes2 = requireAes();
  var ebtk = requireEvp_bytestokey();
  var inherits2 = inherits_browserExports;
  function Cipher(mode2, key2, iv) {
    Transform.call(this);
    this._cache = new Splitter();
    this._cipher = new aes2.AES(key2);
    this._prev = Buffer2.from(iv);
    this._mode = mode2;
    this._autopadding = true;
  }
  inherits2(Cipher, Transform);
  Cipher.prototype._update = function(data2) {
    this._cache.add(data2);
    var chunk;
    var thing;
    var out = [];
    while (chunk = this._cache.get()) {
      thing = this._mode.encrypt(this, chunk);
      out.push(thing);
    }
    return Buffer2.concat(out);
  };
  var PADDING = Buffer2.alloc(16, 16);
  Cipher.prototype._final = function() {
    var chunk = this._cache.flush();
    if (this._autopadding) {
      chunk = this._mode.encrypt(this, chunk);
      this._cipher.scrub();
      return chunk;
    }
    if (!chunk.equals(PADDING)) {
      this._cipher.scrub();
      throw new Error("data not multiple of block length");
    }
  };
  Cipher.prototype.setAutoPadding = function(setTo) {
    this._autopadding = !!setTo;
    return this;
  };
  function Splitter() {
    this.cache = Buffer2.allocUnsafe(0);
  }
  Splitter.prototype.add = function(data2) {
    this.cache = Buffer2.concat([this.cache, data2]);
  };
  Splitter.prototype.get = function() {
    if (this.cache.length > 15) {
      var out = this.cache.slice(0, 16);
      this.cache = this.cache.slice(16);
      return out;
    }
    return null;
  };
  Splitter.prototype.flush = function() {
    var len2 = 16 - this.cache.length;
    var padBuff = Buffer2.allocUnsafe(len2);
    var i4 = -1;
    while (++i4 < len2) {
      padBuff.writeUInt8(len2, i4);
    }
    return Buffer2.concat([this.cache, padBuff]);
  };
  function createCipheriv(suite, password, iv) {
    var config = MODES[suite.toLowerCase()];
    if (!config) throw new TypeError("invalid suite type");
    if (typeof password === "string") password = Buffer2.from(password);
    if (password.length !== config.key / 8) throw new TypeError("invalid key length " + password.length);
    if (typeof iv === "string") iv = Buffer2.from(iv);
    if (config.mode !== "GCM" && iv.length !== config.iv) throw new TypeError("invalid iv length " + iv.length);
    if (config.type === "stream") {
      return new StreamCipher(config.module, password, iv);
    } else if (config.type === "auth") {
      return new AuthCipher(config.module, password, iv);
    }
    return new Cipher(config.module, password, iv);
  }
  function createCipher(suite, password) {
    var config = MODES[suite.toLowerCase()];
    if (!config) throw new TypeError("invalid suite type");
    var keys2 = ebtk(password, false, config.key, config.iv);
    return createCipheriv(suite, keys2.key, keys2.iv);
  }
  encrypter.createCipheriv = createCipheriv;
  encrypter.createCipher = createCipher;
  return encrypter;
}
var decrypter = {};
var hasRequiredDecrypter;
function requireDecrypter() {
  if (hasRequiredDecrypter) return decrypter;
  hasRequiredDecrypter = 1;
  var AuthCipher = requireAuthCipher();
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var MODES = requireModes$1();
  var StreamCipher = requireStreamCipher();
  var Transform = requireCipherBase();
  var aes2 = requireAes();
  var ebtk = requireEvp_bytestokey();
  var inherits2 = inherits_browserExports;
  function Decipher(mode2, key2, iv) {
    Transform.call(this);
    this._cache = new Splitter();
    this._last = void 0;
    this._cipher = new aes2.AES(key2);
    this._prev = Buffer2.from(iv);
    this._mode = mode2;
    this._autopadding = true;
  }
  inherits2(Decipher, Transform);
  Decipher.prototype._update = function(data2) {
    this._cache.add(data2);
    var chunk;
    var thing;
    var out = [];
    while (chunk = this._cache.get(this._autopadding)) {
      thing = this._mode.decrypt(this, chunk);
      out.push(thing);
    }
    return Buffer2.concat(out);
  };
  Decipher.prototype._final = function() {
    var chunk = this._cache.flush();
    if (this._autopadding) {
      return unpad(this._mode.decrypt(this, chunk));
    } else if (chunk) {
      throw new Error("data not multiple of block length");
    }
  };
  Decipher.prototype.setAutoPadding = function(setTo) {
    this._autopadding = !!setTo;
    return this;
  };
  function Splitter() {
    this.cache = Buffer2.allocUnsafe(0);
  }
  Splitter.prototype.add = function(data2) {
    this.cache = Buffer2.concat([this.cache, data2]);
  };
  Splitter.prototype.get = function(autoPadding) {
    var out;
    if (autoPadding) {
      if (this.cache.length > 16) {
        out = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        return out;
      }
    } else {
      if (this.cache.length >= 16) {
        out = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        return out;
      }
    }
    return null;
  };
  Splitter.prototype.flush = function() {
    if (this.cache.length) return this.cache;
  };
  function unpad(last) {
    var padded = last[15];
    if (padded < 1 || padded > 16) {
      throw new Error("unable to decrypt data");
    }
    var i4 = -1;
    while (++i4 < padded) {
      if (last[i4 + (16 - padded)] !== padded) {
        throw new Error("unable to decrypt data");
      }
    }
    if (padded === 16) return;
    return last.slice(0, 16 - padded);
  }
  function createDecipheriv(suite, password, iv) {
    var config = MODES[suite.toLowerCase()];
    if (!config) throw new TypeError("invalid suite type");
    if (typeof iv === "string") iv = Buffer2.from(iv);
    if (config.mode !== "GCM" && iv.length !== config.iv) throw new TypeError("invalid iv length " + iv.length);
    if (typeof password === "string") password = Buffer2.from(password);
    if (password.length !== config.key / 8) throw new TypeError("invalid key length " + password.length);
    if (config.type === "stream") {
      return new StreamCipher(config.module, password, iv, true);
    } else if (config.type === "auth") {
      return new AuthCipher(config.module, password, iv, true);
    }
    return new Decipher(config.module, password, iv);
  }
  function createDecipher(suite, password) {
    var config = MODES[suite.toLowerCase()];
    if (!config) throw new TypeError("invalid suite type");
    var keys2 = ebtk(password, false, config.key, config.iv);
    return createDecipheriv(suite, keys2.key, keys2.iv);
  }
  decrypter.createDecipher = createDecipher;
  decrypter.createDecipheriv = createDecipheriv;
  return decrypter;
}
var hasRequiredBrowser$6;
function requireBrowser$6() {
  if (hasRequiredBrowser$6) return browser$6;
  hasRequiredBrowser$6 = 1;
  var ciphers = requireEncrypter();
  var deciphers = requireDecrypter();
  var modes2 = require$$2;
  function getCiphers() {
    return Object.keys(modes2);
  }
  browser$6.createCipher = browser$6.Cipher = ciphers.createCipher;
  browser$6.createCipheriv = browser$6.Cipheriv = ciphers.createCipheriv;
  browser$6.createDecipher = browser$6.Decipher = deciphers.createDecipher;
  browser$6.createDecipheriv = browser$6.Decipheriv = deciphers.createDecipheriv;
  browser$6.listCiphers = browser$6.getCiphers = getCiphers;
  return browser$6;
}
var modes = {};
var hasRequiredModes;
function requireModes() {
  if (hasRequiredModes) return modes;
  hasRequiredModes = 1;
  (function(exports2) {
    exports2["des-ecb"] = {
      key: 8,
      iv: 0
    };
    exports2["des-cbc"] = exports2.des = {
      key: 8,
      iv: 8
    };
    exports2["des-ede3-cbc"] = exports2.des3 = {
      key: 24,
      iv: 8
    };
    exports2["des-ede3"] = {
      key: 24,
      iv: 0
    };
    exports2["des-ede-cbc"] = {
      key: 16,
      iv: 8
    };
    exports2["des-ede"] = {
      key: 16,
      iv: 0
    };
  })(modes);
  return modes;
}
var hasRequiredBrowser$5;
function requireBrowser$5() {
  if (hasRequiredBrowser$5) return browser$7;
  hasRequiredBrowser$5 = 1;
  var DES = requireBrowserifyDes();
  var aes2 = requireBrowser$6();
  var aesModes = requireModes$1();
  var desModes = requireModes();
  var ebtk = requireEvp_bytestokey();
  function createCipher(suite, password) {
    suite = suite.toLowerCase();
    var keyLen, ivLen;
    if (aesModes[suite]) {
      keyLen = aesModes[suite].key;
      ivLen = aesModes[suite].iv;
    } else if (desModes[suite]) {
      keyLen = desModes[suite].key * 8;
      ivLen = desModes[suite].iv;
    } else {
      throw new TypeError("invalid suite type");
    }
    var keys2 = ebtk(password, false, keyLen, ivLen);
    return createCipheriv(suite, keys2.key, keys2.iv);
  }
  function createDecipher(suite, password) {
    suite = suite.toLowerCase();
    var keyLen, ivLen;
    if (aesModes[suite]) {
      keyLen = aesModes[suite].key;
      ivLen = aesModes[suite].iv;
    } else if (desModes[suite]) {
      keyLen = desModes[suite].key * 8;
      ivLen = desModes[suite].iv;
    } else {
      throw new TypeError("invalid suite type");
    }
    var keys2 = ebtk(password, false, keyLen, ivLen);
    return createDecipheriv(suite, keys2.key, keys2.iv);
  }
  function createCipheriv(suite, key2, iv) {
    suite = suite.toLowerCase();
    if (aesModes[suite]) return aes2.createCipheriv(suite, key2, iv);
    if (desModes[suite]) return new DES({ key: key2, iv, mode: suite });
    throw new TypeError("invalid suite type");
  }
  function createDecipheriv(suite, key2, iv) {
    suite = suite.toLowerCase();
    if (aesModes[suite]) return aes2.createDecipheriv(suite, key2, iv);
    if (desModes[suite]) return new DES({ key: key2, iv, mode: suite, decrypt: true });
    throw new TypeError("invalid suite type");
  }
  function getCiphers() {
    return Object.keys(desModes).concat(aes2.getCiphers());
  }
  browser$7.createCipher = browser$7.Cipher = createCipher;
  browser$7.createCipheriv = browser$7.Cipheriv = createCipheriv;
  browser$7.createDecipher = browser$7.Decipher = createDecipher;
  browser$7.createDecipheriv = browser$7.Decipheriv = createDecipheriv;
  browser$7.listCiphers = browser$7.getCiphers = getCiphers;
  return browser$7;
}
var browser$5 = {};
var mr$7;
var hasRequiredMr;
function requireMr() {
  if (hasRequiredMr) return mr$7;
  hasRequiredMr = 1;
  var bn2 = bnExports;
  var brorand2 = requireBrorand();
  function MillerRabin(rand) {
    this.rand = rand || new brorand2.Rand();
  }
  mr$7 = MillerRabin;
  MillerRabin.create = function create2(rand) {
    return new MillerRabin(rand);
  };
  MillerRabin.prototype._randbelow = function _randbelow(n5) {
    var len2 = n5.bitLength();
    var min_bytes = Math.ceil(len2 / 8);
    do
      var a2 = new bn2(this.rand.generate(min_bytes));
    while (a2.cmp(n5) >= 0);
    return a2;
  };
  MillerRabin.prototype._randrange = function _randrange(start, stop) {
    var size2 = stop.sub(start);
    return start.add(this._randbelow(size2));
  };
  MillerRabin.prototype.test = function test(n5, k3, cb) {
    var len2 = n5.bitLength();
    var red = bn2.mont(n5);
    var rone = new bn2(1).toRed(red);
    if (!k3)
      k3 = Math.max(1, len2 / 48 | 0);
    var n1 = n5.subn(1);
    for (var s2 = 0; !n1.testn(s2); s2++) {
    }
    var d4 = n5.shrn(s2);
    var rn1 = n1.toRed(red);
    var prime = true;
    for (; k3 > 0; k3--) {
      var a2 = this._randrange(new bn2(2), n1);
      if (cb)
        cb(a2);
      var x2 = a2.toRed(red).redPow(d4);
      if (x2.cmp(rone) === 0 || x2.cmp(rn1) === 0)
        continue;
      for (var i4 = 1; i4 < s2; i4++) {
        x2 = x2.redSqr();
        if (x2.cmp(rone) === 0)
          return false;
        if (x2.cmp(rn1) === 0)
          break;
      }
      if (i4 === s2)
        return false;
    }
    return prime;
  };
  MillerRabin.prototype.getDivisor = function getDivisor(n5, k3) {
    var len2 = n5.bitLength();
    var red = bn2.mont(n5);
    var rone = new bn2(1).toRed(red);
    if (!k3)
      k3 = Math.max(1, len2 / 48 | 0);
    var n1 = n5.subn(1);
    for (var s2 = 0; !n1.testn(s2); s2++) {
    }
    var d4 = n5.shrn(s2);
    var rn1 = n1.toRed(red);
    for (; k3 > 0; k3--) {
      var a2 = this._randrange(new bn2(2), n1);
      var g2 = n5.gcd(a2);
      if (g2.cmpn(1) !== 0)
        return g2;
      var x2 = a2.toRed(red).redPow(d4);
      if (x2.cmp(rone) === 0 || x2.cmp(rn1) === 0)
        continue;
      for (var i4 = 1; i4 < s2; i4++) {
        x2 = x2.redSqr();
        if (x2.cmp(rone) === 0)
          return x2.fromRed().subn(1).gcd(n5);
        if (x2.cmp(rn1) === 0)
          break;
      }
      if (i4 === s2) {
        x2 = x2.redSqr();
        return x2.fromRed().subn(1).gcd(n5);
      }
    }
    return false;
  };
  return mr$7;
}
var generatePrime;
var hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime) return generatePrime;
  hasRequiredGeneratePrime = 1;
  var randomBytes2 = requireBrowser$b();
  generatePrime = findPrime;
  findPrime.simpleSieve = simpleSieve;
  findPrime.fermatTest = fermatTest;
  var BN2 = bnExports;
  var TWENTYFOUR = new BN2(24);
  var MillerRabin = requireMr();
  var millerRabin = new MillerRabin();
  var ONE = new BN2(1);
  var TWO = new BN2(2);
  var FIVE = new BN2(5);
  new BN2(16);
  new BN2(8);
  var TEN = new BN2(10);
  var THREE = new BN2(3);
  new BN2(7);
  var ELEVEN = new BN2(11);
  var FOUR = new BN2(4);
  new BN2(12);
  var primes = null;
  function _getPrimes() {
    if (primes !== null)
      return primes;
    var limit = 1048576;
    var res = [];
    res[0] = 2;
    for (var i4 = 1, k3 = 3; k3 < limit; k3 += 2) {
      var sqrt = Math.ceil(Math.sqrt(k3));
      for (var j2 = 0; j2 < i4 && res[j2] <= sqrt; j2++)
        if (k3 % res[j2] === 0)
          break;
      if (i4 !== j2 && res[j2] <= sqrt)
        continue;
      res[i4++] = k3;
    }
    primes = res;
    return res;
  }
  function simpleSieve(p2) {
    var primes2 = _getPrimes();
    for (var i4 = 0; i4 < primes2.length; i4++)
      if (p2.modn(primes2[i4]) === 0) {
        if (p2.cmpn(primes2[i4]) === 0) {
          return true;
        } else {
          return false;
        }
      }
    return true;
  }
  function fermatTest(p2) {
    var red = BN2.mont(p2);
    return TWO.toRed(red).redPow(p2.subn(1)).fromRed().cmpn(1) === 0;
  }
  function findPrime(bits, gen2) {
    if (bits < 16) {
      if (gen2 === 2 || gen2 === 5) {
        return new BN2([140, 123]);
      } else {
        return new BN2([140, 39]);
      }
    }
    gen2 = new BN2(gen2);
    var num, n22;
    while (true) {
      num = new BN2(randomBytes2(Math.ceil(bits / 8)));
      while (num.bitLength() > bits) {
        num.ishrn(1);
      }
      if (num.isEven()) {
        num.iadd(ONE);
      }
      if (!num.testn(1)) {
        num.iadd(TWO);
      }
      if (!gen2.cmp(TWO)) {
        while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
          num.iadd(FOUR);
        }
      } else if (!gen2.cmp(FIVE)) {
        while (num.mod(TEN).cmp(THREE)) {
          num.iadd(FOUR);
        }
      }
      n22 = num.shrn(1);
      if (simpleSieve(n22) && simpleSieve(num) && fermatTest(n22) && fermatTest(num) && millerRabin.test(n22) && millerRabin.test(num)) {
        return num;
      }
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
};
const modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
};
const modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
};
const modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
};
const modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
};
const modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
};
const modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
};
const modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
};
const require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh;
var hasRequiredDh;
function requireDh() {
  if (hasRequiredDh) return dh;
  hasRequiredDh = 1;
  var BN2 = bnExports;
  var MillerRabin = requireMr();
  var millerRabin = new MillerRabin();
  var TWENTYFOUR = new BN2(24);
  var ELEVEN = new BN2(11);
  var TEN = new BN2(10);
  var THREE = new BN2(3);
  var SEVEN = new BN2(7);
  var primes = requireGeneratePrime();
  var randomBytes2 = requireBrowser$b();
  dh = DH;
  function setPublicKey(pub2, enc) {
    enc = enc || "utf8";
    if (!Buffer.isBuffer(pub2)) {
      pub2 = new Buffer(pub2, enc);
    }
    this._pub = new BN2(pub2);
    return this;
  }
  function setPrivateKey(priv2, enc) {
    enc = enc || "utf8";
    if (!Buffer.isBuffer(priv2)) {
      priv2 = new Buffer(priv2, enc);
    }
    this._priv = new BN2(priv2);
    return this;
  }
  var primeCache = {};
  function checkPrime(prime, generator) {
    var gen2 = generator.toString("hex");
    var hex = [gen2, prime.toString(16)].join("_");
    if (hex in primeCache) {
      return primeCache[hex];
    }
    var error = 0;
    if (prime.isEven() || !primes.simpleSieve || !primes.fermatTest(prime) || !millerRabin.test(prime)) {
      error += 1;
      if (gen2 === "02" || gen2 === "05") {
        error += 8;
      } else {
        error += 4;
      }
      primeCache[hex] = error;
      return error;
    }
    if (!millerRabin.test(prime.shrn(1))) {
      error += 2;
    }
    var rem;
    switch (gen2) {
      case "02":
        if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
          error += 8;
        }
        break;
      case "05":
        rem = prime.mod(TEN);
        if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
          error += 8;
        }
        break;
      default:
        error += 4;
    }
    primeCache[hex] = error;
    return error;
  }
  function DH(prime, generator, malleable) {
    this.setGenerator(generator);
    this.__prime = new BN2(prime);
    this._prime = BN2.mont(this.__prime);
    this._primeLen = prime.length;
    this._pub = void 0;
    this._priv = void 0;
    this._primeCode = void 0;
    if (malleable) {
      this.setPublicKey = setPublicKey;
      this.setPrivateKey = setPrivateKey;
    } else {
      this._primeCode = 8;
    }
  }
  Object.defineProperty(DH.prototype, "verifyError", {
    enumerable: true,
    get: function() {
      if (typeof this._primeCode !== "number") {
        this._primeCode = checkPrime(this.__prime, this.__gen);
      }
      return this._primeCode;
    }
  });
  DH.prototype.generateKeys = function() {
    if (!this._priv) {
      this._priv = new BN2(randomBytes2(this._primeLen));
    }
    this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
    return this.getPublicKey();
  };
  DH.prototype.computeSecret = function(other) {
    other = new BN2(other);
    other = other.toRed(this._prime);
    var secret2 = other.redPow(this._priv).fromRed();
    var out = new Buffer(secret2.toArray());
    var prime = this.getPrime();
    if (out.length < prime.length) {
      var front = new Buffer(prime.length - out.length);
      front.fill(0);
      out = Buffer.concat([front, out]);
    }
    return out;
  };
  DH.prototype.getPublicKey = function getPublicKey(enc) {
    return formatReturnValue(this._pub, enc);
  };
  DH.prototype.getPrivateKey = function getPrivateKey(enc) {
    return formatReturnValue(this._priv, enc);
  };
  DH.prototype.getPrime = function(enc) {
    return formatReturnValue(this.__prime, enc);
  };
  DH.prototype.getGenerator = function(enc) {
    return formatReturnValue(this._gen, enc);
  };
  DH.prototype.setGenerator = function(gen2, enc) {
    enc = enc || "utf8";
    if (!Buffer.isBuffer(gen2)) {
      gen2 = new Buffer(gen2, enc);
    }
    this.__gen = gen2;
    this._gen = new BN2(gen2);
    return this;
  };
  function formatReturnValue(bn2, enc) {
    var buf = new Buffer(bn2.toArray());
    if (!enc) {
      return buf;
    } else {
      return buf.toString(enc);
    }
  }
  return dh;
}
var hasRequiredBrowser$4;
function requireBrowser$4() {
  if (hasRequiredBrowser$4) return browser$5;
  hasRequiredBrowser$4 = 1;
  var generatePrime2 = requireGeneratePrime();
  var primes = require$$1$1;
  var DH = requireDh();
  function getDiffieHellman(mod2) {
    var prime = new Buffer(primes[mod2].prime, "hex");
    var gen2 = new Buffer(primes[mod2].gen, "hex");
    return new DH(prime, gen2);
  }
  var ENCODINGS = {
    "binary": true,
    "hex": true,
    "base64": true
  };
  function createDiffieHellman(prime, enc, generator, genc) {
    if (Buffer.isBuffer(enc) || ENCODINGS[enc] === void 0) {
      return createDiffieHellman(prime, "binary", enc, generator);
    }
    enc = enc || "binary";
    genc = genc || "binary";
    generator = generator || new Buffer([2]);
    if (!Buffer.isBuffer(generator)) {
      generator = new Buffer(generator, genc);
    }
    if (typeof prime === "number") {
      return new DH(generatePrime2(prime, generator), generator, true);
    }
    if (!Buffer.isBuffer(prime)) {
      prime = new Buffer(prime, enc);
    }
    return new DH(prime, generator, true);
  }
  browser$5.DiffieHellmanGroup = browser$5.createDiffieHellmanGroup = browser$5.getDiffieHellman = getDiffieHellman;
  browser$5.createDiffieHellman = browser$5.DiffieHellman = createDiffieHellman;
  return browser$5;
}
var sign = { exports: {} };
var bn$7 = { exports: {} };
bn$7.exports;
var hasRequiredBn;
function requireBn() {
  if (hasRequiredBn) return bn$7.exports;
  hasRequiredBn = 1;
  (function(module) {
    (function(module2, exports2) {
      function assert2(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number2, base3, endian) {
        if (BN2.isBN(number2)) {
          return number2;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number2 !== null) {
          if (base3 === "le" || base3 === "be") {
            endian = base3;
            base3 = 10;
          }
          this._init(number2 || 0, base3 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN2;
      } else {
        exports2.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require$$1$2.Buffer;
        }
      } catch (e3) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max2(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN2.min = function min2(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN2.prototype._init = function init4(number2, base3, endian) {
        if (typeof number2 === "number") {
          return this._initNumber(number2, base3, endian);
        }
        if (typeof number2 === "object") {
          return this._initArray(number2, base3, endian);
        }
        if (base3 === "hex") {
          base3 = 16;
        }
        assert2(base3 === (base3 | 0) && base3 >= 2 && base3 <= 36);
        number2 = number2.toString().replace(/\s+/g, "");
        var start = 0;
        if (number2[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number2.length) {
          if (base3 === 16) {
            this._parseHex(number2, start, endian);
          } else {
            this._parseBase(number2, base3, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base3, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number2, base3, endian) {
        if (number2 < 0) {
          this.negative = 1;
          number2 = -number2;
        }
        if (number2 < 67108864) {
          this.words = [number2 & 67108863];
          this.length = 1;
        } else if (number2 < 4503599627370496) {
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert2(number2 < 9007199254740992);
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base3, endian);
      };
      BN2.prototype._initArray = function _initArray(number2, base3, endian) {
        assert2(typeof number2.length === "number");
        if (number2.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number2.length / 3);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var j2, w2;
        var off = 0;
        if (endian === "be") {
          for (i4 = number2.length - 1, j2 = 0; i4 >= 0; i4 -= 3) {
            w2 = number2[i4] | number2[i4 - 1] << 8 | number2[i4 - 2] << 16;
            this.words[j2] |= w2 << off & 67108863;
            this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j2++;
            }
          }
        } else if (endian === "le") {
          for (i4 = 0, j2 = 0; i4 < number2.length; i4 += 3) {
            w2 = number2[i4] | number2[i4 + 1] << 8 | number2[i4 + 2] << 16;
            this.words[j2] |= w2 << off & 67108863;
            this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j2++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string2, index2) {
        var c2 = string2.charCodeAt(index2);
        if (c2 >= 48 && c2 <= 57) {
          return c2 - 48;
        } else if (c2 >= 65 && c2 <= 70) {
          return c2 - 55;
        } else if (c2 >= 97 && c2 <= 102) {
          return c2 - 87;
        } else {
          assert2(false, "Invalid character in " + string2);
        }
      }
      function parseHexByte(string2, lowerBound, index2) {
        var r3 = parseHex4Bits(string2, index2);
        if (index2 - 1 >= lowerBound) {
          r3 |= parseHex4Bits(string2, index2 - 1) << 4;
        }
        return r3;
      }
      BN2.prototype._parseHex = function _parseHex(number2, start, endian) {
        this.length = Math.ceil((number2.length - start) / 6);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var off = 0;
        var j2 = 0;
        var w2;
        if (endian === "be") {
          for (i4 = number2.length - 1; i4 >= start; i4 -= 2) {
            w2 = parseHexByte(number2, start, i4) << off;
            this.words[j2] |= w2 & 67108863;
            if (off >= 18) {
              off -= 18;
              j2 += 1;
              this.words[j2] |= w2 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number2.length - start;
          for (i4 = parseLength % 2 === 0 ? start + 1 : start; i4 < number2.length; i4 += 2) {
            w2 = parseHexByte(number2, start, i4) << off;
            this.words[j2] |= w2 & 67108863;
            if (off >= 18) {
              off -= 18;
              j2 += 1;
              this.words[j2] |= w2 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul6) {
        var r3 = 0;
        var b2 = 0;
        var len2 = Math.min(str.length, end);
        for (var i4 = start; i4 < len2; i4++) {
          var c2 = str.charCodeAt(i4) - 48;
          r3 *= mul6;
          if (c2 >= 49) {
            b2 = c2 - 49 + 10;
          } else if (c2 >= 17) {
            b2 = c2 - 17 + 10;
          } else {
            b2 = c2;
          }
          assert2(c2 >= 0 && b2 < mul6, "Invalid character");
          r3 += b2;
        }
        return r3;
      }
      BN2.prototype._parseBase = function _parseBase(number2, base3, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base3) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base3 | 0;
        var total = number2.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i4 = start; i4 < end; i4 += limbLen) {
          word = parseBase(number2, i4, i4 + limbLen, base3);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow3 = 1;
          word = parseBase(number2, i4, number2.length, base3);
          for (i4 = 0; i4 < mod2; i4++) {
            pow3 *= base3;
          }
          this.imuln(pow3);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN2.prototype.copy = function copy2(dest) {
        dest.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          dest.words[i4] = this.words[i4];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src2) {
        dest.words = src2.words;
        dest.length = src2.length;
        dest.negative = src2.negative;
        dest.red = src2.red;
      }
      BN2.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN2.prototype.clone = function clone() {
        var r3 = new BN2(null);
        this.copy(r3);
        return r3;
      };
      BN2.prototype._expand = function _expand(size2) {
        while (this.length < size2) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect6;
        } catch (e3) {
          BN2.prototype.inspect = inspect6;
        }
      } else {
        BN2.prototype.inspect = inspect6;
      }
      function inspect6() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros2 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString2(base3, padding2) {
        base3 = base3 || 10;
        padding2 = padding2 | 0 || 1;
        var out;
        if (base3 === 16 || base3 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i4 = 0; i4 < this.length; i4++) {
            var w2 = this.words[i4];
            var word = ((w2 << off | carry) & 16777215).toString(16);
            carry = w2 >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i4--;
            }
            if (carry !== 0 || i4 !== this.length - 1) {
              out = zeros2[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base3 === (base3 | 0) && base3 >= 2 && base3 <= 36) {
          var groupSize = groupSizes[base3];
          var groupBase = groupBases[base3];
          out = "";
          var c2 = this.clone();
          c2.negative = 0;
          while (!c2.isZero()) {
            var r3 = c2.modrn(groupBase).toString(base3);
            c2 = c2.idivn(groupBase);
            if (!c2.isZero()) {
              out = zeros2[groupSize - r3.length] + r3 + out;
            } else {
              out = r3 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert2(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber2() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert2(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON2() {
        return this.toString(16, 2);
      };
      if (Buffer2) {
        BN2.prototype.toBuffer = function toBuffer2(endian, length) {
          return this.toArrayLike(Buffer2, endian, length);
        };
      }
      BN2.prototype.toArray = function toArray2(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size2) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size2);
        }
        return new ArrayType(size2);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength2 = this.byteLength();
        var reqLength = length || Math.max(1, byteLength2);
        assert2(byteLength2 <= reqLength, "byte array longer than desired length");
        assert2(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength2);
        return res;
      };
      BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength2) {
        var position = 0;
        var carry = 0;
        for (var i4 = 0, shift = 0; i4 < this.length; i4++) {
          var word = this.words[i4] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength2) {
        var position = res.length - 1;
        var carry = 0;
        for (var i4 = 0, shift = 0; i4 < this.length; i4++) {
          var word = this.words[i4] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w2) {
          return 32 - Math.clz32(w2);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w2) {
          var t2 = w2;
          var r3 = 0;
          if (t2 >= 4096) {
            r3 += 13;
            t2 >>>= 13;
          }
          if (t2 >= 64) {
            r3 += 7;
            t2 >>>= 7;
          }
          if (t2 >= 8) {
            r3 += 4;
            t2 >>>= 4;
          }
          if (t2 >= 2) {
            r3 += 2;
            t2 >>>= 2;
          }
          return r3 + t2;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w2) {
        if (w2 === 0) return 26;
        var t2 = w2;
        var r3 = 0;
        if ((t2 & 8191) === 0) {
          r3 += 13;
          t2 >>>= 13;
        }
        if ((t2 & 127) === 0) {
          r3 += 7;
          t2 >>>= 7;
        }
        if ((t2 & 15) === 0) {
          r3 += 4;
          t2 >>>= 4;
        }
        if ((t2 & 3) === 0) {
          r3 += 2;
          t2 >>>= 2;
        }
        if ((t2 & 1) === 0) {
          r3++;
        }
        return r3;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w2 = this.words[this.length - 1];
        var hi2 = this._countBits(w2);
        return (this.length - 1) * 26 + hi2;
      };
      function toBitArray(num) {
        var w2 = new Array(num.bitLength());
        for (var bit = 0; bit < w2.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w2[bit] = num.words[off] >>> wbit & 1;
        }
        return w2;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r3 = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var b2 = this._zeroBits(this.words[i4]);
          r3 += b2;
          if (b2 !== 26) break;
        }
        return r3;
      };
      BN2.prototype.byteLength = function byteLength2() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos2(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos2(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg4() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i4 = 0; i4 < num.length; i4++) {
          this.words[i4] = this.words[i4] | num.words[i4];
        }
        return this._strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or2(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b2;
        if (this.length > num.length) {
          b2 = num;
        } else {
          b2 = this;
        }
        for (var i4 = 0; i4 < b2.length; i4++) {
          this.words[i4] = this.words[i4] & num.words[i4];
        }
        this.length = b2.length;
        return this._strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a2;
        var b2;
        if (this.length > num.length) {
          a2 = this;
          b2 = num;
        } else {
          a2 = num;
          b2 = this;
        }
        for (var i4 = 0; i4 < b2.length; i4++) {
          this.words[i4] = a2.words[i4] ^ b2.words[i4];
        }
        if (this !== a2) {
          for (; i4 < a2.length; i4++) {
            this.words[i4] = a2.words[i4];
          }
        }
        this.length = a2.length;
        return this._strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor2(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert2(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i4 = 0; i4 < bytesNeeded; i4++) {
          this.words[i4] = ~this.words[i4] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i4] = ~this.words[i4] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert2(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r3;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r3 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r3 = this.isub(num);
          num.negative = 1;
          return r3._normSign();
        }
        var a2, b2;
        if (this.length > num.length) {
          a2 = this;
          b2 = num;
        } else {
          a2 = num;
          b2 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b2.length; i4++) {
          r3 = (a2.words[i4] | 0) + (b2.words[i4] | 0) + carry;
          this.words[i4] = r3 & 67108863;
          carry = r3 >>> 26;
        }
        for (; carry !== 0 && i4 < a2.length; i4++) {
          r3 = (a2.words[i4] | 0) + carry;
          this.words[i4] = r3 & 67108863;
          carry = r3 >>> 26;
        }
        this.length = a2.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a2 !== this) {
          for (; i4 < a2.length; i4++) {
            this.words[i4] = a2.words[i4];
          }
        }
        return this;
      };
      BN2.prototype.add = function add6(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r3 = this.iadd(num);
          num.negative = 1;
          return r3._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a2, b2;
        if (cmp > 0) {
          a2 = this;
          b2 = num;
        } else {
          a2 = num;
          b2 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b2.length; i4++) {
          r3 = (a2.words[i4] | 0) - (b2.words[i4] | 0) + carry;
          carry = r3 >> 26;
          this.words[i4] = r3 & 67108863;
        }
        for (; carry !== 0 && i4 < a2.length; i4++) {
          r3 = (a2.words[i4] | 0) + carry;
          carry = r3 >> 26;
          this.words[i4] = r3 & 67108863;
        }
        if (carry === 0 && i4 < a2.length && a2 !== this) {
          for (; i4 < a2.length; i4++) {
            this.words[i4] = a2.words[i4];
          }
        }
        this.length = Math.max(this.length, i4);
        if (a2 !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len2 = self2.length + num.length | 0;
        out.length = len2;
        len2 = len2 - 1 | 0;
        var a2 = self2.words[0] | 0;
        var b2 = num.words[0] | 0;
        var r3 = a2 * b2;
        var lo2 = r3 & 67108863;
        var carry = r3 / 67108864 | 0;
        out.words[0] = lo2;
        for (var k3 = 1; k3 < len2; k3++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k3, num.length - 1);
          for (var j2 = Math.max(0, k3 - self2.length + 1); j2 <= maxJ; j2++) {
            var i4 = k3 - j2 | 0;
            a2 = self2.words[i4] | 0;
            b2 = num.words[j2] | 0;
            r3 = a2 * b2 + rword;
            ncarry += r3 / 67108864 | 0;
            rword = r3 & 67108863;
          }
          out.words[k3] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k3] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a2 = self2.words;
        var b2 = num.words;
        var o3 = out.words;
        var c2 = 0;
        var lo2;
        var mid;
        var hi2;
        var a0 = a2[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a2[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a2[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a3 = a2[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a2[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a2[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a2[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a2[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a2[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a2[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b2[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b2[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b2[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b3 = b2[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b2[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b2[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b2[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b2[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b2[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b2[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo2 = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi2 = Math.imul(ah0, bh0);
        var w0 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo2 = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi2 = Math.imul(ah1, bh0);
        lo2 = lo2 + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi2 = hi2 + Math.imul(ah0, bh1) | 0;
        var w1 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo2 = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi2 = Math.imul(ah2, bh0);
        lo2 = lo2 + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi2 = hi2 + Math.imul(ah1, bh1) | 0;
        lo2 = lo2 + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi2 = hi2 + Math.imul(ah0, bh2) | 0;
        var w2 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo2 = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi2 = Math.imul(ah3, bh0);
        lo2 = lo2 + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi2 = hi2 + Math.imul(ah2, bh1) | 0;
        lo2 = lo2 + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi2 = hi2 + Math.imul(ah1, bh2) | 0;
        lo2 = lo2 + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi2 = hi2 + Math.imul(ah0, bh3) | 0;
        var w3 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo2 = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi2 = Math.imul(ah4, bh0);
        lo2 = lo2 + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi2 = hi2 + Math.imul(ah3, bh1) | 0;
        lo2 = lo2 + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi2 = hi2 + Math.imul(ah2, bh2) | 0;
        lo2 = lo2 + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi2 = hi2 + Math.imul(ah1, bh3) | 0;
        lo2 = lo2 + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi2 = hi2 + Math.imul(ah0, bh4) | 0;
        var w4 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo2 = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi2 = Math.imul(ah5, bh0);
        lo2 = lo2 + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi2 = hi2 + Math.imul(ah4, bh1) | 0;
        lo2 = lo2 + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi2 = hi2 + Math.imul(ah3, bh2) | 0;
        lo2 = lo2 + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi2 = hi2 + Math.imul(ah2, bh3) | 0;
        lo2 = lo2 + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi2 = hi2 + Math.imul(ah1, bh4) | 0;
        lo2 = lo2 + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi2 = hi2 + Math.imul(ah0, bh5) | 0;
        var w5 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo2 = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi2 = Math.imul(ah6, bh0);
        lo2 = lo2 + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi2 = hi2 + Math.imul(ah5, bh1) | 0;
        lo2 = lo2 + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi2 = hi2 + Math.imul(ah4, bh2) | 0;
        lo2 = lo2 + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi2 = hi2 + Math.imul(ah3, bh3) | 0;
        lo2 = lo2 + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi2 = hi2 + Math.imul(ah2, bh4) | 0;
        lo2 = lo2 + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi2 = hi2 + Math.imul(ah1, bh5) | 0;
        lo2 = lo2 + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi2 = hi2 + Math.imul(ah0, bh6) | 0;
        var w6 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo2 = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi2 = Math.imul(ah7, bh0);
        lo2 = lo2 + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi2 = hi2 + Math.imul(ah6, bh1) | 0;
        lo2 = lo2 + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi2 = hi2 + Math.imul(ah5, bh2) | 0;
        lo2 = lo2 + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi2 = hi2 + Math.imul(ah4, bh3) | 0;
        lo2 = lo2 + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi2 = hi2 + Math.imul(ah3, bh4) | 0;
        lo2 = lo2 + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi2 = hi2 + Math.imul(ah2, bh5) | 0;
        lo2 = lo2 + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi2 = hi2 + Math.imul(ah1, bh6) | 0;
        lo2 = lo2 + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi2 = hi2 + Math.imul(ah0, bh7) | 0;
        var w7 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo2 = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi2 = Math.imul(ah8, bh0);
        lo2 = lo2 + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi2 = hi2 + Math.imul(ah7, bh1) | 0;
        lo2 = lo2 + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi2 = hi2 + Math.imul(ah6, bh2) | 0;
        lo2 = lo2 + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi2 = hi2 + Math.imul(ah5, bh3) | 0;
        lo2 = lo2 + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi2 = hi2 + Math.imul(ah4, bh4) | 0;
        lo2 = lo2 + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi2 = hi2 + Math.imul(ah3, bh5) | 0;
        lo2 = lo2 + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi2 = hi2 + Math.imul(ah2, bh6) | 0;
        lo2 = lo2 + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi2 = hi2 + Math.imul(ah1, bh7) | 0;
        lo2 = lo2 + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi2 = hi2 + Math.imul(ah0, bh8) | 0;
        var w8 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo2 = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi2 = Math.imul(ah9, bh0);
        lo2 = lo2 + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi2 = hi2 + Math.imul(ah8, bh1) | 0;
        lo2 = lo2 + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi2 = hi2 + Math.imul(ah7, bh2) | 0;
        lo2 = lo2 + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi2 = hi2 + Math.imul(ah6, bh3) | 0;
        lo2 = lo2 + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi2 = hi2 + Math.imul(ah5, bh4) | 0;
        lo2 = lo2 + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi2 = hi2 + Math.imul(ah4, bh5) | 0;
        lo2 = lo2 + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi2 = hi2 + Math.imul(ah3, bh6) | 0;
        lo2 = lo2 + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi2 = hi2 + Math.imul(ah2, bh7) | 0;
        lo2 = lo2 + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi2 = hi2 + Math.imul(ah1, bh8) | 0;
        lo2 = lo2 + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi2 = hi2 + Math.imul(ah0, bh9) | 0;
        var w9 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo2 = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi2 = Math.imul(ah9, bh1);
        lo2 = lo2 + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi2 = hi2 + Math.imul(ah8, bh2) | 0;
        lo2 = lo2 + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi2 = hi2 + Math.imul(ah7, bh3) | 0;
        lo2 = lo2 + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi2 = hi2 + Math.imul(ah6, bh4) | 0;
        lo2 = lo2 + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi2 = hi2 + Math.imul(ah5, bh5) | 0;
        lo2 = lo2 + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi2 = hi2 + Math.imul(ah4, bh6) | 0;
        lo2 = lo2 + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi2 = hi2 + Math.imul(ah3, bh7) | 0;
        lo2 = lo2 + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi2 = hi2 + Math.imul(ah2, bh8) | 0;
        lo2 = lo2 + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi2 = hi2 + Math.imul(ah1, bh9) | 0;
        var w10 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo2 = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi2 = Math.imul(ah9, bh2);
        lo2 = lo2 + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi2 = hi2 + Math.imul(ah8, bh3) | 0;
        lo2 = lo2 + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi2 = hi2 + Math.imul(ah7, bh4) | 0;
        lo2 = lo2 + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi2 = hi2 + Math.imul(ah6, bh5) | 0;
        lo2 = lo2 + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi2 = hi2 + Math.imul(ah5, bh6) | 0;
        lo2 = lo2 + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi2 = hi2 + Math.imul(ah4, bh7) | 0;
        lo2 = lo2 + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi2 = hi2 + Math.imul(ah3, bh8) | 0;
        lo2 = lo2 + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi2 = hi2 + Math.imul(ah2, bh9) | 0;
        var w11 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo2 = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi2 = Math.imul(ah9, bh3);
        lo2 = lo2 + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi2 = hi2 + Math.imul(ah8, bh4) | 0;
        lo2 = lo2 + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi2 = hi2 + Math.imul(ah7, bh5) | 0;
        lo2 = lo2 + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi2 = hi2 + Math.imul(ah6, bh6) | 0;
        lo2 = lo2 + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi2 = hi2 + Math.imul(ah5, bh7) | 0;
        lo2 = lo2 + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi2 = hi2 + Math.imul(ah4, bh8) | 0;
        lo2 = lo2 + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi2 = hi2 + Math.imul(ah3, bh9) | 0;
        var w12 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo2 = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi2 = Math.imul(ah9, bh4);
        lo2 = lo2 + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi2 = hi2 + Math.imul(ah8, bh5) | 0;
        lo2 = lo2 + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi2 = hi2 + Math.imul(ah7, bh6) | 0;
        lo2 = lo2 + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi2 = hi2 + Math.imul(ah6, bh7) | 0;
        lo2 = lo2 + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi2 = hi2 + Math.imul(ah5, bh8) | 0;
        lo2 = lo2 + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi2 = hi2 + Math.imul(ah4, bh9) | 0;
        var w13 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo2 = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi2 = Math.imul(ah9, bh5);
        lo2 = lo2 + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi2 = hi2 + Math.imul(ah8, bh6) | 0;
        lo2 = lo2 + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi2 = hi2 + Math.imul(ah7, bh7) | 0;
        lo2 = lo2 + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi2 = hi2 + Math.imul(ah6, bh8) | 0;
        lo2 = lo2 + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi2 = hi2 + Math.imul(ah5, bh9) | 0;
        var w14 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo2 = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi2 = Math.imul(ah9, bh6);
        lo2 = lo2 + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi2 = hi2 + Math.imul(ah8, bh7) | 0;
        lo2 = lo2 + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi2 = hi2 + Math.imul(ah7, bh8) | 0;
        lo2 = lo2 + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi2 = hi2 + Math.imul(ah6, bh9) | 0;
        var w15 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo2 = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi2 = Math.imul(ah9, bh7);
        lo2 = lo2 + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi2 = hi2 + Math.imul(ah8, bh8) | 0;
        lo2 = lo2 + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi2 = hi2 + Math.imul(ah7, bh9) | 0;
        var w16 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo2 = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi2 = Math.imul(ah9, bh8);
        lo2 = lo2 + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi2 = hi2 + Math.imul(ah8, bh9) | 0;
        var w17 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo2 = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi2 = Math.imul(ah9, bh9);
        var w18 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o3[0] = w0;
        o3[1] = w1;
        o3[2] = w2;
        o3[3] = w3;
        o3[4] = w4;
        o3[5] = w5;
        o3[6] = w6;
        o3[7] = w7;
        o3[8] = w8;
        o3[9] = w9;
        o3[10] = w10;
        o3[11] = w11;
        o3[12] = w12;
        o3[13] = w13;
        o3[14] = w14;
        o3[15] = w15;
        o3[16] = w16;
        o3[17] = w17;
        o3[18] = w18;
        if (c2 !== 0) {
          o3[19] = c2;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k3 = 0; k3 < out.length - 1; k3++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k3, num.length - 1);
          for (var j2 = Math.max(0, k3 - self2.length + 1); j2 <= maxJ; j2++) {
            var i4 = k3 - j2;
            var a2 = self2.words[i4] | 0;
            var b2 = num.words[j2] | 0;
            var r3 = a2 * b2;
            var lo2 = r3 & 67108863;
            ncarry = ncarry + (r3 / 67108864 | 0) | 0;
            lo2 = lo2 + rword | 0;
            rword = lo2 & 67108863;
            ncarry = ncarry + (lo2 >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k3] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k3] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len2 = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len2 < 63) {
          res = smallMulTo(this, num, out);
        } else if (len2 < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      BN2.prototype.mul = function mul6(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert2(typeof num === "number");
        assert2(num < 67108864);
        var carry = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var w2 = (this.words[i4] | 0) * num;
          var lo2 = (w2 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w2 / 67108864 | 0;
          carry += lo2 >>> 26;
          this.words[i4] = lo2 & 67108863;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        this.length = num === 0 ? 1 : this.length;
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow3(num) {
        var w2 = toBitArray(num);
        if (w2.length === 0) return new BN2(1);
        var res = this;
        for (var i4 = 0; i4 < w2.length; i4++, res = res.sqr()) {
          if (w2[i4] !== 0) break;
        }
        if (++i4 < w2.length) {
          for (var q2 = res.sqr(); i4 < w2.length; i4++, q2 = q2.sqr()) {
            if (w2[i4] === 0) continue;
            res = res.mul(q2);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r3 = bits % 26;
        var s2 = (bits - r3) / 26;
        var carryMask = 67108863 >>> 26 - r3 << 26 - r3;
        var i4;
        if (r3 !== 0) {
          var carry = 0;
          for (i4 = 0; i4 < this.length; i4++) {
            var newCarry = this.words[i4] & carryMask;
            var c2 = (this.words[i4] | 0) - newCarry << r3;
            this.words[i4] = c2 | carry;
            carry = newCarry >>> 26 - r3;
          }
          if (carry) {
            this.words[i4] = carry;
            this.length++;
          }
        }
        if (s2 !== 0) {
          for (i4 = this.length - 1; i4 >= 0; i4--) {
            this.words[i4 + s2] = this.words[i4];
          }
          for (i4 = 0; i4 < s2; i4++) {
            this.words[i4] = 0;
          }
          this.length += s2;
        }
        return this._strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert2(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert2(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r3 = bits % 26;
        var s2 = Math.min((bits - r3) / 26, this.length);
        var mask2 = 67108863 ^ 67108863 >>> r3 << r3;
        var maskedWords = extended;
        h5 -= s2;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i4 = 0; i4 < s2; i4++) {
            maskedWords.words[i4] = this.words[i4];
          }
          maskedWords.length = s2;
        }
        if (s2 === 0) ;
        else if (this.length > s2) {
          this.length -= s2;
          for (i4 = 0; i4 < this.length; i4++) {
            this.words[i4] = this.words[i4 + s2];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i4 = this.length - 1; i4 >= 0 && (carry !== 0 || i4 >= h5); i4--) {
          var word = this.words[i4] | 0;
          this.words[i4] = carry << 26 - r3 | word >>> r3;
          carry = word & mask2;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert2(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert2(typeof bit === "number" && bit >= 0);
        var r3 = bit % 26;
        var s2 = (bit - r3) / 26;
        var q2 = 1 << r3;
        if (this.length <= s2) return false;
        var w2 = this.words[s2];
        return !!(w2 & q2);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r3 = bits % 26;
        var s2 = (bits - r3) / 26;
        assert2(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s2) {
          return this;
        }
        if (r3 !== 0) {
          s2++;
        }
        this.length = Math.min(s2, this.length);
        if (r3 !== 0) {
          var mask2 = 67108863 ^ 67108863 >>> r3 << r3;
          this.words[this.length - 1] &= mask2;
        }
        return this._strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i4 = 0; i4 < this.length && this.words[i4] >= 67108864; i4++) {
          this.words[i4] -= 67108864;
          if (i4 === this.length - 1) {
            this.words[i4 + 1] = 1;
          } else {
            this.words[i4 + 1]++;
          }
        }
        this.length = Math.max(this.length, i4 + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i4 = 0; i4 < this.length && this.words[i4] < 0; i4++) {
            this.words[i4] += 67108864;
            this.words[i4 + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs2() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul6, shift) {
        var len2 = num.length + shift;
        var i4;
        this._expand(len2);
        var w2;
        var carry = 0;
        for (i4 = 0; i4 < num.length; i4++) {
          w2 = (this.words[i4 + shift] | 0) + carry;
          var right = (num.words[i4] | 0) * mul6;
          w2 -= right & 67108863;
          carry = (w2 >> 26) - (right / 67108864 | 0);
          this.words[i4 + shift] = w2 & 67108863;
        }
        for (; i4 < this.length - shift; i4++) {
          w2 = (this.words[i4 + shift] | 0) + carry;
          carry = w2 >> 26;
          this.words[i4 + shift] = w2 & 67108863;
        }
        if (carry === 0) return this._strip();
        assert2(carry === -1);
        carry = 0;
        for (i4 = 0; i4 < this.length; i4++) {
          w2 = -(this.words[i4] | 0) + carry;
          carry = w2 >> 26;
          this.words[i4] = w2 & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode2) {
        var shift = this.length - num.length;
        var a2 = this.clone();
        var b2 = num;
        var bhi = b2.words[b2.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b2 = b2.ushln(shift);
          a2.iushln(shift);
          bhi = b2.words[b2.length - 1] | 0;
        }
        var m4 = a2.length - b2.length;
        var q2;
        if (mode2 !== "mod") {
          q2 = new BN2(null);
          q2.length = m4 + 1;
          q2.words = new Array(q2.length);
          for (var i4 = 0; i4 < q2.length; i4++) {
            q2.words[i4] = 0;
          }
        }
        var diff = a2.clone()._ishlnsubmul(b2, 1, m4);
        if (diff.negative === 0) {
          a2 = diff;
          if (q2) {
            q2.words[m4] = 1;
          }
        }
        for (var j2 = m4 - 1; j2 >= 0; j2--) {
          var qj = (a2.words[b2.length + j2] | 0) * 67108864 + (a2.words[b2.length + j2 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a2._ishlnsubmul(b2, qj, j2);
          while (a2.negative !== 0) {
            qj--;
            a2.negative = 0;
            a2._ishlnsubmul(b2, 1, j2);
            if (!a2.isZero()) {
              a2.negative ^= 1;
            }
          }
          if (q2) {
            q2.words[j2] = qj;
          }
        }
        if (q2) {
          q2._strip();
        }
        a2._strip();
        if (mode2 !== "div" && shift !== 0) {
          a2.iushrn(shift);
        }
        return {
          div: q2 || null,
          mod: a2
        };
      };
      BN2.prototype.divmod = function divmod(num, mode2, positive) {
        assert2(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode2);
          if (mode2 !== "mod") {
            div = res.div.neg();
          }
          if (mode2 !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode2);
          if (mode2 !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode2);
          if (mode2 !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode2 === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode2 === "mod") {
            return {
              div: null,
              mod: new BN2(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode2);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert2(num <= 67108863);
        var p2 = (1 << 26) % num;
        var acc = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          acc = (p2 * acc + (this.words[i4] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN2.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN2.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert2(num <= 67108863);
        var carry = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var w2 = (this.words[i4] | 0) + carry * 67108864;
          this.words[i4] = w2 / num | 0;
          carry = w2 % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p2) {
        assert2(p2.negative === 0);
        assert2(!p2.isZero());
        var x2 = this;
        var y4 = p2.clone();
        if (x2.negative !== 0) {
          x2 = x2.umod(p2);
        } else {
          x2 = x2.clone();
        }
        var A2 = new BN2(1);
        var B3 = new BN2(0);
        var C2 = new BN2(0);
        var D2 = new BN2(1);
        var g2 = 0;
        while (x2.isEven() && y4.isEven()) {
          x2.iushrn(1);
          y4.iushrn(1);
          ++g2;
        }
        var yp = y4.clone();
        var xp = x2.clone();
        while (!x2.isZero()) {
          for (var i4 = 0, im = 1; (x2.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1) ;
          if (i4 > 0) {
            x2.iushrn(i4);
            while (i4-- > 0) {
              if (A2.isOdd() || B3.isOdd()) {
                A2.iadd(yp);
                B3.isub(xp);
              }
              A2.iushrn(1);
              B3.iushrn(1);
            }
          }
          for (var j2 = 0, jm = 1; (y4.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1) ;
          if (j2 > 0) {
            y4.iushrn(j2);
            while (j2-- > 0) {
              if (C2.isOdd() || D2.isOdd()) {
                C2.iadd(yp);
                D2.isub(xp);
              }
              C2.iushrn(1);
              D2.iushrn(1);
            }
          }
          if (x2.cmp(y4) >= 0) {
            x2.isub(y4);
            A2.isub(C2);
            B3.isub(D2);
          } else {
            y4.isub(x2);
            C2.isub(A2);
            D2.isub(B3);
          }
        }
        return {
          a: C2,
          b: D2,
          gcd: y4.iushln(g2)
        };
      };
      BN2.prototype._invmp = function _invmp(p2) {
        assert2(p2.negative === 0);
        assert2(!p2.isZero());
        var a2 = this;
        var b2 = p2.clone();
        if (a2.negative !== 0) {
          a2 = a2.umod(p2);
        } else {
          a2 = a2.clone();
        }
        var x1 = new BN2(1);
        var x2 = new BN2(0);
        var delta = b2.clone();
        while (a2.cmpn(1) > 0 && b2.cmpn(1) > 0) {
          for (var i4 = 0, im = 1; (a2.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1) ;
          if (i4 > 0) {
            a2.iushrn(i4);
            while (i4-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j2 = 0, jm = 1; (b2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1) ;
          if (j2 > 0) {
            b2.iushrn(j2);
            while (j2-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a2.cmp(b2) >= 0) {
            a2.isub(b2);
            x1.isub(x2);
          } else {
            b2.isub(a2);
            x2.isub(x1);
          }
        }
        var res;
        if (a2.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p2);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a2 = this.clone();
        var b2 = num.clone();
        a2.negative = 0;
        b2.negative = 0;
        for (var shift = 0; a2.isEven() && b2.isEven(); shift++) {
          a2.iushrn(1);
          b2.iushrn(1);
        }
        do {
          while (a2.isEven()) {
            a2.iushrn(1);
          }
          while (b2.isEven()) {
            b2.iushrn(1);
          }
          var r3 = a2.cmp(b2);
          if (r3 < 0) {
            var t2 = a2;
            a2 = b2;
            b2 = t2;
          } else if (r3 === 0 || b2.cmpn(1) === 0) {
            break;
          }
          a2.isub(b2);
        } while (true);
        return b2.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert2(typeof bit === "number");
        var r3 = bit % 26;
        var s2 = (bit - r3) / 26;
        var q2 = 1 << r3;
        if (this.length <= s2) {
          this._expand(s2 + 1);
          this.words[s2] |= q2;
          return this;
        }
        var carry = q2;
        for (var i4 = s2; carry !== 0 && i4 < this.length; i4++) {
          var w2 = this.words[i4] | 0;
          w2 += carry;
          carry = w2 >>> 26;
          w2 &= 67108863;
          this.words[i4] = w2;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert2(num <= 67108863, "Number is too big");
          var w2 = this.words[0] | 0;
          res = w2 === num ? 0 : w2 < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var a2 = this.words[i4] | 0;
          var b2 = num.words[i4] | 0;
          if (a2 === b2) continue;
          if (a2 < b2) {
            res = -1;
          } else if (a2 > b2) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt2(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt2(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq6(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        assert2(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert2(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert2(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert2(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert2(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert2(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert2(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert2(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert2(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert2(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert2(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert2(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert2(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p2) {
        this.name = name;
        this.p = new BN2(p2, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r3 = num;
        var rlen;
        do {
          this.split(r3, this.tmp);
          r3 = this.imulK(r3);
          r3 = r3.iadd(this.tmp);
          rlen = r3.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r3.ucmp(this.p);
        if (cmp === 0) {
          r3.words[0] = 0;
          r3.length = 1;
        } else if (cmp > 0) {
          r3.isub(this.p);
        } else {
          if (r3.strip !== void 0) {
            r3.strip();
          } else {
            r3._strip();
          }
        }
        return r3;
      };
      MPrime.prototype.split = function split2(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split2(input, output2) {
        var mask2 = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i4 = 0; i4 < outLen; i4++) {
          output2.words[i4] = input.words[i4];
        }
        output2.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output2.words[output2.length++] = prev & mask2;
        for (i4 = 10; i4 < input.length; i4++) {
          var next = input.words[i4] | 0;
          input.words[i4 - 10] = (next & mask2) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i4 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo2 = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var w2 = num.words[i4] | 0;
          lo2 += w2 * 977;
          num.words[i4] = lo2 & 67108863;
          lo2 = w2 * 64 + (lo2 / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var hi2 = (num.words[i4] | 0) * 19 + carry;
          var lo2 = hi2 & 67108863;
          hi2 >>>= 26;
          num.words[i4] = lo2;
          carry = hi2;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m4) {
        if (typeof m4 === "string") {
          var prime = BN2._prime(m4);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert2(m4.gtn(1), "modulus must be greater than 1");
          this.m = m4;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a2) {
        assert2(a2.negative === 0, "red works only with positives");
        assert2(a2.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a2, b2) {
        assert2((a2.negative | b2.negative) === 0, "red works only with positives");
        assert2(
          a2.red && a2.red === b2.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a2) {
        if (this.prime) return this.prime.ireduce(a2)._forceRed(this);
        move(a2, a2.umod(this.m)._forceRed(this));
        return a2;
      };
      Red.prototype.neg = function neg4(a2) {
        if (a2.isZero()) {
          return a2.clone();
        }
        return this.m.sub(a2)._forceRed(this);
      };
      Red.prototype.add = function add6(a2, b2) {
        this._verify2(a2, b2);
        var res = a2.add(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a2, b2) {
        this._verify2(a2, b2);
        var res = a2.iadd(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a2, b2) {
        this._verify2(a2, b2);
        var res = a2.sub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a2, b2) {
        this._verify2(a2, b2);
        var res = a2.isub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a2, num) {
        this._verify1(a2);
        return this.imod(a2.ushln(num));
      };
      Red.prototype.imul = function imul(a2, b2) {
        this._verify2(a2, b2);
        return this.imod(a2.imul(b2));
      };
      Red.prototype.mul = function mul6(a2, b2) {
        this._verify2(a2, b2);
        return this.imod(a2.mul(b2));
      };
      Red.prototype.isqr = function isqr(a2) {
        return this.imul(a2, a2.clone());
      };
      Red.prototype.sqr = function sqr(a2) {
        return this.mul(a2, a2);
      };
      Red.prototype.sqrt = function sqrt(a2) {
        if (a2.isZero()) return a2.clone();
        var mod3 = this.m.andln(3);
        assert2(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow3 = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a2, pow3);
        }
        var q2 = this.m.subn(1);
        var s2 = 0;
        while (!q2.isZero() && q2.andln(1) === 0) {
          s2++;
          q2.iushrn(1);
        }
        assert2(!q2.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z3 = this.m.bitLength();
        z3 = new BN2(2 * z3 * z3).toRed(this);
        while (this.pow(z3, lpow).cmp(nOne) !== 0) {
          z3.redIAdd(nOne);
        }
        var c2 = this.pow(z3, q2);
        var r3 = this.pow(a2, q2.addn(1).iushrn(1));
        var t2 = this.pow(a2, q2);
        var m4 = s2;
        while (t2.cmp(one) !== 0) {
          var tmp = t2;
          for (var i4 = 0; tmp.cmp(one) !== 0; i4++) {
            tmp = tmp.redSqr();
          }
          assert2(i4 < m4);
          var b2 = this.pow(c2, new BN2(1).iushln(m4 - i4 - 1));
          r3 = r3.redMul(b2);
          c2 = b2.redSqr();
          t2 = t2.redMul(c2);
          m4 = i4;
        }
        return r3;
      };
      Red.prototype.invm = function invm(a2) {
        var inv = a2._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow3(a2, num) {
        if (num.isZero()) return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0) return a2.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a2;
        for (var i4 = 2; i4 < wnd.length; i4++) {
          wnd[i4] = this.mul(wnd[i4 - 1], a2);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i4 = num.length - 1; i4 >= 0; i4--) {
          var word = num.words[i4];
          for (var j2 = start - 1; j2 >= 0; j2--) {
            var bit = word >> j2 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i4 !== 0 || j2 !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r3 = num.umod(this.m);
        return r3 === num ? r3.clone() : r3;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont2(num) {
        return new Mont(num);
      };
      function Mont(m4) {
        Red.call(this, m4);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r3 = this.imod(num.mul(this.rinv));
        r3.red = null;
        return r3;
      };
      Mont.prototype.imul = function imul(a2, b2) {
        if (a2.isZero() || b2.isZero()) {
          a2.words[0] = 0;
          a2.length = 1;
          return a2;
        }
        var t2 = a2.imul(b2);
        var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u2 = t2.isub(c2).iushrn(this.shift);
        var res = u2;
        if (u2.cmp(this.m) >= 0) {
          res = u2.isub(this.m);
        } else if (u2.cmpn(0) < 0) {
          res = u2.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul6(a2, b2) {
        if (a2.isZero() || b2.isZero()) return new BN2(0)._forceRed(this);
        var t2 = a2.mul(b2);
        var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u2 = t2.isub(c2).iushrn(this.shift);
        var res = u2;
        if (u2.cmp(this.m) >= 0) {
          res = u2.isub(this.m);
        } else if (u2.cmpn(0) < 0) {
          res = u2.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a2) {
        var res = this.imod(a2._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(module, commonjsGlobal);
  })(bn$7);
  return bn$7.exports;
}
var browserifyRsa;
var hasRequiredBrowserifyRsa;
function requireBrowserifyRsa() {
  if (hasRequiredBrowserifyRsa) return browserifyRsa;
  hasRequiredBrowserifyRsa = 1;
  var BN2 = requireBn();
  var randomBytes2 = requireBrowser$b();
  var Buffer2 = requireSafeBuffer$1().Buffer;
  function getr(priv2) {
    var len2 = priv2.modulus.byteLength();
    var r3;
    do {
      r3 = new BN2(randomBytes2(len2));
    } while (r3.cmp(priv2.modulus) >= 0 || !r3.umod(priv2.prime1) || !r3.umod(priv2.prime2));
    return r3;
  }
  function blind(priv2) {
    var r3 = getr(priv2);
    var blinder = r3.toRed(BN2.mont(priv2.modulus)).redPow(new BN2(priv2.publicExponent)).fromRed();
    return { blinder, unblinder: r3.invm(priv2.modulus) };
  }
  function crt(msg, priv2) {
    var blinds = blind(priv2);
    var len2 = priv2.modulus.byteLength();
    var blinded = new BN2(msg).mul(blinds.blinder).umod(priv2.modulus);
    var c1 = blinded.toRed(BN2.mont(priv2.prime1));
    var c2 = blinded.toRed(BN2.mont(priv2.prime2));
    var qinv = priv2.coefficient;
    var p2 = priv2.prime1;
    var q2 = priv2.prime2;
    var m1 = c1.redPow(priv2.exponent1).fromRed();
    var m22 = c2.redPow(priv2.exponent2).fromRed();
    var h5 = m1.isub(m22).imul(qinv).umod(p2).imul(q2);
    return m22.iadd(h5).imul(blinds.unblinder).umod(priv2.modulus).toArrayLike(Buffer2, "be", len2);
  }
  crt.getr = getr;
  browserifyRsa = crt;
  return browserifyRsa;
}
var asn1$1 = {};
var asn1 = {};
var api$3 = {};
var vmBrowserify = {};
var hasRequiredVmBrowserify;
function requireVmBrowserify() {
  if (hasRequiredVmBrowserify) return vmBrowserify;
  hasRequiredVmBrowserify = 1;
  (function(exports) {
    var indexOf = function(xs2, item) {
      if (xs2.indexOf) return xs2.indexOf(item);
      else for (var i4 = 0; i4 < xs2.length; i4++) {
        if (xs2[i4] === item) return i4;
      }
      return -1;
    };
    var Object_keys = function(obj) {
      if (Object.keys) return Object.keys(obj);
      else {
        var res = [];
        for (var key2 in obj) res.push(key2);
        return res;
      }
    };
    var forEach = function(xs2, fn2) {
      if (xs2.forEach) return xs2.forEach(fn2);
      else for (var i4 = 0; i4 < xs2.length; i4++) {
        fn2(xs2[i4], i4, xs2);
      }
    };
    var defineProp = function() {
      try {
        Object.defineProperty({}, "_", {});
        return function(obj, name, value) {
          Object.defineProperty(obj, name, {
            writable: true,
            enumerable: false,
            configurable: true,
            value
          });
        };
      } catch (e3) {
        return function(obj, name, value) {
          obj[name] = value;
        };
      }
    }();
    var globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function NodeScript(code2) {
      if (!(this instanceof Script)) return new Script(code2);
      this.code = code2;
    };
    Script.prototype.runInContext = function(context) {
      if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
      }
      var iframe = document.createElement("iframe");
      if (!iframe.style) iframe.style = {};
      iframe.style.display = "none";
      document.body.appendChild(iframe);
      var win = iframe.contentWindow;
      var wEval = win.eval, wExecScript = win.execScript;
      if (!wEval && wExecScript) {
        wExecScript.call(win, "null");
        wEval = win.eval;
      }
      forEach(Object_keys(context), function(key2) {
        win[key2] = context[key2];
      });
      forEach(globals, function(key2) {
        if (context[key2]) {
          win[key2] = context[key2];
        }
      });
      var winKeys = Object_keys(win);
      var res = wEval.call(win, this.code);
      forEach(Object_keys(win), function(key2) {
        if (key2 in context || indexOf(winKeys, key2) === -1) {
          context[key2] = win[key2];
        }
      });
      forEach(globals, function(key2) {
        if (!(key2 in context)) {
          defineProp(context, key2, win[key2]);
        }
      });
      document.body.removeChild(iframe);
      return res;
    };
    Script.prototype.runInThisContext = function() {
      return eval(this.code);
    };
    Script.prototype.runInNewContext = function(context) {
      var ctx = Script.createContext(context);
      var res = this.runInContext(ctx);
      if (context) {
        forEach(Object_keys(ctx), function(key2) {
          context[key2] = ctx[key2];
        });
      }
      return res;
    };
    forEach(Object_keys(Script.prototype), function(name) {
      exports[name] = Script[name] = function(code2) {
        var s2 = Script(code2);
        return s2[name].apply(s2, [].slice.call(arguments, 1));
      };
    });
    exports.isContext = function(context) {
      return context instanceof Context;
    };
    exports.createScript = function(code2) {
      return exports.Script(code2);
    };
    exports.createContext = Script.createContext = function(context) {
      var copy2 = new Context();
      if (typeof context === "object") {
        forEach(Object_keys(context), function(key2) {
          copy2[key2] = context[key2];
        });
      }
      return copy2;
    };
  })(vmBrowserify);
  return vmBrowserify;
}
var hasRequiredApi;
function requireApi() {
  if (hasRequiredApi) return api$3;
  hasRequiredApi = 1;
  (function(exports2) {
    var asn12 = requireAsn1$1();
    var inherits2 = inherits_browserExports;
    var api2 = exports2;
    api2.define = function define(name, body) {
      return new Entity(name, body);
    };
    function Entity(name, body) {
      this.name = name;
      this.body = body;
      this.decoders = {};
      this.encoders = {};
    }
    Entity.prototype._createNamed = function createNamed(base3) {
      var named;
      try {
        named = requireVmBrowserify().runInThisContext(
          "(function " + this.name + "(entity) {\n  this._initNamed(entity);\n})"
        );
      } catch (e3) {
        named = function(entity) {
          this._initNamed(entity);
        };
      }
      inherits2(named, base3);
      named.prototype._initNamed = function initnamed(entity) {
        base3.call(this, entity);
      };
      return new named(this);
    };
    Entity.prototype._getDecoder = function _getDecoder(enc) {
      enc = enc || "der";
      if (!this.decoders.hasOwnProperty(enc))
        this.decoders[enc] = this._createNamed(asn12.decoders[enc]);
      return this.decoders[enc];
    };
    Entity.prototype.decode = function decode2(data2, enc, options) {
      return this._getDecoder(enc).decode(data2, options);
    };
    Entity.prototype._getEncoder = function _getEncoder(enc) {
      enc = enc || "der";
      if (!this.encoders.hasOwnProperty(enc))
        this.encoders[enc] = this._createNamed(asn12.encoders[enc]);
      return this.encoders[enc];
    };
    Entity.prototype.encode = function encode4(data2, enc, reporter2) {
      return this._getEncoder(enc).encode(data2, reporter2);
    };
  })(api$3);
  return api$3;
}
var base$3 = {};
var reporter = {};
var hasRequiredReporter;
function requireReporter() {
  if (hasRequiredReporter) return reporter;
  hasRequiredReporter = 1;
  var inherits2 = inherits_browserExports;
  function Reporter(options) {
    this._reporterState = {
      obj: null,
      path: [],
      options: options || {},
      errors: []
    };
  }
  reporter.Reporter = Reporter;
  Reporter.prototype.isError = function isError2(obj) {
    return obj instanceof ReporterError;
  };
  Reporter.prototype.save = function save() {
    var state2 = this._reporterState;
    return { obj: state2.obj, pathLen: state2.path.length };
  };
  Reporter.prototype.restore = function restore(data2) {
    var state2 = this._reporterState;
    state2.obj = data2.obj;
    state2.path = state2.path.slice(0, data2.pathLen);
  };
  Reporter.prototype.enterKey = function enterKey(key2) {
    return this._reporterState.path.push(key2);
  };
  Reporter.prototype.exitKey = function exitKey(index2) {
    var state2 = this._reporterState;
    state2.path = state2.path.slice(0, index2 - 1);
  };
  Reporter.prototype.leaveKey = function leaveKey(index2, key2, value) {
    var state2 = this._reporterState;
    this.exitKey(index2);
    if (state2.obj !== null)
      state2.obj[key2] = value;
  };
  Reporter.prototype.path = function path() {
    return this._reporterState.path.join("/");
  };
  Reporter.prototype.enterObject = function enterObject() {
    var state2 = this._reporterState;
    var prev = state2.obj;
    state2.obj = {};
    return prev;
  };
  Reporter.prototype.leaveObject = function leaveObject(prev) {
    var state2 = this._reporterState;
    var now = state2.obj;
    state2.obj = prev;
    return now;
  };
  Reporter.prototype.error = function error(msg) {
    var err;
    var state2 = this._reporterState;
    var inherited = msg instanceof ReporterError;
    if (inherited) {
      err = msg;
    } else {
      err = new ReporterError(state2.path.map(function(elem) {
        return "[" + JSON.stringify(elem) + "]";
      }).join(""), msg.message || msg, msg.stack);
    }
    if (!state2.options.partial)
      throw err;
    if (!inherited)
      state2.errors.push(err);
    return err;
  };
  Reporter.prototype.wrapResult = function wrapResult(result) {
    var state2 = this._reporterState;
    if (!state2.options.partial)
      return result;
    return {
      result: this.isError(result) ? null : result,
      errors: state2.errors
    };
  };
  function ReporterError(path, msg) {
    this.path = path;
    this.rethrow(msg);
  }
  inherits2(ReporterError, Error);
  ReporterError.prototype.rethrow = function rethrow(msg) {
    this.message = msg + " at: " + (this.path || "(shallow)");
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, ReporterError);
    if (!this.stack) {
      try {
        throw new Error(this.message);
      } catch (e3) {
        this.stack = e3.stack;
      }
    }
    return this;
  };
  return reporter;
}
var buffer = {};
var hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  var inherits2 = inherits_browserExports;
  var Reporter = requireBase$1().Reporter;
  var Buffer2 = require$$1$2.Buffer;
  function DecoderBuffer(base3, options) {
    Reporter.call(this, options);
    if (!Buffer2.isBuffer(base3)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = base3;
    this.offset = 0;
    this.length = base3.length;
  }
  inherits2(DecoderBuffer, Reporter);
  buffer.DecoderBuffer = DecoderBuffer;
  DecoderBuffer.prototype.save = function save() {
    return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
  };
  DecoderBuffer.prototype.restore = function restore(save) {
    var res = new DecoderBuffer(this.base);
    res.offset = save.offset;
    res.length = this.offset;
    this.offset = save.offset;
    Reporter.prototype.restore.call(this, save.reporter);
    return res;
  };
  DecoderBuffer.prototype.isEmpty = function isEmpty() {
    return this.offset === this.length;
  };
  DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
    if (this.offset + 1 <= this.length)
      return this.base.readUInt8(this.offset++, true);
    else
      return this.error(fail || "DecoderBuffer overrun");
  };
  DecoderBuffer.prototype.skip = function skip(bytes2, fail) {
    if (!(this.offset + bytes2 <= this.length))
      return this.error(fail || "DecoderBuffer overrun");
    var res = new DecoderBuffer(this.base);
    res._reporterState = this._reporterState;
    res.offset = this.offset;
    res.length = this.offset + bytes2;
    this.offset += bytes2;
    return res;
  };
  DecoderBuffer.prototype.raw = function raw(save) {
    return this.base.slice(save ? save.offset : this.offset, this.length);
  };
  function EncoderBuffer(value, reporter2) {
    if (Array.isArray(value)) {
      this.length = 0;
      this.value = value.map(function(item) {
        if (!(item instanceof EncoderBuffer))
          item = new EncoderBuffer(item, reporter2);
        this.length += item.length;
        return item;
      }, this);
    } else if (typeof value === "number") {
      if (!(0 <= value && value <= 255))
        return reporter2.error("non-byte EncoderBuffer value");
      this.value = value;
      this.length = 1;
    } else if (typeof value === "string") {
      this.value = value;
      this.length = Buffer2.byteLength(value);
    } else if (Buffer2.isBuffer(value)) {
      this.value = value;
      this.length = value.length;
    } else {
      return reporter2.error("Unsupported type: " + typeof value);
    }
  }
  buffer.EncoderBuffer = EncoderBuffer;
  EncoderBuffer.prototype.join = function join(out, offset) {
    if (!out)
      out = new Buffer2(this.length);
    if (!offset)
      offset = 0;
    if (this.length === 0)
      return out;
    if (Array.isArray(this.value)) {
      this.value.forEach(function(item) {
        item.join(out, offset);
        offset += item.length;
      });
    } else {
      if (typeof this.value === "number")
        out[offset] = this.value;
      else if (typeof this.value === "string")
        out.write(this.value, offset);
      else if (Buffer2.isBuffer(this.value))
        this.value.copy(out, offset);
      offset += this.length;
    }
    return out;
  };
  return buffer;
}
var node;
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  var Reporter = requireBase$1().Reporter;
  var EncoderBuffer = requireBase$1().EncoderBuffer;
  var DecoderBuffer = requireBase$1().DecoderBuffer;
  var assert2 = minimalisticAssert;
  var tags = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ];
  var methods = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(tags);
  var overrided = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function Node(enc, parent2) {
    var state2 = {};
    this._baseState = state2;
    state2.enc = enc;
    state2.parent = parent2 || null;
    state2.children = null;
    state2.tag = null;
    state2.args = null;
    state2.reverseArgs = null;
    state2.choice = null;
    state2.optional = false;
    state2.any = false;
    state2.obj = false;
    state2.use = null;
    state2.useDecoder = null;
    state2.key = null;
    state2["default"] = null;
    state2.explicit = null;
    state2.implicit = null;
    state2.contains = null;
    if (!state2.parent) {
      state2.children = [];
      this._wrap();
    }
  }
  node = Node;
  var stateProps = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  Node.prototype.clone = function clone() {
    var state2 = this._baseState;
    var cstate = {};
    stateProps.forEach(function(prop) {
      cstate[prop] = state2[prop];
    });
    var res = new this.constructor(cstate.parent);
    res._baseState = cstate;
    return res;
  };
  Node.prototype._wrap = function wrap2() {
    var state2 = this._baseState;
    methods.forEach(function(method) {
      this[method] = function _wrappedMethod() {
        var clone = new this.constructor(this);
        state2.children.push(clone);
        return clone[method].apply(clone, arguments);
      };
    }, this);
  };
  Node.prototype._init = function init4(body) {
    var state2 = this._baseState;
    assert2(state2.parent === null);
    body.call(this);
    state2.children = state2.children.filter(function(child) {
      return child._baseState.parent === this;
    }, this);
    assert2.equal(state2.children.length, 1, "Root node can have only one child");
  };
  Node.prototype._useArgs = function useArgs(args) {
    var state2 = this._baseState;
    var children = args.filter(function(arg) {
      return arg instanceof this.constructor;
    }, this);
    args = args.filter(function(arg) {
      return !(arg instanceof this.constructor);
    }, this);
    if (children.length !== 0) {
      assert2(state2.children === null);
      state2.children = children;
      children.forEach(function(child) {
        child._baseState.parent = this;
      }, this);
    }
    if (args.length !== 0) {
      assert2(state2.args === null);
      state2.args = args;
      state2.reverseArgs = args.map(function(arg) {
        if (typeof arg !== "object" || arg.constructor !== Object)
          return arg;
        var res = {};
        Object.keys(arg).forEach(function(key2) {
          if (key2 == (key2 | 0))
            key2 |= 0;
          var value = arg[key2];
          res[value] = key2;
        });
        return res;
      });
    }
  };
  overrided.forEach(function(method) {
    Node.prototype[method] = function _overrided() {
      var state2 = this._baseState;
      throw new Error(method + " not implemented for encoding: " + state2.enc);
    };
  });
  tags.forEach(function(tag) {
    Node.prototype[tag] = function _tagMethod() {
      var state2 = this._baseState;
      var args = Array.prototype.slice.call(arguments);
      assert2(state2.tag === null);
      state2.tag = tag;
      this._useArgs(args);
      return this;
    };
  });
  Node.prototype.use = function use(item) {
    assert2(item);
    var state2 = this._baseState;
    assert2(state2.use === null);
    state2.use = item;
    return this;
  };
  Node.prototype.optional = function optional() {
    var state2 = this._baseState;
    state2.optional = true;
    return this;
  };
  Node.prototype.def = function def(val) {
    var state2 = this._baseState;
    assert2(state2["default"] === null);
    state2["default"] = val;
    state2.optional = true;
    return this;
  };
  Node.prototype.explicit = function explicit(num) {
    var state2 = this._baseState;
    assert2(state2.explicit === null && state2.implicit === null);
    state2.explicit = num;
    return this;
  };
  Node.prototype.implicit = function implicit(num) {
    var state2 = this._baseState;
    assert2(state2.explicit === null && state2.implicit === null);
    state2.implicit = num;
    return this;
  };
  Node.prototype.obj = function obj() {
    var state2 = this._baseState;
    var args = Array.prototype.slice.call(arguments);
    state2.obj = true;
    if (args.length !== 0)
      this._useArgs(args);
    return this;
  };
  Node.prototype.key = function key2(newKey) {
    var state2 = this._baseState;
    assert2(state2.key === null);
    state2.key = newKey;
    return this;
  };
  Node.prototype.any = function any() {
    var state2 = this._baseState;
    state2.any = true;
    return this;
  };
  Node.prototype.choice = function choice(obj) {
    var state2 = this._baseState;
    assert2(state2.choice === null);
    state2.choice = obj;
    this._useArgs(Object.keys(obj).map(function(key2) {
      return obj[key2];
    }));
    return this;
  };
  Node.prototype.contains = function contains(item) {
    var state2 = this._baseState;
    assert2(state2.use === null);
    state2.contains = item;
    return this;
  };
  Node.prototype._decode = function decode2(input, options) {
    var state2 = this._baseState;
    if (state2.parent === null)
      return input.wrapResult(state2.children[0]._decode(input, options));
    var result = state2["default"];
    var present = true;
    var prevKey = null;
    if (state2.key !== null)
      prevKey = input.enterKey(state2.key);
    if (state2.optional) {
      var tag = null;
      if (state2.explicit !== null)
        tag = state2.explicit;
      else if (state2.implicit !== null)
        tag = state2.implicit;
      else if (state2.tag !== null)
        tag = state2.tag;
      if (tag === null && !state2.any) {
        var save = input.save();
        try {
          if (state2.choice === null)
            this._decodeGeneric(state2.tag, input, options);
          else
            this._decodeChoice(input, options);
          present = true;
        } catch (e3) {
          present = false;
        }
        input.restore(save);
      } else {
        present = this._peekTag(input, tag, state2.any);
        if (input.isError(present))
          return present;
      }
    }
    var prevObj;
    if (state2.obj && present)
      prevObj = input.enterObject();
    if (present) {
      if (state2.explicit !== null) {
        var explicit = this._decodeTag(input, state2.explicit);
        if (input.isError(explicit))
          return explicit;
        input = explicit;
      }
      var start = input.offset;
      if (state2.use === null && state2.choice === null) {
        if (state2.any)
          var save = input.save();
        var body = this._decodeTag(
          input,
          state2.implicit !== null ? state2.implicit : state2.tag,
          state2.any
        );
        if (input.isError(body))
          return body;
        if (state2.any)
          result = input.raw(save);
        else
          input = body;
      }
      if (options && options.track && state2.tag !== null)
        options.track(input.path(), start, input.length, "tagged");
      if (options && options.track && state2.tag !== null)
        options.track(input.path(), input.offset, input.length, "content");
      if (state2.any)
        result = result;
      else if (state2.choice === null)
        result = this._decodeGeneric(state2.tag, input, options);
      else
        result = this._decodeChoice(input, options);
      if (input.isError(result))
        return result;
      if (!state2.any && state2.choice === null && state2.children !== null) {
        state2.children.forEach(function decodeChildren(child) {
          child._decode(input, options);
        });
      }
      if (state2.contains && (state2.tag === "octstr" || state2.tag === "bitstr")) {
        var data2 = new DecoderBuffer(result);
        result = this._getUse(state2.contains, input._reporterState.obj)._decode(data2, options);
      }
    }
    if (state2.obj && present)
      result = input.leaveObject(prevObj);
    if (state2.key !== null && (result !== null || present === true))
      input.leaveKey(prevKey, state2.key, result);
    else if (prevKey !== null)
      input.exitKey(prevKey);
    return result;
  };
  Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
    var state2 = this._baseState;
    if (tag === "seq" || tag === "set")
      return null;
    if (tag === "seqof" || tag === "setof")
      return this._decodeList(input, tag, state2.args[0], options);
    else if (/str$/.test(tag))
      return this._decodeStr(input, tag, options);
    else if (tag === "objid" && state2.args)
      return this._decodeObjid(input, state2.args[0], state2.args[1], options);
    else if (tag === "objid")
      return this._decodeObjid(input, null, null, options);
    else if (tag === "gentime" || tag === "utctime")
      return this._decodeTime(input, tag, options);
    else if (tag === "null_")
      return this._decodeNull(input, options);
    else if (tag === "bool")
      return this._decodeBool(input, options);
    else if (tag === "objDesc")
      return this._decodeStr(input, tag, options);
    else if (tag === "int" || tag === "enum")
      return this._decodeInt(input, state2.args && state2.args[0], options);
    if (state2.use !== null) {
      return this._getUse(state2.use, input._reporterState.obj)._decode(input, options);
    } else {
      return input.error("unknown tag: " + tag);
    }
  };
  Node.prototype._getUse = function _getUse(entity, obj) {
    var state2 = this._baseState;
    state2.useDecoder = this._use(entity, obj);
    assert2(state2.useDecoder._baseState.parent === null);
    state2.useDecoder = state2.useDecoder._baseState.children[0];
    if (state2.implicit !== state2.useDecoder._baseState.implicit) {
      state2.useDecoder = state2.useDecoder.clone();
      state2.useDecoder._baseState.implicit = state2.implicit;
    }
    return state2.useDecoder;
  };
  Node.prototype._decodeChoice = function decodeChoice(input, options) {
    var state2 = this._baseState;
    var result = null;
    var match = false;
    Object.keys(state2.choice).some(function(key2) {
      var save = input.save();
      var node2 = state2.choice[key2];
      try {
        var value = node2._decode(input, options);
        if (input.isError(value))
          return false;
        result = { type: key2, value };
        match = true;
      } catch (e3) {
        input.restore(save);
        return false;
      }
      return true;
    }, this);
    if (!match)
      return input.error("Choice not matched");
    return result;
  };
  Node.prototype._createEncoderBuffer = function createEncoderBuffer(data2) {
    return new EncoderBuffer(data2, this.reporter);
  };
  Node.prototype._encode = function encode4(data2, reporter2, parent2) {
    var state2 = this._baseState;
    if (state2["default"] !== null && state2["default"] === data2)
      return;
    var result = this._encodeValue(data2, reporter2, parent2);
    if (result === void 0)
      return;
    if (this._skipDefault(result, reporter2, parent2))
      return;
    return result;
  };
  Node.prototype._encodeValue = function encode4(data2, reporter2, parent2) {
    var state2 = this._baseState;
    if (state2.parent === null)
      return state2.children[0]._encode(data2, reporter2 || new Reporter());
    var result = null;
    this.reporter = reporter2;
    if (state2.optional && data2 === void 0) {
      if (state2["default"] !== null)
        data2 = state2["default"];
      else
        return;
    }
    var content = null;
    var primitive = false;
    if (state2.any) {
      result = this._createEncoderBuffer(data2);
    } else if (state2.choice) {
      result = this._encodeChoice(data2, reporter2);
    } else if (state2.contains) {
      content = this._getUse(state2.contains, parent2)._encode(data2, reporter2);
      primitive = true;
    } else if (state2.children) {
      content = state2.children.map(function(child2) {
        if (child2._baseState.tag === "null_")
          return child2._encode(null, reporter2, data2);
        if (child2._baseState.key === null)
          return reporter2.error("Child should have a key");
        var prevKey = reporter2.enterKey(child2._baseState.key);
        if (typeof data2 !== "object")
          return reporter2.error("Child expected, but input is not object");
        var res = child2._encode(data2[child2._baseState.key], reporter2, data2);
        reporter2.leaveKey(prevKey);
        return res;
      }, this).filter(function(child2) {
        return child2;
      });
      content = this._createEncoderBuffer(content);
    } else {
      if (state2.tag === "seqof" || state2.tag === "setof") {
        if (!(state2.args && state2.args.length === 1))
          return reporter2.error("Too many args for : " + state2.tag);
        if (!Array.isArray(data2))
          return reporter2.error("seqof/setof, but data is not Array");
        var child = this.clone();
        child._baseState.implicit = null;
        content = this._createEncoderBuffer(data2.map(function(item) {
          var state3 = this._baseState;
          return this._getUse(state3.args[0], data2)._encode(item, reporter2);
        }, child));
      } else if (state2.use !== null) {
        result = this._getUse(state2.use, parent2)._encode(data2, reporter2);
      } else {
        content = this._encodePrimitive(state2.tag, data2);
        primitive = true;
      }
    }
    var result;
    if (!state2.any && state2.choice === null) {
      var tag = state2.implicit !== null ? state2.implicit : state2.tag;
      var cls = state2.implicit === null ? "universal" : "context";
      if (tag === null) {
        if (state2.use === null)
          reporter2.error("Tag could be omitted only for .use()");
      } else {
        if (state2.use === null)
          result = this._encodeComposite(tag, primitive, cls, content);
      }
    }
    if (state2.explicit !== null)
      result = this._encodeComposite(state2.explicit, false, "context", result);
    return result;
  };
  Node.prototype._encodeChoice = function encodeChoice(data2, reporter2) {
    var state2 = this._baseState;
    var node2 = state2.choice[data2.type];
    if (!node2) {
      assert2(
        false,
        data2.type + " not found in " + JSON.stringify(Object.keys(state2.choice))
      );
    }
    return node2._encode(data2.value, reporter2);
  };
  Node.prototype._encodePrimitive = function encodePrimitive(tag, data2) {
    var state2 = this._baseState;
    if (/str$/.test(tag))
      return this._encodeStr(data2, tag);
    else if (tag === "objid" && state2.args)
      return this._encodeObjid(data2, state2.reverseArgs[0], state2.args[1]);
    else if (tag === "objid")
      return this._encodeObjid(data2, null, null);
    else if (tag === "gentime" || tag === "utctime")
      return this._encodeTime(data2, tag);
    else if (tag === "null_")
      return this._encodeNull();
    else if (tag === "int" || tag === "enum")
      return this._encodeInt(data2, state2.args && state2.reverseArgs[0]);
    else if (tag === "bool")
      return this._encodeBool(data2);
    else if (tag === "objDesc")
      return this._encodeStr(data2, tag);
    else
      throw new Error("Unsupported tag: " + tag);
  };
  Node.prototype._isNumstr = function isNumstr(str) {
    return /^[0-9 ]*$/.test(str);
  };
  Node.prototype._isPrintstr = function isPrintstr(str) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
  };
  return node;
}
var hasRequiredBase$1;
function requireBase$1() {
  if (hasRequiredBase$1) return base$3;
  hasRequiredBase$1 = 1;
  (function(exports2) {
    var base3 = exports2;
    base3.Reporter = requireReporter().Reporter;
    base3.DecoderBuffer = requireBuffer().DecoderBuffer;
    base3.EncoderBuffer = requireBuffer().EncoderBuffer;
    base3.Node = requireNode();
  })(base$3);
  return base$3;
}
var constants = {};
var der = {};
var hasRequiredDer$2;
function requireDer$2() {
  if (hasRequiredDer$2) return der;
  hasRequiredDer$2 = 1;
  (function(exports2) {
    var constants2 = requireConstants();
    exports2.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    };
    exports2.tagClassByName = constants2._reverse(exports2.tagClass);
    exports2.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    };
    exports2.tagByName = constants2._reverse(exports2.tag);
  })(der);
  return der;
}
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  (function(exports2) {
    var constants2 = exports2;
    constants2._reverse = function reverse(map) {
      var res = {};
      Object.keys(map).forEach(function(key2) {
        if ((key2 | 0) == key2)
          key2 = key2 | 0;
        var value = map[key2];
        res[value] = key2;
      });
      return res;
    };
    constants2.der = requireDer$2();
  })(constants);
  return constants;
}
var decoders = {};
var der_1$1;
var hasRequiredDer$1;
function requireDer$1() {
  if (hasRequiredDer$1) return der_1$1;
  hasRequiredDer$1 = 1;
  var inherits2 = inherits_browserExports;
  var asn12 = requireAsn1$1();
  var base3 = asn12.base;
  var bignum = asn12.bignum;
  var der2 = asn12.constants.der;
  function DERDecoder(entity) {
    this.enc = "der";
    this.name = entity.name;
    this.entity = entity;
    this.tree = new DERNode();
    this.tree._init(entity.body);
  }
  der_1$1 = DERDecoder;
  DERDecoder.prototype.decode = function decode2(data2, options) {
    if (!(data2 instanceof base3.DecoderBuffer))
      data2 = new base3.DecoderBuffer(data2, options);
    return this.tree._decode(data2, options);
  };
  function DERNode(parent2) {
    base3.Node.call(this, "der", parent2);
  }
  inherits2(DERNode, base3.Node);
  DERNode.prototype._peekTag = function peekTag(buffer2, tag, any) {
    if (buffer2.isEmpty())
      return false;
    var state2 = buffer2.save();
    var decodedTag = derDecodeTag(buffer2, 'Failed to peek tag: "' + tag + '"');
    if (buffer2.isError(decodedTag))
      return decodedTag;
    buffer2.restore(state2);
    return decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + "of" === tag || any;
  };
  DERNode.prototype._decodeTag = function decodeTag(buffer2, tag, any) {
    var decodedTag = derDecodeTag(
      buffer2,
      'Failed to decode tag of "' + tag + '"'
    );
    if (buffer2.isError(decodedTag))
      return decodedTag;
    var len2 = derDecodeLen(
      buffer2,
      decodedTag.primitive,
      'Failed to get length of "' + tag + '"'
    );
    if (buffer2.isError(len2))
      return len2;
    if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + "of" !== tag) {
      return buffer2.error('Failed to match tag: "' + tag + '"');
    }
    if (decodedTag.primitive || len2 !== null)
      return buffer2.skip(len2, 'Failed to match body of: "' + tag + '"');
    var state2 = buffer2.save();
    var res = this._skipUntilEnd(
      buffer2,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    if (buffer2.isError(res))
      return res;
    len2 = buffer2.offset - state2.offset;
    buffer2.restore(state2);
    return buffer2.skip(len2, 'Failed to match body of: "' + tag + '"');
  };
  DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer2, fail) {
    while (true) {
      var tag = derDecodeTag(buffer2, fail);
      if (buffer2.isError(tag))
        return tag;
      var len2 = derDecodeLen(buffer2, tag.primitive, fail);
      if (buffer2.isError(len2))
        return len2;
      var res;
      if (tag.primitive || len2 !== null)
        res = buffer2.skip(len2);
      else
        res = this._skipUntilEnd(buffer2, fail);
      if (buffer2.isError(res))
        return res;
      if (tag.tagStr === "end")
        break;
    }
  };
  DERNode.prototype._decodeList = function decodeList(buffer2, tag, decoder, options) {
    var result = [];
    while (!buffer2.isEmpty()) {
      var possibleEnd = this._peekTag(buffer2, "end");
      if (buffer2.isError(possibleEnd))
        return possibleEnd;
      var res = decoder.decode(buffer2, "der", options);
      if (buffer2.isError(res) && possibleEnd)
        break;
      result.push(res);
    }
    return result;
  };
  DERNode.prototype._decodeStr = function decodeStr(buffer2, tag) {
    if (tag === "bitstr") {
      var unused = buffer2.readUInt8();
      if (buffer2.isError(unused))
        return unused;
      return { unused, data: buffer2.raw() };
    } else if (tag === "bmpstr") {
      var raw = buffer2.raw();
      if (raw.length % 2 === 1)
        return buffer2.error("Decoding of string type: bmpstr length mismatch");
      var str = "";
      for (var i4 = 0; i4 < raw.length / 2; i4++) {
        str += String.fromCharCode(raw.readUInt16BE(i4 * 2));
      }
      return str;
    } else if (tag === "numstr") {
      var numstr = buffer2.raw().toString("ascii");
      if (!this._isNumstr(numstr)) {
        return buffer2.error("Decoding of string type: numstr unsupported characters");
      }
      return numstr;
    } else if (tag === "octstr") {
      return buffer2.raw();
    } else if (tag === "objDesc") {
      return buffer2.raw();
    } else if (tag === "printstr") {
      var printstr = buffer2.raw().toString("ascii");
      if (!this._isPrintstr(printstr)) {
        return buffer2.error("Decoding of string type: printstr unsupported characters");
      }
      return printstr;
    } else if (/str$/.test(tag)) {
      return buffer2.raw().toString();
    } else {
      return buffer2.error("Decoding of string type: " + tag + " unsupported");
    }
  };
  DERNode.prototype._decodeObjid = function decodeObjid(buffer2, values, relative) {
    var result;
    var identifiers = [];
    var ident = 0;
    while (!buffer2.isEmpty()) {
      var subident = buffer2.readUInt8();
      ident <<= 7;
      ident |= subident & 127;
      if ((subident & 128) === 0) {
        identifiers.push(ident);
        ident = 0;
      }
    }
    if (subident & 128)
      identifiers.push(ident);
    var first = identifiers[0] / 40 | 0;
    var second = identifiers[0] % 40;
    if (relative)
      result = identifiers;
    else
      result = [first, second].concat(identifiers.slice(1));
    if (values) {
      var tmp = values[result.join(" ")];
      if (tmp === void 0)
        tmp = values[result.join(".")];
      if (tmp !== void 0)
        result = tmp;
    }
    return result;
  };
  DERNode.prototype._decodeTime = function decodeTime(buffer2, tag) {
    var str = buffer2.raw().toString();
    if (tag === "gentime") {
      var year = str.slice(0, 4) | 0;
      var mon = str.slice(4, 6) | 0;
      var day = str.slice(6, 8) | 0;
      var hour = str.slice(8, 10) | 0;
      var min2 = str.slice(10, 12) | 0;
      var sec = str.slice(12, 14) | 0;
    } else if (tag === "utctime") {
      var year = str.slice(0, 2) | 0;
      var mon = str.slice(2, 4) | 0;
      var day = str.slice(4, 6) | 0;
      var hour = str.slice(6, 8) | 0;
      var min2 = str.slice(8, 10) | 0;
      var sec = str.slice(10, 12) | 0;
      if (year < 70)
        year = 2e3 + year;
      else
        year = 1900 + year;
    } else {
      return buffer2.error("Decoding " + tag + " time is not supported yet");
    }
    return Date.UTC(year, mon - 1, day, hour, min2, sec, 0);
  };
  DERNode.prototype._decodeNull = function decodeNull(buffer2) {
    return null;
  };
  DERNode.prototype._decodeBool = function decodeBool(buffer2) {
    var res = buffer2.readUInt8();
    if (buffer2.isError(res))
      return res;
    else
      return res !== 0;
  };
  DERNode.prototype._decodeInt = function decodeInt2(buffer2, values) {
    var raw = buffer2.raw();
    var res = new bignum(raw);
    if (values)
      res = values[res.toString(10)] || res;
    return res;
  };
  DERNode.prototype._use = function use(entity, obj) {
    if (typeof entity === "function")
      entity = entity(obj);
    return entity._getDecoder("der").tree;
  };
  function derDecodeTag(buf, fail) {
    var tag = buf.readUInt8(fail);
    if (buf.isError(tag))
      return tag;
    var cls = der2.tagClass[tag >> 6];
    var primitive = (tag & 32) === 0;
    if ((tag & 31) === 31) {
      var oct = tag;
      tag = 0;
      while ((oct & 128) === 128) {
        oct = buf.readUInt8(fail);
        if (buf.isError(oct))
          return oct;
        tag <<= 7;
        tag |= oct & 127;
      }
    } else {
      tag &= 31;
    }
    var tagStr = der2.tag[tag];
    return {
      cls,
      primitive,
      tag,
      tagStr
    };
  }
  function derDecodeLen(buf, primitive, fail) {
    var len2 = buf.readUInt8(fail);
    if (buf.isError(len2))
      return len2;
    if (!primitive && len2 === 128)
      return null;
    if ((len2 & 128) === 0) {
      return len2;
    }
    var num = len2 & 127;
    if (num > 4)
      return buf.error("length octect is too long");
    len2 = 0;
    for (var i4 = 0; i4 < num; i4++) {
      len2 <<= 8;
      var j2 = buf.readUInt8(fail);
      if (buf.isError(j2))
        return j2;
      len2 |= j2;
    }
    return len2;
  }
  return der_1$1;
}
var pem$1;
var hasRequiredPem$1;
function requirePem$1() {
  if (hasRequiredPem$1) return pem$1;
  hasRequiredPem$1 = 1;
  var inherits2 = inherits_browserExports;
  var Buffer2 = require$$1$2.Buffer;
  var DERDecoder = requireDer$1();
  function PEMDecoder(entity) {
    DERDecoder.call(this, entity);
    this.enc = "pem";
  }
  inherits2(PEMDecoder, DERDecoder);
  pem$1 = PEMDecoder;
  PEMDecoder.prototype.decode = function decode2(data2, options) {
    var lines = data2.toString().split(/[\r\n]+/g);
    var label = options.label.toUpperCase();
    var re2 = /^-----(BEGIN|END) ([^-]+)-----$/;
    var start = -1;
    var end = -1;
    for (var i4 = 0; i4 < lines.length; i4++) {
      var match = lines[i4].match(re2);
      if (match === null)
        continue;
      if (match[2] !== label)
        continue;
      if (start === -1) {
        if (match[1] !== "BEGIN")
          break;
        start = i4;
      } else {
        if (match[1] !== "END")
          break;
        end = i4;
        break;
      }
    }
    if (start === -1 || end === -1)
      throw new Error("PEM section not found for: " + label);
    var base642 = lines.slice(start + 1, end).join("");
    base642.replace(/[^a-z0-9\+\/=]+/gi, "");
    var input = new Buffer2(base642, "base64");
    return DERDecoder.prototype.decode.call(this, input, options);
  };
  return pem$1;
}
var hasRequiredDecoders;
function requireDecoders() {
  if (hasRequiredDecoders) return decoders;
  hasRequiredDecoders = 1;
  (function(exports2) {
    var decoders2 = exports2;
    decoders2.der = requireDer$1();
    decoders2.pem = requirePem$1();
  })(decoders);
  return decoders;
}
var encoders = {};
var der_1;
var hasRequiredDer;
function requireDer() {
  if (hasRequiredDer) return der_1;
  hasRequiredDer = 1;
  var inherits2 = inherits_browserExports;
  var Buffer2 = require$$1$2.Buffer;
  var asn12 = requireAsn1$1();
  var base3 = asn12.base;
  var der2 = asn12.constants.der;
  function DEREncoder(entity) {
    this.enc = "der";
    this.name = entity.name;
    this.entity = entity;
    this.tree = new DERNode();
    this.tree._init(entity.body);
  }
  der_1 = DEREncoder;
  DEREncoder.prototype.encode = function encode4(data2, reporter2) {
    return this.tree._encode(data2, reporter2).join();
  };
  function DERNode(parent2) {
    base3.Node.call(this, "der", parent2);
  }
  inherits2(DERNode, base3.Node);
  DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
    var encodedTag = encodeTag(tag, primitive, cls, this.reporter);
    if (content.length < 128) {
      var header = new Buffer2(2);
      header[0] = encodedTag;
      header[1] = content.length;
      return this._createEncoderBuffer([header, content]);
    }
    var lenOctets = 1;
    for (var i4 = content.length; i4 >= 256; i4 >>= 8)
      lenOctets++;
    var header = new Buffer2(1 + 1 + lenOctets);
    header[0] = encodedTag;
    header[1] = 128 | lenOctets;
    for (var i4 = 1 + lenOctets, j2 = content.length; j2 > 0; i4--, j2 >>= 8)
      header[i4] = j2 & 255;
    return this._createEncoderBuffer([header, content]);
  };
  DERNode.prototype._encodeStr = function encodeStr(str, tag) {
    if (tag === "bitstr") {
      return this._createEncoderBuffer([str.unused | 0, str.data]);
    } else if (tag === "bmpstr") {
      var buf = new Buffer2(str.length * 2);
      for (var i4 = 0; i4 < str.length; i4++) {
        buf.writeUInt16BE(str.charCodeAt(i4), i4 * 2);
      }
      return this._createEncoderBuffer(buf);
    } else if (tag === "numstr") {
      if (!this._isNumstr(str)) {
        return this.reporter.error("Encoding of string type: numstr supports only digits and space");
      }
      return this._createEncoderBuffer(str);
    } else if (tag === "printstr") {
      if (!this._isPrintstr(str)) {
        return this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark");
      }
      return this._createEncoderBuffer(str);
    } else if (/str$/.test(tag)) {
      return this._createEncoderBuffer(str);
    } else if (tag === "objDesc") {
      return this._createEncoderBuffer(str);
    } else {
      return this.reporter.error("Encoding of string type: " + tag + " unsupported");
    }
  };
  DERNode.prototype._encodeObjid = function encodeObjid(id2, values, relative) {
    if (typeof id2 === "string") {
      if (!values)
        return this.reporter.error("string objid given, but no values map found");
      if (!values.hasOwnProperty(id2))
        return this.reporter.error("objid not found in values map");
      id2 = values[id2].split(/[\s\.]+/g);
      for (var i4 = 0; i4 < id2.length; i4++)
        id2[i4] |= 0;
    } else if (Array.isArray(id2)) {
      id2 = id2.slice();
      for (var i4 = 0; i4 < id2.length; i4++)
        id2[i4] |= 0;
    }
    if (!Array.isArray(id2)) {
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(id2));
    }
    if (!relative) {
      if (id2[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      id2.splice(0, 2, id2[0] * 40 + id2[1]);
    }
    var size2 = 0;
    for (var i4 = 0; i4 < id2.length; i4++) {
      var ident = id2[i4];
      for (size2++; ident >= 128; ident >>= 7)
        size2++;
    }
    var objid = new Buffer2(size2);
    var offset = objid.length - 1;
    for (var i4 = id2.length - 1; i4 >= 0; i4--) {
      var ident = id2[i4];
      objid[offset--] = ident & 127;
      while ((ident >>= 7) > 0)
        objid[offset--] = 128 | ident & 127;
    }
    return this._createEncoderBuffer(objid);
  };
  function two(num) {
    if (num < 10)
      return "0" + num;
    else
      return num;
  }
  DERNode.prototype._encodeTime = function encodeTime(time2, tag) {
    var str;
    var date = new Date(time2);
    if (tag === "gentime") {
      str = [
        two(date.getFullYear()),
        two(date.getUTCMonth() + 1),
        two(date.getUTCDate()),
        two(date.getUTCHours()),
        two(date.getUTCMinutes()),
        two(date.getUTCSeconds()),
        "Z"
      ].join("");
    } else if (tag === "utctime") {
      str = [
        two(date.getFullYear() % 100),
        two(date.getUTCMonth() + 1),
        two(date.getUTCDate()),
        two(date.getUTCHours()),
        two(date.getUTCMinutes()),
        two(date.getUTCSeconds()),
        "Z"
      ].join("");
    } else {
      this.reporter.error("Encoding " + tag + " time is not supported yet");
    }
    return this._encodeStr(str, "octstr");
  };
  DERNode.prototype._encodeNull = function encodeNull() {
    return this._createEncoderBuffer("");
  };
  DERNode.prototype._encodeInt = function encodeInt2(num, values) {
    if (typeof num === "string") {
      if (!values)
        return this.reporter.error("String int or enum given, but no values map");
      if (!values.hasOwnProperty(num)) {
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
      }
      num = values[num];
    }
    if (typeof num !== "number" && !Buffer2.isBuffer(num)) {
      var numArray = num.toArray();
      if (!num.sign && numArray[0] & 128) {
        numArray.unshift(0);
      }
      num = new Buffer2(numArray);
    }
    if (Buffer2.isBuffer(num)) {
      var size2 = num.length;
      if (num.length === 0)
        size2++;
      var out = new Buffer2(size2);
      num.copy(out);
      if (num.length === 0)
        out[0] = 0;
      return this._createEncoderBuffer(out);
    }
    if (num < 128)
      return this._createEncoderBuffer(num);
    if (num < 256)
      return this._createEncoderBuffer([0, num]);
    var size2 = 1;
    for (var i4 = num; i4 >= 256; i4 >>= 8)
      size2++;
    var out = new Array(size2);
    for (var i4 = out.length - 1; i4 >= 0; i4--) {
      out[i4] = num & 255;
      num >>= 8;
    }
    if (out[0] & 128) {
      out.unshift(0);
    }
    return this._createEncoderBuffer(new Buffer2(out));
  };
  DERNode.prototype._encodeBool = function encodeBool(value) {
    return this._createEncoderBuffer(value ? 255 : 0);
  };
  DERNode.prototype._use = function use(entity, obj) {
    if (typeof entity === "function")
      entity = entity(obj);
    return entity._getEncoder("der").tree;
  };
  DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter2, parent2) {
    var state2 = this._baseState;
    var i4;
    if (state2["default"] === null)
      return false;
    var data2 = dataBuffer.join();
    if (state2.defaultBuffer === void 0)
      state2.defaultBuffer = this._encodeValue(state2["default"], reporter2, parent2).join();
    if (data2.length !== state2.defaultBuffer.length)
      return false;
    for (i4 = 0; i4 < data2.length; i4++)
      if (data2[i4] !== state2.defaultBuffer[i4])
        return false;
    return true;
  };
  function encodeTag(tag, primitive, cls, reporter2) {
    var res;
    if (tag === "seqof")
      tag = "seq";
    else if (tag === "setof")
      tag = "set";
    if (der2.tagByName.hasOwnProperty(tag))
      res = der2.tagByName[tag];
    else if (typeof tag === "number" && (tag | 0) === tag)
      res = tag;
    else
      return reporter2.error("Unknown tag: " + tag);
    if (res >= 31)
      return reporter2.error("Multi-octet tag encoding unsupported");
    if (!primitive)
      res |= 32;
    res |= der2.tagClassByName[cls || "universal"] << 6;
    return res;
  }
  return der_1;
}
var pem;
var hasRequiredPem;
function requirePem() {
  if (hasRequiredPem) return pem;
  hasRequiredPem = 1;
  var inherits2 = inherits_browserExports;
  var DEREncoder = requireDer();
  function PEMEncoder(entity) {
    DEREncoder.call(this, entity);
    this.enc = "pem";
  }
  inherits2(PEMEncoder, DEREncoder);
  pem = PEMEncoder;
  PEMEncoder.prototype.encode = function encode4(data2, options) {
    var buf = DEREncoder.prototype.encode.call(this, data2);
    var p2 = buf.toString("base64");
    var out = ["-----BEGIN " + options.label + "-----"];
    for (var i4 = 0; i4 < p2.length; i4 += 64)
      out.push(p2.slice(i4, i4 + 64));
    out.push("-----END " + options.label + "-----");
    return out.join("\n");
  };
  return pem;
}
var hasRequiredEncoders;
function requireEncoders() {
  if (hasRequiredEncoders) return encoders;
  hasRequiredEncoders = 1;
  (function(exports2) {
    var encoders2 = exports2;
    encoders2.der = requireDer();
    encoders2.pem = requirePem();
  })(encoders);
  return encoders;
}
var hasRequiredAsn1$1;
function requireAsn1$1() {
  if (hasRequiredAsn1$1) return asn1;
  hasRequiredAsn1$1 = 1;
  (function(exports2) {
    var asn12 = exports2;
    asn12.bignum = bnExports;
    asn12.define = requireApi().define;
    asn12.base = requireBase$1();
    asn12.constants = requireConstants();
    asn12.decoders = requireDecoders();
    asn12.encoders = requireEncoders();
  })(asn1);
  return asn1;
}
var certificate;
var hasRequiredCertificate;
function requireCertificate() {
  if (hasRequiredCertificate) return certificate;
  hasRequiredCertificate = 1;
  var asn = requireAsn1$1();
  var Time = asn.define("Time", function() {
    this.choice({
      utcTime: this.utctime(),
      generalTime: this.gentime()
    });
  });
  var AttributeTypeValue = asn.define("AttributeTypeValue", function() {
    this.seq().obj(
      this.key("type").objid(),
      this.key("value").any()
    );
  });
  var AlgorithmIdentifier = asn.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("parameters").optional(),
      this.key("curve").objid().optional()
    );
  });
  var SubjectPublicKeyInfo = asn.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(AlgorithmIdentifier),
      this.key("subjectPublicKey").bitstr()
    );
  });
  var RelativeDistinguishedName = asn.define("RelativeDistinguishedName", function() {
    this.setof(AttributeTypeValue);
  });
  var RDNSequence = asn.define("RDNSequence", function() {
    this.seqof(RelativeDistinguishedName);
  });
  var Name = asn.define("Name", function() {
    this.choice({
      rdnSequence: this.use(RDNSequence)
    });
  });
  var Validity = asn.define("Validity", function() {
    this.seq().obj(
      this.key("notBefore").use(Time),
      this.key("notAfter").use(Time)
    );
  });
  var Extension = asn.define("Extension", function() {
    this.seq().obj(
      this.key("extnID").objid(),
      this.key("critical").bool().def(false),
      this.key("extnValue").octstr()
    );
  });
  var TBSCertificate = asn.define("TBSCertificate", function() {
    this.seq().obj(
      this.key("version").explicit(0)["int"]().optional(),
      this.key("serialNumber")["int"](),
      this.key("signature").use(AlgorithmIdentifier),
      this.key("issuer").use(Name),
      this.key("validity").use(Validity),
      this.key("subject").use(Name),
      this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo),
      this.key("issuerUniqueID").implicit(1).bitstr().optional(),
      this.key("subjectUniqueID").implicit(2).bitstr().optional(),
      this.key("extensions").explicit(3).seqof(Extension).optional()
    );
  });
  var X509Certificate = asn.define("X509Certificate", function() {
    this.seq().obj(
      this.key("tbsCertificate").use(TBSCertificate),
      this.key("signatureAlgorithm").use(AlgorithmIdentifier),
      this.key("signatureValue").bitstr()
    );
  });
  certificate = X509Certificate;
  return certificate;
}
var hasRequiredAsn1;
function requireAsn1() {
  if (hasRequiredAsn1) return asn1$1;
  hasRequiredAsn1 = 1;
  var asn12 = requireAsn1$1();
  asn1$1.certificate = requireCertificate();
  var RSAPrivateKey = asn12.define("RSAPrivateKey", function() {
    this.seq().obj(
      this.key("version")["int"](),
      this.key("modulus")["int"](),
      this.key("publicExponent")["int"](),
      this.key("privateExponent")["int"](),
      this.key("prime1")["int"](),
      this.key("prime2")["int"](),
      this.key("exponent1")["int"](),
      this.key("exponent2")["int"](),
      this.key("coefficient")["int"]()
    );
  });
  asn1$1.RSAPrivateKey = RSAPrivateKey;
  var RSAPublicKey = asn12.define("RSAPublicKey", function() {
    this.seq().obj(
      this.key("modulus")["int"](),
      this.key("publicExponent")["int"]()
    );
  });
  asn1$1.RSAPublicKey = RSAPublicKey;
  var AlgorithmIdentifier = asn12.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("none").null_().optional(),
      this.key("curve").objid().optional(),
      this.key("params").seq().obj(
        this.key("p")["int"](),
        this.key("q")["int"](),
        this.key("g")["int"]()
      ).optional()
    );
  });
  var PublicKey = asn12.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(AlgorithmIdentifier),
      this.key("subjectPublicKey").bitstr()
    );
  });
  asn1$1.PublicKey = PublicKey;
  var PrivateKeyInfo = asn12.define("PrivateKeyInfo", function() {
    this.seq().obj(
      this.key("version")["int"](),
      this.key("algorithm").use(AlgorithmIdentifier),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.PrivateKey = PrivateKeyInfo;
  var EncryptedPrivateKeyInfo = asn12.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").seq().obj(
        this.key("id").objid(),
        this.key("decrypt").seq().obj(
          this.key("kde").seq().obj(
            this.key("id").objid(),
            this.key("kdeparams").seq().obj(
              this.key("salt").octstr(),
              this.key("iters")["int"]()
            )
          ),
          this.key("cipher").seq().obj(
            this.key("algo").objid(),
            this.key("iv").octstr()
          )
        )
      ),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
  var DSAPrivateKey = asn12.define("DSAPrivateKey", function() {
    this.seq().obj(
      this.key("version")["int"](),
      this.key("p")["int"](),
      this.key("q")["int"](),
      this.key("g")["int"](),
      this.key("pub_key")["int"](),
      this.key("priv_key")["int"]()
    );
  });
  asn1$1.DSAPrivateKey = DSAPrivateKey;
  asn1$1.DSAparam = asn12.define("DSAparam", function() {
    this["int"]();
  });
  var ECParameters = asn12.define("ECParameters", function() {
    this.choice({
      namedCurve: this.objid()
    });
  });
  var ECPrivateKey = asn12.define("ECPrivateKey", function() {
    this.seq().obj(
      this.key("version")["int"](),
      this.key("privateKey").octstr(),
      this.key("parameters").optional().explicit(0).use(ECParameters),
      this.key("publicKey").optional().explicit(1).bitstr()
    );
  });
  asn1$1.ECPrivateKey = ECPrivateKey;
  asn1$1.signature = asn12.define("signature", function() {
    this.seq().obj(
      this.key("r")["int"](),
      this.key("s")["int"]()
    );
  });
  return asn1$1;
}
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var fixProc;
var hasRequiredFixProc;
function requireFixProc() {
  if (hasRequiredFixProc) return fixProc;
  hasRequiredFixProc = 1;
  var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
  var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
  var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
  var evp = requireEvp_bytestokey();
  var ciphers = requireBrowser$6();
  var Buffer2 = requireSafeBuffer$1().Buffer;
  fixProc = function(okey, password) {
    var key2 = okey.toString();
    var match = key2.match(findProc);
    var decrypted;
    if (!match) {
      var match2 = key2.match(fullRegex);
      decrypted = Buffer2.from(match2[2].replace(/[\r\n]/g, ""), "base64");
    } else {
      var suite = "aes" + match[1];
      var iv = Buffer2.from(match[2], "hex");
      var cipherText = Buffer2.from(match[3].replace(/[\r\n]/g, ""), "base64");
      var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
      var out = [];
      var cipher2 = ciphers.createDecipheriv(suite, cipherKey, iv);
      out.push(cipher2.update(cipherText));
      out.push(cipher2["final"]());
      decrypted = Buffer2.concat(out);
    }
    var tag = key2.match(startRegex)[1];
    return {
      tag,
      data: decrypted
    };
  };
  return fixProc;
}
var parseAsn1;
var hasRequiredParseAsn1;
function requireParseAsn1() {
  if (hasRequiredParseAsn1) return parseAsn1;
  hasRequiredParseAsn1 = 1;
  var asn12 = requireAsn1();
  var aesid = require$$1;
  var fixProc2 = requireFixProc();
  var ciphers = requireBrowser$6();
  var pbkdf2Sync = requireBrowser$7().pbkdf2Sync;
  var Buffer2 = requireSafeBuffer$1().Buffer;
  function decrypt(data2, password) {
    var salt = data2.algorithm.decrypt.kde.kdeparams.salt;
    var iters = parseInt(data2.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
    var algo = aesid[data2.algorithm.decrypt.cipher.algo.join(".")];
    var iv = data2.algorithm.decrypt.cipher.iv;
    var cipherText = data2.subjectPrivateKey;
    var keylen = parseInt(algo.split("-")[1], 10) / 8;
    var key2 = pbkdf2Sync(password, salt, iters, keylen, "sha1");
    var cipher2 = ciphers.createDecipheriv(algo, key2, iv);
    var out = [];
    out.push(cipher2.update(cipherText));
    out.push(cipher2["final"]());
    return Buffer2.concat(out);
  }
  function parseKeys(buffer2) {
    var password;
    if (typeof buffer2 === "object" && !Buffer2.isBuffer(buffer2)) {
      password = buffer2.passphrase;
      buffer2 = buffer2.key;
    }
    if (typeof buffer2 === "string") {
      buffer2 = Buffer2.from(buffer2);
    }
    var stripped = fixProc2(buffer2, password);
    var type2 = stripped.tag;
    var data2 = stripped.data;
    var subtype, ndata;
    switch (type2) {
      case "CERTIFICATE":
        ndata = asn12.certificate.decode(data2, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        if (!ndata) {
          ndata = asn12.PublicKey.decode(data2, "der");
        }
        subtype = ndata.algorithm.algorithm.join(".");
        switch (subtype) {
          case "1.2.840.113549.1.1.1":
            return asn12.RSAPublicKey.decode(ndata.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            ndata.subjectPrivateKey = ndata.subjectPublicKey;
            return {
              type: "ec",
              data: ndata
            };
          case "1.2.840.10040.4.1":
            ndata.algorithm.params.pub_key = asn12.DSAparam.decode(ndata.subjectPublicKey.data, "der");
            return {
              type: "dsa",
              data: ndata.algorithm.params
            };
          default:
            throw new Error("unknown key id " + subtype);
        }
      case "ENCRYPTED PRIVATE KEY":
        data2 = asn12.EncryptedPrivateKey.decode(data2, "der");
        data2 = decrypt(data2, password);
      case "PRIVATE KEY":
        ndata = asn12.PrivateKey.decode(data2, "der");
        subtype = ndata.algorithm.algorithm.join(".");
        switch (subtype) {
          case "1.2.840.113549.1.1.1":
            return asn12.RSAPrivateKey.decode(ndata.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return {
              curve: ndata.algorithm.curve,
              privateKey: asn12.ECPrivateKey.decode(ndata.subjectPrivateKey, "der").privateKey
            };
          case "1.2.840.10040.4.1":
            ndata.algorithm.params.priv_key = asn12.DSAparam.decode(ndata.subjectPrivateKey, "der");
            return {
              type: "dsa",
              params: ndata.algorithm.params
            };
          default:
            throw new Error("unknown key id " + subtype);
        }
      case "RSA PUBLIC KEY":
        return asn12.RSAPublicKey.decode(data2, "der");
      case "RSA PRIVATE KEY":
        return asn12.RSAPrivateKey.decode(data2, "der");
      case "DSA PRIVATE KEY":
        return {
          type: "dsa",
          params: asn12.DSAPrivateKey.decode(data2, "der")
        };
      case "EC PRIVATE KEY":
        data2 = asn12.ECPrivateKey.decode(data2, "der");
        return {
          curve: data2.parameters.value,
          privateKey: data2.privateKey
        };
      default:
        throw new Error("unknown key type " + type2);
    }
  }
  parseKeys.signature = asn12.signature;
  parseAsn1 = parseKeys;
  return parseAsn1;
}
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign.exports;
  hasRequiredSign = 1;
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var createHmac = requireBrowser$8();
  var crt = requireBrowserifyRsa();
  var EC = requireElliptic().ec;
  var BN2 = requireBn();
  var parseKeys = requireParseAsn1();
  var curves2 = require$$4;
  var RSA_PKCS1_PADDING = 1;
  function sign$12(hash3, key2, hashType, signType, tag) {
    var priv2 = parseKeys(key2);
    if (priv2.curve) {
      if (signType !== "ecdsa" && signType !== "ecdsa/rsa") {
        throw new Error("wrong private key type");
      }
      return ecSign(hash3, priv2);
    } else if (priv2.type === "dsa") {
      if (signType !== "dsa") {
        throw new Error("wrong private key type");
      }
      return dsaSign(hash3, priv2, hashType);
    }
    if (signType !== "rsa" && signType !== "ecdsa/rsa") {
      throw new Error("wrong private key type");
    }
    if (key2.padding !== void 0 && key2.padding !== RSA_PKCS1_PADDING) {
      throw new Error("illegal or unsupported padding mode");
    }
    hash3 = Buffer2.concat([tag, hash3]);
    var len2 = priv2.modulus.byteLength();
    var pad3 = [0, 1];
    while (hash3.length + pad3.length + 1 < len2) {
      pad3.push(255);
    }
    pad3.push(0);
    var i4 = -1;
    while (++i4 < hash3.length) {
      pad3.push(hash3[i4]);
    }
    var out = crt(pad3, priv2);
    return out;
  }
  function ecSign(hash3, priv2) {
    var curveId = curves2[priv2.curve.join(".")];
    if (!curveId) {
      throw new Error("unknown curve " + priv2.curve.join("."));
    }
    var curve2 = new EC(curveId);
    var key2 = curve2.keyFromPrivate(priv2.privateKey);
    var out = key2.sign(hash3);
    return Buffer2.from(out.toDER());
  }
  function dsaSign(hash3, priv2, algo) {
    var x2 = priv2.params.priv_key;
    var p2 = priv2.params.p;
    var q2 = priv2.params.q;
    var g2 = priv2.params.g;
    var r3 = new BN2(0);
    var k3;
    var H3 = bits2int(hash3, q2).mod(q2);
    var s2 = false;
    var kv = getKey(x2, q2, hash3, algo);
    while (s2 === false) {
      k3 = makeKey(q2, kv, algo);
      r3 = makeR(g2, k3, p2, q2);
      s2 = k3.invm(q2).imul(H3.add(x2.mul(r3))).mod(q2);
      if (s2.cmpn(0) === 0) {
        s2 = false;
        r3 = new BN2(0);
      }
    }
    return toDER2(r3, s2);
  }
  function toDER2(r3, s2) {
    r3 = r3.toArray();
    s2 = s2.toArray();
    if (r3[0] & 128) {
      r3 = [0].concat(r3);
    }
    if (s2[0] & 128) {
      s2 = [0].concat(s2);
    }
    var total = r3.length + s2.length + 4;
    var res = [
      48,
      total,
      2,
      r3.length
    ];
    res = res.concat(r3, [2, s2.length], s2);
    return Buffer2.from(res);
  }
  function getKey(x2, q2, hash3, algo) {
    x2 = Buffer2.from(x2.toArray());
    if (x2.length < q2.byteLength()) {
      var zeros2 = Buffer2.alloc(q2.byteLength() - x2.length);
      x2 = Buffer2.concat([zeros2, x2]);
    }
    var hlen = hash3.length;
    var hbits = bits2octets(hash3, q2);
    var v2 = Buffer2.alloc(hlen);
    v2.fill(1);
    var k3 = Buffer2.alloc(hlen);
    k3 = createHmac(algo, k3).update(v2).update(Buffer2.from([0])).update(x2).update(hbits).digest();
    v2 = createHmac(algo, k3).update(v2).digest();
    k3 = createHmac(algo, k3).update(v2).update(Buffer2.from([1])).update(x2).update(hbits).digest();
    v2 = createHmac(algo, k3).update(v2).digest();
    return { k: k3, v: v2 };
  }
  function bits2int(obits, q2) {
    var bits = new BN2(obits);
    var shift = (obits.length << 3) - q2.bitLength();
    if (shift > 0) {
      bits.ishrn(shift);
    }
    return bits;
  }
  function bits2octets(bits, q2) {
    bits = bits2int(bits, q2);
    bits = bits.mod(q2);
    var out = Buffer2.from(bits.toArray());
    if (out.length < q2.byteLength()) {
      var zeros2 = Buffer2.alloc(q2.byteLength() - out.length);
      out = Buffer2.concat([zeros2, out]);
    }
    return out;
  }
  function makeKey(q2, kv, algo) {
    var t2;
    var k3;
    do {
      t2 = Buffer2.alloc(0);
      while (t2.length * 8 < q2.bitLength()) {
        kv.v = createHmac(algo, kv.k).update(kv.v).digest();
        t2 = Buffer2.concat([t2, kv.v]);
      }
      k3 = bits2int(t2, q2);
      kv.k = createHmac(algo, kv.k).update(kv.v).update(Buffer2.from([0])).digest();
      kv.v = createHmac(algo, kv.k).update(kv.v).digest();
    } while (k3.cmp(q2) !== -1);
    return k3;
  }
  function makeR(g2, k3, p2, q2) {
    return g2.toRed(BN2.mont(p2)).redPow(k3).fromRed().mod(q2);
  }
  sign.exports = sign$12;
  sign.exports.getKey = getKey;
  sign.exports.makeKey = makeKey;
  return sign.exports;
}
var verify_1;
var hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify) return verify_1;
  hasRequiredVerify = 1;
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var BN2 = requireBn();
  var EC = requireElliptic().ec;
  var parseKeys = requireParseAsn1();
  var curves2 = require$$4;
  function verify4(sig, hash3, key2, signType, tag) {
    var pub2 = parseKeys(key2);
    if (pub2.type === "ec") {
      if (signType !== "ecdsa" && signType !== "ecdsa/rsa") {
        throw new Error("wrong public key type");
      }
      return ecVerify(sig, hash3, pub2);
    } else if (pub2.type === "dsa") {
      if (signType !== "dsa") {
        throw new Error("wrong public key type");
      }
      return dsaVerify(sig, hash3, pub2);
    }
    if (signType !== "rsa" && signType !== "ecdsa/rsa") {
      throw new Error("wrong public key type");
    }
    hash3 = Buffer2.concat([tag, hash3]);
    var len2 = pub2.modulus.byteLength();
    var pad3 = [1];
    var padNum = 0;
    while (hash3.length + pad3.length + 2 < len2) {
      pad3.push(255);
      padNum += 1;
    }
    pad3.push(0);
    var i4 = -1;
    while (++i4 < hash3.length) {
      pad3.push(hash3[i4]);
    }
    pad3 = Buffer2.from(pad3);
    var red = BN2.mont(pub2.modulus);
    sig = new BN2(sig).toRed(red);
    sig = sig.redPow(new BN2(pub2.publicExponent));
    sig = Buffer2.from(sig.fromRed().toArray());
    var out = padNum < 8 ? 1 : 0;
    len2 = Math.min(sig.length, pad3.length);
    if (sig.length !== pad3.length) {
      out = 1;
    }
    i4 = -1;
    while (++i4 < len2) {
      out |= sig[i4] ^ pad3[i4];
    }
    return out === 0;
  }
  function ecVerify(sig, hash3, pub2) {
    var curveId = curves2[pub2.data.algorithm.curve.join(".")];
    if (!curveId) {
      throw new Error("unknown curve " + pub2.data.algorithm.curve.join("."));
    }
    var curve2 = new EC(curveId);
    var pubkey = pub2.data.subjectPrivateKey.data;
    return curve2.verify(hash3, sig, pubkey);
  }
  function dsaVerify(sig, hash3, pub2) {
    var p2 = pub2.data.p;
    var q2 = pub2.data.q;
    var g2 = pub2.data.g;
    var y4 = pub2.data.pub_key;
    var unpacked = parseKeys.signature.decode(sig, "der");
    var s2 = unpacked.s;
    var r3 = unpacked.r;
    checkValue2(s2, q2);
    checkValue2(r3, q2);
    var montp = BN2.mont(p2);
    var w2 = s2.invm(q2);
    var v2 = g2.toRed(montp).redPow(new BN2(hash3).mul(w2).mod(q2)).fromRed().mul(y4.toRed(montp).redPow(r3.mul(w2).mod(q2)).fromRed()).mod(p2).mod(q2);
    return v2.cmp(r3) === 0;
  }
  function checkValue2(b2, q2) {
    if (b2.cmpn(0) <= 0) {
      throw new Error("invalid sig");
    }
    if (b2.cmp(q2) >= 0) {
      throw new Error("invalid sig");
    }
  }
  verify_1 = verify4;
  return verify_1;
}
var browser$4;
var hasRequiredBrowser$3;
function requireBrowser$3() {
  if (hasRequiredBrowser$3) return browser$4;
  hasRequiredBrowser$3 = 1;
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var createHash2 = requireBrowser$9();
  var stream = requireReadableBrowser();
  var inherits2 = inherits_browserExports;
  var sign5 = requireSign();
  var verify4 = requireVerify();
  var algorithms = require$$6;
  Object.keys(algorithms).forEach(function(key2) {
    algorithms[key2].id = Buffer2.from(algorithms[key2].id, "hex");
    algorithms[key2.toLowerCase()] = algorithms[key2];
  });
  function Sign(algorithm) {
    stream.Writable.call(this);
    var data2 = algorithms[algorithm];
    if (!data2) {
      throw new Error("Unknown message digest");
    }
    this._hashType = data2.hash;
    this._hash = createHash2(data2.hash);
    this._tag = data2.id;
    this._signType = data2.sign;
  }
  inherits2(Sign, stream.Writable);
  Sign.prototype._write = function _write(data2, _3, done) {
    this._hash.update(data2);
    done();
  };
  Sign.prototype.update = function update5(data2, enc) {
    this._hash.update(typeof data2 === "string" ? Buffer2.from(data2, enc) : data2);
    return this;
  };
  Sign.prototype.sign = function signMethod(key2, enc) {
    this.end();
    var hash3 = this._hash.digest();
    var sig = sign5(hash3, key2, this._hashType, this._signType, this._tag);
    return enc ? sig.toString(enc) : sig;
  };
  function Verify(algorithm) {
    stream.Writable.call(this);
    var data2 = algorithms[algorithm];
    if (!data2) {
      throw new Error("Unknown message digest");
    }
    this._hash = createHash2(data2.hash);
    this._tag = data2.id;
    this._signType = data2.sign;
  }
  inherits2(Verify, stream.Writable);
  Verify.prototype._write = function _write(data2, _3, done) {
    this._hash.update(data2);
    done();
  };
  Verify.prototype.update = function update5(data2, enc) {
    this._hash.update(typeof data2 === "string" ? Buffer2.from(data2, enc) : data2);
    return this;
  };
  Verify.prototype.verify = function verifyMethod(key2, sig, enc) {
    var sigBuffer = typeof sig === "string" ? Buffer2.from(sig, enc) : sig;
    this.end();
    var hash3 = this._hash.digest();
    return verify4(sigBuffer, hash3, key2, this._signType, this._tag);
  };
  function createSign(algorithm) {
    return new Sign(algorithm);
  }
  function createVerify(algorithm) {
    return new Verify(algorithm);
  }
  browser$4 = {
    Sign: createSign,
    Verify: createVerify,
    createSign,
    createVerify
  };
  return browser$4;
}
var elliptic = {};
const version$3 = "6.5.4";
const require$$0 = {
  version: version$3
};
var utils$m = {};
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils$m;
  hasRequiredUtils = 1;
  (function(exports2) {
    var utils2 = exports2;
    var BN2 = bnExports;
    var minAssert = minimalisticAssert;
    var minUtils = utils$o;
    utils2.assert = minAssert;
    utils2.toArray = minUtils.toArray;
    utils2.zero2 = minUtils.zero2;
    utils2.toHex = minUtils.toHex;
    utils2.encode = minUtils.encode;
    function getNAF2(num, w2, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      naf.fill(0);
      var ws2 = 1 << w2 + 1;
      var k3 = num.clone();
      for (var i4 = 0; i4 < naf.length; i4++) {
        var z3;
        var mod2 = k3.andln(ws2 - 1);
        if (k3.isOdd()) {
          if (mod2 > (ws2 >> 1) - 1)
            z3 = (ws2 >> 1) - mod2;
          else
            z3 = mod2;
          k3.isubn(z3);
        } else {
          z3 = 0;
        }
        naf[i4] = z3;
        k3.iushrn(1);
      }
      return naf;
    }
    utils2.getNAF = getNAF2;
    function getJSF2(k1, k22) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k22 = k22.clone();
      var d1 = 0;
      var d22 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k22.cmpn(-d22) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k22.andln(3) + d22 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u2;
        if ((m24 & 1) === 0) {
          u2 = 0;
        } else {
          m8 = k22.andln(7) + d22 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u2 = -m24;
          else
            u2 = m24;
        }
        jsf[1].push(u2);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d22 === u2 + 1)
          d22 = 1 - d22;
        k1.iushrn(1);
        k22.iushrn(1);
      }
      return jsf;
    }
    utils2.getJSF = getJSF2;
    function cachedProperty2(obj, name, computer) {
      var key2 = "_" + name;
      obj.prototype[name] = function cachedProperty3() {
        return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
      };
    }
    utils2.cachedProperty = cachedProperty2;
    function parseBytes2(bytes2) {
      return typeof bytes2 === "string" ? utils2.toArray(bytes2, "hex") : bytes2;
    }
    utils2.parseBytes = parseBytes2;
    function intFromLE(bytes2) {
      return new BN2(bytes2, "hex", "le");
    }
    utils2.intFromLE = intFromLE;
  })(utils$m);
  return utils$m;
}
var curve$1 = {};
var base$2;
var hasRequiredBase;
function requireBase() {
  if (hasRequiredBase) return base$2;
  hasRequiredBase = 1;
  var BN2 = bnExports;
  var utils2 = requireUtils();
  var getNAF2 = utils2.getNAF;
  var getJSF2 = utils2.getJSF;
  var assert2 = utils2.assert;
  function BaseCurve2(type2, conf) {
    this.type = type2;
    this.p = new BN2(conf.p, 16);
    this.red = conf.prime ? BN2.red(conf.prime) : BN2.mont(this.p);
    this.zero = new BN2(0).toRed(this.red);
    this.one = new BN2(1).toRed(this.red);
    this.two = new BN2(2).toRed(this.red);
    this.n = conf.n && new BN2(conf.n, 16);
    this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
    this._wnafT1 = new Array(4);
    this._wnafT2 = new Array(4);
    this._wnafT3 = new Array(4);
    this._wnafT4 = new Array(4);
    this._bitLength = this.n ? this.n.bitLength() : 0;
    var adjustCount = this.n && this.p.div(this.n);
    if (!adjustCount || adjustCount.cmpn(100) > 0) {
      this.redN = null;
    } else {
      this._maxwellTrick = true;
      this.redN = this.n.toRed(this.red);
    }
  }
  base$2 = BaseCurve2;
  BaseCurve2.prototype.point = function point5() {
    throw new Error("Not implemented");
  };
  BaseCurve2.prototype.validate = function validate7() {
    throw new Error("Not implemented");
  };
  BaseCurve2.prototype._fixedNafMul = function _fixedNafMul2(p2, k3) {
    assert2(p2.precomputed);
    var doubles = p2._getDoubles();
    var naf = getNAF2(k3, 1, this._bitLength);
    var I4 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
    I4 /= 3;
    var repr = [];
    var j2;
    var nafW;
    for (j2 = 0; j2 < naf.length; j2 += doubles.step) {
      nafW = 0;
      for (var l2 = j2 + doubles.step - 1; l2 >= j2; l2--)
        nafW = (nafW << 1) + naf[l2];
      repr.push(nafW);
    }
    var a2 = this.jpoint(null, null, null);
    var b2 = this.jpoint(null, null, null);
    for (var i4 = I4; i4 > 0; i4--) {
      for (j2 = 0; j2 < repr.length; j2++) {
        nafW = repr[j2];
        if (nafW === i4)
          b2 = b2.mixedAdd(doubles.points[j2]);
        else if (nafW === -i4)
          b2 = b2.mixedAdd(doubles.points[j2].neg());
      }
      a2 = a2.add(b2);
    }
    return a2.toP();
  };
  BaseCurve2.prototype._wnafMul = function _wnafMul2(p2, k3) {
    var w2 = 4;
    var nafPoints = p2._getNAFPoints(w2);
    w2 = nafPoints.wnd;
    var wnd = nafPoints.points;
    var naf = getNAF2(k3, w2, this._bitLength);
    var acc = this.jpoint(null, null, null);
    for (var i4 = naf.length - 1; i4 >= 0; i4--) {
      for (var l2 = 0; i4 >= 0 && naf[i4] === 0; i4--)
        l2++;
      if (i4 >= 0)
        l2++;
      acc = acc.dblp(l2);
      if (i4 < 0)
        break;
      var z3 = naf[i4];
      assert2(z3 !== 0);
      if (p2.type === "affine") {
        if (z3 > 0)
          acc = acc.mixedAdd(wnd[z3 - 1 >> 1]);
        else
          acc = acc.mixedAdd(wnd[-z3 - 1 >> 1].neg());
      } else {
        if (z3 > 0)
          acc = acc.add(wnd[z3 - 1 >> 1]);
        else
          acc = acc.add(wnd[-z3 - 1 >> 1].neg());
      }
    }
    return p2.type === "affine" ? acc.toP() : acc;
  };
  BaseCurve2.prototype._wnafMulAdd = function _wnafMulAdd2(defW, points, coeffs, len2, jacobianResult) {
    var wndWidth = this._wnafT1;
    var wnd = this._wnafT2;
    var naf = this._wnafT3;
    var max2 = 0;
    var i4;
    var j2;
    var p2;
    for (i4 = 0; i4 < len2; i4++) {
      p2 = points[i4];
      var nafPoints = p2._getNAFPoints(defW);
      wndWidth[i4] = nafPoints.wnd;
      wnd[i4] = nafPoints.points;
    }
    for (i4 = len2 - 1; i4 >= 1; i4 -= 2) {
      var a2 = i4 - 1;
      var b2 = i4;
      if (wndWidth[a2] !== 1 || wndWidth[b2] !== 1) {
        naf[a2] = getNAF2(coeffs[a2], wndWidth[a2], this._bitLength);
        naf[b2] = getNAF2(coeffs[b2], wndWidth[b2], this._bitLength);
        max2 = Math.max(naf[a2].length, max2);
        max2 = Math.max(naf[b2].length, max2);
        continue;
      }
      var comb = [
        points[a2],
        /* 1 */
        null,
        /* 3 */
        null,
        /* 5 */
        points[b2]
        /* 7 */
      ];
      if (points[a2].y.cmp(points[b2].y) === 0) {
        comb[1] = points[a2].add(points[b2]);
        comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
      } else if (points[a2].y.cmp(points[b2].y.redNeg()) === 0) {
        comb[1] = points[a2].toJ().mixedAdd(points[b2]);
        comb[2] = points[a2].add(points[b2].neg());
      } else {
        comb[1] = points[a2].toJ().mixedAdd(points[b2]);
        comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
      }
      var index2 = [
        -3,
        /* -1 -1 */
        -1,
        /* -1 0 */
        -5,
        /* -1 1 */
        -7,
        /* 0 -1 */
        0,
        /* 0 0 */
        7,
        /* 0 1 */
        5,
        /* 1 -1 */
        1,
        /* 1 0 */
        3
        /* 1 1 */
      ];
      var jsf = getJSF2(coeffs[a2], coeffs[b2]);
      max2 = Math.max(jsf[0].length, max2);
      naf[a2] = new Array(max2);
      naf[b2] = new Array(max2);
      for (j2 = 0; j2 < max2; j2++) {
        var ja2 = jsf[0][j2] | 0;
        var jb = jsf[1][j2] | 0;
        naf[a2][j2] = index2[(ja2 + 1) * 3 + (jb + 1)];
        naf[b2][j2] = 0;
        wnd[a2] = comb;
      }
    }
    var acc = this.jpoint(null, null, null);
    var tmp = this._wnafT4;
    for (i4 = max2; i4 >= 0; i4--) {
      var k3 = 0;
      while (i4 >= 0) {
        var zero = true;
        for (j2 = 0; j2 < len2; j2++) {
          tmp[j2] = naf[j2][i4] | 0;
          if (tmp[j2] !== 0)
            zero = false;
        }
        if (!zero)
          break;
        k3++;
        i4--;
      }
      if (i4 >= 0)
        k3++;
      acc = acc.dblp(k3);
      if (i4 < 0)
        break;
      for (j2 = 0; j2 < len2; j2++) {
        var z3 = tmp[j2];
        if (z3 === 0)
          continue;
        else if (z3 > 0)
          p2 = wnd[j2][z3 - 1 >> 1];
        else if (z3 < 0)
          p2 = wnd[j2][-z3 - 1 >> 1].neg();
        if (p2.type === "affine")
          acc = acc.mixedAdd(p2);
        else
          acc = acc.add(p2);
      }
    }
    for (i4 = 0; i4 < len2; i4++)
      wnd[i4] = null;
    if (jacobianResult)
      return acc;
    else
      return acc.toP();
  };
  function BasePoint2(curve2, type2) {
    this.curve = curve2;
    this.type = type2;
    this.precomputed = null;
  }
  BaseCurve2.BasePoint = BasePoint2;
  BasePoint2.prototype.eq = function eq6() {
    throw new Error("Not implemented");
  };
  BasePoint2.prototype.validate = function validate7() {
    return this.curve.validate(this);
  };
  BaseCurve2.prototype.decodePoint = function decodePoint4(bytes2, enc) {
    bytes2 = utils2.toArray(bytes2, enc);
    var len2 = this.p.byteLength();
    if ((bytes2[0] === 4 || bytes2[0] === 6 || bytes2[0] === 7) && bytes2.length - 1 === 2 * len2) {
      if (bytes2[0] === 6)
        assert2(bytes2[bytes2.length - 1] % 2 === 0);
      else if (bytes2[0] === 7)
        assert2(bytes2[bytes2.length - 1] % 2 === 1);
      var res = this.point(
        bytes2.slice(1, 1 + len2),
        bytes2.slice(1 + len2, 1 + 2 * len2)
      );
      return res;
    } else if ((bytes2[0] === 2 || bytes2[0] === 3) && bytes2.length - 1 === len2) {
      return this.pointFromX(bytes2.slice(1, 1 + len2), bytes2[0] === 3);
    }
    throw new Error("Unknown point format");
  };
  BasePoint2.prototype.encodeCompressed = function encodeCompressed2(enc) {
    return this.encode(enc, true);
  };
  BasePoint2.prototype._encode = function _encode4(compact) {
    var len2 = this.curve.p.byteLength();
    var x2 = this.getX().toArray("be", len2);
    if (compact)
      return [this.getY().isEven() ? 2 : 3].concat(x2);
    return [4].concat(x2, this.getY().toArray("be", len2));
  };
  BasePoint2.prototype.encode = function encode4(enc, compact) {
    return utils2.encode(this._encode(compact), enc);
  };
  BasePoint2.prototype.precompute = function precompute3(power) {
    if (this.precomputed)
      return this;
    var precomputed = {
      doubles: null,
      naf: null,
      beta: null
    };
    precomputed.naf = this._getNAFPoints(8);
    precomputed.doubles = this._getDoubles(4, power);
    precomputed.beta = this._getBeta();
    this.precomputed = precomputed;
    return this;
  };
  BasePoint2.prototype._hasDoubles = function _hasDoubles2(k3) {
    if (!this.precomputed)
      return false;
    var doubles = this.precomputed.doubles;
    if (!doubles)
      return false;
    return doubles.points.length >= Math.ceil((k3.bitLength() + 1) / doubles.step);
  };
  BasePoint2.prototype._getDoubles = function _getDoubles2(step, power) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    var doubles = [this];
    var acc = this;
    for (var i4 = 0; i4 < power; i4 += step) {
      for (var j2 = 0; j2 < step; j2++)
        acc = acc.dbl();
      doubles.push(acc);
    }
    return {
      step,
      points: doubles
    };
  };
  BasePoint2.prototype._getNAFPoints = function _getNAFPoints2(wnd) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    var res = [this];
    var max2 = (1 << wnd) - 1;
    var dbl5 = max2 === 1 ? null : this.dbl();
    for (var i4 = 1; i4 < max2; i4++)
      res[i4] = res[i4 - 1].add(dbl5);
    return {
      wnd,
      points: res
    };
  };
  BasePoint2.prototype._getBeta = function _getBeta3() {
    return null;
  };
  BasePoint2.prototype.dblp = function dblp3(k3) {
    var r3 = this;
    for (var i4 = 0; i4 < k3; i4++)
      r3 = r3.dbl();
    return r3;
  };
  return base$2;
}
var short$1;
var hasRequiredShort;
function requireShort() {
  if (hasRequiredShort) return short$1;
  hasRequiredShort = 1;
  var utils2 = requireUtils();
  var BN2 = bnExports;
  var inherits2 = inherits_browserExports;
  var Base2 = requireBase();
  var assert2 = utils2.assert;
  function ShortCurve2(conf) {
    Base2.call(this, "short", conf);
    this.a = new BN2(conf.a, 16).toRed(this.red);
    this.b = new BN2(conf.b, 16).toRed(this.red);
    this.tinv = this.two.redInvm();
    this.zeroA = this.a.fromRed().cmpn(0) === 0;
    this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
    this.endo = this._getEndomorphism(conf);
    this._endoWnafT1 = new Array(4);
    this._endoWnafT2 = new Array(4);
  }
  inherits2(ShortCurve2, Base2);
  short$1 = ShortCurve2;
  ShortCurve2.prototype._getEndomorphism = function _getEndomorphism2(conf) {
    if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
      return;
    var beta;
    var lambda;
    if (conf.beta) {
      beta = new BN2(conf.beta, 16).toRed(this.red);
    } else {
      var betas = this._getEndoRoots(this.p);
      beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
      beta = beta.toRed(this.red);
    }
    if (conf.lambda) {
      lambda = new BN2(conf.lambda, 16);
    } else {
      var lambdas = this._getEndoRoots(this.n);
      if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
        lambda = lambdas[0];
      } else {
        lambda = lambdas[1];
        assert2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
      }
    }
    var basis;
    if (conf.basis) {
      basis = conf.basis.map(function(vec) {
        return {
          a: new BN2(vec.a, 16),
          b: new BN2(vec.b, 16)
        };
      });
    } else {
      basis = this._getEndoBasis(lambda);
    }
    return {
      beta,
      lambda,
      basis
    };
  };
  ShortCurve2.prototype._getEndoRoots = function _getEndoRoots2(num) {
    var red = num === this.p ? this.red : BN2.mont(num);
    var tinv = new BN2(2).toRed(red).redInvm();
    var ntinv = tinv.redNeg();
    var s2 = new BN2(3).toRed(red).redNeg().redSqrt().redMul(tinv);
    var l1 = ntinv.redAdd(s2).fromRed();
    var l2 = ntinv.redSub(s2).fromRed();
    return [l1, l2];
  };
  ShortCurve2.prototype._getEndoBasis = function _getEndoBasis2(lambda) {
    var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
    var u2 = lambda;
    var v2 = this.n.clone();
    var x1 = new BN2(1);
    var y1 = new BN2(0);
    var x2 = new BN2(0);
    var y22 = new BN2(1);
    var a0;
    var b0;
    var a1;
    var b1;
    var a2;
    var b2;
    var prevR;
    var i4 = 0;
    var r3;
    var x3;
    while (u2.cmpn(0) !== 0) {
      var q2 = v2.div(u2);
      r3 = v2.sub(q2.mul(u2));
      x3 = x2.sub(q2.mul(x1));
      var y4 = y22.sub(q2.mul(y1));
      if (!a1 && r3.cmp(aprxSqrt) < 0) {
        a0 = prevR.neg();
        b0 = x1;
        a1 = r3.neg();
        b1 = x3;
      } else if (a1 && ++i4 === 2) {
        break;
      }
      prevR = r3;
      v2 = u2;
      u2 = r3;
      x2 = x1;
      x1 = x3;
      y22 = y1;
      y1 = y4;
    }
    a2 = r3.neg();
    b2 = x3;
    var len1 = a1.sqr().add(b1.sqr());
    var len2 = a2.sqr().add(b2.sqr());
    if (len2.cmp(len1) >= 0) {
      a2 = a0;
      b2 = b0;
    }
    if (a1.negative) {
      a1 = a1.neg();
      b1 = b1.neg();
    }
    if (a2.negative) {
      a2 = a2.neg();
      b2 = b2.neg();
    }
    return [
      { a: a1, b: b1 },
      { a: a2, b: b2 }
    ];
  };
  ShortCurve2.prototype._endoSplit = function _endoSplit2(k3) {
    var basis = this.endo.basis;
    var v1 = basis[0];
    var v2 = basis[1];
    var c1 = v2.b.mul(k3).divRound(this.n);
    var c2 = v1.b.neg().mul(k3).divRound(this.n);
    var p1 = c1.mul(v1.a);
    var p2 = c2.mul(v2.a);
    var q1 = c1.mul(v1.b);
    var q2 = c2.mul(v2.b);
    var k1 = k3.sub(p1).sub(p2);
    var k22 = q1.add(q2).neg();
    return { k1, k2: k22 };
  };
  ShortCurve2.prototype.pointFromX = function pointFromX3(x2, odd) {
    x2 = new BN2(x2, 16);
    if (!x2.red)
      x2 = x2.toRed(this.red);
    var y22 = x2.redSqr().redMul(x2).redIAdd(x2.redMul(this.a)).redIAdd(this.b);
    var y4 = y22.redSqrt();
    if (y4.redSqr().redSub(y22).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var isOdd = y4.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd)
      y4 = y4.redNeg();
    return this.point(x2, y4);
  };
  ShortCurve2.prototype.validate = function validate7(point5) {
    if (point5.inf)
      return true;
    var x2 = point5.x;
    var y4 = point5.y;
    var ax = this.a.redMul(x2);
    var rhs = x2.redSqr().redMul(x2).redIAdd(ax).redIAdd(this.b);
    return y4.redSqr().redISub(rhs).cmpn(0) === 0;
  };
  ShortCurve2.prototype._endoWnafMulAdd = function _endoWnafMulAdd2(points, coeffs, jacobianResult) {
    var npoints = this._endoWnafT1;
    var ncoeffs = this._endoWnafT2;
    for (var i4 = 0; i4 < points.length; i4++) {
      var split2 = this._endoSplit(coeffs[i4]);
      var p2 = points[i4];
      var beta = p2._getBeta();
      if (split2.k1.negative) {
        split2.k1.ineg();
        p2 = p2.neg(true);
      }
      if (split2.k2.negative) {
        split2.k2.ineg();
        beta = beta.neg(true);
      }
      npoints[i4 * 2] = p2;
      npoints[i4 * 2 + 1] = beta;
      ncoeffs[i4 * 2] = split2.k1;
      ncoeffs[i4 * 2 + 1] = split2.k2;
    }
    var res = this._wnafMulAdd(1, npoints, ncoeffs, i4 * 2, jacobianResult);
    for (var j2 = 0; j2 < i4 * 2; j2++) {
      npoints[j2] = null;
      ncoeffs[j2] = null;
    }
    return res;
  };
  function Point2(curve2, x2, y4, isRed) {
    Base2.BasePoint.call(this, curve2, "affine");
    if (x2 === null && y4 === null) {
      this.x = null;
      this.y = null;
      this.inf = true;
    } else {
      this.x = new BN2(x2, 16);
      this.y = new BN2(y4, 16);
      if (isRed) {
        this.x.forceRed(this.curve.red);
        this.y.forceRed(this.curve.red);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      this.inf = false;
    }
  }
  inherits2(Point2, Base2.BasePoint);
  ShortCurve2.prototype.point = function point5(x2, y4, isRed) {
    return new Point2(this, x2, y4, isRed);
  };
  ShortCurve2.prototype.pointFromJSON = function pointFromJSON4(obj, red) {
    return Point2.fromJSON(this, obj, red);
  };
  Point2.prototype._getBeta = function _getBeta3() {
    if (!this.curve.endo)
      return;
    var pre = this.precomputed;
    if (pre && pre.beta)
      return pre.beta;
    var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (pre) {
      var curve2 = this.curve;
      var endoMul = function(p2) {
        return curve2.point(p2.x.redMul(curve2.endo.beta), p2.y);
      };
      pre.beta = beta;
      beta.precomputed = {
        beta: null,
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(endoMul)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(endoMul)
        }
      };
    }
    return beta;
  };
  Point2.prototype.toJSON = function toJSON2() {
    if (!this.precomputed)
      return [this.x, this.y];
    return [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }];
  };
  Point2.fromJSON = function fromJSON4(curve2, obj, red) {
    if (typeof obj === "string")
      obj = JSON.parse(obj);
    var res = curve2.point(obj[0], obj[1], red);
    if (!obj[2])
      return res;
    function obj2point(obj2) {
      return curve2.point(obj2[0], obj2[1], red);
    }
    var pre = obj[2];
    res.precomputed = {
      beta: null,
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: [res].concat(pre.doubles.points.map(obj2point))
      },
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: [res].concat(pre.naf.points.map(obj2point))
      }
    };
    return res;
  };
  Point2.prototype.inspect = function inspect6() {
    if (this.isInfinity())
      return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  };
  Point2.prototype.isInfinity = function isInfinity5() {
    return this.inf;
  };
  Point2.prototype.add = function add6(p2) {
    if (this.inf)
      return p2;
    if (p2.inf)
      return this;
    if (this.eq(p2))
      return this.dbl();
    if (this.neg().eq(p2))
      return this.curve.point(null, null);
    if (this.x.cmp(p2.x) === 0)
      return this.curve.point(null, null);
    var c2 = this.y.redSub(p2.y);
    if (c2.cmpn(0) !== 0)
      c2 = c2.redMul(this.x.redSub(p2.x).redInvm());
    var nx = c2.redSqr().redISub(this.x).redISub(p2.x);
    var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };
  Point2.prototype.dbl = function dbl5() {
    if (this.inf)
      return this;
    var ys1 = this.y.redAdd(this.y);
    if (ys1.cmpn(0) === 0)
      return this.curve.point(null, null);
    var a2 = this.curve.a;
    var x2 = this.x.redSqr();
    var dyinv = ys1.redInvm();
    var c2 = x2.redAdd(x2).redIAdd(x2).redIAdd(a2).redMul(dyinv);
    var nx = c2.redSqr().redISub(this.x.redAdd(this.x));
    var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };
  Point2.prototype.getX = function getX4() {
    return this.x.fromRed();
  };
  Point2.prototype.getY = function getY3() {
    return this.y.fromRed();
  };
  Point2.prototype.mul = function mul6(k3) {
    k3 = new BN2(k3, 16);
    if (this.isInfinity())
      return this;
    else if (this._hasDoubles(k3))
      return this.curve._fixedNafMul(this, k3);
    else if (this.curve.endo)
      return this.curve._endoWnafMulAdd([this], [k3]);
    else
      return this.curve._wnafMul(this, k3);
  };
  Point2.prototype.mulAdd = function mulAdd4(k1, p2, k22) {
    var points = [this, p2];
    var coeffs = [k1, k22];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2);
  };
  Point2.prototype.jmulAdd = function jmulAdd3(k1, p2, k22) {
    var points = [this, p2];
    var coeffs = [k1, k22];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs, true);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
  };
  Point2.prototype.eq = function eq6(p2) {
    return this === p2 || this.inf === p2.inf && (this.inf || this.x.cmp(p2.x) === 0 && this.y.cmp(p2.y) === 0);
  };
  Point2.prototype.neg = function neg4(_precompute) {
    if (this.inf)
      return this;
    var res = this.curve.point(this.x, this.y.redNeg());
    if (_precompute && this.precomputed) {
      var pre = this.precomputed;
      var negate = function(p2) {
        return p2.neg();
      };
      res.precomputed = {
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(negate)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(negate)
        }
      };
    }
    return res;
  };
  Point2.prototype.toJ = function toJ2() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var res = this.curve.jpoint(this.x, this.y, this.curve.one);
    return res;
  };
  function JPoint2(curve2, x2, y4, z3) {
    Base2.BasePoint.call(this, curve2, "jacobian");
    if (x2 === null && y4 === null && z3 === null) {
      this.x = this.curve.one;
      this.y = this.curve.one;
      this.z = new BN2(0);
    } else {
      this.x = new BN2(x2, 16);
      this.y = new BN2(y4, 16);
      this.z = new BN2(z3, 16);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;
  }
  inherits2(JPoint2, Base2.BasePoint);
  ShortCurve2.prototype.jpoint = function jpoint3(x2, y4, z3) {
    return new JPoint2(this, x2, y4, z3);
  };
  JPoint2.prototype.toP = function toP2() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var zinv = this.z.redInvm();
    var zinv2 = zinv.redSqr();
    var ax = this.x.redMul(zinv2);
    var ay = this.y.redMul(zinv2).redMul(zinv);
    return this.curve.point(ax, ay);
  };
  JPoint2.prototype.neg = function neg4() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  };
  JPoint2.prototype.add = function add6(p2) {
    if (this.isInfinity())
      return p2;
    if (p2.isInfinity())
      return this;
    var pz2 = p2.z.redSqr();
    var z22 = this.z.redSqr();
    var u1 = this.x.redMul(pz2);
    var u2 = p2.x.redMul(z22);
    var s1 = this.y.redMul(pz2.redMul(p2.z));
    var s2 = p2.y.redMul(z22.redMul(this.z));
    var h5 = u1.redSub(u2);
    var r3 = s1.redSub(s2);
    if (h5.cmpn(0) === 0) {
      if (r3.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }
    var h22 = h5.redSqr();
    var h32 = h22.redMul(h5);
    var v2 = u1.redMul(h22);
    var nx = r3.redSqr().redIAdd(h32).redISub(v2).redISub(v2);
    var ny = r3.redMul(v2.redISub(nx)).redISub(s1.redMul(h32));
    var nz = this.z.redMul(p2.z).redMul(h5);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint2.prototype.mixedAdd = function mixedAdd2(p2) {
    if (this.isInfinity())
      return p2.toJ();
    if (p2.isInfinity())
      return this;
    var z22 = this.z.redSqr();
    var u1 = this.x;
    var u2 = p2.x.redMul(z22);
    var s1 = this.y;
    var s2 = p2.y.redMul(z22).redMul(this.z);
    var h5 = u1.redSub(u2);
    var r3 = s1.redSub(s2);
    if (h5.cmpn(0) === 0) {
      if (r3.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }
    var h22 = h5.redSqr();
    var h32 = h22.redMul(h5);
    var v2 = u1.redMul(h22);
    var nx = r3.redSqr().redIAdd(h32).redISub(v2).redISub(v2);
    var ny = r3.redMul(v2.redISub(nx)).redISub(s1.redMul(h32));
    var nz = this.z.redMul(h5);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint2.prototype.dblp = function dblp3(pow3) {
    if (pow3 === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!pow3)
      return this.dbl();
    var i4;
    if (this.curve.zeroA || this.curve.threeA) {
      var r3 = this;
      for (i4 = 0; i4 < pow3; i4++)
        r3 = r3.dbl();
      return r3;
    }
    var a2 = this.curve.a;
    var tinv = this.curve.tinv;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jyd = jy.redAdd(jy);
    for (i4 = 0; i4 < pow3; i4++) {
      var jx2 = jx.redSqr();
      var jyd2 = jyd.redSqr();
      var jyd4 = jyd2.redSqr();
      var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
      var t1 = jx.redMul(jyd2);
      var nx = c2.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var dny = c2.redMul(t2);
      dny = dny.redIAdd(dny).redISub(jyd4);
      var nz = jyd.redMul(jz);
      if (i4 + 1 < pow3)
        jz4 = jz4.redMul(jyd4);
      jx = nx;
      jz = nz;
      jyd = dny;
    }
    return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
  };
  JPoint2.prototype.dbl = function dbl5() {
    if (this.isInfinity())
      return this;
    if (this.curve.zeroA)
      return this._zeroDbl();
    else if (this.curve.threeA)
      return this._threeDbl();
    else
      return this._dbl();
  };
  JPoint2.prototype._zeroDbl = function _zeroDbl2() {
    var nx;
    var ny;
    var nz;
    if (this.zOne) {
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var yyyy = yy.redSqr();
      var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s2 = s2.redIAdd(s2);
      var m4 = xx.redAdd(xx).redIAdd(xx);
      var t2 = m4.redSqr().redISub(s2).redISub(s2);
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      nx = t2;
      ny = m4.redMul(s2.redISub(t2)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      var a2 = this.x.redSqr();
      var b2 = this.y.redSqr();
      var c2 = b2.redSqr();
      var d4 = this.x.redAdd(b2).redSqr().redISub(a2).redISub(c2);
      d4 = d4.redIAdd(d4);
      var e3 = a2.redAdd(a2).redIAdd(a2);
      var f6 = e3.redSqr();
      var c8 = c2.redIAdd(c2);
      c8 = c8.redIAdd(c8);
      c8 = c8.redIAdd(c8);
      nx = f6.redISub(d4).redISub(d4);
      ny = e3.redMul(d4.redISub(nx)).redISub(c8);
      nz = this.y.redMul(this.z);
      nz = nz.redIAdd(nz);
    }
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint2.prototype._threeDbl = function _threeDbl2() {
    var nx;
    var ny;
    var nz;
    if (this.zOne) {
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var yyyy = yy.redSqr();
      var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s2 = s2.redIAdd(s2);
      var m4 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
      var t2 = m4.redSqr().redISub(s2).redISub(s2);
      nx = t2;
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      ny = m4.redMul(s2.redISub(t2)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      var delta = this.z.redSqr();
      var gamma = this.y.redSqr();
      var beta = this.x.redMul(gamma);
      var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
      alpha = alpha.redAdd(alpha).redIAdd(alpha);
      var beta4 = beta.redIAdd(beta);
      beta4 = beta4.redIAdd(beta4);
      var beta8 = beta4.redAdd(beta4);
      nx = alpha.redSqr().redISub(beta8);
      nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
      var ggamma8 = gamma.redSqr();
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
    }
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint2.prototype._dbl = function _dbl2() {
    var a2 = this.curve.a;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jx2 = jx.redSqr();
    var jy2 = jy.redSqr();
    var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
    var jxd4 = jx.redAdd(jx);
    jxd4 = jxd4.redIAdd(jxd4);
    var t1 = jxd4.redMul(jy2);
    var nx = c2.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var jyd8 = jy2.redSqr();
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    var ny = c2.redMul(t2).redISub(jyd8);
    var nz = jy.redAdd(jy).redMul(jz);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint2.prototype.trpl = function trpl2() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var zz = this.z.redSqr();
    var yyyy = yy.redSqr();
    var m4 = xx.redAdd(xx).redIAdd(xx);
    var mm = m4.redSqr();
    var e3 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    e3 = e3.redIAdd(e3);
    e3 = e3.redAdd(e3).redIAdd(e3);
    e3 = e3.redISub(mm);
    var ee2 = e3.redSqr();
    var t2 = yyyy.redIAdd(yyyy);
    t2 = t2.redIAdd(t2);
    t2 = t2.redIAdd(t2);
    t2 = t2.redIAdd(t2);
    var u2 = m4.redIAdd(e3).redSqr().redISub(mm).redISub(ee2).redISub(t2);
    var yyu4 = yy.redMul(u2);
    yyu4 = yyu4.redIAdd(yyu4);
    yyu4 = yyu4.redIAdd(yyu4);
    var nx = this.x.redMul(ee2).redISub(yyu4);
    nx = nx.redIAdd(nx);
    nx = nx.redIAdd(nx);
    var ny = this.y.redMul(u2.redMul(t2.redISub(u2)).redISub(e3.redMul(ee2)));
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    var nz = this.z.redAdd(e3).redSqr().redISub(zz).redISub(ee2);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint2.prototype.mul = function mul6(k3, kbase) {
    k3 = new BN2(k3, kbase);
    return this.curve._wnafMul(this, k3);
  };
  JPoint2.prototype.eq = function eq6(p2) {
    if (p2.type === "affine")
      return this.eq(p2.toJ());
    if (this === p2)
      return true;
    var z22 = this.z.redSqr();
    var pz2 = p2.z.redSqr();
    if (this.x.redMul(pz2).redISub(p2.x.redMul(z22)).cmpn(0) !== 0)
      return false;
    var z3 = z22.redMul(this.z);
    var pz3 = pz2.redMul(p2.z);
    return this.y.redMul(pz3).redISub(p2.y.redMul(z3)).cmpn(0) === 0;
  };
  JPoint2.prototype.eqXToP = function eqXToP3(x2) {
    var zs2 = this.z.redSqr();
    var rx = x2.toRed(this.curve.red).redMul(zs2);
    if (this.x.cmp(rx) === 0)
      return true;
    var xc3 = x2.clone();
    var t2 = this.curve.redN.redMul(zs2);
    for (; ; ) {
      xc3.iadd(this.curve.n);
      if (xc3.cmp(this.curve.p) >= 0)
        return false;
      rx.redIAdd(t2);
      if (this.x.cmp(rx) === 0)
        return true;
    }
  };
  JPoint2.prototype.inspect = function inspect6() {
    if (this.isInfinity())
      return "<EC JPoint Infinity>";
    return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  };
  JPoint2.prototype.isInfinity = function isInfinity5() {
    return this.z.cmpn(0) === 0;
  };
  return short$1;
}
var mont$1;
var hasRequiredMont;
function requireMont() {
  if (hasRequiredMont) return mont$1;
  hasRequiredMont = 1;
  var BN2 = bnExports;
  var inherits2 = inherits_browserExports;
  var Base2 = requireBase();
  var utils2 = requireUtils();
  function MontCurve2(conf) {
    Base2.call(this, "mont", conf);
    this.a = new BN2(conf.a, 16).toRed(this.red);
    this.b = new BN2(conf.b, 16).toRed(this.red);
    this.i4 = new BN2(4).toRed(this.red).redInvm();
    this.two = new BN2(2).toRed(this.red);
    this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  inherits2(MontCurve2, Base2);
  mont$1 = MontCurve2;
  MontCurve2.prototype.validate = function validate7(point5) {
    var x2 = point5.normalize().x;
    var x22 = x2.redSqr();
    var rhs = x22.redMul(x2).redAdd(x22.redMul(this.a)).redAdd(x2);
    var y4 = rhs.redSqrt();
    return y4.redSqr().cmp(rhs) === 0;
  };
  function Point2(curve2, x2, z3) {
    Base2.BasePoint.call(this, curve2, "projective");
    if (x2 === null && z3 === null) {
      this.x = this.curve.one;
      this.z = this.curve.zero;
    } else {
      this.x = new BN2(x2, 16);
      this.z = new BN2(z3, 16);
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
    }
  }
  inherits2(Point2, Base2.BasePoint);
  MontCurve2.prototype.decodePoint = function decodePoint4(bytes2, enc) {
    return this.point(utils2.toArray(bytes2, enc), 1);
  };
  MontCurve2.prototype.point = function point5(x2, z3) {
    return new Point2(this, x2, z3);
  };
  MontCurve2.prototype.pointFromJSON = function pointFromJSON4(obj) {
    return Point2.fromJSON(this, obj);
  };
  Point2.prototype.precompute = function precompute3() {
  };
  Point2.prototype._encode = function _encode4() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  };
  Point2.fromJSON = function fromJSON4(curve2, obj) {
    return new Point2(curve2, obj[0], obj[1] || curve2.one);
  };
  Point2.prototype.inspect = function inspect6() {
    if (this.isInfinity())
      return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  Point2.prototype.isInfinity = function isInfinity5() {
    return this.z.cmpn(0) === 0;
  };
  Point2.prototype.dbl = function dbl5() {
    var a2 = this.x.redAdd(this.z);
    var aa2 = a2.redSqr();
    var b2 = this.x.redSub(this.z);
    var bb = b2.redSqr();
    var c2 = aa2.redSub(bb);
    var nx = aa2.redMul(bb);
    var nz = c2.redMul(bb.redAdd(this.curve.a24.redMul(c2)));
    return this.curve.point(nx, nz);
  };
  Point2.prototype.add = function add6() {
    throw new Error("Not supported on Montgomery curve");
  };
  Point2.prototype.diffAdd = function diffAdd2(p2, diff) {
    var a2 = this.x.redAdd(this.z);
    var b2 = this.x.redSub(this.z);
    var c2 = p2.x.redAdd(p2.z);
    var d4 = p2.x.redSub(p2.z);
    var da2 = d4.redMul(a2);
    var cb = c2.redMul(b2);
    var nx = diff.z.redMul(da2.redAdd(cb).redSqr());
    var nz = diff.x.redMul(da2.redISub(cb).redSqr());
    return this.curve.point(nx, nz);
  };
  Point2.prototype.mul = function mul6(k3) {
    var t2 = k3.clone();
    var a2 = this;
    var b2 = this.curve.point(null, null);
    var c2 = this;
    for (var bits = []; t2.cmpn(0) !== 0; t2.iushrn(1))
      bits.push(t2.andln(1));
    for (var i4 = bits.length - 1; i4 >= 0; i4--) {
      if (bits[i4] === 0) {
        a2 = a2.diffAdd(b2, c2);
        b2 = b2.dbl();
      } else {
        b2 = a2.diffAdd(b2, c2);
        a2 = a2.dbl();
      }
    }
    return b2;
  };
  Point2.prototype.mulAdd = function mulAdd4() {
    throw new Error("Not supported on Montgomery curve");
  };
  Point2.prototype.jumlAdd = function jumlAdd2() {
    throw new Error("Not supported on Montgomery curve");
  };
  Point2.prototype.eq = function eq6(other) {
    return this.getX().cmp(other.getX()) === 0;
  };
  Point2.prototype.normalize = function normalize3() {
    this.x = this.x.redMul(this.z.redInvm());
    this.z = this.curve.one;
    return this;
  };
  Point2.prototype.getX = function getX4() {
    this.normalize();
    return this.x.fromRed();
  };
  return mont$1;
}
var edwards$1;
var hasRequiredEdwards;
function requireEdwards() {
  if (hasRequiredEdwards) return edwards$1;
  hasRequiredEdwards = 1;
  var utils2 = requireUtils();
  var BN2 = bnExports;
  var inherits2 = inherits_browserExports;
  var Base2 = requireBase();
  var assert2 = utils2.assert;
  function EdwardsCurve2(conf) {
    this.twisted = (conf.a | 0) !== 1;
    this.mOneA = this.twisted && (conf.a | 0) === -1;
    this.extended = this.mOneA;
    Base2.call(this, "edwards", conf);
    this.a = new BN2(conf.a, 16).umod(this.red.m);
    this.a = this.a.toRed(this.red);
    this.c = new BN2(conf.c, 16).toRed(this.red);
    this.c2 = this.c.redSqr();
    this.d = new BN2(conf.d, 16).toRed(this.red);
    this.dd = this.d.redAdd(this.d);
    assert2(!this.twisted || this.c.fromRed().cmpn(1) === 0);
    this.oneC = (conf.c | 0) === 1;
  }
  inherits2(EdwardsCurve2, Base2);
  edwards$1 = EdwardsCurve2;
  EdwardsCurve2.prototype._mulA = function _mulA2(num) {
    if (this.mOneA)
      return num.redNeg();
    else
      return this.a.redMul(num);
  };
  EdwardsCurve2.prototype._mulC = function _mulC2(num) {
    if (this.oneC)
      return num;
    else
      return this.c.redMul(num);
  };
  EdwardsCurve2.prototype.jpoint = function jpoint3(x2, y4, z3, t2) {
    return this.point(x2, y4, z3, t2);
  };
  EdwardsCurve2.prototype.pointFromX = function pointFromX3(x2, odd) {
    x2 = new BN2(x2, 16);
    if (!x2.red)
      x2 = x2.toRed(this.red);
    var x22 = x2.redSqr();
    var rhs = this.c2.redSub(this.a.redMul(x22));
    var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x22));
    var y22 = rhs.redMul(lhs.redInvm());
    var y4 = y22.redSqrt();
    if (y4.redSqr().redSub(y22).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var isOdd = y4.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd)
      y4 = y4.redNeg();
    return this.point(x2, y4);
  };
  EdwardsCurve2.prototype.pointFromY = function pointFromY2(y4, odd) {
    y4 = new BN2(y4, 16);
    if (!y4.red)
      y4 = y4.toRed(this.red);
    var y22 = y4.redSqr();
    var lhs = y22.redSub(this.c2);
    var rhs = y22.redMul(this.d).redMul(this.c2).redSub(this.a);
    var x2 = lhs.redMul(rhs.redInvm());
    if (x2.cmp(this.zero) === 0) {
      if (odd)
        throw new Error("invalid point");
      else
        return this.point(this.zero, y4);
    }
    var x3 = x2.redSqrt();
    if (x3.redSqr().redSub(x2).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    if (x3.fromRed().isOdd() !== odd)
      x3 = x3.redNeg();
    return this.point(x3, y4);
  };
  EdwardsCurve2.prototype.validate = function validate7(point5) {
    if (point5.isInfinity())
      return true;
    point5.normalize();
    var x2 = point5.x.redSqr();
    var y22 = point5.y.redSqr();
    var lhs = x2.redMul(this.a).redAdd(y22);
    var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y22)));
    return lhs.cmp(rhs) === 0;
  };
  function Point2(curve2, x2, y4, z3, t2) {
    Base2.BasePoint.call(this, curve2, "projective");
    if (x2 === null && y4 === null && z3 === null) {
      this.x = this.curve.zero;
      this.y = this.curve.one;
      this.z = this.curve.one;
      this.t = this.curve.zero;
      this.zOne = true;
    } else {
      this.x = new BN2(x2, 16);
      this.y = new BN2(y4, 16);
      this.z = z3 ? new BN2(z3, 16) : this.curve.one;
      this.t = t2 && new BN2(t2, 16);
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      if (this.t && !this.t.red)
        this.t = this.t.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
      if (this.curve.extended && !this.t) {
        this.t = this.x.redMul(this.y);
        if (!this.zOne)
          this.t = this.t.redMul(this.z.redInvm());
      }
    }
  }
  inherits2(Point2, Base2.BasePoint);
  EdwardsCurve2.prototype.pointFromJSON = function pointFromJSON4(obj) {
    return Point2.fromJSON(this, obj);
  };
  EdwardsCurve2.prototype.point = function point5(x2, y4, z3, t2) {
    return new Point2(this, x2, y4, z3, t2);
  };
  Point2.fromJSON = function fromJSON4(curve2, obj) {
    return new Point2(curve2, obj[0], obj[1], obj[2]);
  };
  Point2.prototype.inspect = function inspect6() {
    if (this.isInfinity())
      return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  Point2.prototype.isInfinity = function isInfinity5() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  };
  Point2.prototype._extDbl = function _extDbl2() {
    var a2 = this.x.redSqr();
    var b2 = this.y.redSqr();
    var c2 = this.z.redSqr();
    c2 = c2.redIAdd(c2);
    var d4 = this.curve._mulA(a2);
    var e3 = this.x.redAdd(this.y).redSqr().redISub(a2).redISub(b2);
    var g2 = d4.redAdd(b2);
    var f6 = g2.redSub(c2);
    var h5 = d4.redSub(b2);
    var nx = e3.redMul(f6);
    var ny = g2.redMul(h5);
    var nt2 = e3.redMul(h5);
    var nz = f6.redMul(g2);
    return this.curve.point(nx, ny, nz, nt2);
  };
  Point2.prototype._projDbl = function _projDbl2() {
    var b2 = this.x.redAdd(this.y).redSqr();
    var c2 = this.x.redSqr();
    var d4 = this.y.redSqr();
    var nx;
    var ny;
    var nz;
    var e3;
    var h5;
    var j2;
    if (this.curve.twisted) {
      e3 = this.curve._mulA(c2);
      var f6 = e3.redAdd(d4);
      if (this.zOne) {
        nx = b2.redSub(c2).redSub(d4).redMul(f6.redSub(this.curve.two));
        ny = f6.redMul(e3.redSub(d4));
        nz = f6.redSqr().redSub(f6).redSub(f6);
      } else {
        h5 = this.z.redSqr();
        j2 = f6.redSub(h5).redISub(h5);
        nx = b2.redSub(c2).redISub(d4).redMul(j2);
        ny = f6.redMul(e3.redSub(d4));
        nz = f6.redMul(j2);
      }
    } else {
      e3 = c2.redAdd(d4);
      h5 = this.curve._mulC(this.z).redSqr();
      j2 = e3.redSub(h5).redSub(h5);
      nx = this.curve._mulC(b2.redISub(e3)).redMul(j2);
      ny = this.curve._mulC(e3).redMul(c2.redISub(d4));
      nz = e3.redMul(j2);
    }
    return this.curve.point(nx, ny, nz);
  };
  Point2.prototype.dbl = function dbl5() {
    if (this.isInfinity())
      return this;
    if (this.curve.extended)
      return this._extDbl();
    else
      return this._projDbl();
  };
  Point2.prototype._extAdd = function _extAdd2(p2) {
    var a2 = this.y.redSub(this.x).redMul(p2.y.redSub(p2.x));
    var b2 = this.y.redAdd(this.x).redMul(p2.y.redAdd(p2.x));
    var c2 = this.t.redMul(this.curve.dd).redMul(p2.t);
    var d4 = this.z.redMul(p2.z.redAdd(p2.z));
    var e3 = b2.redSub(a2);
    var f6 = d4.redSub(c2);
    var g2 = d4.redAdd(c2);
    var h5 = b2.redAdd(a2);
    var nx = e3.redMul(f6);
    var ny = g2.redMul(h5);
    var nt2 = e3.redMul(h5);
    var nz = f6.redMul(g2);
    return this.curve.point(nx, ny, nz, nt2);
  };
  Point2.prototype._projAdd = function _projAdd2(p2) {
    var a2 = this.z.redMul(p2.z);
    var b2 = a2.redSqr();
    var c2 = this.x.redMul(p2.x);
    var d4 = this.y.redMul(p2.y);
    var e3 = this.curve.d.redMul(c2).redMul(d4);
    var f6 = b2.redSub(e3);
    var g2 = b2.redAdd(e3);
    var tmp = this.x.redAdd(this.y).redMul(p2.x.redAdd(p2.y)).redISub(c2).redISub(d4);
    var nx = a2.redMul(f6).redMul(tmp);
    var ny;
    var nz;
    if (this.curve.twisted) {
      ny = a2.redMul(g2).redMul(d4.redSub(this.curve._mulA(c2)));
      nz = f6.redMul(g2);
    } else {
      ny = a2.redMul(g2).redMul(d4.redSub(c2));
      nz = this.curve._mulC(f6).redMul(g2);
    }
    return this.curve.point(nx, ny, nz);
  };
  Point2.prototype.add = function add6(p2) {
    if (this.isInfinity())
      return p2;
    if (p2.isInfinity())
      return this;
    if (this.curve.extended)
      return this._extAdd(p2);
    else
      return this._projAdd(p2);
  };
  Point2.prototype.mul = function mul6(k3) {
    if (this._hasDoubles(k3))
      return this.curve._fixedNafMul(this, k3);
    else
      return this.curve._wnafMul(this, k3);
  };
  Point2.prototype.mulAdd = function mulAdd4(k1, p2, k22) {
    return this.curve._wnafMulAdd(1, [this, p2], [k1, k22], 2, false);
  };
  Point2.prototype.jmulAdd = function jmulAdd3(k1, p2, k22) {
    return this.curve._wnafMulAdd(1, [this, p2], [k1, k22], 2, true);
  };
  Point2.prototype.normalize = function normalize3() {
    if (this.zOne)
      return this;
    var zi2 = this.z.redInvm();
    this.x = this.x.redMul(zi2);
    this.y = this.y.redMul(zi2);
    if (this.t)
      this.t = this.t.redMul(zi2);
    this.z = this.curve.one;
    this.zOne = true;
    return this;
  };
  Point2.prototype.neg = function neg4() {
    return this.curve.point(
      this.x.redNeg(),
      this.y,
      this.z,
      this.t && this.t.redNeg()
    );
  };
  Point2.prototype.getX = function getX4() {
    this.normalize();
    return this.x.fromRed();
  };
  Point2.prototype.getY = function getY3() {
    this.normalize();
    return this.y.fromRed();
  };
  Point2.prototype.eq = function eq6(other) {
    return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
  };
  Point2.prototype.eqXToP = function eqXToP3(x2) {
    var rx = x2.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(rx) === 0)
      return true;
    var xc3 = x2.clone();
    var t2 = this.curve.redN.redMul(this.z);
    for (; ; ) {
      xc3.iadd(this.curve.n);
      if (xc3.cmp(this.curve.p) >= 0)
        return false;
      rx.redIAdd(t2);
      if (this.x.cmp(rx) === 0)
        return true;
    }
  };
  Point2.prototype.toP = Point2.prototype.normalize;
  Point2.prototype.mixedAdd = Point2.prototype.add;
  return edwards$1;
}
var hasRequiredCurve;
function requireCurve() {
  if (hasRequiredCurve) return curve$1;
  hasRequiredCurve = 1;
  (function(exports2) {
    var curve2 = exports2;
    curve2.base = requireBase();
    curve2.short = requireShort();
    curve2.mont = requireMont();
    curve2.edwards = requireEdwards();
  })(curve$1);
  return curve$1;
}
var curves$2 = {};
var hash$3 = {};
var utils$l = {};
var assert$e = minimalisticAssert;
var inherits$3 = inherits_browserExports;
utils$l.inherits = inherits$3;
function isSurrogatePair(msg, i4) {
  if ((msg.charCodeAt(i4) & 64512) !== 55296) {
    return false;
  }
  if (i4 < 0 || i4 + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i4 + 1) & 64512) === 56320;
}
function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === "string") {
    if (!enc) {
      var p2 = 0;
      for (var i4 = 0; i4 < msg.length; i4++) {
        var c2 = msg.charCodeAt(i4);
        if (c2 < 128) {
          res[p2++] = c2;
        } else if (c2 < 2048) {
          res[p2++] = c2 >> 6 | 192;
          res[p2++] = c2 & 63 | 128;
        } else if (isSurrogatePair(msg, i4)) {
          c2 = 65536 + ((c2 & 1023) << 10) + (msg.charCodeAt(++i4) & 1023);
          res[p2++] = c2 >> 18 | 240;
          res[p2++] = c2 >> 12 & 63 | 128;
          res[p2++] = c2 >> 6 & 63 | 128;
          res[p2++] = c2 & 63 | 128;
        } else {
          res[p2++] = c2 >> 12 | 224;
          res[p2++] = c2 >> 6 & 63 | 128;
          res[p2++] = c2 & 63 | 128;
        }
      }
    } else if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (i4 = 0; i4 < msg.length; i4 += 2)
        res.push(parseInt(msg[i4] + msg[i4 + 1], 16));
    }
  } else {
    for (i4 = 0; i4 < msg.length; i4++)
      res[i4] = msg[i4] | 0;
  }
  return res;
}
utils$l.toArray = toArray;
function toHex$1(msg) {
  var res = "";
  for (var i4 = 0; i4 < msg.length; i4++)
    res += zero2(msg[i4].toString(16));
  return res;
}
utils$l.toHex = toHex$1;
function htonl(w2) {
  var res = w2 >>> 24 | w2 >>> 8 & 65280 | w2 << 8 & 16711680 | (w2 & 255) << 24;
  return res >>> 0;
}
utils$l.htonl = htonl;
function toHex32(msg, endian) {
  var res = "";
  for (var i4 = 0; i4 < msg.length; i4++) {
    var w2 = msg[i4];
    if (endian === "little")
      w2 = htonl(w2);
    res += zero8(w2.toString(16));
  }
  return res;
}
utils$l.toHex32 = toHex32;
function zero2(word) {
  if (word.length === 1)
    return "0" + word;
  else
    return word;
}
utils$l.zero2 = zero2;
function zero8(word) {
  if (word.length === 7)
    return "0" + word;
  else if (word.length === 6)
    return "00" + word;
  else if (word.length === 5)
    return "000" + word;
  else if (word.length === 4)
    return "0000" + word;
  else if (word.length === 3)
    return "00000" + word;
  else if (word.length === 2)
    return "000000" + word;
  else if (word.length === 1)
    return "0000000" + word;
  else
    return word;
}
utils$l.zero8 = zero8;
function join32(msg, start, end, endian) {
  var len2 = end - start;
  assert$e(len2 % 4 === 0);
  var res = new Array(len2 / 4);
  for (var i4 = 0, k3 = start; i4 < res.length; i4++, k3 += 4) {
    var w2;
    if (endian === "big")
      w2 = msg[k3] << 24 | msg[k3 + 1] << 16 | msg[k3 + 2] << 8 | msg[k3 + 3];
    else
      w2 = msg[k3 + 3] << 24 | msg[k3 + 2] << 16 | msg[k3 + 1] << 8 | msg[k3];
    res[i4] = w2 >>> 0;
  }
  return res;
}
utils$l.join32 = join32;
function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i4 = 0, k3 = 0; i4 < msg.length; i4++, k3 += 4) {
    var m4 = msg[i4];
    if (endian === "big") {
      res[k3] = m4 >>> 24;
      res[k3 + 1] = m4 >>> 16 & 255;
      res[k3 + 2] = m4 >>> 8 & 255;
      res[k3 + 3] = m4 & 255;
    } else {
      res[k3 + 3] = m4 >>> 24;
      res[k3 + 2] = m4 >>> 16 & 255;
      res[k3 + 1] = m4 >>> 8 & 255;
      res[k3] = m4 & 255;
    }
  }
  return res;
}
utils$l.split32 = split32;
function rotr32$1(w2, b2) {
  return w2 >>> b2 | w2 << 32 - b2;
}
utils$l.rotr32 = rotr32$1;
function rotl32$2(w2, b2) {
  return w2 << b2 | w2 >>> 32 - b2;
}
utils$l.rotl32 = rotl32$2;
function sum32$3(a2, b2) {
  return a2 + b2 >>> 0;
}
utils$l.sum32 = sum32$3;
function sum32_3$1(a2, b2, c2) {
  return a2 + b2 + c2 >>> 0;
}
utils$l.sum32_3 = sum32_3$1;
function sum32_4$2(a2, b2, c2, d4) {
  return a2 + b2 + c2 + d4 >>> 0;
}
utils$l.sum32_4 = sum32_4$2;
function sum32_5$2(a2, b2, c2, d4, e3) {
  return a2 + b2 + c2 + d4 + e3 >>> 0;
}
utils$l.sum32_5 = sum32_5$2;
function sum64$1(buf, pos, ah2, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];
  var lo2 = al + bl >>> 0;
  var hi2 = (lo2 < al ? 1 : 0) + ah2 + bh;
  buf[pos] = hi2 >>> 0;
  buf[pos + 1] = lo2;
}
utils$l.sum64 = sum64$1;
function sum64_hi$1(ah2, al, bh, bl) {
  var lo2 = al + bl >>> 0;
  var hi2 = (lo2 < al ? 1 : 0) + ah2 + bh;
  return hi2 >>> 0;
}
utils$l.sum64_hi = sum64_hi$1;
function sum64_lo$1(ah2, al, bh, bl) {
  var lo2 = al + bl;
  return lo2 >>> 0;
}
utils$l.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(ah2, al, bh, bl, ch, cl, dh2, dl) {
  var carry = 0;
  var lo2 = al;
  lo2 = lo2 + bl >>> 0;
  carry += lo2 < al ? 1 : 0;
  lo2 = lo2 + cl >>> 0;
  carry += lo2 < cl ? 1 : 0;
  lo2 = lo2 + dl >>> 0;
  carry += lo2 < dl ? 1 : 0;
  var hi2 = ah2 + bh + ch + dh2 + carry;
  return hi2 >>> 0;
}
utils$l.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(ah2, al, bh, bl, ch, cl, dh2, dl) {
  var lo2 = al + bl + cl + dl;
  return lo2 >>> 0;
}
utils$l.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(ah2, al, bh, bl, ch, cl, dh2, dl, eh2, el) {
  var carry = 0;
  var lo2 = al;
  lo2 = lo2 + bl >>> 0;
  carry += lo2 < al ? 1 : 0;
  lo2 = lo2 + cl >>> 0;
  carry += lo2 < cl ? 1 : 0;
  lo2 = lo2 + dl >>> 0;
  carry += lo2 < dl ? 1 : 0;
  lo2 = lo2 + el >>> 0;
  carry += lo2 < el ? 1 : 0;
  var hi2 = ah2 + bh + ch + dh2 + eh2 + carry;
  return hi2 >>> 0;
}
utils$l.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(ah2, al, bh, bl, ch, cl, dh2, dl, eh2, el) {
  var lo2 = al + bl + cl + dl + el;
  return lo2 >>> 0;
}
utils$l.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(ah2, al, num) {
  var r3 = al << 32 - num | ah2 >>> num;
  return r3 >>> 0;
}
utils$l.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(ah2, al, num) {
  var r3 = ah2 << 32 - num | al >>> num;
  return r3 >>> 0;
}
utils$l.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(ah2, al, num) {
  return ah2 >>> num;
}
utils$l.shr64_hi = shr64_hi$1;
function shr64_lo$1(ah2, al, num) {
  var r3 = ah2 << 32 - num | al >>> num;
  return r3 >>> 0;
}
utils$l.shr64_lo = shr64_lo$1;
var common$5 = {};
var utils$k = utils$l;
var assert$d = minimalisticAssert;
function BlockHash$4() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = "big";
  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function update(msg, enc) {
  msg = utils$k.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;
  if (this.pending.length >= this._delta8) {
    msg = this.pending;
    var r3 = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r3, msg.length);
    if (this.pending.length === 0)
      this.pending = null;
    msg = utils$k.join32(msg, 0, msg.length - r3, this.endian);
    for (var i4 = 0; i4 < msg.length; i4 += this._delta32)
      this._update(msg, i4, i4 + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert$d(this.pending === null);
  return this._digest(enc);
};
BlockHash$4.prototype._pad = function pad2() {
  var len2 = this.pendingTotal;
  var bytes2 = this._delta8;
  var k3 = bytes2 - (len2 + this.padLength) % bytes2;
  var res = new Array(k3 + this.padLength);
  res[0] = 128;
  for (var i4 = 1; i4 < k3; i4++)
    res[i4] = 0;
  len2 <<= 3;
  if (this.endian === "big") {
    for (var t2 = 8; t2 < this.padLength; t2++)
      res[i4++] = 0;
    res[i4++] = 0;
    res[i4++] = 0;
    res[i4++] = 0;
    res[i4++] = 0;
    res[i4++] = len2 >>> 24 & 255;
    res[i4++] = len2 >>> 16 & 255;
    res[i4++] = len2 >>> 8 & 255;
    res[i4++] = len2 & 255;
  } else {
    res[i4++] = len2 & 255;
    res[i4++] = len2 >>> 8 & 255;
    res[i4++] = len2 >>> 16 & 255;
    res[i4++] = len2 >>> 24 & 255;
    res[i4++] = 0;
    res[i4++] = 0;
    res[i4++] = 0;
    res[i4++] = 0;
    for (t2 = 8; t2 < this.padLength; t2++)
      res[i4++] = 0;
  }
  return res;
};
var sha = {};
var common$4 = {};
var utils$j = utils$l;
var rotr32 = utils$j.rotr32;
function ft_1$1(s2, x2, y4, z3) {
  if (s2 === 0)
    return ch32$1(x2, y4, z3);
  if (s2 === 1 || s2 === 3)
    return p32(x2, y4, z3);
  if (s2 === 2)
    return maj32$1(x2, y4, z3);
}
common$4.ft_1 = ft_1$1;
function ch32$1(x2, y4, z3) {
  return x2 & y4 ^ ~x2 & z3;
}
common$4.ch32 = ch32$1;
function maj32$1(x2, y4, z3) {
  return x2 & y4 ^ x2 & z3 ^ y4 & z3;
}
common$4.maj32 = maj32$1;
function p32(x2, y4, z3) {
  return x2 ^ y4 ^ z3;
}
common$4.p32 = p32;
function s0_256$1(x2) {
  return rotr32(x2, 2) ^ rotr32(x2, 13) ^ rotr32(x2, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(x2) {
  return rotr32(x2, 6) ^ rotr32(x2, 11) ^ rotr32(x2, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(x2) {
  return rotr32(x2, 7) ^ rotr32(x2, 18) ^ x2 >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(x2) {
  return rotr32(x2, 17) ^ rotr32(x2, 19) ^ x2 >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$i = utils$l;
var common$3 = common$5;
var shaCommon$1 = common$4;
var rotl32$1 = utils$i.rotl32;
var sum32$2 = utils$i.sum32;
var sum32_5$1 = utils$i.sum32_5;
var ft_1 = shaCommon$1.ft_1;
var BlockHash$3 = common$3.BlockHash;
var sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this);
  this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ];
  this.W = new Array(80);
}
utils$i.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function _update(msg, start) {
  var W2 = this.W;
  for (var i4 = 0; i4 < 16; i4++)
    W2[i4] = msg[start + i4];
  for (; i4 < W2.length; i4++)
    W2[i4] = rotl32$1(W2[i4 - 3] ^ W2[i4 - 8] ^ W2[i4 - 14] ^ W2[i4 - 16], 1);
  var a2 = this.h[0];
  var b2 = this.h[1];
  var c2 = this.h[2];
  var d4 = this.h[3];
  var e3 = this.h[4];
  for (i4 = 0; i4 < W2.length; i4++) {
    var s2 = ~~(i4 / 20);
    var t2 = sum32_5$1(rotl32$1(a2, 5), ft_1(s2, b2, c2, d4), e3, W2[i4], sha1_K[s2]);
    e3 = d4;
    d4 = c2;
    c2 = rotl32$1(b2, 30);
    b2 = a2;
    a2 = t2;
  }
  this.h[0] = sum32$2(this.h[0], a2);
  this.h[1] = sum32$2(this.h[1], b2);
  this.h[2] = sum32$2(this.h[2], c2);
  this.h[3] = sum32$2(this.h[3], d4);
  this.h[4] = sum32$2(this.h[4], e3);
};
SHA1.prototype._digest = function digest2(enc) {
  if (enc === "hex")
    return utils$i.toHex32(this.h, "big");
  else
    return utils$i.split32(this.h, "big");
};
var utils$h = utils$l;
var common$2 = common$5;
var shaCommon = common$4;
var assert$c = minimalisticAssert;
var sum32$1 = utils$h.sum32;
var sum32_4$1 = utils$h.sum32_4;
var sum32_5 = utils$h.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;
var BlockHash$2 = common$2.BlockHash;
var sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$2() {
  if (!(this instanceof SHA256$2))
    return new SHA256$2();
  BlockHash$2.call(this);
  this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils$h.inherits(SHA256$2, BlockHash$2);
var _256 = SHA256$2;
SHA256$2.blockSize = 512;
SHA256$2.outSize = 256;
SHA256$2.hmacStrength = 192;
SHA256$2.padLength = 64;
SHA256$2.prototype._update = function _update2(msg, start) {
  var W2 = this.W;
  for (var i4 = 0; i4 < 16; i4++)
    W2[i4] = msg[start + i4];
  for (; i4 < W2.length; i4++)
    W2[i4] = sum32_4$1(g1_256(W2[i4 - 2]), W2[i4 - 7], g0_256(W2[i4 - 15]), W2[i4 - 16]);
  var a2 = this.h[0];
  var b2 = this.h[1];
  var c2 = this.h[2];
  var d4 = this.h[3];
  var e3 = this.h[4];
  var f6 = this.h[5];
  var g2 = this.h[6];
  var h5 = this.h[7];
  assert$c(this.k.length === W2.length);
  for (i4 = 0; i4 < W2.length; i4++) {
    var T12 = sum32_5(h5, s1_256(e3), ch32(e3, f6, g2), this.k[i4], W2[i4]);
    var T2 = sum32$1(s0_256(a2), maj32(a2, b2, c2));
    h5 = g2;
    g2 = f6;
    f6 = e3;
    e3 = sum32$1(d4, T12);
    d4 = c2;
    c2 = b2;
    b2 = a2;
    a2 = sum32$1(T12, T2);
  }
  this.h[0] = sum32$1(this.h[0], a2);
  this.h[1] = sum32$1(this.h[1], b2);
  this.h[2] = sum32$1(this.h[2], c2);
  this.h[3] = sum32$1(this.h[3], d4);
  this.h[4] = sum32$1(this.h[4], e3);
  this.h[5] = sum32$1(this.h[5], f6);
  this.h[6] = sum32$1(this.h[6], g2);
  this.h[7] = sum32$1(this.h[7], h5);
};
SHA256$2.prototype._digest = function digest3(enc) {
  if (enc === "hex")
    return utils$h.toHex32(this.h, "big");
  else
    return utils$h.split32(this.h, "big");
};
var utils$g = utils$l;
var SHA256$1 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256$1.call(this);
  this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$g.inherits(SHA224, SHA256$1);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function digest4(enc) {
  if (enc === "hex")
    return utils$g.toHex32(this.h.slice(0, 7), "big");
  else
    return utils$g.split32(this.h.slice(0, 7), "big");
};
var utils$f = utils$l;
var common$1 = common$5;
var assert$b = minimalisticAssert;
var rotr64_hi = utils$f.rotr64_hi;
var rotr64_lo = utils$f.rotr64_lo;
var shr64_hi = utils$f.shr64_hi;
var shr64_lo = utils$f.shr64_lo;
var sum64 = utils$f.sum64;
var sum64_hi = utils$f.sum64_hi;
var sum64_lo = utils$f.sum64_lo;
var sum64_4_hi = utils$f.sum64_4_hi;
var sum64_4_lo = utils$f.sum64_4_lo;
var sum64_5_hi = utils$f.sum64_5_hi;
var sum64_5_lo = utils$f.sum64_5_lo;
var BlockHash$1 = common$1.BlockHash;
var sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$2() {
  if (!(this instanceof SHA512$2))
    return new SHA512$2();
  BlockHash$1.call(this);
  this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils$f.inherits(SHA512$2, BlockHash$1);
var _512 = SHA512$2;
SHA512$2.blockSize = 1024;
SHA512$2.outSize = 512;
SHA512$2.hmacStrength = 192;
SHA512$2.padLength = 128;
SHA512$2.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W2 = this.W;
  for (var i4 = 0; i4 < 32; i4++)
    W2[i4] = msg[start + i4];
  for (; i4 < W2.length; i4 += 2) {
    var c0_hi = g1_512_hi(W2[i4 - 4], W2[i4 - 3]);
    var c0_lo = g1_512_lo(W2[i4 - 4], W2[i4 - 3]);
    var c1_hi = W2[i4 - 14];
    var c1_lo = W2[i4 - 13];
    var c2_hi = g0_512_hi(W2[i4 - 30], W2[i4 - 29]);
    var c2_lo = g0_512_lo(W2[i4 - 30], W2[i4 - 29]);
    var c3_hi = W2[i4 - 32];
    var c3_lo = W2[i4 - 31];
    W2[i4] = sum64_4_hi(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo
    );
    W2[i4 + 1] = sum64_4_lo(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo
    );
  }
};
SHA512$2.prototype._update = function _update3(msg, start) {
  this._prepareBlock(msg, start);
  var W2 = this.W;
  var ah2 = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh2 = this.h[6];
  var dl = this.h[7];
  var eh2 = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];
  assert$b(this.k.length === W2.length);
  for (var i4 = 0; i4 < W2.length; i4 += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh2, el);
    var c1_lo = s1_512_lo(eh2, el);
    var c2_hi = ch64_hi(eh2, el, fh, fl, gh);
    var c2_lo = ch64_lo(eh2, el, fh, fl, gh, gl);
    var c3_hi = this.k[i4];
    var c3_lo = this.k[i4 + 1];
    var c4_hi = W2[i4];
    var c4_lo = W2[i4 + 1];
    var T1_hi = sum64_5_hi(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo,
      c4_hi,
      c4_lo
    );
    var T1_lo = sum64_5_lo(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo,
      c4_hi,
      c4_lo
    );
    c0_hi = s0_512_hi(ah2, al);
    c0_lo = s0_512_lo(ah2, al);
    c1_hi = maj64_hi(ah2, al, bh, bl, ch);
    c1_lo = maj64_lo(ah2, al, bh, bl, ch, cl);
    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
    hh = gh;
    hl = gl;
    gh = fh;
    gl = fl;
    fh = eh2;
    fl = el;
    eh2 = sum64_hi(dh2, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);
    dh2 = ch;
    dl = cl;
    ch = bh;
    cl = bl;
    bh = ah2;
    bl = al;
    ah2 = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }
  sum64(this.h, 0, ah2, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh2, dl);
  sum64(this.h, 8, eh2, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};
SHA512$2.prototype._digest = function digest5(enc) {
  if (enc === "hex")
    return utils$f.toHex32(this.h, "big");
  else
    return utils$f.split32(this.h, "big");
};
function ch64_hi(xh, xl, yh, yl, zh) {
  var r3 = xh & yh ^ ~xh & zh;
  if (r3 < 0)
    r3 += 4294967296;
  return r3;
}
function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r3 = xl & yl ^ ~xl & zl;
  if (r3 < 0)
    r3 += 4294967296;
  return r3;
}
function maj64_hi(xh, xl, yh, yl, zh) {
  var r3 = xh & yh ^ xh & zh ^ yh & zh;
  if (r3 < 0)
    r3 += 4294967296;
  return r3;
}
function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r3 = xl & yl ^ xl & zl ^ yl & zl;
  if (r3 < 0)
    r3 += 4294967296;
  return r3;
}
function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);
  var c2_hi = rotr64_hi(xl, xh, 7);
  var r3 = c0_hi ^ c1_hi ^ c2_hi;
  if (r3 < 0)
    r3 += 4294967296;
  return r3;
}
function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);
  var c2_lo = rotr64_lo(xl, xh, 7);
  var r3 = c0_lo ^ c1_lo ^ c2_lo;
  if (r3 < 0)
    r3 += 4294967296;
  return r3;
}
function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);
  var r3 = c0_hi ^ c1_hi ^ c2_hi;
  if (r3 < 0)
    r3 += 4294967296;
  return r3;
}
function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);
  var r3 = c0_lo ^ c1_lo ^ c2_lo;
  if (r3 < 0)
    r3 += 4294967296;
  return r3;
}
function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);
  var r3 = c0_hi ^ c1_hi ^ c2_hi;
  if (r3 < 0)
    r3 += 4294967296;
  return r3;
}
function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);
  var r3 = c0_lo ^ c1_lo ^ c2_lo;
  if (r3 < 0)
    r3 += 4294967296;
  return r3;
}
function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);
  var c2_hi = shr64_hi(xh, xl, 6);
  var r3 = c0_hi ^ c1_hi ^ c2_hi;
  if (r3 < 0)
    r3 += 4294967296;
  return r3;
}
function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);
  var c2_lo = shr64_lo(xh, xl, 6);
  var r3 = c0_lo ^ c1_lo ^ c2_lo;
  if (r3 < 0)
    r3 += 4294967296;
  return r3;
}
var utils$e = utils$l;
var SHA512$1 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512$1.call(this);
  this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$e.inherits(SHA384, SHA512$1);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function digest6(enc) {
  if (enc === "hex")
    return utils$e.toHex32(this.h.slice(0, 12), "big");
  else
    return utils$e.split32(this.h.slice(0, 12), "big");
};
sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;
var ripemd = {};
var utils$d = utils$l;
var common = common$5;
var rotl32 = utils$d.rotl32;
var sum32 = utils$d.sum32;
var sum32_3 = utils$d.sum32_3;
var sum32_4 = utils$d.sum32_4;
var BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this);
  this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  this.endian = "little";
}
utils$d.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function update2(msg, start) {
  var A2 = this.h[0];
  var B3 = this.h[1];
  var C2 = this.h[2];
  var D2 = this.h[3];
  var E2 = this.h[4];
  var Ah = A2;
  var Bh = B3;
  var Ch = C2;
  var Dh = D2;
  var Eh = E2;
  for (var j2 = 0; j2 < 80; j2++) {
    var T2 = sum32(
      rotl32(
        sum32_4(A2, f$8(j2, B3, C2, D2), msg[r$7[j2] + start], K$3(j2)),
        s$4[j2]
      ),
      E2
    );
    A2 = E2;
    E2 = D2;
    D2 = rotl32(C2, 10);
    C2 = B3;
    B3 = T2;
    T2 = sum32(
      rotl32(
        sum32_4(Ah, f$8(79 - j2, Bh, Ch, Dh), msg[rh$2[j2] + start], Kh(j2)),
        sh$2[j2]
      ),
      Eh
    );
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T2;
  }
  T2 = sum32_3(this.h[1], C2, Dh);
  this.h[1] = sum32_3(this.h[2], D2, Eh);
  this.h[2] = sum32_3(this.h[3], E2, Ah);
  this.h[3] = sum32_3(this.h[4], A2, Bh);
  this.h[4] = sum32_3(this.h[0], B3, Ch);
  this.h[0] = T2;
};
RIPEMD160.prototype._digest = function digest7(enc) {
  if (enc === "hex")
    return utils$d.toHex32(this.h, "little");
  else
    return utils$d.split32(this.h, "little");
};
function f$8(j2, x2, y4, z3) {
  if (j2 <= 15)
    return x2 ^ y4 ^ z3;
  else if (j2 <= 31)
    return x2 & y4 | ~x2 & z3;
  else if (j2 <= 47)
    return (x2 | ~y4) ^ z3;
  else if (j2 <= 63)
    return x2 & z3 | y4 & ~z3;
  else
    return x2 ^ (y4 | ~z3);
}
function K$3(j2) {
  if (j2 <= 15)
    return 0;
  else if (j2 <= 31)
    return 1518500249;
  else if (j2 <= 47)
    return 1859775393;
  else if (j2 <= 63)
    return 2400959708;
  else
    return 2840853838;
}
function Kh(j2) {
  if (j2 <= 15)
    return 1352829926;
  else if (j2 <= 31)
    return 1548603684;
  else if (j2 <= 47)
    return 1836072691;
  else if (j2 <= 63)
    return 2053994217;
  else
    return 0;
}
var r$7 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
];
var rh$2 = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
];
var s$4 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
];
var sh$2 = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
];
var utils$c = utils$l;
var assert$a = minimalisticAssert;
function Hmac(hash3, key2, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash3, key2, enc);
  this.Hash = hash3;
  this.blockSize = hash3.blockSize / 8;
  this.outSize = hash3.outSize / 8;
  this.inner = null;
  this.outer = null;
  this._init(utils$c.toArray(key2, enc));
}
var hmac$1 = Hmac;
Hmac.prototype._init = function init2(key2) {
  if (key2.length > this.blockSize)
    key2 = new this.Hash().update(key2).digest();
  assert$a(key2.length <= this.blockSize);
  for (var i4 = key2.length; i4 < this.blockSize; i4++)
    key2.push(0);
  for (i4 = 0; i4 < key2.length; i4++)
    key2[i4] ^= 54;
  this.inner = new this.Hash().update(key2);
  for (i4 = 0; i4 < key2.length; i4++)
    key2[i4] ^= 106;
  this.outer = new this.Hash().update(key2);
};
Hmac.prototype.update = function update3(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};
Hmac.prototype.digest = function digest8(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};
(function(exports2) {
  var hash3 = exports2;
  hash3.utils = utils$l;
  hash3.common = common$5;
  hash3.sha = sha;
  hash3.ripemd = ripemd;
  hash3.hmac = hmac$1;
  hash3.sha1 = hash3.sha.sha1;
  hash3.sha256 = hash3.sha.sha256;
  hash3.sha224 = hash3.sha.sha224;
  hash3.sha384 = hash3.sha.sha384;
  hash3.sha512 = hash3.sha.sha512;
  hash3.ripemd160 = hash3.ripemd.ripemd160;
})(hash$3);
var secp256k1$2;
var hasRequiredSecp256k1$1;
function requireSecp256k1$1() {
  if (hasRequiredSecp256k1$1) return secp256k1$2;
  hasRequiredSecp256k1$1 = 1;
  secp256k1$2 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  };
  return secp256k1$2;
}
var hasRequiredCurves;
function requireCurves() {
  if (hasRequiredCurves) return curves$2;
  hasRequiredCurves = 1;
  (function(exports2) {
    var curves2 = exports2;
    var hash3 = hash$3;
    var curve2 = requireCurve();
    var utils2 = requireUtils();
    var assert2 = utils2.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve2.short(options);
      else if (options.type === "edwards")
        this.curve = new curve2.edwards(options);
      else
        this.curve = new curve2.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert2(this.g.validate(), "Invalid curve");
      assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves2.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
      Object.defineProperty(curves2, name, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve3 = new PresetCurve(options);
          Object.defineProperty(curves2, name, {
            configurable: true,
            enumerable: true,
            value: curve3
          });
          return curve3;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash3.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash3.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash3.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash3.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash3.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash3.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash3.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = requireSecp256k1$1();
    } catch (e3) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash3.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  })(curves$2);
  return curves$2;
}
var hash$2 = hash$3;
var utils$b = utils$o;
var assert$9 = minimalisticAssert;
function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils$b.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils$b.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils$b.toArray(options.pers, options.persEnc || "hex");
  assert$9(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._init(entropy, nonce, pers);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function init3(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i4 = 0; i4 < this.V.length; i4++) {
    this.K[i4] = 0;
    this.V[i4] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function hmac2() {
  return new hash$2.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function update4(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add6, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add6;
    add6 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils$b.toArray(entropy, entropyEnc);
  add6 = utils$b.toArray(add6, addEnc);
  assert$9(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._update(entropy.concat(add6 || []));
  this._reseed = 1;
};
HmacDRBG.prototype.generate = function generate(len2, enc, add6, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add6;
    add6 = enc;
    enc = null;
  }
  if (add6) {
    add6 = utils$b.toArray(add6, addEnc || "hex");
    this._update(add6);
  }
  var temp = [];
  while (temp.length < len2) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len2);
  this._update(add6);
  this._reseed++;
  return utils$b.encode(res, enc);
};
var key$3;
var hasRequiredKey$1;
function requireKey$1() {
  if (hasRequiredKey$1) return key$3;
  hasRequiredKey$1 = 1;
  var BN2 = bnExports;
  var utils2 = requireUtils();
  var assert2 = utils2.assert;
  function KeyPair2(ec2, options) {
    this.ec = ec2;
    this.priv = null;
    this.pub = null;
    if (options.priv)
      this._importPrivate(options.priv, options.privEnc);
    if (options.pub)
      this._importPublic(options.pub, options.pubEnc);
  }
  key$3 = KeyPair2;
  KeyPair2.fromPublic = function fromPublic3(ec2, pub2, enc) {
    if (pub2 instanceof KeyPair2)
      return pub2;
    return new KeyPair2(ec2, {
      pub: pub2,
      pubEnc: enc
    });
  };
  KeyPair2.fromPrivate = function fromPrivate2(ec2, priv2, enc) {
    if (priv2 instanceof KeyPair2)
      return priv2;
    return new KeyPair2(ec2, {
      priv: priv2,
      privEnc: enc
    });
  };
  KeyPair2.prototype.validate = function validate7() {
    var pub2 = this.getPublic();
    if (pub2.isInfinity())
      return { result: false, reason: "Invalid public key" };
    if (!pub2.validate())
      return { result: false, reason: "Public key is not a point" };
    if (!pub2.mul(this.ec.curve.n).isInfinity())
      return { result: false, reason: "Public key * N != O" };
    return { result: true, reason: null };
  };
  KeyPair2.prototype.getPublic = function getPublic3(compact, enc) {
    if (typeof compact === "string") {
      enc = compact;
      compact = null;
    }
    if (!this.pub)
      this.pub = this.ec.g.mul(this.priv);
    if (!enc)
      return this.pub;
    return this.pub.encode(enc, compact);
  };
  KeyPair2.prototype.getPrivate = function getPrivate2(enc) {
    if (enc === "hex")
      return this.priv.toString(16, 2);
    else
      return this.priv;
  };
  KeyPair2.prototype._importPrivate = function _importPrivate2(key2, enc) {
    this.priv = new BN2(key2, enc || 16);
    this.priv = this.priv.umod(this.ec.curve.n);
  };
  KeyPair2.prototype._importPublic = function _importPublic2(key2, enc) {
    if (key2.x || key2.y) {
      if (this.ec.curve.type === "mont") {
        assert2(key2.x, "Need x coordinate");
      } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
        assert2(key2.x && key2.y, "Need both x and y coordinate");
      }
      this.pub = this.ec.curve.point(key2.x, key2.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(key2, enc);
  };
  KeyPair2.prototype.derive = function derive2(pub2) {
    if (!pub2.validate()) {
      assert2(pub2.validate(), "public point not validated");
    }
    return pub2.mul(this.priv).getX();
  };
  KeyPair2.prototype.sign = function sign5(msg, enc, options) {
    return this.ec.sign(msg, this, enc, options);
  };
  KeyPair2.prototype.verify = function verify4(msg, signature2) {
    return this.ec.verify(msg, signature2, this);
  };
  KeyPair2.prototype.inspect = function inspect6() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  };
  return key$3;
}
var signature$3;
var hasRequiredSignature$1;
function requireSignature$1() {
  if (hasRequiredSignature$1) return signature$3;
  hasRequiredSignature$1 = 1;
  var BN2 = bnExports;
  var utils2 = requireUtils();
  var assert2 = utils2.assert;
  function Signature2(options, enc) {
    if (options instanceof Signature2)
      return options;
    if (this._importDER(options, enc))
      return;
    assert2(options.r && options.s, "Signature without r or s");
    this.r = new BN2(options.r, 16);
    this.s = new BN2(options.s, 16);
    if (options.recoveryParam === void 0)
      this.recoveryParam = null;
    else
      this.recoveryParam = options.recoveryParam;
  }
  signature$3 = Signature2;
  function Position2() {
    this.place = 0;
  }
  function getLength6(buf, p2) {
    var initial = buf[p2.place++];
    if (!(initial & 128)) {
      return initial;
    }
    var octetLen = initial & 15;
    if (octetLen === 0 || octetLen > 4) {
      return false;
    }
    var val = 0;
    for (var i4 = 0, off = p2.place; i4 < octetLen; i4++, off++) {
      val <<= 8;
      val |= buf[off];
      val >>>= 0;
    }
    if (val <= 127) {
      return false;
    }
    p2.place = off;
    return val;
  }
  function rmPadding2(buf) {
    var i4 = 0;
    var len2 = buf.length - 1;
    while (!buf[i4] && !(buf[i4 + 1] & 128) && i4 < len2) {
      i4++;
    }
    if (i4 === 0) {
      return buf;
    }
    return buf.slice(i4);
  }
  Signature2.prototype._importDER = function _importDER2(data2, enc) {
    data2 = utils2.toArray(data2, enc);
    var p2 = new Position2();
    if (data2[p2.place++] !== 48) {
      return false;
    }
    var len2 = getLength6(data2, p2);
    if (len2 === false) {
      return false;
    }
    if (len2 + p2.place !== data2.length) {
      return false;
    }
    if (data2[p2.place++] !== 2) {
      return false;
    }
    var rlen = getLength6(data2, p2);
    if (rlen === false) {
      return false;
    }
    var r3 = data2.slice(p2.place, rlen + p2.place);
    p2.place += rlen;
    if (data2[p2.place++] !== 2) {
      return false;
    }
    var slen = getLength6(data2, p2);
    if (slen === false) {
      return false;
    }
    if (data2.length !== slen + p2.place) {
      return false;
    }
    var s2 = data2.slice(p2.place, slen + p2.place);
    if (r3[0] === 0) {
      if (r3[1] & 128) {
        r3 = r3.slice(1);
      } else {
        return false;
      }
    }
    if (s2[0] === 0) {
      if (s2[1] & 128) {
        s2 = s2.slice(1);
      } else {
        return false;
      }
    }
    this.r = new BN2(r3);
    this.s = new BN2(s2);
    this.recoveryParam = null;
    return true;
  };
  function constructLength2(arr, len2) {
    if (len2 < 128) {
      arr.push(len2);
      return;
    }
    var octets = 1 + (Math.log(len2) / Math.LN2 >>> 3);
    arr.push(octets | 128);
    while (--octets) {
      arr.push(len2 >>> (octets << 3) & 255);
    }
    arr.push(len2);
  }
  Signature2.prototype.toDER = function toDER2(enc) {
    var r3 = this.r.toArray();
    var s2 = this.s.toArray();
    if (r3[0] & 128)
      r3 = [0].concat(r3);
    if (s2[0] & 128)
      s2 = [0].concat(s2);
    r3 = rmPadding2(r3);
    s2 = rmPadding2(s2);
    while (!s2[0] && !(s2[1] & 128)) {
      s2 = s2.slice(1);
    }
    var arr = [2];
    constructLength2(arr, r3.length);
    arr = arr.concat(r3);
    arr.push(2);
    constructLength2(arr, s2.length);
    var backHalf = arr.concat(s2);
    var res = [48];
    constructLength2(res, backHalf.length);
    res = res.concat(backHalf);
    return utils2.encode(res, enc);
  };
  return signature$3;
}
var ec$4;
var hasRequiredEc$1;
function requireEc$1() {
  if (hasRequiredEc$1) return ec$4;
  hasRequiredEc$1 = 1;
  var BN2 = bnExports;
  var HmacDRBG2 = hmacDrbg;
  var utils2 = requireUtils();
  var curves2 = requireCurves();
  var rand = requireBrorand();
  var assert2 = utils2.assert;
  var KeyPair2 = requireKey$1();
  var Signature2 = requireSignature$1();
  function EC(options) {
    if (!(this instanceof EC))
      return new EC(options);
    if (typeof options === "string") {
      assert2(
        Object.prototype.hasOwnProperty.call(curves2, options),
        "Unknown curve " + options
      );
      options = curves2[options];
    }
    if (options instanceof curves2.PresetCurve)
      options = { curve: options };
    this.curve = options.curve.curve;
    this.n = this.curve.n;
    this.nh = this.n.ushrn(1);
    this.g = this.curve.g;
    this.g = options.curve.g;
    this.g.precompute(options.curve.n.bitLength() + 1);
    this.hash = options.hash || options.curve.hash;
  }
  ec$4 = EC;
  EC.prototype.keyPair = function keyPair(options) {
    return new KeyPair2(this, options);
  };
  EC.prototype.keyFromPrivate = function keyFromPrivate(priv2, enc) {
    return KeyPair2.fromPrivate(this, priv2, enc);
  };
  EC.prototype.keyFromPublic = function keyFromPublic2(pub2, enc) {
    return KeyPair2.fromPublic(this, pub2, enc);
  };
  EC.prototype.genKeyPair = function genKeyPair(options) {
    if (!options)
      options = {};
    var drbg = new HmacDRBG2({
      hash: this.hash,
      pers: options.pers,
      persEnc: options.persEnc || "utf8",
      entropy: options.entropy || rand(this.hash.hmacStrength),
      entropyEnc: options.entropy && options.entropyEnc || "utf8",
      nonce: this.n.toArray()
    });
    var bytes2 = this.n.byteLength();
    var ns2 = this.n.sub(new BN2(2));
    for (; ; ) {
      var priv2 = new BN2(drbg.generate(bytes2));
      if (priv2.cmp(ns2) > 0)
        continue;
      priv2.iaddn(1);
      return this.keyFromPrivate(priv2);
    }
  };
  EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
    var delta = msg.byteLength() * 8 - this.n.bitLength();
    if (delta > 0)
      msg = msg.ushrn(delta);
    if (!truncOnly && msg.cmp(this.n) >= 0)
      return msg.sub(this.n);
    else
      return msg;
  };
  EC.prototype.sign = function sign5(msg, key2, enc, options) {
    if (typeof enc === "object") {
      options = enc;
      enc = null;
    }
    if (!options)
      options = {};
    key2 = this.keyFromPrivate(key2, enc);
    msg = this._truncateToN(new BN2(msg, 16));
    var bytes2 = this.n.byteLength();
    var bkey = key2.getPrivate().toArray("be", bytes2);
    var nonce = msg.toArray("be", bytes2);
    var drbg = new HmacDRBG2({
      hash: this.hash,
      entropy: bkey,
      nonce,
      pers: options.pers,
      persEnc: options.persEnc || "utf8"
    });
    var ns1 = this.n.sub(new BN2(1));
    for (var iter = 0; ; iter++) {
      var k3 = options.k ? options.k(iter) : new BN2(drbg.generate(this.n.byteLength()));
      k3 = this._truncateToN(k3, true);
      if (k3.cmpn(1) <= 0 || k3.cmp(ns1) >= 0)
        continue;
      var kp = this.g.mul(k3);
      if (kp.isInfinity())
        continue;
      var kpX = kp.getX();
      var r3 = kpX.umod(this.n);
      if (r3.cmpn(0) === 0)
        continue;
      var s2 = k3.invm(this.n).mul(r3.mul(key2.getPrivate()).iadd(msg));
      s2 = s2.umod(this.n);
      if (s2.cmpn(0) === 0)
        continue;
      var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r3) !== 0 ? 2 : 0);
      if (options.canonical && s2.cmp(this.nh) > 0) {
        s2 = this.n.sub(s2);
        recoveryParam ^= 1;
      }
      return new Signature2({ r: r3, s: s2, recoveryParam });
    }
  };
  EC.prototype.verify = function verify4(msg, signature2, key2, enc) {
    msg = this._truncateToN(new BN2(msg, 16));
    key2 = this.keyFromPublic(key2, enc);
    signature2 = new Signature2(signature2, "hex");
    var r3 = signature2.r;
    var s2 = signature2.s;
    if (r3.cmpn(1) < 0 || r3.cmp(this.n) >= 0)
      return false;
    if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
      return false;
    var sinv = s2.invm(this.n);
    var u1 = sinv.mul(msg).umod(this.n);
    var u2 = sinv.mul(r3).umod(this.n);
    var p2;
    if (!this.curve._maxwellTrick) {
      p2 = this.g.mulAdd(u1, key2.getPublic(), u2);
      if (p2.isInfinity())
        return false;
      return p2.getX().umod(this.n).cmp(r3) === 0;
    }
    p2 = this.g.jmulAdd(u1, key2.getPublic(), u2);
    if (p2.isInfinity())
      return false;
    return p2.eqXToP(r3);
  };
  EC.prototype.recoverPubKey = function(msg, signature2, j2, enc) {
    assert2((3 & j2) === j2, "The recovery param is more than two bits");
    signature2 = new Signature2(signature2, enc);
    var n5 = this.n;
    var e3 = new BN2(msg);
    var r3 = signature2.r;
    var s2 = signature2.s;
    var isYOdd = j2 & 1;
    var isSecondKey = j2 >> 1;
    if (r3.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
      throw new Error("Unable to find sencond key candinate");
    if (isSecondKey)
      r3 = this.curve.pointFromX(r3.add(this.curve.n), isYOdd);
    else
      r3 = this.curve.pointFromX(r3, isYOdd);
    var rInv = signature2.r.invm(n5);
    var s1 = n5.sub(e3).mul(rInv).umod(n5);
    var s22 = s2.mul(rInv).umod(n5);
    return this.g.mulAdd(s1, r3, s22);
  };
  EC.prototype.getKeyRecoveryParam = function(e3, signature2, Q2, enc) {
    signature2 = new Signature2(signature2, enc);
    if (signature2.recoveryParam !== null)
      return signature2.recoveryParam;
    for (var i4 = 0; i4 < 4; i4++) {
      var Qprime;
      try {
        Qprime = this.recoverPubKey(e3, signature2, i4);
      } catch (e4) {
        continue;
      }
      if (Qprime.eq(Q2))
        return i4;
    }
    throw new Error("Unable to find valid recovery factor");
  };
  return ec$4;
}
var key$2;
var hasRequiredKey;
function requireKey() {
  if (hasRequiredKey) return key$2;
  hasRequiredKey = 1;
  var utils2 = requireUtils();
  var assert2 = utils2.assert;
  var parseBytes2 = utils2.parseBytes;
  var cachedProperty2 = utils2.cachedProperty;
  function KeyPair2(eddsa2, params) {
    this.eddsa = eddsa2;
    this._secret = parseBytes2(params.secret);
    if (eddsa2.isPoint(params.pub))
      this._pub = params.pub;
    else
      this._pubBytes = parseBytes2(params.pub);
  }
  KeyPair2.fromPublic = function fromPublic3(eddsa2, pub2) {
    if (pub2 instanceof KeyPair2)
      return pub2;
    return new KeyPair2(eddsa2, { pub: pub2 });
  };
  KeyPair2.fromSecret = function fromSecret2(eddsa2, secret2) {
    if (secret2 instanceof KeyPair2)
      return secret2;
    return new KeyPair2(eddsa2, { secret: secret2 });
  };
  KeyPair2.prototype.secret = function secret2() {
    return this._secret;
  };
  cachedProperty2(KeyPair2, "pubBytes", function pubBytes2() {
    return this.eddsa.encodePoint(this.pub());
  });
  cachedProperty2(KeyPair2, "pub", function pub2() {
    if (this._pubBytes)
      return this.eddsa.decodePoint(this._pubBytes);
    return this.eddsa.g.mul(this.priv());
  });
  cachedProperty2(KeyPair2, "privBytes", function privBytes2() {
    var eddsa2 = this.eddsa;
    var hash3 = this.hash();
    var lastIx = eddsa2.encodingLength - 1;
    var a2 = hash3.slice(0, eddsa2.encodingLength);
    a2[0] &= 248;
    a2[lastIx] &= 127;
    a2[lastIx] |= 64;
    return a2;
  });
  cachedProperty2(KeyPair2, "priv", function priv2() {
    return this.eddsa.decodeInt(this.privBytes());
  });
  cachedProperty2(KeyPair2, "hash", function hash3() {
    return this.eddsa.hash().update(this.secret()).digest();
  });
  cachedProperty2(KeyPair2, "messagePrefix", function messagePrefix2() {
    return this.hash().slice(this.eddsa.encodingLength);
  });
  KeyPair2.prototype.sign = function sign5(message) {
    assert2(this._secret, "KeyPair can only verify");
    return this.eddsa.sign(message, this);
  };
  KeyPair2.prototype.verify = function verify4(message, sig) {
    return this.eddsa.verify(message, sig, this);
  };
  KeyPair2.prototype.getSecret = function getSecret2(enc) {
    assert2(this._secret, "KeyPair is public only");
    return utils2.encode(this.secret(), enc);
  };
  KeyPair2.prototype.getPublic = function getPublic3(enc) {
    return utils2.encode(this.pubBytes(), enc);
  };
  key$2 = KeyPair2;
  return key$2;
}
var signature$2;
var hasRequiredSignature;
function requireSignature() {
  if (hasRequiredSignature) return signature$2;
  hasRequiredSignature = 1;
  var BN2 = bnExports;
  var utils2 = requireUtils();
  var assert2 = utils2.assert;
  var cachedProperty2 = utils2.cachedProperty;
  var parseBytes2 = utils2.parseBytes;
  function Signature2(eddsa2, sig) {
    this.eddsa = eddsa2;
    if (typeof sig !== "object")
      sig = parseBytes2(sig);
    if (Array.isArray(sig)) {
      sig = {
        R: sig.slice(0, eddsa2.encodingLength),
        S: sig.slice(eddsa2.encodingLength)
      };
    }
    assert2(sig.R && sig.S, "Signature without R or S");
    if (eddsa2.isPoint(sig.R))
      this._R = sig.R;
    if (sig.S instanceof BN2)
      this._S = sig.S;
    this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
    this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
  }
  cachedProperty2(Signature2, "S", function S4() {
    return this.eddsa.decodeInt(this.Sencoded());
  });
  cachedProperty2(Signature2, "R", function R5() {
    return this.eddsa.decodePoint(this.Rencoded());
  });
  cachedProperty2(Signature2, "Rencoded", function Rencoded2() {
    return this.eddsa.encodePoint(this.R());
  });
  cachedProperty2(Signature2, "Sencoded", function Sencoded2() {
    return this.eddsa.encodeInt(this.S());
  });
  Signature2.prototype.toBytes = function toBytes3() {
    return this.Rencoded().concat(this.Sencoded());
  };
  Signature2.prototype.toHex = function toHex3() {
    return utils2.encode(this.toBytes(), "hex").toUpperCase();
  };
  signature$2 = Signature2;
  return signature$2;
}
var eddsa$1;
var hasRequiredEddsa;
function requireEddsa() {
  if (hasRequiredEddsa) return eddsa$1;
  hasRequiredEddsa = 1;
  var hash3 = hash$3;
  var curves2 = requireCurves();
  var utils2 = requireUtils();
  var assert2 = utils2.assert;
  var parseBytes2 = utils2.parseBytes;
  var KeyPair2 = requireKey();
  var Signature2 = requireSignature();
  function EDDSA2(curve2) {
    assert2(curve2 === "ed25519", "only tested with ed25519 so far");
    if (!(this instanceof EDDSA2))
      return new EDDSA2(curve2);
    curve2 = curves2[curve2].curve;
    this.curve = curve2;
    this.g = curve2.g;
    this.g.precompute(curve2.n.bitLength() + 1);
    this.pointClass = curve2.point().constructor;
    this.encodingLength = Math.ceil(curve2.n.bitLength() / 8);
    this.hash = hash3.sha512;
  }
  eddsa$1 = EDDSA2;
  EDDSA2.prototype.sign = function sign5(message, secret2) {
    message = parseBytes2(message);
    var key2 = this.keyFromSecret(secret2);
    var r3 = this.hashInt(key2.messagePrefix(), message);
    var R5 = this.g.mul(r3);
    var Rencoded2 = this.encodePoint(R5);
    var s_ = this.hashInt(Rencoded2, key2.pubBytes(), message).mul(key2.priv());
    var S4 = r3.add(s_).umod(this.curve.n);
    return this.makeSignature({ R: R5, S: S4, Rencoded: Rencoded2 });
  };
  EDDSA2.prototype.verify = function verify4(message, sig, pub2) {
    message = parseBytes2(message);
    sig = this.makeSignature(sig);
    var key2 = this.keyFromPublic(pub2);
    var h5 = this.hashInt(sig.Rencoded(), key2.pubBytes(), message);
    var SG = this.g.mul(sig.S());
    var RplusAh = sig.R().add(key2.pub().mul(h5));
    return RplusAh.eq(SG);
  };
  EDDSA2.prototype.hashInt = function hashInt2() {
    var hash4 = this.hash();
    for (var i4 = 0; i4 < arguments.length; i4++)
      hash4.update(arguments[i4]);
    return utils2.intFromLE(hash4.digest()).umod(this.curve.n);
  };
  EDDSA2.prototype.keyFromPublic = function keyFromPublic2(pub2) {
    return KeyPair2.fromPublic(this, pub2);
  };
  EDDSA2.prototype.keyFromSecret = function keyFromSecret2(secret2) {
    return KeyPair2.fromSecret(this, secret2);
  };
  EDDSA2.prototype.makeSignature = function makeSignature2(sig) {
    if (sig instanceof Signature2)
      return sig;
    return new Signature2(this, sig);
  };
  EDDSA2.prototype.encodePoint = function encodePoint2(point5) {
    var enc = point5.getY().toArray("le", this.encodingLength);
    enc[this.encodingLength - 1] |= point5.getX().isOdd() ? 128 : 0;
    return enc;
  };
  EDDSA2.prototype.decodePoint = function decodePoint4(bytes2) {
    bytes2 = utils2.parseBytes(bytes2);
    var lastIx = bytes2.length - 1;
    var normed = bytes2.slice(0, lastIx).concat(bytes2[lastIx] & -129);
    var xIsOdd = (bytes2[lastIx] & 128) !== 0;
    var y4 = utils2.intFromLE(normed);
    return this.curve.pointFromY(y4, xIsOdd);
  };
  EDDSA2.prototype.encodeInt = function encodeInt2(num) {
    return num.toArray("le", this.encodingLength);
  };
  EDDSA2.prototype.decodeInt = function decodeInt2(bytes2) {
    return utils2.intFromLE(bytes2);
  };
  EDDSA2.prototype.isPoint = function isPoint2(val) {
    return val instanceof this.pointClass;
  };
  return eddsa$1;
}
var hasRequiredElliptic$1;
function requireElliptic$1() {
  if (hasRequiredElliptic$1) return elliptic;
  hasRequiredElliptic$1 = 1;
  (function(exports2) {
    var elliptic2 = exports2;
    elliptic2.version = require$$0.version;
    elliptic2.utils = requireUtils();
    elliptic2.rand = requireBrorand();
    elliptic2.curve = requireCurve();
    elliptic2.curves = requireCurves();
    elliptic2.ec = requireEc$1();
    elliptic2.eddsa = requireEddsa();
  })(elliptic);
  return elliptic;
}
var browser$3;
var hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2) return browser$3;
  hasRequiredBrowser$2 = 1;
  var elliptic2 = requireElliptic$1();
  var BN2 = bnExports;
  browser$3 = function createECDH(curve2) {
    return new ECDH(curve2);
  };
  var aliases = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  aliases.p224 = aliases.secp224r1;
  aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
  aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
  aliases.p384 = aliases.secp384r1;
  aliases.p521 = aliases.secp521r1;
  function ECDH(curve2) {
    this.curveType = aliases[curve2];
    if (!this.curveType) {
      this.curveType = {
        name: curve2
      };
    }
    this.curve = new elliptic2.ec(this.curveType.name);
    this.keys = void 0;
  }
  ECDH.prototype.generateKeys = function(enc, format2) {
    this.keys = this.curve.genKeyPair();
    return this.getPublicKey(enc, format2);
  };
  ECDH.prototype.computeSecret = function(other, inenc, enc) {
    inenc = inenc || "utf8";
    if (!Buffer.isBuffer(other)) {
      other = new Buffer(other, inenc);
    }
    var otherPub = this.curve.keyFromPublic(other).getPublic();
    var out = otherPub.mul(this.keys.getPrivate()).getX();
    return formatReturnValue(out, enc, this.curveType.byteLength);
  };
  ECDH.prototype.getPublicKey = function(enc, format2) {
    var key2 = this.keys.getPublic(format2 === "compressed", true);
    if (format2 === "hybrid") {
      if (key2[key2.length - 1] % 2) {
        key2[0] = 7;
      } else {
        key2[0] = 6;
      }
    }
    return formatReturnValue(key2, enc);
  };
  ECDH.prototype.getPrivateKey = function(enc) {
    return formatReturnValue(this.keys.getPrivate(), enc);
  };
  ECDH.prototype.setPublicKey = function(pub2, enc) {
    enc = enc || "utf8";
    if (!Buffer.isBuffer(pub2)) {
      pub2 = new Buffer(pub2, enc);
    }
    this.keys._importPublic(pub2);
    return this;
  };
  ECDH.prototype.setPrivateKey = function(priv2, enc) {
    enc = enc || "utf8";
    if (!Buffer.isBuffer(priv2)) {
      priv2 = new Buffer(priv2, enc);
    }
    var _priv = new BN2(priv2);
    _priv = _priv.toString(16);
    this.keys = this.curve.genKeyPair();
    this.keys._importPrivate(_priv);
    return this;
  };
  function formatReturnValue(bn2, enc, len2) {
    if (!Array.isArray(bn2)) {
      bn2 = bn2.toArray();
    }
    var buf = new Buffer(bn2);
    if (len2 && buf.length < len2) {
      var zeros2 = new Buffer(len2 - buf.length);
      zeros2.fill(0);
      buf = Buffer.concat([zeros2, buf]);
    }
    if (!enc) {
      return buf;
    } else {
      return buf.toString(enc);
    }
  }
  return browser$3;
}
var browser$2 = {};
var mgf;
var hasRequiredMgf;
function requireMgf() {
  if (hasRequiredMgf) return mgf;
  hasRequiredMgf = 1;
  var createHash2 = requireBrowser$9();
  var Buffer2 = requireSafeBuffer$1().Buffer;
  mgf = function(seed, len2) {
    var t2 = Buffer2.alloc(0);
    var i4 = 0;
    var c2;
    while (t2.length < len2) {
      c2 = i2ops(i4++);
      t2 = Buffer2.concat([t2, createHash2("sha1").update(seed).update(c2).digest()]);
    }
    return t2.slice(0, len2);
  };
  function i2ops(c2) {
    var out = Buffer2.allocUnsafe(4);
    out.writeUInt32BE(c2, 0);
    return out;
  }
  return mgf;
}
var xor;
var hasRequiredXor;
function requireXor() {
  if (hasRequiredXor) return xor;
  hasRequiredXor = 1;
  xor = function xor2(a2, b2) {
    var len2 = a2.length;
    var i4 = -1;
    while (++i4 < len2) {
      a2[i4] ^= b2[i4];
    }
    return a2;
  };
  return xor;
}
var withPublic_1;
var hasRequiredWithPublic;
function requireWithPublic() {
  if (hasRequiredWithPublic) return withPublic_1;
  hasRequiredWithPublic = 1;
  var BN2 = bnExports;
  var Buffer2 = requireSafeBuffer$1().Buffer;
  function withPublic(paddedMsg, key2) {
    return Buffer2.from(paddedMsg.toRed(BN2.mont(key2.modulus)).redPow(new BN2(key2.publicExponent)).fromRed().toArray());
  }
  withPublic_1 = withPublic;
  return withPublic_1;
}
var publicEncrypt;
var hasRequiredPublicEncrypt;
function requirePublicEncrypt() {
  if (hasRequiredPublicEncrypt) return publicEncrypt;
  hasRequiredPublicEncrypt = 1;
  var parseKeys = requireParseAsn1();
  var randomBytes2 = requireBrowser$b();
  var createHash2 = requireBrowser$9();
  var mgf2 = requireMgf();
  var xor2 = requireXor();
  var BN2 = bnExports;
  var withPublic = requireWithPublic();
  var crt = requireBrowserifyRsa();
  var Buffer2 = requireSafeBuffer$1().Buffer;
  publicEncrypt = function publicEncrypt2(publicKey, msg, reverse) {
    var padding2;
    if (publicKey.padding) {
      padding2 = publicKey.padding;
    } else if (reverse) {
      padding2 = 1;
    } else {
      padding2 = 4;
    }
    var key2 = parseKeys(publicKey);
    var paddedMsg;
    if (padding2 === 4) {
      paddedMsg = oaep(key2, msg);
    } else if (padding2 === 1) {
      paddedMsg = pkcs1(key2, msg, reverse);
    } else if (padding2 === 3) {
      paddedMsg = new BN2(msg);
      if (paddedMsg.cmp(key2.modulus) >= 0) {
        throw new Error("data too long for modulus");
      }
    } else {
      throw new Error("unknown padding");
    }
    if (reverse) {
      return crt(paddedMsg, key2);
    } else {
      return withPublic(paddedMsg, key2);
    }
  };
  function oaep(key2, msg) {
    var k3 = key2.modulus.byteLength();
    var mLen = msg.length;
    var iHash = createHash2("sha1").update(Buffer2.alloc(0)).digest();
    var hLen = iHash.length;
    var hLen2 = 2 * hLen;
    if (mLen > k3 - hLen2 - 2) {
      throw new Error("message too long");
    }
    var ps2 = Buffer2.alloc(k3 - mLen - hLen2 - 2);
    var dblen = k3 - hLen - 1;
    var seed = randomBytes2(hLen);
    var maskedDb = xor2(Buffer2.concat([iHash, ps2, Buffer2.alloc(1, 1), msg], dblen), mgf2(seed, dblen));
    var maskedSeed = xor2(seed, mgf2(maskedDb, hLen));
    return new BN2(Buffer2.concat([Buffer2.alloc(1), maskedSeed, maskedDb], k3));
  }
  function pkcs1(key2, msg, reverse) {
    var mLen = msg.length;
    var k3 = key2.modulus.byteLength();
    if (mLen > k3 - 11) {
      throw new Error("message too long");
    }
    var ps2;
    if (reverse) {
      ps2 = Buffer2.alloc(k3 - mLen - 3, 255);
    } else {
      ps2 = nonZero(k3 - mLen - 3);
    }
    return new BN2(Buffer2.concat([Buffer2.from([0, reverse ? 1 : 2]), ps2, Buffer2.alloc(1), msg], k3));
  }
  function nonZero(len2) {
    var out = Buffer2.allocUnsafe(len2);
    var i4 = 0;
    var cache = randomBytes2(len2 * 2);
    var cur = 0;
    var num;
    while (i4 < len2) {
      if (cur === cache.length) {
        cache = randomBytes2(len2 * 2);
        cur = 0;
      }
      num = cache[cur++];
      if (num) {
        out[i4++] = num;
      }
    }
    return out;
  }
  return publicEncrypt;
}
var privateDecrypt;
var hasRequiredPrivateDecrypt;
function requirePrivateDecrypt() {
  if (hasRequiredPrivateDecrypt) return privateDecrypt;
  hasRequiredPrivateDecrypt = 1;
  var parseKeys = requireParseAsn1();
  var mgf2 = requireMgf();
  var xor2 = requireXor();
  var BN2 = bnExports;
  var crt = requireBrowserifyRsa();
  var createHash2 = requireBrowser$9();
  var withPublic = requireWithPublic();
  var Buffer2 = requireSafeBuffer$1().Buffer;
  privateDecrypt = function privateDecrypt2(privateKey, enc, reverse) {
    var padding2;
    if (privateKey.padding) {
      padding2 = privateKey.padding;
    } else if (reverse) {
      padding2 = 1;
    } else {
      padding2 = 4;
    }
    var key2 = parseKeys(privateKey);
    var k3 = key2.modulus.byteLength();
    if (enc.length > k3 || new BN2(enc).cmp(key2.modulus) >= 0) {
      throw new Error("decryption error");
    }
    var msg;
    if (reverse) {
      msg = withPublic(new BN2(enc), key2);
    } else {
      msg = crt(enc, key2);
    }
    var zBuffer = Buffer2.alloc(k3 - msg.length);
    msg = Buffer2.concat([zBuffer, msg], k3);
    if (padding2 === 4) {
      return oaep(key2, msg);
    } else if (padding2 === 1) {
      return pkcs1(key2, msg, reverse);
    } else if (padding2 === 3) {
      return msg;
    } else {
      throw new Error("unknown padding");
    }
  };
  function oaep(key2, msg) {
    var k3 = key2.modulus.byteLength();
    var iHash = createHash2("sha1").update(Buffer2.alloc(0)).digest();
    var hLen = iHash.length;
    if (msg[0] !== 0) {
      throw new Error("decryption error");
    }
    var maskedSeed = msg.slice(1, hLen + 1);
    var maskedDb = msg.slice(hLen + 1);
    var seed = xor2(maskedSeed, mgf2(maskedDb, hLen));
    var db = xor2(maskedDb, mgf2(seed, k3 - hLen - 1));
    if (compare(iHash, db.slice(0, hLen))) {
      throw new Error("decryption error");
    }
    var i4 = hLen;
    while (db[i4] === 0) {
      i4++;
    }
    if (db[i4++] !== 1) {
      throw new Error("decryption error");
    }
    return db.slice(i4);
  }
  function pkcs1(key2, msg, reverse) {
    var p1 = msg.slice(0, 2);
    var i4 = 2;
    var status = 0;
    while (msg[i4++] !== 0) {
      if (i4 >= msg.length) {
        status++;
        break;
      }
    }
    var ps2 = msg.slice(2, i4 - 1);
    if (p1.toString("hex") !== "0002" && !reverse || p1.toString("hex") !== "0001" && reverse) {
      status++;
    }
    if (ps2.length < 8) {
      status++;
    }
    if (status) {
      throw new Error("decryption error");
    }
    return msg.slice(i4);
  }
  function compare(a2, b2) {
    a2 = Buffer2.from(a2);
    b2 = Buffer2.from(b2);
    var dif = 0;
    var len2 = a2.length;
    if (a2.length !== b2.length) {
      dif++;
      len2 = Math.min(a2.length, b2.length);
    }
    var i4 = -1;
    while (++i4 < len2) {
      dif += a2[i4] ^ b2[i4];
    }
    return dif;
  }
  return privateDecrypt;
}
var hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1) return browser$2;
  hasRequiredBrowser$1 = 1;
  (function(exports2) {
    exports2.publicEncrypt = requirePublicEncrypt();
    exports2.privateDecrypt = requirePrivateDecrypt();
    exports2.privateEncrypt = function privateEncrypt(key2, buf) {
      return exports2.publicEncrypt(key2, buf, true);
    };
    exports2.publicDecrypt = function publicDecrypt(key2, buf) {
      return exports2.privateDecrypt(key2, buf, true);
    };
  })(browser$2);
  return browser$2;
}
var browser$1 = {};
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser$1;
  hasRequiredBrowser = 1;
  function oldBrowser() {
    throw new Error("secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11");
  }
  var safeBuffer2 = requireSafeBuffer$1();
  var randombytes = requireBrowser$b();
  var Buffer2 = safeBuffer2.Buffer;
  var kBufferMaxLength = safeBuffer2.kMaxLength;
  var crypto2 = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
  var kMaxUint32 = Math.pow(2, 32) - 1;
  function assertOffset(offset, length) {
    if (typeof offset !== "number" || offset !== offset) {
      throw new TypeError("offset must be a number");
    }
    if (offset > kMaxUint32 || offset < 0) {
      throw new TypeError("offset must be a uint32");
    }
    if (offset > kBufferMaxLength || offset > length) {
      throw new RangeError("offset out of range");
    }
  }
  function assertSize2(size2, offset, length) {
    if (typeof size2 !== "number" || size2 !== size2) {
      throw new TypeError("size must be a number");
    }
    if (size2 > kMaxUint32 || size2 < 0) {
      throw new TypeError("size must be a uint32");
    }
    if (size2 + offset > length || size2 > kBufferMaxLength) {
      throw new RangeError("buffer too small");
    }
  }
  if (crypto2 && crypto2.getRandomValues || !process$1.browser) {
    browser$1.randomFill = randomFill;
    browser$1.randomFillSync = randomFillSync;
  } else {
    browser$1.randomFill = oldBrowser;
    browser$1.randomFillSync = oldBrowser;
  }
  function randomFill(buf, offset, size2, cb) {
    if (!Buffer2.isBuffer(buf) && !(buf instanceof commonjsGlobal.Uint8Array)) {
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    }
    if (typeof offset === "function") {
      cb = offset;
      offset = 0;
      size2 = buf.length;
    } else if (typeof size2 === "function") {
      cb = size2;
      size2 = buf.length - offset;
    } else if (typeof cb !== "function") {
      throw new TypeError('"cb" argument must be a function');
    }
    assertOffset(offset, buf.length);
    assertSize2(size2, offset, buf.length);
    return actualFill(buf, offset, size2, cb);
  }
  function actualFill(buf, offset, size2, cb) {
    if (process$1.browser) {
      var ourBuf = buf.buffer;
      var uint = new Uint8Array(ourBuf, offset, size2);
      crypto2.getRandomValues(uint);
      if (cb) {
        process$1.nextTick(function() {
          cb(null, buf);
        });
        return;
      }
      return buf;
    }
    if (cb) {
      randombytes(size2, function(err, bytes3) {
        if (err) {
          return cb(err);
        }
        bytes3.copy(buf, offset);
        cb(null, buf);
      });
      return;
    }
    var bytes2 = randombytes(size2);
    bytes2.copy(buf, offset);
    return buf;
  }
  function randomFillSync(buf, offset, size2) {
    if (typeof offset === "undefined") {
      offset = 0;
    }
    if (!Buffer2.isBuffer(buf) && !(buf instanceof commonjsGlobal.Uint8Array)) {
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    }
    assertOffset(offset, buf.length);
    if (size2 === void 0) size2 = buf.length - offset;
    assertSize2(size2, offset, buf.length);
    return actualFill(buf, offset, size2);
  }
  return browser$1;
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify) return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1;
  cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = requireBrowser$b();
  cryptoBrowserify.createHash = cryptoBrowserify.Hash = requireBrowser$9();
  cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = requireBrowser$8();
  var algos2 = requireAlgos();
  var algoKeys = Object.keys(algos2);
  var hashes = [
    "sha1",
    "sha224",
    "sha256",
    "sha384",
    "sha512",
    "md5",
    "rmd160"
  ].concat(algoKeys);
  cryptoBrowserify.getHashes = function() {
    return hashes;
  };
  var p2 = requireBrowser$7();
  cryptoBrowserify.pbkdf2 = p2.pbkdf2;
  cryptoBrowserify.pbkdf2Sync = p2.pbkdf2Sync;
  var aes2 = requireBrowser$5();
  cryptoBrowserify.Cipher = aes2.Cipher;
  cryptoBrowserify.createCipher = aes2.createCipher;
  cryptoBrowserify.Cipheriv = aes2.Cipheriv;
  cryptoBrowserify.createCipheriv = aes2.createCipheriv;
  cryptoBrowserify.Decipher = aes2.Decipher;
  cryptoBrowserify.createDecipher = aes2.createDecipher;
  cryptoBrowserify.Decipheriv = aes2.Decipheriv;
  cryptoBrowserify.createDecipheriv = aes2.createDecipheriv;
  cryptoBrowserify.getCiphers = aes2.getCiphers;
  cryptoBrowserify.listCiphers = aes2.listCiphers;
  var dh2 = requireBrowser$4();
  cryptoBrowserify.DiffieHellmanGroup = dh2.DiffieHellmanGroup;
  cryptoBrowserify.createDiffieHellmanGroup = dh2.createDiffieHellmanGroup;
  cryptoBrowserify.getDiffieHellman = dh2.getDiffieHellman;
  cryptoBrowserify.createDiffieHellman = dh2.createDiffieHellman;
  cryptoBrowserify.DiffieHellman = dh2.DiffieHellman;
  var sign5 = requireBrowser$3();
  cryptoBrowserify.createSign = sign5.createSign;
  cryptoBrowserify.Sign = sign5.Sign;
  cryptoBrowserify.createVerify = sign5.createVerify;
  cryptoBrowserify.Verify = sign5.Verify;
  cryptoBrowserify.createECDH = requireBrowser$2();
  var publicEncrypt2 = requireBrowser$1();
  cryptoBrowserify.publicEncrypt = publicEncrypt2.publicEncrypt;
  cryptoBrowserify.privateEncrypt = publicEncrypt2.privateEncrypt;
  cryptoBrowserify.publicDecrypt = publicEncrypt2.publicDecrypt;
  cryptoBrowserify.privateDecrypt = publicEncrypt2.privateDecrypt;
  var rf = requireBrowser();
  cryptoBrowserify.randomFill = rf.randomFill;
  cryptoBrowserify.randomFillSync = rf.randomFillSync;
  cryptoBrowserify.createCredentials = function() {
    throw new Error("sorry, createCredentials is not implemented yet\nwe accept pull requests\nhttps://github.com/browserify/crypto-browserify");
  };
  cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  };
  return cryptoBrowserify;
}
var hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand) return brorand.exports;
  hasRequiredBrorand = 1;
  var r3;
  brorand.exports = function rand(len2) {
    if (!r3)
      r3 = new Rand(null);
    return r3.generate(len2);
  };
  function Rand(rand) {
    this.rand = rand;
  }
  brorand.exports.Rand = Rand;
  Rand.prototype.generate = function generate2(len2) {
    return this._rand(len2);
  };
  Rand.prototype._rand = function _rand(n5) {
    if (this.rand.getBytes)
      return this.rand.getBytes(n5);
    var res = new Uint8Array(n5);
    for (var i4 = 0; i4 < res.length; i4++)
      res[i4] = this.rand.getByte();
    return res;
  };
  if (typeof self === "object") {
    if (self.crypto && self.crypto.getRandomValues) {
      Rand.prototype._rand = function _rand(n5) {
        var arr = new Uint8Array(n5);
        self.crypto.getRandomValues(arr);
        return arr;
      };
    } else if (self.msCrypto && self.msCrypto.getRandomValues) {
      Rand.prototype._rand = function _rand(n5) {
        var arr = new Uint8Array(n5);
        self.msCrypto.getRandomValues(arr);
        return arr;
      };
    } else if (typeof window === "object") {
      Rand.prototype._rand = function() {
        throw new Error("Not implemented yet");
      };
    }
  } else {
    try {
      var crypto2 = requireCryptoBrowserify();
      if (typeof crypto2.randomBytes !== "function")
        throw new Error("Not supported");
      Rand.prototype._rand = function _rand(n5) {
        return crypto2.randomBytes(n5);
      };
    } catch (e3) {
    }
  }
  return brorand.exports;
}
var curve = {};
var BN$6 = bnExports;
var utils$a = utils$p;
var getNAF = utils$a.getNAF;
var getJSF = utils$a.getJSF;
var assert$8 = utils$a.assert;
function BaseCurve(type2, conf) {
  this.type = type2;
  this.p = new BN$6(conf.p, 16);
  this.red = conf.prime ? BN$6.red(conf.prime) : BN$6.mont(this.p);
  this.zero = new BN$6(0).toRed(this.red);
  this.one = new BN$6(1).toRed(this.red);
  this.two = new BN$6(2).toRed(this.red);
  this.n = conf.n && new BN$6(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base$1 = BaseCurve;
BaseCurve.prototype.point = function point() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function validate() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p2, k3) {
  assert$8(p2.precomputed);
  var doubles = p2._getDoubles();
  var naf = getNAF(k3, 1, this._bitLength);
  var I4 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I4 /= 3;
  var repr = [];
  var j2;
  var nafW;
  for (j2 = 0; j2 < naf.length; j2 += doubles.step) {
    nafW = 0;
    for (var l2 = j2 + doubles.step - 1; l2 >= j2; l2--)
      nafW = (nafW << 1) + naf[l2];
    repr.push(nafW);
  }
  var a2 = this.jpoint(null, null, null);
  var b2 = this.jpoint(null, null, null);
  for (var i4 = I4; i4 > 0; i4--) {
    for (j2 = 0; j2 < repr.length; j2++) {
      nafW = repr[j2];
      if (nafW === i4)
        b2 = b2.mixedAdd(doubles.points[j2]);
      else if (nafW === -i4)
        b2 = b2.mixedAdd(doubles.points[j2].neg());
    }
    a2 = a2.add(b2);
  }
  return a2.toP();
};
BaseCurve.prototype._wnafMul = function _wnafMul(p2, k3) {
  var w2 = 4;
  var nafPoints = p2._getNAFPoints(w2);
  w2 = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF(k3, w2, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i4 = naf.length - 1; i4 >= 0; i4--) {
    for (var l2 = 0; i4 >= 0 && naf[i4] === 0; i4--)
      l2++;
    if (i4 >= 0)
      l2++;
    acc = acc.dblp(l2);
    if (i4 < 0)
      break;
    var z3 = naf[i4];
    assert$8(z3 !== 0);
    if (p2.type === "affine") {
      if (z3 > 0)
        acc = acc.mixedAdd(wnd[z3 - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z3 - 1 >> 1].neg());
    } else {
      if (z3 > 0)
        acc = acc.add(wnd[z3 - 1 >> 1]);
      else
        acc = acc.add(wnd[-z3 - 1 >> 1].neg());
    }
  }
  return p2.type === "affine" ? acc.toP() : acc;
};
BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len2, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max2 = 0;
  var i4;
  var j2;
  var p2;
  for (i4 = 0; i4 < len2; i4++) {
    p2 = points[i4];
    var nafPoints = p2._getNAFPoints(defW);
    wndWidth[i4] = nafPoints.wnd;
    wnd[i4] = nafPoints.points;
  }
  for (i4 = len2 - 1; i4 >= 1; i4 -= 2) {
    var a2 = i4 - 1;
    var b2 = i4;
    if (wndWidth[a2] !== 1 || wndWidth[b2] !== 1) {
      naf[a2] = getNAF(coeffs[a2], wndWidth[a2], this._bitLength);
      naf[b2] = getNAF(coeffs[b2], wndWidth[b2], this._bitLength);
      max2 = Math.max(naf[a2].length, max2);
      max2 = Math.max(naf[b2].length, max2);
      continue;
    }
    var comb = [
      points[a2],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      points[b2]
      /* 7 */
    ];
    if (points[a2].y.cmp(points[b2].y) === 0) {
      comb[1] = points[a2].add(points[b2]);
      comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
    } else if (points[a2].y.cmp(points[b2].y.redNeg()) === 0) {
      comb[1] = points[a2].toJ().mixedAdd(points[b2]);
      comb[2] = points[a2].add(points[b2].neg());
    } else {
      comb[1] = points[a2].toJ().mixedAdd(points[b2]);
      comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
    }
    var index2 = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ];
    var jsf = getJSF(coeffs[a2], coeffs[b2]);
    max2 = Math.max(jsf[0].length, max2);
    naf[a2] = new Array(max2);
    naf[b2] = new Array(max2);
    for (j2 = 0; j2 < max2; j2++) {
      var ja2 = jsf[0][j2] | 0;
      var jb = jsf[1][j2] | 0;
      naf[a2][j2] = index2[(ja2 + 1) * 3 + (jb + 1)];
      naf[b2][j2] = 0;
      wnd[a2] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i4 = max2; i4 >= 0; i4--) {
    var k3 = 0;
    while (i4 >= 0) {
      var zero = true;
      for (j2 = 0; j2 < len2; j2++) {
        tmp[j2] = naf[j2][i4] | 0;
        if (tmp[j2] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k3++;
      i4--;
    }
    if (i4 >= 0)
      k3++;
    acc = acc.dblp(k3);
    if (i4 < 0)
      break;
    for (j2 = 0; j2 < len2; j2++) {
      var z3 = tmp[j2];
      if (z3 === 0)
        continue;
      else if (z3 > 0)
        p2 = wnd[j2][z3 - 1 >> 1];
      else if (z3 < 0)
        p2 = wnd[j2][-z3 - 1 >> 1].neg();
      if (p2.type === "affine")
        acc = acc.mixedAdd(p2);
      else
        acc = acc.add(p2);
    }
  }
  for (i4 = 0; i4 < len2; i4++)
    wnd[i4] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint(curve2, type2) {
  this.curve = curve2;
  this.type = type2;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function eq() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function validate2() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function decodePoint(bytes2, enc) {
  bytes2 = utils$a.toArray(bytes2, enc);
  var len2 = this.p.byteLength();
  if ((bytes2[0] === 4 || bytes2[0] === 6 || bytes2[0] === 7) && bytes2.length - 1 === 2 * len2) {
    if (bytes2[0] === 6)
      assert$8(bytes2[bytes2.length - 1] % 2 === 0);
    else if (bytes2[0] === 7)
      assert$8(bytes2[bytes2.length - 1] % 2 === 1);
    var res = this.point(
      bytes2.slice(1, 1 + len2),
      bytes2.slice(1 + len2, 1 + 2 * len2)
    );
    return res;
  } else if ((bytes2[0] === 2 || bytes2[0] === 3) && bytes2.length - 1 === len2) {
    return this.pointFromX(bytes2.slice(1, 1 + len2), bytes2[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};
BasePoint.prototype._encode = function _encode2(compact) {
  var len2 = this.curve.p.byteLength();
  var x2 = this.getX().toArray("be", len2);
  if (compact)
    return [this.getY().isEven() ? 2 : 3].concat(x2);
  return [4].concat(x2, this.getY().toArray("be", len2));
};
BasePoint.prototype.encode = function encode2(enc, compact) {
  return utils$a.encode(this._encode(compact), enc);
};
BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint.prototype._hasDoubles = function _hasDoubles(k3) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k3.bitLength() + 1) / doubles.step);
};
BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i4 = 0; i4 < power; i4 += step) {
    for (var j2 = 0; j2 < step; j2++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max2 = (1 << wnd) - 1;
  var dbl5 = max2 === 1 ? null : this.dbl();
  for (var i4 = 1; i4 < max2; i4++)
    res[i4] = res[i4 - 1].add(dbl5);
  return {
    wnd,
    points: res
  };
};
BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};
BasePoint.prototype.dblp = function dblp(k3) {
  var r3 = this;
  for (var i4 = 0; i4 < k3; i4++)
    r3 = r3.dbl();
  return r3;
};
var utils$9 = utils$p;
var BN$5 = bnExports;
var inherits$2 = inherits_browserExports;
var Base$2 = base$1;
var assert$7 = utils$9.assert;
function ShortCurve(conf) {
  Base$2.call(this, "short", conf);
  this.a = new BN$5(conf.a, 16).toRed(this.red);
  this.b = new BN$5(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits$2(ShortCurve, Base$2);
var short = ShortCurve;
ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN$5(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN$5(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$7(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN$5(vec.a, 16),
        b: new BN$5(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  var red = num === this.p ? this.red : BN$5.mont(num);
  var tinv = new BN$5(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s2 = new BN$5(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s2).fromRed();
  var l2 = ntinv.redSub(s2).fromRed();
  return [l1, l2];
};
ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u2 = lambda;
  var v2 = this.n.clone();
  var x1 = new BN$5(1);
  var y1 = new BN$5(0);
  var x2 = new BN$5(0);
  var y22 = new BN$5(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a2;
  var b2;
  var prevR;
  var i4 = 0;
  var r3;
  var x3;
  while (u2.cmpn(0) !== 0) {
    var q2 = v2.div(u2);
    r3 = v2.sub(q2.mul(u2));
    x3 = x2.sub(q2.mul(x1));
    var y4 = y22.sub(q2.mul(y1));
    if (!a1 && r3.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r3.neg();
      b1 = x3;
    } else if (a1 && ++i4 === 2) {
      break;
    }
    prevR = r3;
    v2 = u2;
    u2 = r3;
    x2 = x1;
    x1 = x3;
    y22 = y1;
    y1 = y4;
  }
  a2 = r3.neg();
  b2 = x3;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};
ShortCurve.prototype._endoSplit = function _endoSplit(k3) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k3).divRound(this.n);
  var c2 = v1.b.neg().mul(k3).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);
  var k1 = k3.sub(p1).sub(p2);
  var k22 = q1.add(q2).neg();
  return { k1, k2: k22 };
};
ShortCurve.prototype.pointFromX = function pointFromX(x2, odd) {
  x2 = new BN$5(x2, 16);
  if (!x2.red)
    x2 = x2.toRed(this.red);
  var y22 = x2.redSqr().redMul(x2).redIAdd(x2.redMul(this.a)).redIAdd(this.b);
  var y4 = y22.redSqrt();
  if (y4.redSqr().redSub(y22).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y4.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y4 = y4.redNeg();
  return this.point(x2, y4);
};
ShortCurve.prototype.validate = function validate3(point5) {
  if (point5.inf)
    return true;
  var x2 = point5.x;
  var y4 = point5.y;
  var ax = this.a.redMul(x2);
  var rhs = x2.redSqr().redMul(x2).redIAdd(ax).redIAdd(this.b);
  return y4.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i4 = 0; i4 < points.length; i4++) {
    var split2 = this._endoSplit(coeffs[i4]);
    var p2 = points[i4];
    var beta = p2._getBeta();
    if (split2.k1.negative) {
      split2.k1.ineg();
      p2 = p2.neg(true);
    }
    if (split2.k2.negative) {
      split2.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i4 * 2] = p2;
    npoints[i4 * 2 + 1] = beta;
    ncoeffs[i4 * 2] = split2.k1;
    ncoeffs[i4 * 2 + 1] = split2.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i4 * 2, jacobianResult);
  for (var j2 = 0; j2 < i4 * 2; j2++) {
    npoints[j2] = null;
    ncoeffs[j2] = null;
  }
  return res;
};
function Point$2(curve2, x2, y4, isRed) {
  Base$2.BasePoint.call(this, curve2, "affine");
  if (x2 === null && y4 === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN$5(x2, 16);
    this.y = new BN$5(y4, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits$2(Point$2, Base$2.BasePoint);
ShortCurve.prototype.point = function point2(x2, y4, isRed) {
  return new Point$2(this, x2, y4, isRed);
};
ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point$2.fromJSON(this, obj, red);
};
Point$2.prototype._getBeta = function _getBeta2() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve2 = this.curve;
    var endoMul = function(p2) {
      return curve2.point(p2.x.redMul(curve2.endo.beta), p2.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point$2.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point$2.fromJSON = function fromJSON(curve2, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve2.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve2.point(obj2[0], obj2[1], red);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point$2.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point$2.prototype.isInfinity = function isInfinity() {
  return this.inf;
};
Point$2.prototype.add = function add2(p2) {
  if (this.inf)
    return p2;
  if (p2.inf)
    return this;
  if (this.eq(p2))
    return this.dbl();
  if (this.neg().eq(p2))
    return this.curve.point(null, null);
  if (this.x.cmp(p2.x) === 0)
    return this.curve.point(null, null);
  var c2 = this.y.redSub(p2.y);
  if (c2.cmpn(0) !== 0)
    c2 = c2.redMul(this.x.redSub(p2.x).redInvm());
  var nx = c2.redSqr().redISub(this.x).redISub(p2.x);
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point$2.prototype.dbl = function dbl() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a2 = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c2 = x2.redAdd(x2).redIAdd(x2).redIAdd(a2).redMul(dyinv);
  var nx = c2.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point$2.prototype.getX = function getX() {
  return this.x.fromRed();
};
Point$2.prototype.getY = function getY() {
  return this.y.fromRed();
};
Point$2.prototype.mul = function mul(k3) {
  k3 = new BN$5(k3, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k3))
    return this.curve._fixedNafMul(this, k3);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k3]);
  else
    return this.curve._wnafMul(this, k3);
};
Point$2.prototype.mulAdd = function mulAdd(k1, p2, k22) {
  var points = [this, p2];
  var coeffs = [k1, k22];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point$2.prototype.jmulAdd = function jmulAdd(k1, p2, k22) {
  var points = [this, p2];
  var coeffs = [k1, k22];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point$2.prototype.eq = function eq2(p2) {
  return this === p2 || this.inf === p2.inf && (this.inf || this.x.cmp(p2.x) === 0 && this.y.cmp(p2.y) === 0);
};
Point$2.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p2) {
      return p2.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};
Point$2.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint(curve2, x2, y4, z3) {
  Base$2.BasePoint.call(this, curve2, "jacobian");
  if (x2 === null && y4 === null && z3 === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN$5(0);
  } else {
    this.x = new BN$5(x2, 16);
    this.y = new BN$5(y4, 16);
    this.z = new BN$5(z3, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits$2(JPoint, Base$2.BasePoint);
ShortCurve.prototype.jpoint = function jpoint(x2, y4, z3) {
  return new JPoint(this, x2, y4, z3);
};
JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint.prototype.neg = function neg2() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function add3(p2) {
  if (this.isInfinity())
    return p2;
  if (p2.isInfinity())
    return this;
  var pz2 = p2.z.redSqr();
  var z22 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p2.x.redMul(z22);
  var s1 = this.y.redMul(pz2.redMul(p2.z));
  var s2 = p2.y.redMul(z22.redMul(this.z));
  var h5 = u1.redSub(u2);
  var r3 = s1.redSub(s2);
  if (h5.cmpn(0) === 0) {
    if (r3.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h5.redSqr();
  var h32 = h22.redMul(h5);
  var v2 = u1.redMul(h22);
  var nx = r3.redSqr().redIAdd(h32).redISub(v2).redISub(v2);
  var ny = r3.redMul(v2.redISub(nx)).redISub(s1.redMul(h32));
  var nz = this.z.redMul(p2.z).redMul(h5);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mixedAdd = function mixedAdd(p2) {
  if (this.isInfinity())
    return p2.toJ();
  if (p2.isInfinity())
    return this;
  var z22 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p2.x.redMul(z22);
  var s1 = this.y;
  var s2 = p2.y.redMul(z22).redMul(this.z);
  var h5 = u1.redSub(u2);
  var r3 = s1.redSub(s2);
  if (h5.cmpn(0) === 0) {
    if (r3.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h5.redSqr();
  var h32 = h22.redMul(h5);
  var v2 = u1.redMul(h22);
  var nx = r3.redSqr().redIAdd(h32).redISub(v2).redISub(v2);
  var ny = r3.redMul(v2.redISub(nx)).redISub(s1.redMul(h32));
  var nz = this.z.redMul(h5);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.dblp = function dblp2(pow3) {
  if (pow3 === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow3)
    return this.dbl();
  var i4;
  if (this.curve.zeroA || this.curve.threeA) {
    var r3 = this;
    for (i4 = 0; i4 < pow3; i4++)
      r3 = r3.dbl();
    return r3;
  }
  var a2 = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i4 = 0; i4 < pow3; i4++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c2.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c2.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i4 + 1 < pow3)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint.prototype.dbl = function dbl2() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m4 = xx.redAdd(xx).redIAdd(xx);
    var t2 = m4.redSqr().redISub(s2).redISub(s2);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t2;
    ny = m4.redMul(s2.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a2 = this.x.redSqr();
    var b2 = this.y.redSqr();
    var c2 = b2.redSqr();
    var d4 = this.x.redAdd(b2).redSqr().redISub(a2).redISub(c2);
    d4 = d4.redIAdd(d4);
    var e3 = a2.redAdd(a2).redIAdd(a2);
    var f6 = e3.redSqr();
    var c8 = c2.redIAdd(c2);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f6.redISub(d4).redISub(d4);
    ny = e3.redMul(d4.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m4 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t2 = m4.redSqr().redISub(s2).redISub(s2);
    nx = t2;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m4.redMul(s2.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._dbl = function _dbl() {
  var a2 = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c2.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c2.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m4 = xx.redAdd(xx).redIAdd(xx);
  var mm = m4.redSqr();
  var e3 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e3 = e3.redIAdd(e3);
  e3 = e3.redAdd(e3).redIAdd(e3);
  e3 = e3.redISub(mm);
  var ee2 = e3.redSqr();
  var t2 = yyyy.redIAdd(yyyy);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  var u2 = m4.redIAdd(e3).redSqr().redISub(mm).redISub(ee2).redISub(t2);
  var yyu4 = yy.redMul(u2);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee2).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u2.redMul(t2.redISub(u2)).redISub(e3.redMul(ee2)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e3).redSqr().redISub(zz).redISub(ee2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mul = function mul2(k3, kbase) {
  k3 = new BN$5(k3, kbase);
  return this.curve._wnafMul(this, k3);
};
JPoint.prototype.eq = function eq3(p2) {
  if (p2.type === "affine")
    return this.eq(p2.toJ());
  if (this === p2)
    return true;
  var z22 = this.z.redSqr();
  var pz2 = p2.z.redSqr();
  if (this.x.redMul(pz2).redISub(p2.x.redMul(z22)).cmpn(0) !== 0)
    return false;
  var z3 = z22.redMul(this.z);
  var pz3 = pz2.redMul(p2.z);
  return this.y.redMul(pz3).redISub(p2.y.redMul(z3)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function eqXToP(x2) {
  var zs2 = this.z.redSqr();
  var rx = x2.toRed(this.curve.red).redMul(zs2);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc3 = x2.clone();
  var t2 = this.curve.redN.redMul(zs2);
  for (; ; ) {
    xc3.iadd(this.curve.n);
    if (xc3.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t2);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint.prototype.inspect = function inspect2() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function isInfinity2() {
  return this.z.cmpn(0) === 0;
};
var BN$4 = bnExports;
var inherits$1 = inherits_browserExports;
var Base$1 = base$1;
var utils$8 = utils$p;
function MontCurve(conf) {
  Base$1.call(this, "mont", conf);
  this.a = new BN$4(conf.a, 16).toRed(this.red);
  this.b = new BN$4(conf.b, 16).toRed(this.red);
  this.i4 = new BN$4(4).toRed(this.red).redInvm();
  this.two = new BN$4(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits$1(MontCurve, Base$1);
var mont = MontCurve;
MontCurve.prototype.validate = function validate4(point5) {
  var x2 = point5.normalize().x;
  var x22 = x2.redSqr();
  var rhs = x22.redMul(x2).redAdd(x22.redMul(this.a)).redAdd(x2);
  var y4 = rhs.redSqrt();
  return y4.redSqr().cmp(rhs) === 0;
};
function Point$1(curve2, x2, z3) {
  Base$1.BasePoint.call(this, curve2, "projective");
  if (x2 === null && z3 === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN$4(x2, 16);
    this.z = new BN$4(z3, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits$1(Point$1, Base$1.BasePoint);
MontCurve.prototype.decodePoint = function decodePoint2(bytes2, enc) {
  return this.point(utils$8.toArray(bytes2, enc), 1);
};
MontCurve.prototype.point = function point3(x2, z3) {
  return new Point$1(this, x2, z3);
};
MontCurve.prototype.pointFromJSON = function pointFromJSON2(obj) {
  return Point$1.fromJSON(this, obj);
};
Point$1.prototype.precompute = function precompute2() {
};
Point$1.prototype._encode = function _encode3() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
Point$1.fromJSON = function fromJSON2(curve2, obj) {
  return new Point$1(curve2, obj[0], obj[1] || curve2.one);
};
Point$1.prototype.inspect = function inspect3() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point$1.prototype.isInfinity = function isInfinity3() {
  return this.z.cmpn(0) === 0;
};
Point$1.prototype.dbl = function dbl3() {
  var a2 = this.x.redAdd(this.z);
  var aa2 = a2.redSqr();
  var b2 = this.x.redSub(this.z);
  var bb = b2.redSqr();
  var c2 = aa2.redSub(bb);
  var nx = aa2.redMul(bb);
  var nz = c2.redMul(bb.redAdd(this.curve.a24.redMul(c2)));
  return this.curve.point(nx, nz);
};
Point$1.prototype.add = function add4() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.diffAdd = function diffAdd(p2, diff) {
  var a2 = this.x.redAdd(this.z);
  var b2 = this.x.redSub(this.z);
  var c2 = p2.x.redAdd(p2.z);
  var d4 = p2.x.redSub(p2.z);
  var da2 = d4.redMul(a2);
  var cb = c2.redMul(b2);
  var nx = diff.z.redMul(da2.redAdd(cb).redSqr());
  var nz = diff.x.redMul(da2.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};
Point$1.prototype.mul = function mul3(k3) {
  var t2 = k3.clone();
  var a2 = this;
  var b2 = this.curve.point(null, null);
  var c2 = this;
  for (var bits = []; t2.cmpn(0) !== 0; t2.iushrn(1))
    bits.push(t2.andln(1));
  for (var i4 = bits.length - 1; i4 >= 0; i4--) {
    if (bits[i4] === 0) {
      a2 = a2.diffAdd(b2, c2);
      b2 = b2.dbl();
    } else {
      b2 = a2.diffAdd(b2, c2);
      a2 = a2.dbl();
    }
  }
  return b2;
};
Point$1.prototype.mulAdd = function mulAdd2() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.jumlAdd = function jumlAdd() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.eq = function eq4(other) {
  return this.getX().cmp(other.getX()) === 0;
};
Point$1.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};
Point$1.prototype.getX = function getX2() {
  this.normalize();
  return this.x.fromRed();
};
var utils$7 = utils$p;
var BN$3 = bnExports;
var inherits = inherits_browserExports;
var Base = base$1;
var assert$6 = utils$7.assert;
function EdwardsCurve(conf) {
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;
  Base.call(this, "edwards", conf);
  this.a = new BN$3(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN$3(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN$3(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);
  assert$6(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
var edwards = EdwardsCurve;
EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};
EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};
EdwardsCurve.prototype.jpoint = function jpoint2(x2, y4, z3, t2) {
  return this.point(x2, y4, z3, t2);
};
EdwardsCurve.prototype.pointFromX = function pointFromX2(x2, odd) {
  x2 = new BN$3(x2, 16);
  if (!x2.red)
    x2 = x2.toRed(this.red);
  var x22 = x2.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x22));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x22));
  var y22 = rhs.redMul(lhs.redInvm());
  var y4 = y22.redSqrt();
  if (y4.redSqr().redSub(y22).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y4.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y4 = y4.redNeg();
  return this.point(x2, y4);
};
EdwardsCurve.prototype.pointFromY = function pointFromY(y4, odd) {
  y4 = new BN$3(y4, 16);
  if (!y4.red)
    y4 = y4.toRed(this.red);
  var y22 = y4.redSqr();
  var lhs = y22.redSub(this.c2);
  var rhs = y22.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());
  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error("invalid point");
    else
      return this.point(this.zero, y4);
  }
  var x3 = x2.redSqrt();
  if (x3.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  if (x3.fromRed().isOdd() !== odd)
    x3 = x3.redNeg();
  return this.point(x3, y4);
};
EdwardsCurve.prototype.validate = function validate5(point5) {
  if (point5.isInfinity())
    return true;
  point5.normalize();
  var x2 = point5.x.redSqr();
  var y22 = point5.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y22);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y22)));
  return lhs.cmp(rhs) === 0;
};
function Point(curve2, x2, y4, z3, t2) {
  Base.BasePoint.call(this, curve2, "projective");
  if (x2 === null && y4 === null && z3 === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN$3(x2, 16);
    this.y = new BN$3(y4, 16);
    this.z = z3 ? new BN$3(z3, 16) : this.curve.one;
    this.t = t2 && new BN$3(t2, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);
EdwardsCurve.prototype.pointFromJSON = function pointFromJSON3(obj) {
  return Point.fromJSON(this, obj);
};
EdwardsCurve.prototype.point = function point4(x2, y4, z3, t2) {
  return new Point(this, x2, y4, z3, t2);
};
Point.fromJSON = function fromJSON3(curve2, obj) {
  return new Point(curve2, obj[0], obj[1], obj[2]);
};
Point.prototype.inspect = function inspect4() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function isInfinity4() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Point.prototype._extDbl = function _extDbl() {
  var a2 = this.x.redSqr();
  var b2 = this.y.redSqr();
  var c2 = this.z.redSqr();
  c2 = c2.redIAdd(c2);
  var d4 = this.curve._mulA(a2);
  var e3 = this.x.redAdd(this.y).redSqr().redISub(a2).redISub(b2);
  var g2 = d4.redAdd(b2);
  var f6 = g2.redSub(c2);
  var h5 = d4.redSub(b2);
  var nx = e3.redMul(f6);
  var ny = g2.redMul(h5);
  var nt2 = e3.redMul(h5);
  var nz = f6.redMul(g2);
  return this.curve.point(nx, ny, nz, nt2);
};
Point.prototype._projDbl = function _projDbl() {
  var b2 = this.x.redAdd(this.y).redSqr();
  var c2 = this.x.redSqr();
  var d4 = this.y.redSqr();
  var nx;
  var ny;
  var nz;
  var e3;
  var h5;
  var j2;
  if (this.curve.twisted) {
    e3 = this.curve._mulA(c2);
    var f6 = e3.redAdd(d4);
    if (this.zOne) {
      nx = b2.redSub(c2).redSub(d4).redMul(f6.redSub(this.curve.two));
      ny = f6.redMul(e3.redSub(d4));
      nz = f6.redSqr().redSub(f6).redSub(f6);
    } else {
      h5 = this.z.redSqr();
      j2 = f6.redSub(h5).redISub(h5);
      nx = b2.redSub(c2).redISub(d4).redMul(j2);
      ny = f6.redMul(e3.redSub(d4));
      nz = f6.redMul(j2);
    }
  } else {
    e3 = c2.redAdd(d4);
    h5 = this.curve._mulC(this.z).redSqr();
    j2 = e3.redSub(h5).redSub(h5);
    nx = this.curve._mulC(b2.redISub(e3)).redMul(j2);
    ny = this.curve._mulC(e3).redMul(c2.redISub(d4));
    nz = e3.redMul(j2);
  }
  return this.curve.point(nx, ny, nz);
};
Point.prototype.dbl = function dbl4() {
  if (this.isInfinity())
    return this;
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};
Point.prototype._extAdd = function _extAdd(p2) {
  var a2 = this.y.redSub(this.x).redMul(p2.y.redSub(p2.x));
  var b2 = this.y.redAdd(this.x).redMul(p2.y.redAdd(p2.x));
  var c2 = this.t.redMul(this.curve.dd).redMul(p2.t);
  var d4 = this.z.redMul(p2.z.redAdd(p2.z));
  var e3 = b2.redSub(a2);
  var f6 = d4.redSub(c2);
  var g2 = d4.redAdd(c2);
  var h5 = b2.redAdd(a2);
  var nx = e3.redMul(f6);
  var ny = g2.redMul(h5);
  var nt2 = e3.redMul(h5);
  var nz = f6.redMul(g2);
  return this.curve.point(nx, ny, nz, nt2);
};
Point.prototype._projAdd = function _projAdd(p2) {
  var a2 = this.z.redMul(p2.z);
  var b2 = a2.redSqr();
  var c2 = this.x.redMul(p2.x);
  var d4 = this.y.redMul(p2.y);
  var e3 = this.curve.d.redMul(c2).redMul(d4);
  var f6 = b2.redSub(e3);
  var g2 = b2.redAdd(e3);
  var tmp = this.x.redAdd(this.y).redMul(p2.x.redAdd(p2.y)).redISub(c2).redISub(d4);
  var nx = a2.redMul(f6).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    ny = a2.redMul(g2).redMul(d4.redSub(this.curve._mulA(c2)));
    nz = f6.redMul(g2);
  } else {
    ny = a2.redMul(g2).redMul(d4.redSub(c2));
    nz = this.curve._mulC(f6).redMul(g2);
  }
  return this.curve.point(nx, ny, nz);
};
Point.prototype.add = function add5(p2) {
  if (this.isInfinity())
    return p2;
  if (p2.isInfinity())
    return this;
  if (this.curve.extended)
    return this._extAdd(p2);
  else
    return this._projAdd(p2);
};
Point.prototype.mul = function mul4(k3) {
  if (this._hasDoubles(k3))
    return this.curve._fixedNafMul(this, k3);
  else
    return this.curve._wnafMul(this, k3);
};
Point.prototype.mulAdd = function mulAdd3(k1, p2, k22) {
  return this.curve._wnafMulAdd(1, [this, p2], [k1, k22], 2, false);
};
Point.prototype.jmulAdd = function jmulAdd2(k1, p2, k22) {
  return this.curve._wnafMulAdd(1, [this, p2], [k1, k22], 2, true);
};
Point.prototype.normalize = function normalize2() {
  if (this.zOne)
    return this;
  var zi2 = this.z.redInvm();
  this.x = this.x.redMul(zi2);
  this.y = this.y.redMul(zi2);
  if (this.t)
    this.t = this.t.redMul(zi2);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};
Point.prototype.neg = function neg3() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
Point.prototype.getX = function getX3() {
  this.normalize();
  return this.x.fromRed();
};
Point.prototype.getY = function getY2() {
  this.normalize();
  return this.y.fromRed();
};
Point.prototype.eq = function eq5(other) {
  return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
};
Point.prototype.eqXToP = function eqXToP2(x2) {
  var rx = x2.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc3 = x2.clone();
  var t2 = this.curve.redN.redMul(this.z);
  for (; ; ) {
    xc3.iadd(this.curve.n);
    if (xc3.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t2);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;
(function(exports2) {
  var curve2 = exports2;
  curve2.base = base$1;
  curve2.short = short;
  curve2.mont = mont;
  curve2.edwards = edwards;
})(curve);
var curves$1 = {};
var secp256k1$1;
var hasRequiredSecp256k1;
function requireSecp256k1() {
  if (hasRequiredSecp256k1) return secp256k1$1;
  hasRequiredSecp256k1 = 1;
  secp256k1$1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  };
  return secp256k1$1;
}
(function(exports2) {
  var curves2 = exports2;
  var hash3 = hash$3;
  var curve$12 = curve;
  var utils2 = utils$p;
  var assert2 = utils2.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve$12.short(options);
    else if (options.type === "edwards")
      this.curve = new curve$12.edwards(options);
    else
      this.curve = new curve$12.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert2(this.g.validate(), "Invalid curve");
    assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves2.PresetCurve = PresetCurve;
  function defineCurve(name, options) {
    Object.defineProperty(curves2, name, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve2 = new PresetCurve(options);
        Object.defineProperty(curves2, name, {
          configurable: true,
          enumerable: true,
          value: curve2
        });
        return curve2;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash3.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash3.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = requireSecp256k1();
  } catch (e3) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash3.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
})(curves$1);
var BN$2 = bnExports;
var utils$6 = utils$p;
var assert$5 = utils$6.assert;
function KeyPair$2(ec2, options) {
  this.ec = ec2;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key$1 = KeyPair$2;
KeyPair$2.fromPublic = function fromPublic(ec2, pub2, enc) {
  if (pub2 instanceof KeyPair$2)
    return pub2;
  return new KeyPair$2(ec2, {
    pub: pub2,
    pubEnc: enc
  });
};
KeyPair$2.fromPrivate = function fromPrivate(ec2, priv2, enc) {
  if (priv2 instanceof KeyPair$2)
    return priv2;
  return new KeyPair$2(ec2, {
    priv: priv2,
    privEnc: enc
  });
};
KeyPair$2.prototype.validate = function validate6() {
  var pub2 = this.getPublic();
  if (pub2.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub2.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub2.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
};
KeyPair$2.prototype.getPublic = function getPublic(compact, enc) {
  if (typeof compact === "string") {
    enc = compact;
    compact = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact);
};
KeyPair$2.prototype.getPrivate = function getPrivate(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair$2.prototype._importPrivate = function _importPrivate(key2, enc) {
  this.priv = new BN$2(key2, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair$2.prototype._importPublic = function _importPublic(key2, enc) {
  if (key2.x || key2.y) {
    if (this.ec.curve.type === "mont") {
      assert$5(key2.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$5(key2.x && key2.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key2.x, key2.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key2, enc);
};
KeyPair$2.prototype.derive = function derive(pub2) {
  if (!pub2.validate()) {
    assert$5(pub2.validate(), "public point not validated");
  }
  return pub2.mul(this.priv).getX();
};
KeyPair$2.prototype.sign = function sign2(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair$2.prototype.verify = function verify(msg, signature2, options) {
  return this.ec.verify(msg, signature2, this, void 0, options);
};
KeyPair$2.prototype.inspect = function inspect5() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var BN$1 = bnExports;
var utils$5 = utils$p;
var assert$4 = utils$5.assert;
function Signature$3(options, enc) {
  if (options instanceof Signature$3)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$4(options.r && options.s, "Signature without r or s");
  this.r = new BN$1(options.r, 16);
  this.s = new BN$1(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature$1 = Signature$3;
function Position() {
  this.place = 0;
}
function getLength(buf, p2) {
  var initial = buf[p2.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  if (buf[p2.place] === 0) {
    return false;
  }
  var val = 0;
  for (var i4 = 0, off = p2.place; i4 < octetLen; i4++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p2.place = off;
  return val;
}
function rmPadding(buf) {
  var i4 = 0;
  var len2 = buf.length - 1;
  while (!buf[i4] && !(buf[i4 + 1] & 128) && i4 < len2) {
    i4++;
  }
  if (i4 === 0) {
    return buf;
  }
  return buf.slice(i4);
}
Signature$3.prototype._importDER = function _importDER(data2, enc) {
  data2 = utils$5.toArray(data2, enc);
  var p2 = new Position();
  if (data2[p2.place++] !== 48) {
    return false;
  }
  var len2 = getLength(data2, p2);
  if (len2 === false) {
    return false;
  }
  if (len2 + p2.place !== data2.length) {
    return false;
  }
  if (data2[p2.place++] !== 2) {
    return false;
  }
  var rlen = getLength(data2, p2);
  if (rlen === false) {
    return false;
  }
  if ((data2[p2.place] & 128) !== 0) {
    return false;
  }
  var r3 = data2.slice(p2.place, rlen + p2.place);
  p2.place += rlen;
  if (data2[p2.place++] !== 2) {
    return false;
  }
  var slen = getLength(data2, p2);
  if (slen === false) {
    return false;
  }
  if (data2.length !== slen + p2.place) {
    return false;
  }
  if ((data2[p2.place] & 128) !== 0) {
    return false;
  }
  var s2 = data2.slice(p2.place, slen + p2.place);
  if (r3[0] === 0) {
    if (r3[1] & 128) {
      r3 = r3.slice(1);
    } else {
      return false;
    }
  }
  if (s2[0] === 0) {
    if (s2[1] & 128) {
      s2 = s2.slice(1);
    } else {
      return false;
    }
  }
  this.r = new BN$1(r3);
  this.s = new BN$1(s2);
  this.recoveryParam = null;
  return true;
};
function constructLength(arr, len2) {
  if (len2 < 128) {
    arr.push(len2);
    return;
  }
  var octets = 1 + (Math.log(len2) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len2 >>> (octets << 3) & 255);
  }
  arr.push(len2);
}
Signature$3.prototype.toDER = function toDER(enc) {
  var r3 = this.r.toArray();
  var s2 = this.s.toArray();
  if (r3[0] & 128)
    r3 = [0].concat(r3);
  if (s2[0] & 128)
    s2 = [0].concat(s2);
  r3 = rmPadding(r3);
  s2 = rmPadding(s2);
  while (!s2[0] && !(s2[1] & 128)) {
    s2 = s2.slice(1);
  }
  var arr = [2];
  constructLength(arr, r3.length);
  arr = arr.concat(r3);
  arr.push(2);
  constructLength(arr, s2.length);
  var backHalf = arr.concat(s2);
  var res = [48];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils$5.encode(res, enc);
};
var ec$3;
var hasRequiredEc;
function requireEc() {
  if (hasRequiredEc) return ec$3;
  hasRequiredEc = 1;
  var BN2 = bnExports;
  var HmacDRBG2 = hmacDrbg;
  var utils2 = utils$p;
  var curves2 = curves$1;
  var rand = requireBrorand();
  var assert2 = utils2.assert;
  var KeyPair2 = key$1;
  var Signature2 = signature$1;
  function EC(options) {
    if (!(this instanceof EC))
      return new EC(options);
    if (typeof options === "string") {
      assert2(
        Object.prototype.hasOwnProperty.call(curves2, options),
        "Unknown curve " + options
      );
      options = curves2[options];
    }
    if (options instanceof curves2.PresetCurve)
      options = { curve: options };
    this.curve = options.curve.curve;
    this.n = this.curve.n;
    this.nh = this.n.ushrn(1);
    this.g = this.curve.g;
    this.g = options.curve.g;
    this.g.precompute(options.curve.n.bitLength() + 1);
    this.hash = options.hash || options.curve.hash;
  }
  ec$3 = EC;
  EC.prototype.keyPair = function keyPair(options) {
    return new KeyPair2(this, options);
  };
  EC.prototype.keyFromPrivate = function keyFromPrivate(priv2, enc) {
    return KeyPair2.fromPrivate(this, priv2, enc);
  };
  EC.prototype.keyFromPublic = function keyFromPublic2(pub2, enc) {
    return KeyPair2.fromPublic(this, pub2, enc);
  };
  EC.prototype.genKeyPair = function genKeyPair(options) {
    if (!options)
      options = {};
    var drbg = new HmacDRBG2({
      hash: this.hash,
      pers: options.pers,
      persEnc: options.persEnc || "utf8",
      entropy: options.entropy || rand(this.hash.hmacStrength),
      entropyEnc: options.entropy && options.entropyEnc || "utf8",
      nonce: this.n.toArray()
    });
    var bytes2 = this.n.byteLength();
    var ns2 = this.n.sub(new BN2(2));
    for (; ; ) {
      var priv2 = new BN2(drbg.generate(bytes2));
      if (priv2.cmp(ns2) > 0)
        continue;
      priv2.iaddn(1);
      return this.keyFromPrivate(priv2);
    }
  };
  EC.prototype._truncateToN = function _truncateToN(msg, truncOnly, bitLength) {
    var byteLength2;
    if (BN2.isBN(msg) || typeof msg === "number") {
      msg = new BN2(msg, 16);
      byteLength2 = msg.byteLength();
    } else if (typeof msg === "object") {
      byteLength2 = msg.length;
      msg = new BN2(msg, 16);
    } else {
      var str = msg.toString();
      byteLength2 = str.length + 1 >>> 1;
      msg = new BN2(str, 16);
    }
    if (typeof bitLength !== "number") {
      bitLength = byteLength2 * 8;
    }
    var delta = bitLength - this.n.bitLength();
    if (delta > 0)
      msg = msg.ushrn(delta);
    if (!truncOnly && msg.cmp(this.n) >= 0)
      return msg.sub(this.n);
    else
      return msg;
  };
  EC.prototype.sign = function sign5(msg, key2, enc, options) {
    if (typeof enc === "object") {
      options = enc;
      enc = null;
    }
    if (!options)
      options = {};
    if (typeof msg !== "string" && typeof msg !== "number" && !BN2.isBN(msg)) {
      assert2(
        typeof msg === "object" && msg && typeof msg.length === "number",
        "Expected message to be an array-like, a hex string, or a BN instance"
      );
      assert2(msg.length >>> 0 === msg.length);
      for (var i4 = 0; i4 < msg.length; i4++) assert2((msg[i4] & 255) === msg[i4]);
    }
    key2 = this.keyFromPrivate(key2, enc);
    msg = this._truncateToN(msg, false, options.msgBitLength);
    assert2(!msg.isNeg(), "Can not sign a negative message");
    var bytes2 = this.n.byteLength();
    var bkey = key2.getPrivate().toArray("be", bytes2);
    var nonce = msg.toArray("be", bytes2);
    assert2(new BN2(nonce).eq(msg), "Can not sign message");
    var drbg = new HmacDRBG2({
      hash: this.hash,
      entropy: bkey,
      nonce,
      pers: options.pers,
      persEnc: options.persEnc || "utf8"
    });
    var ns1 = this.n.sub(new BN2(1));
    for (var iter = 0; ; iter++) {
      var k3 = options.k ? options.k(iter) : new BN2(drbg.generate(this.n.byteLength()));
      k3 = this._truncateToN(k3, true);
      if (k3.cmpn(1) <= 0 || k3.cmp(ns1) >= 0)
        continue;
      var kp = this.g.mul(k3);
      if (kp.isInfinity())
        continue;
      var kpX = kp.getX();
      var r3 = kpX.umod(this.n);
      if (r3.cmpn(0) === 0)
        continue;
      var s2 = k3.invm(this.n).mul(r3.mul(key2.getPrivate()).iadd(msg));
      s2 = s2.umod(this.n);
      if (s2.cmpn(0) === 0)
        continue;
      var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r3) !== 0 ? 2 : 0);
      if (options.canonical && s2.cmp(this.nh) > 0) {
        s2 = this.n.sub(s2);
        recoveryParam ^= 1;
      }
      return new Signature2({ r: r3, s: s2, recoveryParam });
    }
  };
  EC.prototype.verify = function verify4(msg, signature2, key2, enc, options) {
    if (!options)
      options = {};
    msg = this._truncateToN(msg, false, options.msgBitLength);
    key2 = this.keyFromPublic(key2, enc);
    signature2 = new Signature2(signature2, "hex");
    var r3 = signature2.r;
    var s2 = signature2.s;
    if (r3.cmpn(1) < 0 || r3.cmp(this.n) >= 0)
      return false;
    if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
      return false;
    var sinv = s2.invm(this.n);
    var u1 = sinv.mul(msg).umod(this.n);
    var u2 = sinv.mul(r3).umod(this.n);
    var p2;
    if (!this.curve._maxwellTrick) {
      p2 = this.g.mulAdd(u1, key2.getPublic(), u2);
      if (p2.isInfinity())
        return false;
      return p2.getX().umod(this.n).cmp(r3) === 0;
    }
    p2 = this.g.jmulAdd(u1, key2.getPublic(), u2);
    if (p2.isInfinity())
      return false;
    return p2.eqXToP(r3);
  };
  EC.prototype.recoverPubKey = function(msg, signature2, j2, enc) {
    assert2((3 & j2) === j2, "The recovery param is more than two bits");
    signature2 = new Signature2(signature2, enc);
    var n5 = this.n;
    var e3 = new BN2(msg);
    var r3 = signature2.r;
    var s2 = signature2.s;
    var isYOdd = j2 & 1;
    var isSecondKey = j2 >> 1;
    if (r3.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
      throw new Error("Unable to find sencond key candinate");
    if (isSecondKey)
      r3 = this.curve.pointFromX(r3.add(this.curve.n), isYOdd);
    else
      r3 = this.curve.pointFromX(r3, isYOdd);
    var rInv = signature2.r.invm(n5);
    var s1 = n5.sub(e3).mul(rInv).umod(n5);
    var s22 = s2.mul(rInv).umod(n5);
    return this.g.mulAdd(s1, r3, s22);
  };
  EC.prototype.getKeyRecoveryParam = function(e3, signature2, Q2, enc) {
    signature2 = new Signature2(signature2, enc);
    if (signature2.recoveryParam !== null)
      return signature2.recoveryParam;
    for (var i4 = 0; i4 < 4; i4++) {
      var Qprime;
      try {
        Qprime = this.recoverPubKey(e3, signature2, i4);
      } catch (e4) {
        continue;
      }
      if (Qprime.eq(Q2))
        return i4;
    }
    throw new Error("Unable to find valid recovery factor");
  };
  return ec$3;
}
var utils$4 = utils$p;
var assert$3 = utils$4.assert;
var parseBytes$2 = utils$4.parseBytes;
var cachedProperty$1 = utils$4.cachedProperty;
function KeyPair$1(eddsa2, params) {
  this.eddsa = eddsa2;
  this._secret = parseBytes$2(params.secret);
  if (eddsa2.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes$2(params.pub);
}
KeyPair$1.fromPublic = function fromPublic2(eddsa2, pub2) {
  if (pub2 instanceof KeyPair$1)
    return pub2;
  return new KeyPair$1(eddsa2, { pub: pub2 });
};
KeyPair$1.fromSecret = function fromSecret(eddsa2, secret2) {
  if (secret2 instanceof KeyPair$1)
    return secret2;
  return new KeyPair$1(eddsa2, { secret: secret2 });
};
KeyPair$1.prototype.secret = function secret() {
  return this._secret;
};
cachedProperty$1(KeyPair$1, "pubBytes", function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});
cachedProperty$1(KeyPair$1, "pub", function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});
cachedProperty$1(KeyPair$1, "privBytes", function privBytes() {
  var eddsa2 = this.eddsa;
  var hash3 = this.hash();
  var lastIx = eddsa2.encodingLength - 1;
  var a2 = hash3.slice(0, eddsa2.encodingLength);
  a2[0] &= 248;
  a2[lastIx] &= 127;
  a2[lastIx] |= 64;
  return a2;
});
cachedProperty$1(KeyPair$1, "priv", function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty$1(KeyPair$1, "hash", function hash2() {
  return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty$1(KeyPair$1, "messagePrefix", function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});
KeyPair$1.prototype.sign = function sign3(message) {
  assert$3(this._secret, "KeyPair can only verify");
  return this.eddsa.sign(message, this);
};
KeyPair$1.prototype.verify = function verify2(message, sig) {
  return this.eddsa.verify(message, sig, this);
};
KeyPair$1.prototype.getSecret = function getSecret(enc) {
  assert$3(this._secret, "KeyPair is public only");
  return utils$4.encode(this.secret(), enc);
};
KeyPair$1.prototype.getPublic = function getPublic2(enc) {
  return utils$4.encode(this.pubBytes(), enc);
};
var key = KeyPair$1;
var BN = bnExports;
var utils$3 = utils$p;
var assert$2 = utils$3.assert;
var cachedProperty = utils$3.cachedProperty;
var parseBytes$1 = utils$3.parseBytes;
function Signature$2(eddsa2, sig) {
  this.eddsa = eddsa2;
  if (typeof sig !== "object")
    sig = parseBytes$1(sig);
  if (Array.isArray(sig)) {
    assert$2(sig.length === eddsa2.encodingLength * 2, "Signature has invalid size");
    sig = {
      R: sig.slice(0, eddsa2.encodingLength),
      S: sig.slice(eddsa2.encodingLength)
    };
  }
  assert$2(sig.R && sig.S, "Signature without R or S");
  if (eddsa2.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;
  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}
cachedProperty(Signature$2, "S", function S3() {
  return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature$2, "R", function R3() {
  return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature$2, "Rencoded", function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature$2, "Sencoded", function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});
Signature$2.prototype.toBytes = function toBytes2() {
  return this.Rencoded().concat(this.Sencoded());
};
Signature$2.prototype.toHex = function toHex2() {
  return utils$3.encode(this.toBytes(), "hex").toUpperCase();
};
var signature = Signature$2;
var hash$1 = hash$3;
var curves = curves$1;
var utils$2 = utils$p;
var assert$1 = utils$2.assert;
var parseBytes = utils$2.parseBytes;
var KeyPair = key;
var Signature$1 = signature;
function EDDSA(curve2) {
  assert$1(curve2 === "ed25519", "only tested with ed25519 so far");
  if (!(this instanceof EDDSA))
    return new EDDSA(curve2);
  curve2 = curves[curve2].curve;
  this.curve = curve2;
  this.g = curve2.g;
  this.g.precompute(curve2.n.bitLength() + 1);
  this.pointClass = curve2.point().constructor;
  this.encodingLength = Math.ceil(curve2.n.bitLength() / 8);
  this.hash = hash$1.sha512;
}
var eddsa = EDDSA;
EDDSA.prototype.sign = function sign4(message, secret2) {
  message = parseBytes(message);
  var key2 = this.keyFromSecret(secret2);
  var r3 = this.hashInt(key2.messagePrefix(), message);
  var R5 = this.g.mul(r3);
  var Rencoded2 = this.encodePoint(R5);
  var s_ = this.hashInt(Rencoded2, key2.pubBytes(), message).mul(key2.priv());
  var S4 = r3.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R5, S: S4, Rencoded: Rencoded2 });
};
EDDSA.prototype.verify = function verify3(message, sig, pub2) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {
    return false;
  }
  var key2 = this.keyFromPublic(pub2);
  var h5 = this.hashInt(sig.Rencoded(), key2.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key2.pub().mul(h5));
  return RplusAh.eq(SG);
};
EDDSA.prototype.hashInt = function hashInt() {
  var hash3 = this.hash();
  for (var i4 = 0; i4 < arguments.length; i4++)
    hash3.update(arguments[i4]);
  return utils$2.intFromLE(hash3.digest()).umod(this.curve.n);
};
EDDSA.prototype.keyFromPublic = function keyFromPublic(pub2) {
  return KeyPair.fromPublic(this, pub2);
};
EDDSA.prototype.keyFromSecret = function keyFromSecret(secret2) {
  return KeyPair.fromSecret(this, secret2);
};
EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature$1)
    return sig;
  return new Signature$1(this, sig);
};
EDDSA.prototype.encodePoint = function encodePoint(point5) {
  var enc = point5.getY().toArray("le", this.encodingLength);
  enc[this.encodingLength - 1] |= point5.getX().isOdd() ? 128 : 0;
  return enc;
};
EDDSA.prototype.decodePoint = function decodePoint3(bytes2) {
  bytes2 = utils$2.parseBytes(bytes2);
  var lastIx = bytes2.length - 1;
  var normed = bytes2.slice(0, lastIx).concat(bytes2[lastIx] & -129);
  var xIsOdd = (bytes2[lastIx] & 128) !== 0;
  var y4 = utils$2.intFromLE(normed);
  return this.curve.pointFromY(y4, xIsOdd);
};
EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray("le", this.encodingLength);
};
EDDSA.prototype.decodeInt = function decodeInt(bytes2) {
  return utils$2.intFromLE(bytes2);
};
EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};
var hasRequiredElliptic;
function requireElliptic() {
  if (hasRequiredElliptic) return elliptic$1;
  hasRequiredElliptic = 1;
  (function(exports2) {
    var elliptic2 = exports2;
    elliptic2.version = require$$0$1.version;
    elliptic2.utils = utils$p;
    elliptic2.rand = requireBrorand();
    elliptic2.curve = curve;
    elliptic2.curves = curves$1;
    elliptic2.ec = requireEc();
    elliptic2.eddsa = eddsa;
  })(elliptic$1);
  return elliptic$1;
}
var ellipticExports = requireElliptic();
const C$6 = { waku: { publish: "waku_publish", batchPublish: "waku_batchPublish", subscribe: "waku_subscribe", batchSubscribe: "waku_batchSubscribe", subscription: "waku_subscription", unsubscribe: "waku_unsubscribe", batchUnsubscribe: "waku_batchUnsubscribe", batchFetchMessages: "waku_batchFetchMessages" }, irn: { publish: "irn_publish", batchPublish: "irn_batchPublish", subscribe: "irn_subscribe", batchSubscribe: "irn_batchSubscribe", subscription: "irn_subscription", unsubscribe: "irn_unsubscribe", batchUnsubscribe: "irn_batchUnsubscribe", batchFetchMessages: "irn_batchFetchMessages" }, iridium: { publish: "iridium_publish", batchPublish: "iridium_batchPublish", subscribe: "iridium_subscribe", batchSubscribe: "iridium_batchSubscribe", subscription: "iridium_subscription", unsubscribe: "iridium_unsubscribe", batchUnsubscribe: "iridium_batchUnsubscribe", batchFetchMessages: "iridium_batchFetchMessages" } };
const Pe$1 = ":";
function Ye$4(e3) {
  const [t2, n5] = e3.split(Pe$1);
  return { namespace: t2, reference: n5 };
}
function Dt$6(e3) {
  const { namespace: t2, reference: n5 } = e3;
  return [t2, n5].join(Pe$1);
}
function Xe$4(e3) {
  const [t2, n5, r3] = e3.split(Pe$1);
  return { namespace: t2, reference: n5, address: r3 };
}
function Mt$6(e3) {
  const { namespace: t2, reference: n5, address: r3 } = e3;
  return [t2, n5, r3].join(Pe$1);
}
function Ze$4(e3, t2) {
  const n5 = [];
  return e3.forEach((r3) => {
    const o3 = t2(r3);
    n5.includes(o3) || n5.push(o3);
  }), n5;
}
function Vt$6(e3) {
  const { address: t2 } = Xe$4(e3);
  return t2;
}
function Ht$6(e3) {
  const { namespace: t2, reference: n5 } = Xe$4(e3);
  return Dt$6({ namespace: t2, reference: n5 });
}
function Mr$6(e3, t2) {
  const { namespace: n5, reference: r3 } = Ye$4(t2);
  return Mt$6({ namespace: n5, reference: r3, address: e3 });
}
function Vr$6(e3) {
  return Ze$4(e3, Vt$6);
}
function Kt$6(e3) {
  return Ze$4(e3, Ht$6);
}
function Hr$6(e3, t2 = []) {
  const n5 = [];
  return Object.keys(e3).forEach((r3) => {
    if (t2.length && !t2.includes(r3)) return;
    const o3 = e3[r3];
    n5.push(...o3.accounts);
  }), n5;
}
function Kr$6(e3, t2 = []) {
  const n5 = [];
  return Object.keys(e3).forEach((r3) => {
    if (t2.length && !t2.includes(r3)) return;
    const o3 = e3[r3];
    n5.push(...Kt$6(o3.accounts));
  }), n5;
}
function Fr$6(e3, t2 = []) {
  const n5 = [];
  return Object.keys(e3).forEach((r3) => {
    if (t2.length && !t2.includes(r3)) return;
    const o3 = e3[r3];
    n5.push(...Le$8(r3, o3));
  }), n5;
}
function Le$8(e3, t2) {
  return e3.includes(":") ? [e3] : t2.chains || [];
}
const Ft$6 = "ReactNative", H$6 = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" }, Be$6 = " ", qr$6 = ":", qt$6 = "/", Qe$4 = 2, Gr$6 = 1e3, Gt$6 = "js";
function et$4() {
  return typeof process$1 < "u" && typeof process$1.versions < "u" && typeof process$1.versions.node < "u";
}
function ne$6() {
  return !getDocument_1() && !!getNavigator_1() && navigator.product === Ft$6;
}
function Wr$6() {
  return ne$6() && typeof global$1 < "u" && typeof (global$1 == null ? void 0 : global$1.Platform) < "u" && (global$1 == null ? void 0 : global$1.Platform.OS) === "android";
}
function zr$6() {
  return ne$6() && typeof global$1 < "u" && typeof (global$1 == null ? void 0 : global$1.Platform) < "u" && (global$1 == null ? void 0 : global$1.Platform.OS) === "ios";
}
function Ae$6() {
  return !et$4() && !!getNavigator_1() && !!getDocument_1();
}
function ue$5() {
  return ne$6() ? H$6.reactNative : et$4() ? H$6.node : Ae$6() ? H$6.browser : H$6.unknown;
}
function Jr$6() {
  var e3;
  try {
    return ne$6() && typeof global$1 < "u" && typeof (global$1 == null ? void 0 : global$1.Application) < "u" ? (e3 = global$1.Application) == null ? void 0 : e3.applicationId : void 0;
  } catch {
    return;
  }
}
function Wt$6(e3, t2) {
  const n5 = new URLSearchParams(e3);
  for (const r3 of Object.keys(t2).sort()) if (t2.hasOwnProperty(r3)) {
    const o3 = t2[r3];
    o3 !== void 0 && n5.set(r3, o3);
  }
  return n5.toString();
}
function Yr$6() {
  return getWindowMetadata_1() || { name: "", description: "", url: "", icons: [""] };
}
function Xr$6(e3, t2) {
  var n5;
  const r3 = ue$5(), o3 = { protocol: e3, version: t2, env: r3 };
  return r3 === "browser" && (o3.host = ((n5 = getLocation_1()) == null ? void 0 : n5.host) || "unknown"), o3;
}
function zt$6() {
  if (ue$5() === H$6.reactNative && typeof global$1 < "u" && typeof (global$1 == null ? void 0 : global$1.Platform) < "u") {
    const { OS: n5, Version: r3 } = global$1.Platform;
    return [n5, r3].join("-");
  }
  const e3 = detect();
  if (e3 === null) return "unknown";
  const t2 = e3.os ? e3.os.replace(" ", "").toLowerCase() : "unknown";
  return e3.type === "browser" ? [t2, e3.name, e3.version].join("-") : [t2, e3.version].join("-");
}
function Jt$6() {
  var e3;
  const t2 = ue$5();
  return t2 === H$6.browser ? [t2, ((e3 = getLocation_1()) == null ? void 0 : e3.host) || "unknown"].join(":") : t2;
}
function Yt$6(e3, t2, n5) {
  const r3 = zt$6(), o3 = Jt$6();
  return [[e3, t2].join("-"), [Gt$6, n5].join("-"), r3, o3].join("/");
}
function Zr$6({ protocol: e3, version: t2, relayUrl: n5, sdkVersion: r3, auth: o3, projectId: s2, useOnCloseEvent: i4, bundleId: c2, packageName: u2 }) {
  const a2 = n5.split("?"), l2 = Yt$6(e3, t2, r3), f6 = { auth: o3, ua: l2, projectId: s2, useOnCloseEvent: i4 || void 0, packageName: u2 || void 0, bundleId: c2 || void 0 }, d4 = Wt$6(a2[1] || "", f6);
  return a2[0] + "?" + d4;
}
function Qr$6(e3) {
  let t2 = (e3.match(/^[^:]+(?=:\/\/)/gi) || [])[0];
  const n5 = typeof t2 < "u" ? e3.split("://")[1] : e3;
  return t2 = t2 === "wss" ? "https" : "http", [t2, n5].join("://");
}
function eo$6(e3, t2, n5) {
  if (!e3[t2] || typeof e3[t2] !== n5) throw new Error(`Missing or invalid "${t2}" param`);
}
function Xt$6(e3, t2 = Qe$4) {
  return Zt$6(e3.split(qt$6), t2);
}
function to$6(e3) {
  return Xt$6(e3).join(Be$6);
}
function re$6(e3, t2) {
  return e3.filter((n5) => t2.includes(n5)).length === e3.length;
}
function Zt$6(e3, t2 = Qe$4) {
  return e3.slice(Math.max(e3.length - t2, 0));
}
function no$6(e3) {
  return Object.fromEntries(e3.entries());
}
function ro$6(e3) {
  return new Map(Object.entries(e3));
}
function oo$6(e3, t2) {
  const n5 = {};
  return Object.keys(e3).forEach((r3) => {
    n5[r3] = t2(e3[r3]);
  }), n5;
}
const so$6 = (e3) => e3;
function Qt$6(e3) {
  return e3.trim().replace(/^\w/, (t2) => t2.toUpperCase());
}
function io$6(e3) {
  return e3.split(Be$6).map((t2) => Qt$6(t2)).join(Be$6);
}
function co$4(e3 = cjs$3.FIVE_MINUTES, t2) {
  const n5 = cjs$3.toMiliseconds(e3 || cjs$3.FIVE_MINUTES);
  let r3, o3, s2, i4;
  return { resolve: (c2) => {
    s2 && r3 && (clearTimeout(s2), r3(c2), i4 = Promise.resolve(c2));
  }, reject: (c2) => {
    s2 && o3 && (clearTimeout(s2), o3(c2));
  }, done: () => new Promise((c2, u2) => {
    if (i4) return c2(i4);
    s2 = setTimeout(() => {
      const a2 = new Error(t2);
      i4 = Promise.reject(a2), u2(a2);
    }, n5), r3 = c2, o3 = u2;
  }) };
}
function ao$6(e3, t2, n5) {
  return new Promise(async (r3, o3) => {
    const s2 = setTimeout(() => o3(new Error(n5)), t2);
    try {
      const i4 = await e3;
      r3(i4);
    } catch (i4) {
      o3(i4);
    }
    clearTimeout(s2);
  });
}
function tt$4(e3, t2) {
  if (typeof t2 == "string" && t2.startsWith(`${e3}:`)) return t2;
  if (e3.toLowerCase() === "topic") {
    if (typeof t2 != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${t2}`;
  } else if (e3.toLowerCase() === "id") {
    if (typeof t2 != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${t2}`;
  }
  throw new Error(`Unknown expirer target type: ${e3}`);
}
function uo$4(e3) {
  return tt$4("topic", e3);
}
function fo$4(e3) {
  return tt$4("id", e3);
}
function lo$4(e3) {
  const [t2, n5] = e3.split(":"), r3 = { id: void 0, topic: void 0 };
  if (t2 === "topic" && typeof n5 == "string") r3.topic = n5;
  else if (t2 === "id" && Number.isInteger(Number(n5))) r3.id = Number(n5);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${t2}:${n5}`);
  return r3;
}
function ho$4(e3, t2) {
  return cjs$3.fromMiliseconds((t2 || Date.now()) + cjs$3.toMiliseconds(e3));
}
function po$4(e3) {
  return Date.now() >= cjs$3.toMiliseconds(e3);
}
function go$4(e3, t2) {
  return `${e3}${t2 ? `:${t2}` : ""}`;
}
function Q$3(e3 = [], t2 = []) {
  return [.../* @__PURE__ */ new Set([...e3, ...t2])];
}
async function yo$4({ id: e3, topic: t2, wcDeepLink: n5 }) {
  var r3;
  try {
    if (!n5) return;
    const o3 = typeof n5 == "string" ? JSON.parse(n5) : n5, s2 = o3 == null ? void 0 : o3.href;
    if (typeof s2 != "string") return;
    const i4 = en$6(s2, e3, t2), c2 = ue$5();
    if (c2 === H$6.browser) {
      if (!((r3 = getDocument_1()) != null && r3.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      tn$6(i4);
    } else c2 === H$6.reactNative && typeof (global$1 == null ? void 0 : global$1.Linking) < "u" && await global$1.Linking.openURL(i4);
  } catch (o3) {
    console.error(o3);
  }
}
function en$6(e3, t2, n5) {
  const r3 = `requestId=${t2}&sessionTopic=${n5}`;
  e3.endsWith("/") && (e3 = e3.slice(0, -1));
  let o3 = `${e3}`;
  if (e3.startsWith("https://t.me")) {
    const s2 = e3.includes("?") ? "&startapp=" : "?startapp=";
    o3 = `${o3}${s2}${on$6(r3, true)}`;
  } else o3 = `${o3}/wc?${r3}`;
  return o3;
}
function tn$6(e3) {
  let t2 = "_self";
  rn$6() ? t2 = "_top" : (nn$6() || e3.startsWith("https://") || e3.startsWith("http://")) && (t2 = "_blank"), window.open(e3, t2, "noreferrer noopener");
}
async function mo$4(e3, t2) {
  let n5 = "";
  try {
    if (Ae$6() && (n5 = localStorage.getItem(t2), n5)) return n5;
    n5 = await e3.getItem(t2);
  } catch (r3) {
    console.error(r3);
  }
  return n5;
}
function nt$3(e3, t2) {
  return e3.filter((n5) => t2.includes(n5));
}
function bo$4(e3, t2) {
  if (!e3.includes(t2)) return null;
  const n5 = e3.split(/([&,?,=])/), r3 = n5.indexOf(t2);
  return n5[r3 + 2];
}
function wo$4() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (e3) => {
    const t2 = Math.random() * 16 | 0;
    return (e3 === "x" ? t2 : t2 & 3 | 8).toString(16);
  });
}
function Eo$4() {
  return typeof process$1 < "u" && process$1.env.IS_VITEST === "true";
}
function nn$6() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function rn$6() {
  try {
    return window.self !== window.top;
  } catch {
    return false;
  }
}
function on$6(e3, t2 = false) {
  const n5 = Buffer.from(e3).toString("base64");
  return t2 ? n5.replace(/[=]/g, "") : n5;
}
function rt$4(e3) {
  return Buffer.from(e3, "base64").toString("utf-8");
}
function vo$4(e3) {
  return new Promise((t2) => setTimeout(t2, e3));
}
function Ne$6(e3) {
  if (!Number.isSafeInteger(e3) || e3 < 0) throw new Error("positive integer expected, got " + e3);
}
function xo$4(e3) {
  return e3 instanceof Uint8Array || ArrayBuffer.isView(e3) && e3.constructor.name === "Uint8Array";
}
function je$6(e3, ...t2) {
  if (!xo$4(e3)) throw new Error("Uint8Array expected");
  if (t2.length > 0 && !t2.includes(e3.length)) throw new Error("Uint8Array expected of length " + t2 + ", got length=" + e3.length);
}
function ot$3(e3) {
  if (typeof e3 != "function" || typeof e3.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Ne$6(e3.outputLen), Ne$6(e3.blockLen);
}
function me$1(e3, t2 = true) {
  if (e3.destroyed) throw new Error("Hash instance has been destroyed");
  if (t2 && e3.finished) throw new Error("Hash#digest() has already been called");
}
function sn$6(e3, t2) {
  je$6(e3);
  const n5 = t2.outputLen;
  if (e3.length < n5) throw new Error("digestInto() expects output buffer of length at least " + n5);
}
const Ce$4 = BigInt(2 ** 32 - 1), cn$6 = BigInt(32);
function Oo$4(e3, t2 = false) {
  return t2 ? { h: Number(e3 & Ce$4), l: Number(e3 >> cn$6 & Ce$4) } : { h: Number(e3 >> cn$6 & Ce$4) | 0, l: Number(e3 & Ce$4) | 0 };
}
function Io$4(e3, t2 = false) {
  let n5 = new Uint32Array(e3.length), r3 = new Uint32Array(e3.length);
  for (let o3 = 0; o3 < e3.length; o3++) {
    const { h: s2, l: i4 } = Oo$4(e3[o3], t2);
    [n5[o3], r3[o3]] = [s2, i4];
  }
  return [n5, r3];
}
const Ao$4 = (e3, t2, n5) => e3 << n5 | t2 >>> 32 - n5, No$4 = (e3, t2, n5) => t2 << n5 | e3 >>> 32 - n5, So$4 = (e3, t2, n5) => t2 << n5 - 32 | e3 >>> 64 - n5, Uo$4 = (e3, t2, n5) => e3 << n5 - 32 | t2 >>> 64 - n5, be$3 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function _o$4(e3) {
  return new Uint32Array(e3.buffer, e3.byteOffset, Math.floor(e3.byteLength / 4));
}
function st$4(e3) {
  return new DataView(e3.buffer, e3.byteOffset, e3.byteLength);
}
function J$6(e3, t2) {
  return e3 << 32 - t2 | e3 >>> t2;
}
const an$6 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function To$4(e3) {
  return e3 << 24 & 4278190080 | e3 << 8 & 16711680 | e3 >>> 8 & 65280 | e3 >>> 24 & 255;
}
function un$6(e3) {
  for (let t2 = 0; t2 < e3.length; t2++) e3[t2] = To$4(e3[t2]);
}
function $o$4(e3) {
  if (typeof e3 != "string") throw new Error("utf8ToBytes expected string, got " + typeof e3);
  return new Uint8Array(new TextEncoder().encode(e3));
}
function we$6(e3) {
  return typeof e3 == "string" && (e3 = $o$4(e3)), je$6(e3), e3;
}
let it$4 = class it2 {
  clone() {
    return this._cloneInto();
  }
};
function fn$6(e3) {
  const t2 = (r3) => e3().update(we$6(r3)).digest(), n5 = e3();
  return t2.outputLen = n5.outputLen, t2.blockLen = n5.blockLen, t2.create = () => e3(), t2;
}
function Se$6(e3 = 32) {
  if (be$3 && typeof be$3.getRandomValues == "function") return be$3.getRandomValues(new Uint8Array(e3));
  if (be$3 && typeof be$3.randomBytes == "function") return be$3.randomBytes(e3);
  throw new Error("crypto.getRandomValues must be defined");
}
const ln$6 = [], dn$6 = [], hn$6 = [], Ro$4 = BigInt(0), Ue$8 = BigInt(1), Po$4 = BigInt(2), Lo$4 = BigInt(7), Bo$4 = BigInt(256), jo$4 = BigInt(113);
for (let e3 = 0, t2 = Ue$8, n5 = 1, r3 = 0; e3 < 24; e3++) {
  [n5, r3] = [r3, (2 * n5 + 3 * r3) % 5], ln$6.push(2 * (5 * r3 + n5)), dn$6.push((e3 + 1) * (e3 + 2) / 2 % 64);
  let o3 = Ro$4;
  for (let s2 = 0; s2 < 7; s2++) t2 = (t2 << Ue$8 ^ (t2 >> Lo$4) * jo$4) % Bo$4, t2 & Po$4 && (o3 ^= Ue$8 << (Ue$8 << BigInt(s2)) - Ue$8);
  hn$6.push(o3);
}
const [Co$4, ko$4] = Io$4(hn$6, true), pn$6 = (e3, t2, n5) => n5 > 32 ? So$4(e3, t2, n5) : Ao$4(e3, t2, n5), gn$6 = (e3, t2, n5) => n5 > 32 ? Uo$4(e3, t2, n5) : No$4(e3, t2, n5);
function Do$4(e3, t2 = 24) {
  const n5 = new Uint32Array(10);
  for (let r3 = 24 - t2; r3 < 24; r3++) {
    for (let i4 = 0; i4 < 10; i4++) n5[i4] = e3[i4] ^ e3[i4 + 10] ^ e3[i4 + 20] ^ e3[i4 + 30] ^ e3[i4 + 40];
    for (let i4 = 0; i4 < 10; i4 += 2) {
      const c2 = (i4 + 8) % 10, u2 = (i4 + 2) % 10, a2 = n5[u2], l2 = n5[u2 + 1], f6 = pn$6(a2, l2, 1) ^ n5[c2], d4 = gn$6(a2, l2, 1) ^ n5[c2 + 1];
      for (let g2 = 0; g2 < 50; g2 += 10) e3[i4 + g2] ^= f6, e3[i4 + g2 + 1] ^= d4;
    }
    let o3 = e3[2], s2 = e3[3];
    for (let i4 = 0; i4 < 24; i4++) {
      const c2 = dn$6[i4], u2 = pn$6(o3, s2, c2), a2 = gn$6(o3, s2, c2), l2 = ln$6[i4];
      o3 = e3[l2], s2 = e3[l2 + 1], e3[l2] = u2, e3[l2 + 1] = a2;
    }
    for (let i4 = 0; i4 < 50; i4 += 10) {
      for (let c2 = 0; c2 < 10; c2++) n5[c2] = e3[i4 + c2];
      for (let c2 = 0; c2 < 10; c2++) e3[i4 + c2] ^= ~n5[(c2 + 2) % 10] & n5[(c2 + 4) % 10];
    }
    e3[0] ^= Co$4[r3], e3[1] ^= ko$4[r3];
  }
  n5.fill(0);
}
let Bt$6 = class Bt2 extends it$4 {
  constructor(t2, n5, r3, o3 = false, s2 = 24) {
    if (super(), this.blockLen = t2, this.suffix = n5, this.outputLen = r3, this.enableXOF = o3, this.rounds = s2, this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, Ne$6(r3), 0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = _o$4(this.state);
  }
  keccak() {
    an$6 || un$6(this.state32), Do$4(this.state32, this.rounds), an$6 || un$6(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(t2) {
    me$1(this);
    const { blockLen: n5, state: r3 } = this;
    t2 = we$6(t2);
    const o3 = t2.length;
    for (let s2 = 0; s2 < o3; ) {
      const i4 = Math.min(n5 - this.pos, o3 - s2);
      for (let c2 = 0; c2 < i4; c2++) r3[this.pos++] ^= t2[s2++];
      this.pos === n5 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const { state: t2, suffix: n5, pos: r3, blockLen: o3 } = this;
    t2[r3] ^= n5, (n5 & 128) !== 0 && r3 === o3 - 1 && this.keccak(), t2[o3 - 1] ^= 128, this.keccak();
  }
  writeInto(t2) {
    me$1(this, false), je$6(t2), this.finish();
    const n5 = this.state, { blockLen: r3 } = this;
    for (let o3 = 0, s2 = t2.length; o3 < s2; ) {
      this.posOut >= r3 && this.keccak();
      const i4 = Math.min(r3 - this.posOut, s2 - o3);
      t2.set(n5.subarray(this.posOut, this.posOut + i4), o3), this.posOut += i4, o3 += i4;
    }
    return t2;
  }
  xofInto(t2) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(t2);
  }
  xof(t2) {
    return Ne$6(t2), this.xofInto(new Uint8Array(t2));
  }
  digestInto(t2) {
    if (sn$6(t2, this), this.finished) throw new Error("digest() was already called");
    return this.writeInto(t2), this.destroy(), t2;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, this.state.fill(0);
  }
  _cloneInto(t2) {
    const { blockLen: n5, suffix: r3, outputLen: o3, rounds: s2, enableXOF: i4 } = this;
    return t2 || (t2 = new Bt2(n5, r3, o3, i4, s2)), t2.state32.set(this.state32), t2.pos = this.pos, t2.posOut = this.posOut, t2.finished = this.finished, t2.rounds = s2, t2.suffix = r3, t2.outputLen = o3, t2.enableXOF = i4, t2.destroyed = this.destroyed, t2;
  }
};
const Mo$4 = (e3, t2, n5) => fn$6(() => new Bt$6(t2, e3, n5)), Vo$4 = Mo$4(1, 136, 256 / 8), Ho$4 = "https://rpc.walletconnect.org/v1";
function ct$3(e3) {
  const t2 = `Ethereum Signed Message:
${e3.length}`, n5 = new TextEncoder().encode(t2 + e3);
  return "0x" + Buffer.from(Vo$4(n5)).toString("hex");
}
async function yn$6(e3, t2, n5, r3, o3, s2) {
  switch (n5.t) {
    case "eip191":
      return await mn$6(e3, t2, n5.s);
    case "eip1271":
      return await bn$6(e3, t2, n5.s, r3, o3, s2);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${n5.t}`);
  }
}
async function mn$6(e3, t2, n5) {
  return (await recoverAddress$2({ hash: ct$3(t2), signature: n5 })).toLowerCase() === e3.toLowerCase();
}
async function bn$6(e3, t2, n5, r3, o3, s2) {
  const i4 = Ye$4(r3);
  if (!i4.namespace || !i4.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r3}`);
  try {
    const c2 = "0x1626ba7e", u2 = "0000000000000000000000000000000000000000000000000000000000000040", a2 = "0000000000000000000000000000000000000000000000000000000000000041", l2 = n5.substring(2), f6 = ct$3(t2).substring(2), d4 = c2 + f6 + u2 + a2 + l2, g2 = await fetch(`${s2 || Ho$4}/?chainId=${r3}&projectId=${o3}`, { method: "POST", body: JSON.stringify({ id: Ko$4(), jsonrpc: "2.0", method: "eth_call", params: [{ to: e3, data: d4 }, "latest"] }) }), { result: y4 } = await g2.json();
    return y4 ? y4.slice(0, c2.length).toLowerCase() === c2.toLowerCase() : false;
  } catch (c2) {
    return console.error("isValidEip1271Signature: ", c2), false;
  }
}
function Ko$4() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
var Fo$4 = Object.defineProperty, qo$4 = Object.defineProperties, Go$4 = Object.getOwnPropertyDescriptors, wn$6 = Object.getOwnPropertySymbols, Wo$4 = Object.prototype.hasOwnProperty, zo$4 = Object.prototype.propertyIsEnumerable, En$6 = (e3, t2, n5) => t2 in e3 ? Fo$4(e3, t2, { enumerable: true, configurable: true, writable: true, value: n5 }) : e3[t2] = n5, at$3 = (e3, t2) => {
  for (var n5 in t2 || (t2 = {})) Wo$4.call(t2, n5) && En$6(e3, n5, t2[n5]);
  if (wn$6) for (var n5 of wn$6(t2)) zo$4.call(t2, n5) && En$6(e3, n5, t2[n5]);
  return e3;
}, vn$6 = (e3, t2) => qo$4(e3, Go$4(t2));
const Jo$4 = "did:pkh:", ke$8 = (e3) => e3 == null ? void 0 : e3.split(":"), xn$6 = (e3) => {
  const t2 = e3 && ke$8(e3);
  if (t2) return e3.includes(Jo$4) ? t2[3] : t2[1];
}, On$6 = (e3) => {
  const t2 = e3 && ke$8(e3);
  if (t2) return t2[2] + ":" + t2[3];
}, ut$6 = (e3) => {
  const t2 = e3 && ke$8(e3);
  if (t2) return t2.pop();
};
async function Yo$4(e3) {
  const { cacao: t2, projectId: n5 } = e3, { s: r3, p: o3 } = t2, s2 = In$6(o3, o3.iss), i4 = ut$6(o3.iss);
  return await yn$6(i4, s2, r3, On$6(o3.iss), n5);
}
const In$6 = (e3, t2) => {
  const n5 = `${e3.domain} wants you to sign in with your Ethereum account:`, r3 = ut$6(t2);
  if (!e3.aud && !e3.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
  let o3 = e3.statement || void 0;
  const s2 = `URI: ${e3.aud || e3.uri}`, i4 = `Version: ${e3.version}`, c2 = `Chain ID: ${xn$6(t2)}`, u2 = `Nonce: ${e3.nonce}`, a2 = `Issued At: ${e3.iat}`, l2 = e3.exp ? `Expiration Time: ${e3.exp}` : void 0, f6 = e3.nbf ? `Not Before: ${e3.nbf}` : void 0, d4 = e3.requestId ? `Request ID: ${e3.requestId}` : void 0, g2 = e3.resources ? `Resources:${e3.resources.map((h5) => `
- ${h5}`).join("")}` : void 0, y4 = Me$8(e3.resources);
  if (y4) {
    const h5 = oe$4(y4);
    o3 = dt$5(o3, h5);
  }
  return [n5, r3, "", o3, "", s2, i4, c2, u2, a2, l2, f6, d4, g2].filter((h5) => h5 != null).join(`
`);
};
function Xo$4(e3, t2, n5) {
  return n5.includes("did:pkh:") || (n5 = `did:pkh:${n5}`), { h: { t: "caip122" }, p: { iss: n5, domain: e3.domain, aud: e3.aud, version: e3.version, nonce: e3.nonce, iat: e3.iat, statement: e3.statement, requestId: e3.requestId, resources: e3.resources, nbf: e3.nbf, exp: e3.exp }, s: t2 };
}
function Zo$4(e3) {
  var t2;
  const { authPayload: n5, chains: r3, methods: o3 } = e3, s2 = n5.statement || "";
  if (!(r3 != null && r3.length)) return n5;
  const i4 = n5.chains, c2 = nt$3(i4, r3);
  if (!(c2 != null && c2.length)) throw new Error("No supported chains");
  const u2 = An$6(n5.resources);
  if (!u2) return n5;
  Y$3(u2);
  const a2 = Nn$6(u2, "eip155");
  let l2 = (n5 == null ? void 0 : n5.resources) || [];
  if (a2 != null && a2.length) {
    const f6 = Sn$6(a2), d4 = nt$3(f6, o3);
    if (!(d4 != null && d4.length)) throw new Error(`Supported methods don't satisfy the requested: ${JSON.stringify(f6)}, supported: ${JSON.stringify(o3)}`);
    const g2 = ft$5("request", d4, { chains: c2 }), y4 = $n$6(u2, "eip155", g2);
    l2 = ((t2 = n5 == null ? void 0 : n5.resources) == null ? void 0 : t2.slice(0, -1)) || [], l2.push(De$6(y4));
  }
  return vn$6(at$3({}, n5), { statement: Pn$6(s2, Me$8(l2)), chains: c2, resources: n5 != null && n5.resources || l2.length > 0 ? l2 : void 0 });
}
function An$6(e3) {
  const t2 = Me$8(e3);
  if (t2 && lt$3(t2)) return oe$4(t2);
}
function Qo$4(e3, t2) {
  var n5;
  return (n5 = e3 == null ? void 0 : e3.att) == null ? void 0 : n5.hasOwnProperty(t2);
}
function Nn$6(e3, t2) {
  var n5, r3;
  return (n5 = e3 == null ? void 0 : e3.att) != null && n5[t2] ? Object.keys((r3 = e3 == null ? void 0 : e3.att) == null ? void 0 : r3[t2]) : [];
}
function es$4(e3) {
  return (e3 == null ? void 0 : e3.map((t2) => Object.keys(t2))) || [];
}
function Sn$6(e3) {
  return (e3 == null ? void 0 : e3.map((t2) => {
    var n5;
    return (n5 = t2.split("/")) == null ? void 0 : n5[1];
  })) || [];
}
function Un$6(e3) {
  return Buffer.from(JSON.stringify(e3)).toString("base64");
}
function _n$6(e3) {
  return JSON.parse(Buffer.from(e3, "base64").toString("utf-8"));
}
function Y$3(e3) {
  if (!e3) throw new Error("No recap provided, value is undefined");
  if (!e3.att) throw new Error("No `att` property found");
  const t2 = Object.keys(e3.att);
  if (!(t2 != null && t2.length)) throw new Error("No resources found in `att` property");
  t2.forEach((n5) => {
    const r3 = e3.att[n5];
    if (Array.isArray(r3)) throw new Error(`Resource must be an object: ${n5}`);
    if (typeof r3 != "object") throw new Error(`Resource must be an object: ${n5}`);
    if (!Object.keys(r3).length) throw new Error(`Resource object is empty: ${n5}`);
    Object.keys(r3).forEach((o3) => {
      const s2 = r3[o3];
      if (!Array.isArray(s2)) throw new Error(`Ability limits ${o3} must be an array of objects, found: ${s2}`);
      if (!s2.length) throw new Error(`Value of ${o3} is empty array, must be an array with objects`);
      s2.forEach((i4) => {
        if (typeof i4 != "object") throw new Error(`Ability limits (${o3}) must be an array of objects, found: ${i4}`);
      });
    });
  });
}
function Tn$6(e3, t2, n5, r3 = {}) {
  return n5 == null ? void 0 : n5.sort((o3, s2) => o3.localeCompare(s2)), { att: { [e3]: ft$5(t2, n5, r3) } };
}
function $n$6(e3, t2, n5) {
  var r3;
  e3.att[t2] = at$3({}, n5);
  const o3 = (r3 = Object.keys(e3.att)) == null ? void 0 : r3.sort((i4, c2) => i4.localeCompare(c2)), s2 = { att: {} };
  return o3.reduce((i4, c2) => (i4.att[c2] = e3.att[c2], i4), s2);
}
function ft$5(e3, t2, n5 = {}) {
  t2 = t2 == null ? void 0 : t2.sort((o3, s2) => o3.localeCompare(s2));
  const r3 = t2.map((o3) => ({ [`${e3}/${o3}`]: [n5] }));
  return Object.assign({}, ...r3);
}
function De$6(e3) {
  return Y$3(e3), `urn:recap:${Un$6(e3).replace(/=/g, "")}`;
}
function oe$4(e3) {
  const t2 = _n$6(e3.replace("urn:recap:", ""));
  return Y$3(t2), t2;
}
function ts$4(e3, t2, n5) {
  const r3 = Tn$6(e3, t2, n5);
  return De$6(r3);
}
function lt$3(e3) {
  return e3 && e3.includes("urn:recap:");
}
function ns$4(e3, t2) {
  const n5 = oe$4(e3), r3 = oe$4(t2), o3 = Rn$6(n5, r3);
  return De$6(o3);
}
function Rn$6(e3, t2) {
  Y$3(e3), Y$3(t2);
  const n5 = Object.keys(e3.att).concat(Object.keys(t2.att)).sort((o3, s2) => o3.localeCompare(s2)), r3 = { att: {} };
  return n5.forEach((o3) => {
    var s2, i4;
    Object.keys(((s2 = e3.att) == null ? void 0 : s2[o3]) || {}).concat(Object.keys(((i4 = t2.att) == null ? void 0 : i4[o3]) || {})).sort((c2, u2) => c2.localeCompare(u2)).forEach((c2) => {
      var u2, a2;
      r3.att[o3] = vn$6(at$3({}, r3.att[o3]), { [c2]: ((u2 = e3.att[o3]) == null ? void 0 : u2[c2]) || ((a2 = t2.att[o3]) == null ? void 0 : a2[c2]) });
    });
  }), r3;
}
function dt$5(e3 = "", t2) {
  Y$3(t2);
  const n5 = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (e3.includes(n5)) return e3;
  const r3 = [];
  let o3 = 0;
  Object.keys(t2.att).forEach((c2) => {
    const u2 = Object.keys(t2.att[c2]).map((f6) => ({ ability: f6.split("/")[0], action: f6.split("/")[1] }));
    u2.sort((f6, d4) => f6.action.localeCompare(d4.action));
    const a2 = {};
    u2.forEach((f6) => {
      a2[f6.ability] || (a2[f6.ability] = []), a2[f6.ability].push(f6.action);
    });
    const l2 = Object.keys(a2).map((f6) => (o3++, `(${o3}) '${f6}': '${a2[f6].join("', '")}' for '${c2}'.`));
    r3.push(l2.join(", ").replace(".,", "."));
  });
  const s2 = r3.join(" "), i4 = `${n5}${s2}`;
  return `${e3 ? e3 + " " : ""}${i4}`;
}
function rs$4(e3) {
  var t2;
  const n5 = oe$4(e3);
  Y$3(n5);
  const r3 = (t2 = n5.att) == null ? void 0 : t2.eip155;
  return r3 ? Object.keys(r3).map((o3) => o3.split("/")[1]) : [];
}
function os$4(e3) {
  const t2 = oe$4(e3);
  Y$3(t2);
  const n5 = [];
  return Object.values(t2.att).forEach((r3) => {
    Object.values(r3).forEach((o3) => {
      var s2;
      (s2 = o3 == null ? void 0 : o3[0]) != null && s2.chains && n5.push(o3[0].chains);
    });
  }), [...new Set(n5.flat())];
}
function Pn$6(e3, t2) {
  if (!t2) return e3;
  const n5 = oe$4(t2);
  return Y$3(n5), dt$5(e3, n5);
}
function Me$8(e3) {
  if (!e3) return;
  const t2 = e3 == null ? void 0 : e3[e3.length - 1];
  return lt$3(t2) ? t2 : void 0;
}
function ht$5(e3) {
  if (!Number.isSafeInteger(e3) || e3 < 0) throw new Error("positive integer expected, got " + e3);
}
function Ln$6(e3) {
  return e3 instanceof Uint8Array || ArrayBuffer.isView(e3) && e3.constructor.name === "Uint8Array";
}
function F$6(e3, ...t2) {
  if (!Ln$6(e3)) throw new Error("Uint8Array expected");
  if (t2.length > 0 && !t2.includes(e3.length)) throw new Error("Uint8Array expected of length " + t2 + ", got length=" + e3.length);
}
function Bn$6(e3, t2 = true) {
  if (e3.destroyed) throw new Error("Hash instance has been destroyed");
  if (t2 && e3.finished) throw new Error("Hash#digest() has already been called");
}
function ss$4(e3, t2) {
  F$6(e3);
  const n5 = t2.outputLen;
  if (e3.length < n5) throw new Error("digestInto() expects output buffer of length at least " + n5);
}
function jn$6(e3) {
  if (typeof e3 != "boolean") throw new Error(`boolean expected, not ${e3}`);
}
const se$6 = (e3) => new Uint32Array(e3.buffer, e3.byteOffset, Math.floor(e3.byteLength / 4)), is$4 = (e3) => new DataView(e3.buffer, e3.byteOffset, e3.byteLength), cs$4 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!cs$4) throw new Error("Non little-endian hardware is not supported");
function as$4(e3) {
  if (typeof e3 != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(e3));
}
function pt$5(e3) {
  if (typeof e3 == "string") e3 = as$4(e3);
  else if (Ln$6(e3)) e3 = gt$1(e3);
  else throw new Error("Uint8Array expected, got " + typeof e3);
  return e3;
}
function us$4(e3, t2) {
  if (t2 == null || typeof t2 != "object") throw new Error("options must be defined");
  return Object.assign(e3, t2);
}
function fs$6(e3, t2) {
  if (e3.length !== t2.length) return false;
  let n5 = 0;
  for (let r3 = 0; r3 < e3.length; r3++) n5 |= e3[r3] ^ t2[r3];
  return n5 === 0;
}
const ls$4 = (e3, t2) => {
  function n5(r3, ...o3) {
    if (F$6(r3), e3.nonceLength !== void 0) {
      const l2 = o3[0];
      if (!l2) throw new Error("nonce / iv required");
      e3.varSizeNonce ? F$6(l2) : F$6(l2, e3.nonceLength);
    }
    const s2 = e3.tagLength;
    s2 && o3[1] !== void 0 && F$6(o3[1]);
    const i4 = t2(r3, ...o3), c2 = (l2, f6) => {
      if (f6 !== void 0) {
        if (l2 !== 2) throw new Error("cipher output not supported");
        F$6(f6);
      }
    };
    let u2 = false;
    return { encrypt(l2, f6) {
      if (u2) throw new Error("cannot encrypt() twice with same key + nonce");
      return u2 = true, F$6(l2), c2(i4.encrypt.length, f6), i4.encrypt(l2, f6);
    }, decrypt(l2, f6) {
      if (F$6(l2), s2 && l2.length < s2) throw new Error("invalid ciphertext length: smaller than tagLength=" + s2);
      return c2(i4.decrypt.length, f6), i4.decrypt(l2, f6);
    } };
  }
  return Object.assign(n5, e3), n5;
};
function Cn$6(e3, t2, n5 = true) {
  if (t2 === void 0) return new Uint8Array(e3);
  if (t2.length !== e3) throw new Error("invalid output length, expected " + e3 + ", got: " + t2.length);
  if (n5 && !ds$4(t2)) throw new Error("invalid output, must be aligned");
  return t2;
}
function kn$6(e3, t2, n5, r3) {
  if (typeof e3.setBigUint64 == "function") return e3.setBigUint64(t2, n5, r3);
  const o3 = BigInt(32), s2 = BigInt(4294967295), i4 = Number(n5 >> o3 & s2), c2 = Number(n5 & s2), u2 = 4, a2 = 0;
  e3.setUint32(t2 + u2, i4, r3), e3.setUint32(t2 + a2, c2, r3);
}
function ds$4(e3) {
  return e3.byteOffset % 4 === 0;
}
function gt$1(e3) {
  return Uint8Array.from(e3);
}
function Ee$6(...e3) {
  for (let t2 = 0; t2 < e3.length; t2++) e3[t2].fill(0);
}
const Dn$6 = (e3) => Uint8Array.from(e3.split("").map((t2) => t2.charCodeAt(0))), hs$4 = Dn$6("expand 16-byte k"), ps$4 = Dn$6("expand 32-byte k"), gs$4 = se$6(hs$4), ys$4 = se$6(ps$4);
function x$6(e3, t2) {
  return e3 << t2 | e3 >>> 32 - t2;
}
function yt$3(e3) {
  return e3.byteOffset % 4 === 0;
}
const Ve$6 = 64, ms$4 = 16, Mn$6 = 2 ** 32 - 1, Vn$6 = new Uint32Array();
function bs$6(e3, t2, n5, r3, o3, s2, i4, c2) {
  const u2 = o3.length, a2 = new Uint8Array(Ve$6), l2 = se$6(a2), f6 = yt$3(o3) && yt$3(s2), d4 = f6 ? se$6(o3) : Vn$6, g2 = f6 ? se$6(s2) : Vn$6;
  for (let y4 = 0; y4 < u2; i4++) {
    if (e3(t2, n5, r3, l2, i4, c2), i4 >= Mn$6) throw new Error("arx: counter overflow");
    const h5 = Math.min(Ve$6, u2 - y4);
    if (f6 && h5 === Ve$6) {
      const m4 = y4 / 4;
      if (y4 % 4 !== 0) throw new Error("arx: invalid block position");
      for (let B3 = 0, b2; B3 < ms$4; B3++) b2 = m4 + B3, g2[b2] = d4[b2] ^ l2[B3];
      y4 += Ve$6;
      continue;
    }
    for (let m4 = 0, B3; m4 < h5; m4++) B3 = y4 + m4, s2[B3] = o3[B3] ^ a2[m4];
    y4 += h5;
  }
}
function ws$4(e3, t2) {
  const { allowShortKeys: n5, extendNonceFn: r3, counterLength: o3, counterRight: s2, rounds: i4 } = us$4({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, t2);
  if (typeof e3 != "function") throw new Error("core must be a function");
  return ht$5(o3), ht$5(i4), jn$6(s2), jn$6(n5), (c2, u2, a2, l2, f6 = 0) => {
    F$6(c2), F$6(u2), F$6(a2);
    const d4 = a2.length;
    if (l2 === void 0 && (l2 = new Uint8Array(d4)), F$6(l2), ht$5(f6), f6 < 0 || f6 >= Mn$6) throw new Error("arx: counter overflow");
    if (l2.length < d4) throw new Error(`arx: output (${l2.length}) is shorter than data (${d4})`);
    const g2 = [];
    let y4 = c2.length, h5, m4;
    if (y4 === 32) g2.push(h5 = gt$1(c2)), m4 = ys$4;
    else if (y4 === 16 && n5) h5 = new Uint8Array(32), h5.set(c2), h5.set(c2, 16), m4 = gs$4, g2.push(h5);
    else throw new Error(`arx: invalid 32-byte key, got length=${y4}`);
    yt$3(u2) || g2.push(u2 = gt$1(u2));
    const B3 = se$6(h5);
    if (r3) {
      if (u2.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
      r3(m4, B3, se$6(u2.subarray(0, 16)), B3), u2 = u2.subarray(16);
    }
    const b2 = 16 - o3;
    if (b2 !== u2.length) throw new Error(`arx: nonce must be ${b2} or 16 bytes`);
    if (b2 !== 12) {
      const I4 = new Uint8Array(12);
      I4.set(u2, s2 ? 0 : 12 - u2.length), u2 = I4, g2.push(u2);
    }
    const _3 = se$6(u2);
    return bs$6(e3, m4, B3, _3, a2, l2, f6, i4), Ee$6(...g2), l2;
  };
}
const M$7 = (e3, t2) => e3[t2++] & 255 | (e3[t2++] & 255) << 8;
let Es$4 = class Es2 {
  constructor(t2) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, t2 = pt$5(t2), F$6(t2, 32);
    const n5 = M$7(t2, 0), r3 = M$7(t2, 2), o3 = M$7(t2, 4), s2 = M$7(t2, 6), i4 = M$7(t2, 8), c2 = M$7(t2, 10), u2 = M$7(t2, 12), a2 = M$7(t2, 14);
    this.r[0] = n5 & 8191, this.r[1] = (n5 >>> 13 | r3 << 3) & 8191, this.r[2] = (r3 >>> 10 | o3 << 6) & 7939, this.r[3] = (o3 >>> 7 | s2 << 9) & 8191, this.r[4] = (s2 >>> 4 | i4 << 12) & 255, this.r[5] = i4 >>> 1 & 8190, this.r[6] = (i4 >>> 14 | c2 << 2) & 8191, this.r[7] = (c2 >>> 11 | u2 << 5) & 8065, this.r[8] = (u2 >>> 8 | a2 << 8) & 8191, this.r[9] = a2 >>> 5 & 127;
    for (let l2 = 0; l2 < 8; l2++) this.pad[l2] = M$7(t2, 16 + 2 * l2);
  }
  process(t2, n5, r3 = false) {
    const o3 = r3 ? 0 : 2048, { h: s2, r: i4 } = this, c2 = i4[0], u2 = i4[1], a2 = i4[2], l2 = i4[3], f6 = i4[4], d4 = i4[5], g2 = i4[6], y4 = i4[7], h5 = i4[8], m4 = i4[9], B3 = M$7(t2, n5 + 0), b2 = M$7(t2, n5 + 2), _3 = M$7(t2, n5 + 4), I4 = M$7(t2, n5 + 6), k3 = M$7(t2, n5 + 8), E2 = M$7(t2, n5 + 10), L4 = M$7(t2, n5 + 12), j2 = M$7(t2, n5 + 14);
    let v2 = s2[0] + (B3 & 8191), O4 = s2[1] + ((B3 >>> 13 | b2 << 3) & 8191), w2 = s2[2] + ((b2 >>> 10 | _3 << 6) & 8191), R5 = s2[3] + ((_3 >>> 7 | I4 << 9) & 8191), A2 = s2[4] + ((I4 >>> 4 | k3 << 12) & 8191), T2 = s2[5] + (k3 >>> 1 & 8191), N3 = s2[6] + ((k3 >>> 14 | E2 << 2) & 8191), S4 = s2[7] + ((E2 >>> 11 | L4 << 5) & 8191), U = s2[8] + ((L4 >>> 8 | j2 << 8) & 8191), $2 = s2[9] + (j2 >>> 5 | o3), p2 = 0, C2 = p2 + v2 * c2 + O4 * (5 * m4) + w2 * (5 * h5) + R5 * (5 * y4) + A2 * (5 * g2);
    p2 = C2 >>> 13, C2 &= 8191, C2 += T2 * (5 * d4) + N3 * (5 * f6) + S4 * (5 * l2) + U * (5 * a2) + $2 * (5 * u2), p2 += C2 >>> 13, C2 &= 8191;
    let D2 = p2 + v2 * u2 + O4 * c2 + w2 * (5 * m4) + R5 * (5 * h5) + A2 * (5 * y4);
    p2 = D2 >>> 13, D2 &= 8191, D2 += T2 * (5 * g2) + N3 * (5 * d4) + S4 * (5 * f6) + U * (5 * l2) + $2 * (5 * a2), p2 += D2 >>> 13, D2 &= 8191;
    let P3 = p2 + v2 * a2 + O4 * u2 + w2 * c2 + R5 * (5 * m4) + A2 * (5 * h5);
    p2 = P3 >>> 13, P3 &= 8191, P3 += T2 * (5 * y4) + N3 * (5 * g2) + S4 * (5 * d4) + U * (5 * f6) + $2 * (5 * l2), p2 += P3 >>> 13, P3 &= 8191;
    let G2 = p2 + v2 * l2 + O4 * a2 + w2 * u2 + R5 * c2 + A2 * (5 * m4);
    p2 = G2 >>> 13, G2 &= 8191, G2 += T2 * (5 * h5) + N3 * (5 * y4) + S4 * (5 * g2) + U * (5 * d4) + $2 * (5 * f6), p2 += G2 >>> 13, G2 &= 8191;
    let X2 = p2 + v2 * f6 + O4 * l2 + w2 * a2 + R5 * u2 + A2 * c2;
    p2 = X2 >>> 13, X2 &= 8191, X2 += T2 * (5 * m4) + N3 * (5 * h5) + S4 * (5 * y4) + U * (5 * g2) + $2 * (5 * d4), p2 += X2 >>> 13, X2 &= 8191;
    let Z3 = p2 + v2 * d4 + O4 * f6 + w2 * l2 + R5 * a2 + A2 * u2;
    p2 = Z3 >>> 13, Z3 &= 8191, Z3 += T2 * c2 + N3 * (5 * m4) + S4 * (5 * h5) + U * (5 * y4) + $2 * (5 * g2), p2 += Z3 >>> 13, Z3 &= 8191;
    let he2 = p2 + v2 * g2 + O4 * d4 + w2 * f6 + R5 * l2 + A2 * a2;
    p2 = he2 >>> 13, he2 &= 8191, he2 += T2 * u2 + N3 * c2 + S4 * (5 * m4) + U * (5 * h5) + $2 * (5 * y4), p2 += he2 >>> 13, he2 &= 8191;
    let pe2 = p2 + v2 * y4 + O4 * g2 + w2 * d4 + R5 * f6 + A2 * l2;
    p2 = pe2 >>> 13, pe2 &= 8191, pe2 += T2 * a2 + N3 * u2 + S4 * c2 + U * (5 * m4) + $2 * (5 * h5), p2 += pe2 >>> 13, pe2 &= 8191;
    let ge2 = p2 + v2 * h5 + O4 * y4 + w2 * g2 + R5 * d4 + A2 * f6;
    p2 = ge2 >>> 13, ge2 &= 8191, ge2 += T2 * l2 + N3 * a2 + S4 * u2 + U * c2 + $2 * (5 * m4), p2 += ge2 >>> 13, ge2 &= 8191;
    let ye2 = p2 + v2 * m4 + O4 * h5 + w2 * y4 + R5 * g2 + A2 * d4;
    p2 = ye2 >>> 13, ye2 &= 8191, ye2 += T2 * f6 + N3 * l2 + S4 * a2 + U * u2 + $2 * c2, p2 += ye2 >>> 13, ye2 &= 8191, p2 = (p2 << 2) + p2 | 0, p2 = p2 + C2 | 0, C2 = p2 & 8191, p2 = p2 >>> 13, D2 += p2, s2[0] = C2, s2[1] = D2, s2[2] = P3, s2[3] = G2, s2[4] = X2, s2[5] = Z3, s2[6] = he2, s2[7] = pe2, s2[8] = ge2, s2[9] = ye2;
  }
  finalize() {
    const { h: t2, pad: n5 } = this, r3 = new Uint16Array(10);
    let o3 = t2[1] >>> 13;
    t2[1] &= 8191;
    for (let c2 = 2; c2 < 10; c2++) t2[c2] += o3, o3 = t2[c2] >>> 13, t2[c2] &= 8191;
    t2[0] += o3 * 5, o3 = t2[0] >>> 13, t2[0] &= 8191, t2[1] += o3, o3 = t2[1] >>> 13, t2[1] &= 8191, t2[2] += o3, r3[0] = t2[0] + 5, o3 = r3[0] >>> 13, r3[0] &= 8191;
    for (let c2 = 1; c2 < 10; c2++) r3[c2] = t2[c2] + o3, o3 = r3[c2] >>> 13, r3[c2] &= 8191;
    r3[9] -= 8192;
    let s2 = (o3 ^ 1) - 1;
    for (let c2 = 0; c2 < 10; c2++) r3[c2] &= s2;
    s2 = ~s2;
    for (let c2 = 0; c2 < 10; c2++) t2[c2] = t2[c2] & s2 | r3[c2];
    t2[0] = (t2[0] | t2[1] << 13) & 65535, t2[1] = (t2[1] >>> 3 | t2[2] << 10) & 65535, t2[2] = (t2[2] >>> 6 | t2[3] << 7) & 65535, t2[3] = (t2[3] >>> 9 | t2[4] << 4) & 65535, t2[4] = (t2[4] >>> 12 | t2[5] << 1 | t2[6] << 14) & 65535, t2[5] = (t2[6] >>> 2 | t2[7] << 11) & 65535, t2[6] = (t2[7] >>> 5 | t2[8] << 8) & 65535, t2[7] = (t2[8] >>> 8 | t2[9] << 5) & 65535;
    let i4 = t2[0] + n5[0];
    t2[0] = i4 & 65535;
    for (let c2 = 1; c2 < 8; c2++) i4 = (t2[c2] + n5[c2] | 0) + (i4 >>> 16) | 0, t2[c2] = i4 & 65535;
    Ee$6(r3);
  }
  update(t2) {
    Bn$6(this);
    const { buffer: n5, blockLen: r3 } = this;
    t2 = pt$5(t2);
    const o3 = t2.length;
    for (let s2 = 0; s2 < o3; ) {
      const i4 = Math.min(r3 - this.pos, o3 - s2);
      if (i4 === r3) {
        for (; r3 <= o3 - s2; s2 += r3) this.process(t2, s2);
        continue;
      }
      n5.set(t2.subarray(s2, s2 + i4), this.pos), this.pos += i4, s2 += i4, this.pos === r3 && (this.process(n5, 0, false), this.pos = 0);
    }
    return this;
  }
  destroy() {
    Ee$6(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(t2) {
    Bn$6(this), ss$4(t2, this), this.finished = true;
    const { buffer: n5, h: r3 } = this;
    let { pos: o3 } = this;
    if (o3) {
      for (n5[o3++] = 1; o3 < 16; o3++) n5[o3] = 0;
      this.process(n5, 0, true);
    }
    this.finalize();
    let s2 = 0;
    for (let i4 = 0; i4 < 8; i4++) t2[s2++] = r3[i4] >>> 0, t2[s2++] = r3[i4] >>> 8;
    return t2;
  }
  digest() {
    const { buffer: t2, outputLen: n5 } = this;
    this.digestInto(t2);
    const r3 = t2.slice(0, n5);
    return this.destroy(), r3;
  }
};
function vs$6(e3) {
  const t2 = (r3, o3) => e3(o3).update(pt$5(r3)).digest(), n5 = e3(new Uint8Array(32));
  return t2.outputLen = n5.outputLen, t2.blockLen = n5.blockLen, t2.create = (r3) => e3(r3), t2;
}
const xs$6 = vs$6((e3) => new Es$4(e3));
function Os$6(e3, t2, n5, r3, o3, s2 = 20) {
  let i4 = e3[0], c2 = e3[1], u2 = e3[2], a2 = e3[3], l2 = t2[0], f6 = t2[1], d4 = t2[2], g2 = t2[3], y4 = t2[4], h5 = t2[5], m4 = t2[6], B3 = t2[7], b2 = o3, _3 = n5[0], I4 = n5[1], k3 = n5[2], E2 = i4, L4 = c2, j2 = u2, v2 = a2, O4 = l2, w2 = f6, R5 = d4, A2 = g2, T2 = y4, N3 = h5, S4 = m4, U = B3, $2 = b2, p2 = _3, C2 = I4, D2 = k3;
  for (let G2 = 0; G2 < s2; G2 += 2) E2 = E2 + O4 | 0, $2 = x$6($2 ^ E2, 16), T2 = T2 + $2 | 0, O4 = x$6(O4 ^ T2, 12), E2 = E2 + O4 | 0, $2 = x$6($2 ^ E2, 8), T2 = T2 + $2 | 0, O4 = x$6(O4 ^ T2, 7), L4 = L4 + w2 | 0, p2 = x$6(p2 ^ L4, 16), N3 = N3 + p2 | 0, w2 = x$6(w2 ^ N3, 12), L4 = L4 + w2 | 0, p2 = x$6(p2 ^ L4, 8), N3 = N3 + p2 | 0, w2 = x$6(w2 ^ N3, 7), j2 = j2 + R5 | 0, C2 = x$6(C2 ^ j2, 16), S4 = S4 + C2 | 0, R5 = x$6(R5 ^ S4, 12), j2 = j2 + R5 | 0, C2 = x$6(C2 ^ j2, 8), S4 = S4 + C2 | 0, R5 = x$6(R5 ^ S4, 7), v2 = v2 + A2 | 0, D2 = x$6(D2 ^ v2, 16), U = U + D2 | 0, A2 = x$6(A2 ^ U, 12), v2 = v2 + A2 | 0, D2 = x$6(D2 ^ v2, 8), U = U + D2 | 0, A2 = x$6(A2 ^ U, 7), E2 = E2 + w2 | 0, D2 = x$6(D2 ^ E2, 16), S4 = S4 + D2 | 0, w2 = x$6(w2 ^ S4, 12), E2 = E2 + w2 | 0, D2 = x$6(D2 ^ E2, 8), S4 = S4 + D2 | 0, w2 = x$6(w2 ^ S4, 7), L4 = L4 + R5 | 0, $2 = x$6($2 ^ L4, 16), U = U + $2 | 0, R5 = x$6(R5 ^ U, 12), L4 = L4 + R5 | 0, $2 = x$6($2 ^ L4, 8), U = U + $2 | 0, R5 = x$6(R5 ^ U, 7), j2 = j2 + A2 | 0, p2 = x$6(p2 ^ j2, 16), T2 = T2 + p2 | 0, A2 = x$6(A2 ^ T2, 12), j2 = j2 + A2 | 0, p2 = x$6(p2 ^ j2, 8), T2 = T2 + p2 | 0, A2 = x$6(A2 ^ T2, 7), v2 = v2 + O4 | 0, C2 = x$6(C2 ^ v2, 16), N3 = N3 + C2 | 0, O4 = x$6(O4 ^ N3, 12), v2 = v2 + O4 | 0, C2 = x$6(C2 ^ v2, 8), N3 = N3 + C2 | 0, O4 = x$6(O4 ^ N3, 7);
  let P3 = 0;
  r3[P3++] = i4 + E2 | 0, r3[P3++] = c2 + L4 | 0, r3[P3++] = u2 + j2 | 0, r3[P3++] = a2 + v2 | 0, r3[P3++] = l2 + O4 | 0, r3[P3++] = f6 + w2 | 0, r3[P3++] = d4 + R5 | 0, r3[P3++] = g2 + A2 | 0, r3[P3++] = y4 + T2 | 0, r3[P3++] = h5 + N3 | 0, r3[P3++] = m4 + S4 | 0, r3[P3++] = B3 + U | 0, r3[P3++] = b2 + $2 | 0, r3[P3++] = _3 + p2 | 0, r3[P3++] = I4 + C2 | 0, r3[P3++] = k3 + D2 | 0;
}
const Is$6 = ws$4(Os$6, { counterRight: false, counterLength: 4, allowShortKeys: false }), As$6 = new Uint8Array(16), Hn$6 = (e3, t2) => {
  e3.update(t2);
  const n5 = t2.length % 16;
  n5 && e3.update(As$6.subarray(n5));
}, Ns$6 = new Uint8Array(32);
function Kn$6(e3, t2, n5, r3, o3) {
  const s2 = e3(t2, n5, Ns$6), i4 = xs$6.create(s2);
  o3 && Hn$6(i4, o3), Hn$6(i4, r3);
  const c2 = new Uint8Array(16), u2 = is$4(c2);
  kn$6(u2, 0, BigInt(o3 ? o3.length : 0), true), kn$6(u2, 8, BigInt(r3.length), true), i4.update(c2);
  const a2 = i4.digest();
  return Ee$6(s2, c2), a2;
}
const Ss$4 = (e3) => (t2, n5, r3) => ({ encrypt(s2, i4) {
  const c2 = s2.length;
  i4 = Cn$6(c2 + 16, i4, false), i4.set(s2);
  const u2 = i4.subarray(0, -16);
  e3(t2, n5, u2, u2, 1);
  const a2 = Kn$6(e3, t2, n5, u2, r3);
  return i4.set(a2, c2), Ee$6(a2), i4;
}, decrypt(s2, i4) {
  i4 = Cn$6(s2.length - 16, i4, false);
  const c2 = s2.subarray(0, -16), u2 = s2.subarray(-16), a2 = Kn$6(e3, t2, n5, c2, r3);
  if (!fs$6(u2, a2)) throw new Error("invalid tag");
  return i4.set(s2.subarray(0, -16)), e3(t2, n5, i4, i4, 1), Ee$6(a2), i4;
} }), Fn$6 = ls$4({ blockSize: 64, nonceLength: 12, tagLength: 16 }, Ss$4(Is$6));
let qn$6 = class qn2 extends it$4 {
  constructor(t2, n5) {
    super(), this.finished = false, this.destroyed = false, ot$3(t2);
    const r3 = we$6(n5);
    if (this.iHash = t2.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o3 = this.blockLen, s2 = new Uint8Array(o3);
    s2.set(r3.length > o3 ? t2.create().update(r3).digest() : r3);
    for (let i4 = 0; i4 < s2.length; i4++) s2[i4] ^= 54;
    this.iHash.update(s2), this.oHash = t2.create();
    for (let i4 = 0; i4 < s2.length; i4++) s2[i4] ^= 106;
    this.oHash.update(s2), s2.fill(0);
  }
  update(t2) {
    return me$1(this), this.iHash.update(t2), this;
  }
  digestInto(t2) {
    me$1(this), je$6(t2, this.outputLen), this.finished = true, this.iHash.digestInto(t2), this.oHash.update(t2), this.oHash.digestInto(t2), this.destroy();
  }
  digest() {
    const t2 = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t2), t2;
  }
  _cloneInto(t2) {
    t2 || (t2 = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n5, iHash: r3, finished: o3, destroyed: s2, blockLen: i4, outputLen: c2 } = this;
    return t2 = t2, t2.finished = o3, t2.destroyed = s2, t2.blockLen = i4, t2.outputLen = c2, t2.oHash = n5._cloneInto(t2.oHash), t2.iHash = r3._cloneInto(t2.iHash), t2;
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
const mt$3 = (e3, t2, n5) => new qn$6(e3, t2).update(n5).digest();
mt$3.create = (e3, t2) => new qn$6(e3, t2);
function Us$4(e3, t2, n5) {
  return ot$3(e3), n5 === void 0 && (n5 = new Uint8Array(e3.outputLen)), mt$3(e3, we$6(n5), we$6(t2));
}
const bt$1 = new Uint8Array([0]), Gn$6 = new Uint8Array();
function _s$4(e3, t2, n5, r3 = 32) {
  if (ot$3(e3), Ne$6(r3), r3 > 255 * e3.outputLen) throw new Error("Length should be <= 255*HashLen");
  const o3 = Math.ceil(r3 / e3.outputLen);
  n5 === void 0 && (n5 = Gn$6);
  const s2 = new Uint8Array(o3 * e3.outputLen), i4 = mt$3.create(e3, t2), c2 = i4._cloneInto(), u2 = new Uint8Array(i4.outputLen);
  for (let a2 = 0; a2 < o3; a2++) bt$1[0] = a2 + 1, c2.update(a2 === 0 ? Gn$6 : u2).update(n5).update(bt$1).digestInto(u2), s2.set(u2, e3.outputLen * a2), i4._cloneInto(c2);
  return i4.destroy(), c2.destroy(), u2.fill(0), bt$1.fill(0), s2.slice(0, r3);
}
const Ts$6 = (e3, t2, n5, r3, o3) => _s$4(e3, Us$4(e3, t2, n5), r3, o3);
function $s$4(e3, t2, n5, r3) {
  if (typeof e3.setBigUint64 == "function") return e3.setBigUint64(t2, n5, r3);
  const o3 = BigInt(32), s2 = BigInt(4294967295), i4 = Number(n5 >> o3 & s2), c2 = Number(n5 & s2), u2 = r3 ? 4 : 0, a2 = r3 ? 0 : 4;
  e3.setUint32(t2 + u2, i4, r3), e3.setUint32(t2 + a2, c2, r3);
}
function Rs$6(e3, t2, n5) {
  return e3 & t2 ^ ~e3 & n5;
}
function Ps$6(e3, t2, n5) {
  return e3 & t2 ^ e3 & n5 ^ t2 & n5;
}
let Ls$7 = class Ls2 extends it$4 {
  constructor(t2, n5, r3, o3) {
    super(), this.blockLen = t2, this.outputLen = n5, this.padOffset = r3, this.isLE = o3, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(t2), this.view = st$4(this.buffer);
  }
  update(t2) {
    me$1(this);
    const { view: n5, buffer: r3, blockLen: o3 } = this;
    t2 = we$6(t2);
    const s2 = t2.length;
    for (let i4 = 0; i4 < s2; ) {
      const c2 = Math.min(o3 - this.pos, s2 - i4);
      if (c2 === o3) {
        const u2 = st$4(t2);
        for (; o3 <= s2 - i4; i4 += o3) this.process(u2, i4);
        continue;
      }
      r3.set(t2.subarray(i4, i4 + c2), this.pos), this.pos += c2, i4 += c2, this.pos === o3 && (this.process(n5, 0), this.pos = 0);
    }
    return this.length += t2.length, this.roundClean(), this;
  }
  digestInto(t2) {
    me$1(this), sn$6(t2, this), this.finished = true;
    const { buffer: n5, view: r3, blockLen: o3, isLE: s2 } = this;
    let { pos: i4 } = this;
    n5[i4++] = 128, this.buffer.subarray(i4).fill(0), this.padOffset > o3 - i4 && (this.process(r3, 0), i4 = 0);
    for (let f6 = i4; f6 < o3; f6++) n5[f6] = 0;
    $s$4(r3, o3 - 8, BigInt(this.length * 8), s2), this.process(r3, 0);
    const c2 = st$4(t2), u2 = this.outputLen;
    if (u2 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const a2 = u2 / 4, l2 = this.get();
    if (a2 > l2.length) throw new Error("_sha2: outputLen bigger than state");
    for (let f6 = 0; f6 < a2; f6++) c2.setUint32(4 * f6, l2[f6], s2);
  }
  digest() {
    const { buffer: t2, outputLen: n5 } = this;
    this.digestInto(t2);
    const r3 = t2.slice(0, n5);
    return this.destroy(), r3;
  }
  _cloneInto(t2) {
    t2 || (t2 = new this.constructor()), t2.set(...this.get());
    const { blockLen: n5, buffer: r3, length: o3, finished: s2, destroyed: i4, pos: c2 } = this;
    return t2.length = o3, t2.pos = c2, t2.finished = s2, t2.destroyed = i4, o3 % n5 && t2.buffer.set(r3), t2;
  }
};
const Bs$4 = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]), ie$6 = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]), ce$5 = new Uint32Array(64);
let js$6 = class js2 extends Ls$7 {
  constructor() {
    super(64, 32, 8, false), this.A = ie$6[0] | 0, this.B = ie$6[1] | 0, this.C = ie$6[2] | 0, this.D = ie$6[3] | 0, this.E = ie$6[4] | 0, this.F = ie$6[5] | 0, this.G = ie$6[6] | 0, this.H = ie$6[7] | 0;
  }
  get() {
    const { A: t2, B: n5, C: r3, D: o3, E: s2, F: i4, G: c2, H: u2 } = this;
    return [t2, n5, r3, o3, s2, i4, c2, u2];
  }
  set(t2, n5, r3, o3, s2, i4, c2, u2) {
    this.A = t2 | 0, this.B = n5 | 0, this.C = r3 | 0, this.D = o3 | 0, this.E = s2 | 0, this.F = i4 | 0, this.G = c2 | 0, this.H = u2 | 0;
  }
  process(t2, n5) {
    for (let f6 = 0; f6 < 16; f6++, n5 += 4) ce$5[f6] = t2.getUint32(n5, false);
    for (let f6 = 16; f6 < 64; f6++) {
      const d4 = ce$5[f6 - 15], g2 = ce$5[f6 - 2], y4 = J$6(d4, 7) ^ J$6(d4, 18) ^ d4 >>> 3, h5 = J$6(g2, 17) ^ J$6(g2, 19) ^ g2 >>> 10;
      ce$5[f6] = h5 + ce$5[f6 - 7] + y4 + ce$5[f6 - 16] | 0;
    }
    let { A: r3, B: o3, C: s2, D: i4, E: c2, F: u2, G: a2, H: l2 } = this;
    for (let f6 = 0; f6 < 64; f6++) {
      const d4 = J$6(c2, 6) ^ J$6(c2, 11) ^ J$6(c2, 25), g2 = l2 + d4 + Rs$6(c2, u2, a2) + Bs$4[f6] + ce$5[f6] | 0, h5 = (J$6(r3, 2) ^ J$6(r3, 13) ^ J$6(r3, 22)) + Ps$6(r3, o3, s2) | 0;
      l2 = a2, a2 = u2, u2 = c2, c2 = i4 + g2 | 0, i4 = s2, s2 = o3, o3 = r3, r3 = g2 + h5 | 0;
    }
    r3 = r3 + this.A | 0, o3 = o3 + this.B | 0, s2 = s2 + this.C | 0, i4 = i4 + this.D | 0, c2 = c2 + this.E | 0, u2 = u2 + this.F | 0, a2 = a2 + this.G | 0, l2 = l2 + this.H | 0, this.set(r3, o3, s2, i4, c2, u2, a2, l2);
  }
  roundClean() {
    ce$5.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
const He$6 = fn$6(() => new js$6());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Wn$6 = BigInt(0);
function wt$5(e3) {
  return e3 instanceof Uint8Array || ArrayBuffer.isView(e3) && e3.constructor.name === "Uint8Array";
}
function zn$6(e3) {
  if (!wt$5(e3)) throw new Error("Uint8Array expected");
}
const Cs$6 = Array.from({ length: 256 }, (e3, t2) => t2.toString(16).padStart(2, "0"));
function ks$4(e3) {
  zn$6(e3);
  let t2 = "";
  for (let n5 = 0; n5 < e3.length; n5++) t2 += Cs$6[e3[n5]];
  return t2;
}
function Ds$6(e3) {
  if (typeof e3 != "string") throw new Error("hex string expected, got " + typeof e3);
  return e3 === "" ? Wn$6 : BigInt("0x" + e3);
}
const ee$1 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Jn$6(e3) {
  if (e3 >= ee$1._0 && e3 <= ee$1._9) return e3 - ee$1._0;
  if (e3 >= ee$1.A && e3 <= ee$1.F) return e3 - (ee$1.A - 10);
  if (e3 >= ee$1.a && e3 <= ee$1.f) return e3 - (ee$1.a - 10);
}
function Yn$6(e3) {
  if (typeof e3 != "string") throw new Error("hex string expected, got " + typeof e3);
  const t2 = e3.length, n5 = t2 / 2;
  if (t2 % 2) throw new Error("hex string expected, got unpadded hex of length " + t2);
  const r3 = new Uint8Array(n5);
  for (let o3 = 0, s2 = 0; o3 < n5; o3++, s2 += 2) {
    const i4 = Jn$6(e3.charCodeAt(s2)), c2 = Jn$6(e3.charCodeAt(s2 + 1));
    if (i4 === void 0 || c2 === void 0) {
      const u2 = e3[s2] + e3[s2 + 1];
      throw new Error('hex string expected, got non-hex character "' + u2 + '" at index ' + s2);
    }
    r3[o3] = i4 * 16 + c2;
  }
  return r3;
}
function Xn$6(e3) {
  return zn$6(e3), Ds$6(ks$4(Uint8Array.from(e3).reverse()));
}
function Ms$4(e3, t2) {
  return Yn$6(e3.toString(16).padStart(t2 * 2, "0"));
}
function Vs$6(e3, t2) {
  return Ms$4(e3, t2).reverse();
}
function Zn$6(e3, t2, n5) {
  let r3;
  if (typeof t2 == "string") try {
    r3 = Yn$6(t2);
  } catch (s2) {
    throw new Error(e3 + " must be hex string or Uint8Array, cause: " + s2);
  }
  else if (wt$5(t2)) r3 = Uint8Array.from(t2);
  else throw new Error(e3 + " must be hex string or Uint8Array");
  const o3 = r3.length;
  if (typeof n5 == "number" && o3 !== n5) throw new Error(e3 + " of length " + n5 + " expected, got " + o3);
  return r3;
}
const Et$8 = (e3) => typeof e3 == "bigint" && Wn$6 <= e3;
function Hs$6(e3, t2, n5) {
  return Et$8(e3) && Et$8(t2) && Et$8(n5) && t2 <= e3 && e3 < n5;
}
function Qn$6(e3, t2, n5, r3) {
  if (!Hs$6(t2, n5, r3)) throw new Error("expected valid " + e3 + ": " + n5 + " <= n < " + r3 + ", got " + t2);
}
const Ks$4 = { bigint: (e3) => typeof e3 == "bigint", function: (e3) => typeof e3 == "function", boolean: (e3) => typeof e3 == "boolean", string: (e3) => typeof e3 == "string", stringOrUint8Array: (e3) => typeof e3 == "string" || wt$5(e3), isSafeInteger: (e3) => Number.isSafeInteger(e3), array: (e3) => Array.isArray(e3), field: (e3, t2) => t2.Fp.isValid(e3), hash: (e3) => typeof e3 == "function" && Number.isSafeInteger(e3.outputLen) };
function Fs$4(e3, t2, n5 = {}) {
  const r3 = (o3, s2, i4) => {
    const c2 = Ks$4[s2];
    if (typeof c2 != "function") throw new Error("invalid validator function");
    const u2 = e3[o3];
    if (!(i4 && u2 === void 0) && !c2(u2, e3)) throw new Error("param " + String(o3) + " is invalid. Expected " + s2 + ", got " + u2);
  };
  for (const [o3, s2] of Object.entries(t2)) r3(o3, s2, false);
  for (const [o3, s2] of Object.entries(n5)) r3(o3, s2, true);
  return e3;
}
const ve$3 = BigInt(0), Ke$8 = BigInt(1);
function er$6(e3, t2) {
  const n5 = e3 % t2;
  return n5 >= ve$3 ? n5 : t2 + n5;
}
function qs$8(e3, t2, n5) {
  if (t2 < ve$3) throw new Error("invalid exponent, negatives unsupported");
  if (n5 <= ve$3) throw new Error("invalid modulus");
  if (n5 === Ke$8) return ve$3;
  let r3 = Ke$8;
  for (; t2 > ve$3; ) t2 & Ke$8 && (r3 = r3 * e3 % n5), e3 = e3 * e3 % n5, t2 >>= Ke$8;
  return r3;
}
function z$9(e3, t2, n5) {
  let r3 = e3;
  for (; t2-- > ve$3; ) r3 *= r3, r3 %= n5;
  return r3;
}
BigInt(0), BigInt(1), BigInt(0), BigInt(1), BigInt(2), BigInt(8);
const xe$6 = BigInt(0), vt$5 = BigInt(1);
function Gs$6(e3) {
  return Fs$4(e3, { a: "bigint" }, { montgomeryBits: "isSafeInteger", nByteLength: "isSafeInteger", adjustScalarBytes: "function", domain: "function", powPminus2: "function", Gu: "bigint" }), Object.freeze({ ...e3 });
}
function Ws$6(e3) {
  const t2 = Gs$6(e3), { P: n5 } = t2, r3 = (b2) => er$6(b2, n5), o3 = t2.montgomeryBits, s2 = Math.ceil(o3 / 8), i4 = t2.nByteLength, c2 = t2.adjustScalarBytes || ((b2) => b2), u2 = t2.powPminus2 || ((b2) => qs$8(b2, n5 - BigInt(2), n5));
  function a2(b2, _3, I4) {
    const k3 = r3(b2 * (_3 - I4));
    return _3 = r3(_3 - k3), I4 = r3(I4 + k3), [_3, I4];
  }
  const l2 = (t2.a - BigInt(2)) / BigInt(4);
  function f6(b2, _3) {
    Qn$6("u", b2, xe$6, n5), Qn$6("scalar", _3, xe$6, n5);
    const I4 = _3, k3 = b2;
    let E2 = vt$5, L4 = xe$6, j2 = b2, v2 = vt$5, O4 = xe$6, w2;
    for (let A2 = BigInt(o3 - 1); A2 >= xe$6; A2--) {
      const T2 = I4 >> A2 & vt$5;
      O4 ^= T2, w2 = a2(O4, E2, j2), E2 = w2[0], j2 = w2[1], w2 = a2(O4, L4, v2), L4 = w2[0], v2 = w2[1], O4 = T2;
      const N3 = E2 + L4, S4 = r3(N3 * N3), U = E2 - L4, $2 = r3(U * U), p2 = S4 - $2, C2 = j2 + v2, D2 = j2 - v2, P3 = r3(D2 * N3), G2 = r3(C2 * U), X2 = P3 + G2, Z3 = P3 - G2;
      j2 = r3(X2 * X2), v2 = r3(k3 * r3(Z3 * Z3)), E2 = r3(S4 * $2), L4 = r3(p2 * (S4 + r3(l2 * p2)));
    }
    w2 = a2(O4, E2, j2), E2 = w2[0], j2 = w2[1], w2 = a2(O4, L4, v2), L4 = w2[0], v2 = w2[1];
    const R5 = u2(L4);
    return r3(E2 * R5);
  }
  function d4(b2) {
    return Vs$6(r3(b2), s2);
  }
  function g2(b2) {
    const _3 = Zn$6("u coordinate", b2, s2);
    return i4 === 32 && (_3[31] &= 127), Xn$6(_3);
  }
  function y4(b2) {
    const _3 = Zn$6("scalar", b2), I4 = _3.length;
    if (I4 !== s2 && I4 !== i4) {
      let k3 = "" + s2 + " or " + i4;
      throw new Error("invalid scalar, expected " + k3 + " bytes, got " + I4);
    }
    return Xn$6(c2(_3));
  }
  function h5(b2, _3) {
    const I4 = g2(_3), k3 = y4(b2), E2 = f6(I4, k3);
    if (E2 === xe$6) throw new Error("invalid private or public key received");
    return d4(E2);
  }
  const m4 = d4(t2.Gu);
  function B3(b2) {
    return h5(b2, m4);
  }
  return { scalarMult: h5, scalarMultBase: B3, getSharedSecret: (b2, _3) => h5(b2, _3), getPublicKey: (b2) => B3(b2), utils: { randomPrivateKey: () => t2.randomBytes(t2.nByteLength) }, GuBytes: m4 };
}
const xt$6 = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
BigInt(0);
const zs$4 = BigInt(1), tr$6 = BigInt(2), Js$6 = BigInt(3), Ys$6 = BigInt(5);
BigInt(8);
function Xs$6(e3) {
  const t2 = BigInt(10), n5 = BigInt(20), r3 = BigInt(40), o3 = BigInt(80), s2 = xt$6, c2 = e3 * e3 % s2 * e3 % s2, u2 = z$9(c2, tr$6, s2) * c2 % s2, a2 = z$9(u2, zs$4, s2) * e3 % s2, l2 = z$9(a2, Ys$6, s2) * a2 % s2, f6 = z$9(l2, t2, s2) * l2 % s2, d4 = z$9(f6, n5, s2) * f6 % s2, g2 = z$9(d4, r3, s2) * d4 % s2, y4 = z$9(g2, o3, s2) * g2 % s2, h5 = z$9(y4, o3, s2) * g2 % s2, m4 = z$9(h5, t2, s2) * l2 % s2;
  return { pow_p_5_8: z$9(m4, tr$6, s2) * e3 % s2, b2: c2 };
}
function Zs$6(e3) {
  return e3[0] &= 248, e3[31] &= 127, e3[31] |= 64, e3;
}
const Ot$5 = Ws$6({ P: xt$6, a: BigInt(486662), montgomeryBits: 255, nByteLength: 32, Gu: BigInt(9), powPminus2: (e3) => {
  const t2 = xt$6, { pow_p_5_8: n5, b2: r3 } = Xs$6(e3);
  return er$6(z$9(n5, Js$6, t2) * r3, t2);
}, adjustScalarBytes: Zs$6, randomBytes: Se$6 }), It$5 = "base10", V$9 = "base16", At$6 = "base64pad", Qs$6 = "base64url", Oe$6 = "utf8", Nt$6 = 0, Ie$4 = 1, _e$8 = 2, ei$6 = 0, nr$6 = 1, Te$4 = 12, St$8 = 32;
function ti$6() {
  const e3 = Ot$5.utils.randomPrivateKey(), t2 = Ot$5.getPublicKey(e3);
  return { privateKey: toString$1(e3, V$9), publicKey: toString$1(t2, V$9) };
}
function ni$6() {
  const e3 = Se$6(St$8);
  return toString$1(e3, V$9);
}
function ri$6(e3, t2) {
  const n5 = Ot$5.getSharedSecret(fromString(e3, V$9), fromString(t2, V$9)), r3 = Ts$6(He$6, n5, void 0, void 0, St$8);
  return toString$1(r3, V$9);
}
function oi$6(e3) {
  const t2 = He$6(fromString(e3, V$9));
  return toString$1(t2, V$9);
}
function si$6(e3) {
  const t2 = He$6(fromString(e3, Oe$6));
  return toString$1(t2, V$9);
}
function Ut$6(e3) {
  return fromString(`${e3}`, It$5);
}
function fe$3(e3) {
  return Number(toString$1(e3, It$5));
}
function ii$6(e3) {
  const t2 = Ut$6(typeof e3.type < "u" ? e3.type : Nt$6);
  if (fe$3(t2) === Ie$4 && typeof e3.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const n5 = typeof e3.senderPublicKey < "u" ? fromString(e3.senderPublicKey, V$9) : void 0, r3 = typeof e3.iv < "u" ? fromString(e3.iv, V$9) : Se$6(Te$4), o3 = fromString(e3.symKey, V$9), s2 = Fn$6(o3, r3).encrypt(fromString(e3.message, Oe$6));
  return _t$7({ type: t2, sealed: s2, iv: r3, senderPublicKey: n5, encoding: e3.encoding });
}
function ci$6(e3) {
  const t2 = fromString(e3.symKey, V$9), { sealed: n5, iv: r3 } = Fe$8(e3), o3 = Fn$6(t2, r3).decrypt(n5);
  if (o3 === null) throw new Error("Failed to decrypt");
  return toString$1(o3, Oe$6);
}
function ai$6(e3, t2) {
  const n5 = Ut$6(_e$8), r3 = Se$6(Te$4), o3 = fromString(e3, Oe$6);
  return _t$7({ type: n5, sealed: o3, iv: r3, encoding: t2 });
}
function ui$6(e3, t2) {
  const { sealed: n5 } = Fe$8({ encoded: e3, encoding: t2 });
  return toString$1(n5, Oe$6);
}
function _t$7(e3) {
  const { encoding: t2 = At$6 } = e3;
  if (fe$3(e3.type) === _e$8) return toString$1(concat$1([e3.type, e3.sealed]), t2);
  if (fe$3(e3.type) === Ie$4) {
    if (typeof e3.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return toString$1(concat$1([e3.type, e3.senderPublicKey, e3.iv, e3.sealed]), t2);
  }
  return toString$1(concat$1([e3.type, e3.iv, e3.sealed]), t2);
}
function Fe$8(e3) {
  const { encoded: t2, encoding: n5 = At$6 } = e3, r3 = fromString(t2, n5), o3 = r3.slice(ei$6, nr$6), s2 = nr$6;
  if (fe$3(o3) === Ie$4) {
    const a2 = s2 + St$8, l2 = a2 + Te$4, f6 = r3.slice(s2, a2), d4 = r3.slice(a2, l2), g2 = r3.slice(l2);
    return { type: o3, sealed: g2, iv: d4, senderPublicKey: f6 };
  }
  if (fe$3(o3) === _e$8) {
    const a2 = r3.slice(s2), l2 = Se$6(Te$4);
    return { type: o3, sealed: a2, iv: l2 };
  }
  const i4 = s2 + Te$4, c2 = r3.slice(s2, i4), u2 = r3.slice(i4);
  return { type: o3, sealed: u2, iv: c2 };
}
function fi$6(e3, t2) {
  const n5 = Fe$8({ encoded: e3, encoding: t2 == null ? void 0 : t2.encoding });
  return rr$6({ type: fe$3(n5.type), senderPublicKey: typeof n5.senderPublicKey < "u" ? toString$1(n5.senderPublicKey, V$9) : void 0, receiverPublicKey: t2 == null ? void 0 : t2.receiverPublicKey });
}
function rr$6(e3) {
  const t2 = (e3 == null ? void 0 : e3.type) || Nt$6;
  if (t2 === Ie$4) {
    if (typeof (e3 == null ? void 0 : e3.senderPublicKey) > "u") throw new Error("missing sender public key");
    if (typeof (e3 == null ? void 0 : e3.receiverPublicKey) > "u") throw new Error("missing receiver public key");
  }
  return { type: t2, senderPublicKey: e3 == null ? void 0 : e3.senderPublicKey, receiverPublicKey: e3 == null ? void 0 : e3.receiverPublicKey };
}
function li$6(e3) {
  return e3.type === Ie$4 && typeof e3.senderPublicKey == "string" && typeof e3.receiverPublicKey == "string";
}
function di$6(e3) {
  return e3.type === _e$8;
}
function or$6(e3) {
  return new ellipticExports.ec("p256").keyFromPublic({ x: Buffer.from(e3.x, "base64").toString("hex"), y: Buffer.from(e3.y, "base64").toString("hex") }, "hex");
}
function hi$6(e3) {
  let t2 = e3.replace(/-/g, "+").replace(/_/g, "/");
  const n5 = t2.length % 4;
  return n5 > 0 && (t2 += "=".repeat(4 - n5)), t2;
}
function pi$6(e3) {
  return Buffer.from(hi$6(e3), "base64");
}
function gi$6(e3, t2) {
  const [n5, r3, o3] = e3.split("."), s2 = pi$6(o3);
  if (s2.length !== 64) throw new Error("Invalid signature length");
  const i4 = s2.slice(0, 32).toString("hex"), c2 = s2.slice(32, 64).toString("hex"), u2 = `${n5}.${r3}`, a2 = He$6(u2), l2 = or$6(t2), f6 = toString$1(a2, V$9);
  if (!l2.verify(f6, { r: i4, s: c2 })) throw new Error("Invalid signature");
  return sn$7(e3).payload;
}
const sr$6 = "irn";
function yi$6(e3) {
  return (e3 == null ? void 0 : e3.relay) || { protocol: sr$6 };
}
function mi$6(e3) {
  const t2 = C$6[e3];
  if (typeof t2 > "u") throw new Error(`Relay Protocol not supported: ${e3}`);
  return t2;
}
function ir$6(e3, t2 = "-") {
  const n5 = {}, r3 = "relay" + t2;
  return Object.keys(e3).forEach((o3) => {
    if (o3.startsWith(r3)) {
      const s2 = o3.replace(r3, ""), i4 = e3[o3];
      n5[s2] = i4;
    }
  }), n5;
}
function bi$6(e3) {
  if (!e3.includes("wc:")) {
    const a2 = rt$4(e3);
    a2 != null && a2.includes("wc:") && (e3 = a2);
  }
  e3 = e3.includes("wc://") ? e3.replace("wc://", "") : e3, e3 = e3.includes("wc:") ? e3.replace("wc:", "") : e3;
  const t2 = e3.indexOf(":"), n5 = e3.indexOf("?") !== -1 ? e3.indexOf("?") : void 0, r3 = e3.substring(0, t2), o3 = e3.substring(t2 + 1, n5).split("@"), s2 = typeof n5 < "u" ? e3.substring(n5) : "", i4 = new URLSearchParams(s2), c2 = {};
  i4.forEach((a2, l2) => {
    c2[l2] = a2;
  });
  const u2 = typeof c2.methods == "string" ? c2.methods.split(",") : void 0;
  return { protocol: r3, topic: cr$6(o3[0]), version: parseInt(o3[1], 10), symKey: c2.symKey, relay: ir$6(c2), methods: u2, expiryTimestamp: c2.expiryTimestamp ? parseInt(c2.expiryTimestamp, 10) : void 0 };
}
function cr$6(e3) {
  return e3.startsWith("//") ? e3.substring(2) : e3;
}
function ar$6(e3, t2 = "-") {
  const n5 = "relay", r3 = {};
  return Object.keys(e3).forEach((o3) => {
    const s2 = o3, i4 = n5 + t2 + s2;
    e3[s2] && (r3[i4] = e3[s2]);
  }), r3;
}
function wi$6(e3) {
  const t2 = new URLSearchParams(), n5 = ar$6(e3.relay);
  Object.keys(n5).sort().forEach((o3) => {
    t2.set(o3, n5[o3]);
  }), t2.set("symKey", e3.symKey), e3.expiryTimestamp && t2.set("expiryTimestamp", e3.expiryTimestamp.toString()), e3.methods && t2.set("methods", e3.methods.join(","));
  const r3 = t2.toString();
  return `${e3.protocol}:${e3.topic}@${e3.version}?${r3}`;
}
function Ei$6(e3, t2, n5) {
  return `${e3}?wc_ev=${n5}&topic=${t2}`;
}
var vi$6 = Object.defineProperty, xi$6 = Object.defineProperties, Oi$6 = Object.getOwnPropertyDescriptors, ur$6 = Object.getOwnPropertySymbols, Ii$6 = Object.prototype.hasOwnProperty, Ai$6 = Object.prototype.propertyIsEnumerable, fr$6 = (e3, t2, n5) => t2 in e3 ? vi$6(e3, t2, { enumerable: true, configurable: true, writable: true, value: n5 }) : e3[t2] = n5, Ni$6 = (e3, t2) => {
  for (var n5 in t2 || (t2 = {})) Ii$6.call(t2, n5) && fr$6(e3, n5, t2[n5]);
  if (ur$6) for (var n5 of ur$6(t2)) Ai$6.call(t2, n5) && fr$6(e3, n5, t2[n5]);
  return e3;
}, Si$6 = (e3, t2) => xi$6(e3, Oi$6(t2));
function le$5(e3) {
  const t2 = [];
  return e3.forEach((n5) => {
    const [r3, o3] = n5.split(":");
    t2.push(`${r3}:${o3}`);
  }), t2;
}
function lr$6(e3) {
  const t2 = [];
  return Object.values(e3).forEach((n5) => {
    t2.push(...le$5(n5.accounts));
  }), t2;
}
function dr$6(e3, t2) {
  const n5 = [];
  return Object.values(e3).forEach((r3) => {
    le$5(r3.accounts).includes(t2) && n5.push(...r3.methods);
  }), n5;
}
function hr$6(e3, t2) {
  const n5 = [];
  return Object.values(e3).forEach((r3) => {
    le$5(r3.accounts).includes(t2) && n5.push(...r3.events);
  }), n5;
}
function Ui$4(e3, t2) {
  const n5 = Ir$6(e3, t2);
  if (n5) throw new Error(n5.message);
  const r3 = {};
  for (const [o3, s2] of Object.entries(e3)) r3[o3] = { methods: s2.methods, events: s2.events, chains: s2.accounts.map((i4) => `${i4.split(":")[0]}:${i4.split(":")[1]}`) };
  return r3;
}
function _i$6(e3) {
  const { proposal: { requiredNamespaces: t2, optionalNamespaces: n5 = {} }, supportedNamespaces: r3 } = e3, o3 = $t$3(t2), s2 = $t$3(n5), i4 = {};
  Object.keys(r3).forEach((a2) => {
    const l2 = r3[a2].chains, f6 = r3[a2].methods, d4 = r3[a2].events, g2 = r3[a2].accounts;
    l2.forEach((y4) => {
      if (!g2.some((h5) => h5.includes(y4))) throw new Error(`No accounts provided for chain ${y4} in namespace ${a2}`);
    }), i4[a2] = { chains: l2, methods: f6, events: d4, accounts: g2 };
  });
  const c2 = Nr$6(t2, i4, "approve()");
  if (c2) throw new Error(c2.message);
  const u2 = {};
  return !Object.keys(t2).length && !Object.keys(n5).length ? i4 : (Object.keys(o3).forEach((a2) => {
    const l2 = r3[a2].chains.filter((y4) => {
      var h5, m4;
      return (m4 = (h5 = o3[a2]) == null ? void 0 : h5.chains) == null ? void 0 : m4.includes(y4);
    }), f6 = r3[a2].methods.filter((y4) => {
      var h5, m4;
      return (m4 = (h5 = o3[a2]) == null ? void 0 : h5.methods) == null ? void 0 : m4.includes(y4);
    }), d4 = r3[a2].events.filter((y4) => {
      var h5, m4;
      return (m4 = (h5 = o3[a2]) == null ? void 0 : h5.events) == null ? void 0 : m4.includes(y4);
    }), g2 = l2.map((y4) => r3[a2].accounts.filter((h5) => h5.includes(`${y4}:`))).flat();
    u2[a2] = { chains: l2, methods: f6, events: d4, accounts: g2 };
  }), Object.keys(s2).forEach((a2) => {
    var l2, f6, d4, g2, y4, h5;
    if (!r3[a2]) return;
    const m4 = (f6 = (l2 = s2[a2]) == null ? void 0 : l2.chains) == null ? void 0 : f6.filter((I4) => r3[a2].chains.includes(I4)), B3 = r3[a2].methods.filter((I4) => {
      var k3, E2;
      return (E2 = (k3 = s2[a2]) == null ? void 0 : k3.methods) == null ? void 0 : E2.includes(I4);
    }), b2 = r3[a2].events.filter((I4) => {
      var k3, E2;
      return (E2 = (k3 = s2[a2]) == null ? void 0 : k3.events) == null ? void 0 : E2.includes(I4);
    }), _3 = m4 == null ? void 0 : m4.map((I4) => r3[a2].accounts.filter((k3) => k3.includes(`${I4}:`))).flat();
    u2[a2] = { chains: Q$3((d4 = u2[a2]) == null ? void 0 : d4.chains, m4), methods: Q$3((g2 = u2[a2]) == null ? void 0 : g2.methods, B3), events: Q$3((y4 = u2[a2]) == null ? void 0 : y4.events, b2), accounts: Q$3((h5 = u2[a2]) == null ? void 0 : h5.accounts, _3) };
  }), u2);
}
function Tt$6(e3) {
  return e3.includes(":");
}
function pr$6(e3) {
  return Tt$6(e3) ? e3.split(":")[0] : e3;
}
function $t$3(e3) {
  var t2, n5, r3;
  const o3 = {};
  if (!qe$6(e3)) return o3;
  for (const [s2, i4] of Object.entries(e3)) {
    const c2 = Tt$6(s2) ? [s2] : i4.chains, u2 = i4.methods || [], a2 = i4.events || [], l2 = pr$6(s2);
    o3[l2] = Si$6(Ni$6({}, o3[l2]), { chains: Q$3(c2, (t2 = o3[l2]) == null ? void 0 : t2.chains), methods: Q$3(u2, (n5 = o3[l2]) == null ? void 0 : n5.methods), events: Q$3(a2, (r3 = o3[l2]) == null ? void 0 : r3.events) });
  }
  return o3;
}
function gr$6(e3) {
  const t2 = {};
  return e3 == null ? void 0 : e3.forEach((n5) => {
    var r3;
    const [o3, s2] = n5.split(":");
    t2[o3] || (t2[o3] = { accounts: [], chains: [], events: [], methods: [] }), t2[o3].accounts.push(n5), (r3 = t2[o3].chains) == null || r3.push(`${o3}:${s2}`);
  }), t2;
}
function Ti$6(e3, t2) {
  t2 = t2.map((r3) => r3.replace("did:pkh:", ""));
  const n5 = gr$6(t2);
  for (const [r3, o3] of Object.entries(n5)) o3.methods ? o3.methods = Q$3(o3.methods, e3) : o3.methods = e3, o3.events = ["chainChanged", "accountsChanged"];
  return n5;
}
const yr$6 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, mr$6 = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function te$4(e3, t2) {
  const { message: n5, code: r3 } = mr$6[e3];
  return { message: t2 ? `${n5} ${t2}` : n5, code: r3 };
}
function de$5(e3, t2) {
  const { message: n5, code: r3 } = yr$6[e3];
  return { message: t2 ? `${n5} ${t2}` : n5, code: r3 };
}
function $e$7(e3, t2) {
  return Array.isArray(e3) ? typeof t2 < "u" && e3.length ? e3.every(t2) : true : false;
}
function qe$6(e3) {
  return Object.getPrototypeOf(e3) === Object.prototype && Object.keys(e3).length;
}
function ae$6(e3) {
  return typeof e3 > "u";
}
function q$5(e3, t2) {
  return t2 && ae$6(e3) ? true : typeof e3 == "string" && !!e3.trim().length;
}
function Ge$6(e3, t2) {
  return t2 && ae$6(e3) ? true : typeof e3 == "number" && !isNaN(e3);
}
function $i$6(e3, t2) {
  const { requiredNamespaces: n5 } = t2, r3 = Object.keys(e3.namespaces), o3 = Object.keys(n5);
  let s2 = true;
  return re$6(o3, r3) ? (r3.forEach((i4) => {
    const { accounts: c2, methods: u2, events: a2 } = e3.namespaces[i4], l2 = le$5(c2), f6 = n5[i4];
    (!re$6(Le$8(i4, f6), l2) || !re$6(f6.methods, u2) || !re$6(f6.events, a2)) && (s2 = false);
  }), s2) : false;
}
function Re$4(e3) {
  return q$5(e3, false) && e3.includes(":") ? e3.split(":").length === 2 : false;
}
function br$6(e3) {
  if (q$5(e3, false) && e3.includes(":")) {
    const t2 = e3.split(":");
    if (t2.length === 3) {
      const n5 = t2[0] + ":" + t2[1];
      return !!t2[2] && Re$4(n5);
    }
  }
  return false;
}
function Ri$6(e3) {
  function t2(n5) {
    try {
      return typeof new URL(n5) < "u";
    } catch {
      return false;
    }
  }
  try {
    if (q$5(e3, false)) {
      if (t2(e3)) return true;
      const n5 = rt$4(e3);
      return t2(n5);
    }
  } catch {
  }
  return false;
}
function Pi$6(e3) {
  var t2;
  return (t2 = e3 == null ? void 0 : e3.proposer) == null ? void 0 : t2.publicKey;
}
function Li$6(e3) {
  return e3 == null ? void 0 : e3.topic;
}
function Bi$4(e3, t2) {
  let n5 = null;
  return q$5(e3 == null ? void 0 : e3.publicKey, false) || (n5 = te$4("MISSING_OR_INVALID", `${t2} controller public key should be a string`)), n5;
}
function Rt$6(e3) {
  let t2 = true;
  return $e$7(e3) ? e3.length && (t2 = e3.every((n5) => q$5(n5, false))) : t2 = false, t2;
}
function wr$6(e3, t2, n5) {
  let r3 = null;
  return $e$7(t2) && t2.length ? t2.forEach((o3) => {
    r3 || Re$4(o3) || (r3 = de$5("UNSUPPORTED_CHAINS", `${n5}, chain ${o3} should be a string and conform to "namespace:chainId" format`));
  }) : Re$4(e3) || (r3 = de$5("UNSUPPORTED_CHAINS", `${n5}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r3;
}
function Er$6(e3, t2, n5) {
  let r3 = null;
  return Object.entries(e3).forEach(([o3, s2]) => {
    if (r3) return;
    const i4 = wr$6(o3, Le$8(o3, s2), `${t2} ${n5}`);
    i4 && (r3 = i4);
  }), r3;
}
function vr$6(e3, t2) {
  let n5 = null;
  return $e$7(e3) ? e3.forEach((r3) => {
    n5 || br$6(r3) || (n5 = de$5("UNSUPPORTED_ACCOUNTS", `${t2}, account ${r3} should be a string and conform to "namespace:chainId:address" format`));
  }) : n5 = de$5("UNSUPPORTED_ACCOUNTS", `${t2}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), n5;
}
function xr$6(e3, t2) {
  let n5 = null;
  return Object.values(e3).forEach((r3) => {
    if (n5) return;
    const o3 = vr$6(r3 == null ? void 0 : r3.accounts, `${t2} namespace`);
    o3 && (n5 = o3);
  }), n5;
}
function Or$6(e3, t2) {
  let n5 = null;
  return Rt$6(e3 == null ? void 0 : e3.methods) ? Rt$6(e3 == null ? void 0 : e3.events) || (n5 = de$5("UNSUPPORTED_EVENTS", `${t2}, events should be an array of strings or empty array for no events`)) : n5 = de$5("UNSUPPORTED_METHODS", `${t2}, methods should be an array of strings or empty array for no methods`), n5;
}
function Pt$3(e3, t2) {
  let n5 = null;
  return Object.values(e3).forEach((r3) => {
    if (n5) return;
    const o3 = Or$6(r3, `${t2}, namespace`);
    o3 && (n5 = o3);
  }), n5;
}
function ji$4(e3, t2, n5) {
  let r3 = null;
  if (e3 && qe$6(e3)) {
    const o3 = Pt$3(e3, t2);
    o3 && (r3 = o3);
    const s2 = Er$6(e3, t2, n5);
    s2 && (r3 = s2);
  } else r3 = te$4("MISSING_OR_INVALID", `${t2}, ${n5} should be an object with data`);
  return r3;
}
function Ir$6(e3, t2) {
  let n5 = null;
  if (e3 && qe$6(e3)) {
    const r3 = Pt$3(e3, t2);
    r3 && (n5 = r3);
    const o3 = xr$6(e3, t2);
    o3 && (n5 = o3);
  } else n5 = te$4("MISSING_OR_INVALID", `${t2}, namespaces should be an object with data`);
  return n5;
}
function Ar$6(e3) {
  return q$5(e3.protocol, true);
}
function Ci$6(e3, t2) {
  let n5 = false;
  return t2 && !e3 ? n5 = true : e3 && $e$7(e3) && e3.length && e3.forEach((r3) => {
    n5 = Ar$6(r3);
  }), n5;
}
function ki$4(e3) {
  return typeof e3 == "number";
}
function Di$6(e3) {
  return typeof e3 < "u" && typeof e3 !== null;
}
function Mi$4(e3) {
  return !(!e3 || typeof e3 != "object" || !e3.code || !Ge$6(e3.code, false) || !e3.message || !q$5(e3.message, false));
}
function Vi$4(e3) {
  return !(ae$6(e3) || !q$5(e3.method, false));
}
function Hi$4(e3) {
  return !(ae$6(e3) || ae$6(e3.result) && ae$6(e3.error) || !Ge$6(e3.id, false) || !q$5(e3.jsonrpc, false));
}
function Ki$4(e3) {
  return !(ae$6(e3) || !q$5(e3.name, false));
}
function Fi$4(e3, t2) {
  return !(!Re$4(t2) || !lr$6(e3).includes(t2));
}
function qi$4(e3, t2, n5) {
  return q$5(n5, false) ? dr$6(e3, t2).includes(n5) : false;
}
function Gi$4(e3, t2, n5) {
  return q$5(n5, false) ? hr$6(e3, t2).includes(n5) : false;
}
function Nr$6(e3, t2, n5) {
  let r3 = null;
  const o3 = Wi$4(e3), s2 = zi$6(t2), i4 = Object.keys(o3), c2 = Object.keys(s2), u2 = Sr$6(Object.keys(e3)), a2 = Sr$6(Object.keys(t2)), l2 = u2.filter((f6) => !a2.includes(f6));
  return l2.length && (r3 = te$4("NON_CONFORMING_NAMESPACES", `${n5} namespaces keys don't satisfy requiredNamespaces.
      Required: ${l2.toString()}
      Received: ${Object.keys(t2).toString()}`)), re$6(i4, c2) || (r3 = te$4("NON_CONFORMING_NAMESPACES", `${n5} namespaces chains don't satisfy required namespaces.
      Required: ${i4.toString()}
      Approved: ${c2.toString()}`)), Object.keys(t2).forEach((f6) => {
    if (!f6.includes(":") || r3) return;
    const d4 = le$5(t2[f6].accounts);
    d4.includes(f6) || (r3 = te$4("NON_CONFORMING_NAMESPACES", `${n5} namespaces accounts don't satisfy namespace accounts for ${f6}
        Required: ${f6}
        Approved: ${d4.toString()}`));
  }), i4.forEach((f6) => {
    r3 || (re$6(o3[f6].methods, s2[f6].methods) ? re$6(o3[f6].events, s2[f6].events) || (r3 = te$4("NON_CONFORMING_NAMESPACES", `${n5} namespaces events don't satisfy namespace events for ${f6}`)) : r3 = te$4("NON_CONFORMING_NAMESPACES", `${n5} namespaces methods don't satisfy namespace methods for ${f6}`));
  }), r3;
}
function Wi$4(e3) {
  const t2 = {};
  return Object.keys(e3).forEach((n5) => {
    var r3;
    n5.includes(":") ? t2[n5] = e3[n5] : (r3 = e3[n5].chains) == null || r3.forEach((o3) => {
      t2[o3] = { methods: e3[n5].methods, events: e3[n5].events };
    });
  }), t2;
}
function Sr$6(e3) {
  return [...new Set(e3.map((t2) => t2.includes(":") ? t2.split(":")[0] : t2))];
}
function zi$6(e3) {
  const t2 = {};
  return Object.keys(e3).forEach((n5) => {
    if (n5.includes(":")) t2[n5] = e3[n5];
    else {
      const r3 = le$5(e3[n5].accounts);
      r3 == null ? void 0 : r3.forEach((o3) => {
        t2[o3] = { accounts: e3[n5].accounts.filter((s2) => s2.includes(`${o3}:`)), methods: e3[n5].methods, events: e3[n5].events };
      });
    }
  }), t2;
}
function Ji$4(e3, t2) {
  return Ge$6(e3, false) && e3 <= t2.max && e3 >= t2.min;
}
function Yi$4() {
  const e3 = ue$5();
  return new Promise((t2) => {
    switch (e3) {
      case H$6.browser:
        t2(Ur$6());
        break;
      case H$6.reactNative:
        t2(_r$6());
        break;
      case H$6.node:
        t2(Tr$6());
        break;
      default:
        t2(true);
    }
  });
}
function Ur$6() {
  return Ae$6() && (navigator == null ? void 0 : navigator.onLine);
}
async function _r$6() {
  if (ne$6() && typeof global$1 < "u" && global$1 != null && global$1.NetInfo) {
    const e3 = await (global$1 == null ? void 0 : global$1.NetInfo.fetch());
    return e3 == null ? void 0 : e3.isConnected;
  }
  return true;
}
function Tr$6() {
  return true;
}
function Xi$4(e3) {
  switch (ue$5()) {
    case H$6.browser:
      $r$6(e3);
      break;
    case H$6.reactNative:
      Rr$6(e3);
      break;
    case H$6.node:
      break;
  }
}
function $r$6(e3) {
  !ne$6() && Ae$6() && (window.addEventListener("online", () => e3(true)), window.addEventListener("offline", () => e3(false)));
}
function Rr$6(e3) {
  ne$6() && typeof global$1 < "u" && global$1 != null && global$1.NetInfo && (global$1 == null ? void 0 : global$1.NetInfo.addEventListener((t2) => e3(t2 == null ? void 0 : t2.isConnected)));
}
const Lt$6 = {};
let Zi$4 = class Zi2 {
  static get(t2) {
    return Lt$6[t2];
  }
  static set(t2, n5) {
    Lt$6[t2] = n5;
  }
  static delete(t2) {
    delete Lt$6[t2];
  }
};
const index_es$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BASE10: It$5,
  BASE16: V$9,
  BASE64: At$6,
  BASE64URL: Qs$6,
  COLON: qr$6,
  DEFAULT_DEPTH: Qe$4,
  EMPTY_SPACE: Be$6,
  ENV_MAP: H$6,
  INTERNAL_ERRORS: mr$6,
  MemoryStore: Zi$4,
  ONE_THOUSAND: Gr$6,
  REACT_NATIVE_PRODUCT: Ft$6,
  RELAYER_DEFAULT_PROTOCOL: sr$6,
  SDK_ERRORS: yr$6,
  SDK_TYPE: Gt$6,
  SLASH: qt$6,
  TYPE_0: Nt$6,
  TYPE_1: Ie$4,
  TYPE_2: _e$8,
  UTF8: Oe$6,
  addResourceToRecap: $n$6,
  appendToQueryString: Wt$6,
  assertType: eo$6,
  assignAbilityToActions: ft$5,
  base64Decode: _n$6,
  base64Encode: Un$6,
  buildApprovedNamespaces: _i$6,
  buildAuthObject: Xo$4,
  buildNamespacesFromAuth: Ti$6,
  buildRecapStatement: Pn$6,
  calcExpiry: ho$4,
  capitalize: io$6,
  capitalizeWord: Qt$6,
  createDelayedPromise: co$4,
  createEncodedRecap: ts$4,
  createExpiringPromise: ao$6,
  createRecap: Tn$6,
  decodeRecap: oe$4,
  decodeTypeByte: fe$3,
  decodeTypeTwoEnvelope: ui$6,
  decrypt: ci$6,
  deriveSymKey: ri$6,
  deserialize: Fe$8,
  encodeRecap: De$6,
  encodeTypeByte: Ut$6,
  encodeTypeTwoEnvelope: ai$6,
  encrypt: ii$6,
  engineEvent: go$4,
  enumify: so$6,
  formatAccountId: Mt$6,
  formatAccountWithChain: Mr$6,
  formatChainId: Dt$6,
  formatDeeplinkUrl: en$6,
  formatExpirerTarget: tt$4,
  formatIdTarget: fo$4,
  formatMessage: In$6,
  formatMessageContext: to$6,
  formatRelayParams: ar$6,
  formatRelayRpcUrl: Zr$6,
  formatStatementFromRecap: dt$5,
  formatTopicTarget: uo$4,
  formatUA: Yt$6,
  formatUri: wi$6,
  fromBase64: rt$4,
  generateKeyPair: ti$6,
  generateRandomBytes32: ni$6,
  getAccountsChains: le$5,
  getAccountsFromNamespaces: Hr$6,
  getAddressFromAccount: Vt$6,
  getAddressesFromAccounts: Vr$6,
  getAppId: Jr$6,
  getAppMetadata: Yr$6,
  getBrowserOnlineStatus: Ur$6,
  getChainFromAccount: Ht$6,
  getChainsFromAccounts: Kt$6,
  getChainsFromNamespace: Le$8,
  getChainsFromNamespaces: Kr$6,
  getChainsFromRecap: os$4,
  getChainsFromRequiredNamespaces: Fr$6,
  getCommonValuesInArrays: nt$3,
  getCryptoKeyFromKeyData: or$6,
  getDecodedRecapFromResources: An$6,
  getDeepLink: mo$4,
  getDidAddress: ut$6,
  getDidAddressSegments: ke$8,
  getDidChainId: xn$6,
  getEnvironment: ue$5,
  getHttpUrl: Qr$6,
  getInternalError: te$4,
  getJavascriptID: Jt$6,
  getJavascriptOS: zt$6,
  getLastItems: Zt$6,
  getLinkModeURL: Ei$6,
  getMethodsFromRecap: rs$4,
  getNamespacedDidChainId: On$6,
  getNamespacesChains: lr$6,
  getNamespacesEventsForChainId: hr$6,
  getNamespacesFromAccounts: gr$6,
  getNamespacesMethodsForChainId: dr$6,
  getNodeOnlineStatus: Tr$6,
  getReCapActions: Sn$6,
  getReactNativeOnlineStatus: _r$6,
  getRecapAbilitiesFromResource: es$4,
  getRecapFromResources: Me$8,
  getRecapResource: Nn$6,
  getRelayClientMetadata: Xr$6,
  getRelayProtocolApi: mi$6,
  getRelayProtocolName: yi$6,
  getRequiredNamespacesFromNamespaces: Ui$4,
  getSdkError: de$5,
  getSearchParamFromURL: bo$4,
  getUniqueValues: Ze$4,
  handleDeeplinkRedirect: yo$4,
  hasOverlap: re$6,
  hashEthereumMessage: ct$3,
  hashKey: oi$6,
  hashMessage: si$6,
  isAndroid: Wr$6,
  isBrowser: Ae$6,
  isCaipNamespace: Tt$6,
  isConformingNamespaces: Nr$6,
  isExpired: po$4,
  isIframe: rn$6,
  isIos: zr$6,
  isNode: et$4,
  isOnline: Yi$4,
  isProposalStruct: Pi$6,
  isReactNative: ne$6,
  isRecap: lt$3,
  isSessionCompatible: $i$6,
  isSessionStruct: Li$6,
  isTelegram: nn$6,
  isTestRun: Eo$4,
  isTypeOneEnvelope: li$6,
  isTypeTwoEnvelope: di$6,
  isUndefined: ae$6,
  isValidAccountId: br$6,
  isValidAccounts: vr$6,
  isValidActions: Or$6,
  isValidArray: $e$7,
  isValidChainId: Re$4,
  isValidChains: wr$6,
  isValidController: Bi$4,
  isValidEip1271Signature: bn$6,
  isValidEip191Signature: mn$6,
  isValidErrorReason: Mi$4,
  isValidEvent: Ki$4,
  isValidId: ki$4,
  isValidNamespaceAccounts: xr$6,
  isValidNamespaceActions: Pt$3,
  isValidNamespaceChains: Er$6,
  isValidNamespaceMethodsOrEvents: Rt$6,
  isValidNamespaces: Ir$6,
  isValidNamespacesChainId: Fi$4,
  isValidNamespacesEvent: Gi$4,
  isValidNamespacesRequest: qi$4,
  isValidNumber: Ge$6,
  isValidObject: qe$6,
  isValidParams: Di$6,
  isValidRecap: Y$3,
  isValidRelay: Ar$6,
  isValidRelays: Ci$6,
  isValidRequest: Vi$4,
  isValidRequestExpiry: Ji$4,
  isValidRequiredNamespaces: ji$4,
  isValidResponse: Hi$4,
  isValidString: q$5,
  isValidUrl: Ri$6,
  mapEntries: oo$6,
  mapToObj: no$6,
  mergeArrays: Q$3,
  mergeEncodedRecaps: ns$4,
  mergeRecaps: Rn$6,
  normalizeNamespaces: $t$3,
  objToMap: ro$6,
  openDeeplink: tn$6,
  parseAccountId: Xe$4,
  parseChainId: Ye$4,
  parseContextNames: Xt$6,
  parseExpirerTarget: lo$4,
  parseNamespaceKey: pr$6,
  parseRelayParams: ir$6,
  parseTopic: cr$6,
  parseUri: bi$6,
  populateAuthPayload: Zo$4,
  recapHasResource: Qo$4,
  serialize: _t$7,
  sleep: vo$4,
  subscribeToBrowserNetworkChange: $r$6,
  subscribeToNetworkChange: Xi$4,
  subscribeToReactNativeNetworkChange: Rr$6,
  toBase64: on$6,
  uuidv4: wo$4,
  validateDecoding: fi$6,
  validateEncoding: rr$6,
  validateSignedCacao: Yo$4,
  verifyP256Jwt: gi$6,
  verifySignature: yn$6
}, Symbol.toStringTag, { value: "Module" }));
const PARSE_ERROR = "PARSE_ERROR";
const INVALID_REQUEST = "INVALID_REQUEST";
const METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
const INVALID_PARAMS = "INVALID_PARAMS";
const INTERNAL_ERROR = "INTERNAL_ERROR";
const SERVER_ERROR = "SERVER_ERROR";
const RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
const STANDARD_ERROR_MAP = {
  [PARSE_ERROR]: { code: -32700, message: "Parse error" },
  [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
  [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
  [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
  [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
  [SERVER_ERROR]: { code: -32e3, message: "Server error" }
};
const DEFAULT_ERROR = SERVER_ERROR;
function isReservedErrorCode(code2) {
  return RESERVED_ERROR_CODES.includes(code2);
}
function getError(type2) {
  if (!Object.keys(STANDARD_ERROR_MAP).includes(type2)) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return STANDARD_ERROR_MAP[type2];
}
function getErrorByCode(code2) {
  const match = Object.values(STANDARD_ERROR_MAP).find((e3) => e3.code === code2);
  if (!match) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return match;
}
function parseConnectionError(e3, url, type2) {
  return e3.message.includes("getaddrinfo ENOTFOUND") || e3.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${type2} RPC url at ${url}`) : e3;
}
var cjs = {};
var crypto$2 = {};
var hasRequiredCrypto;
function requireCrypto() {
  if (hasRequiredCrypto) return crypto$2;
  hasRequiredCrypto = 1;
  Object.defineProperty(crypto$2, "__esModule", { value: true });
  crypto$2.isBrowserCryptoAvailable = crypto$2.getSubtleCrypto = crypto$2.getBrowerCrypto = void 0;
  function getBrowerCrypto() {
    return (commonjsGlobal === null || commonjsGlobal === void 0 ? void 0 : commonjsGlobal.crypto) || (commonjsGlobal === null || commonjsGlobal === void 0 ? void 0 : commonjsGlobal.msCrypto) || {};
  }
  crypto$2.getBrowerCrypto = getBrowerCrypto;
  function getSubtleCrypto() {
    const browserCrypto = getBrowerCrypto();
    return browserCrypto.subtle || browserCrypto.webkitSubtle;
  }
  crypto$2.getSubtleCrypto = getSubtleCrypto;
  function isBrowserCryptoAvailable() {
    return !!getBrowerCrypto() && !!getSubtleCrypto();
  }
  crypto$2.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  return crypto$2;
}
var env = {};
var hasRequiredEnv;
function requireEnv() {
  if (hasRequiredEnv) return env;
  hasRequiredEnv = 1;
  Object.defineProperty(env, "__esModule", { value: true });
  env.isBrowser = env.isNode = env.isReactNative = void 0;
  function isReactNative() {
    return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
  }
  env.isReactNative = isReactNative;
  function isNode() {
    return typeof process$1 !== "undefined" && typeof process$1.versions !== "undefined" && typeof process$1.versions.node !== "undefined";
  }
  env.isNode = isNode;
  function isBrowser() {
    return !isReactNative() && !isNode();
  }
  env.isBrowser = isBrowser;
  return env;
}
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  const tslib_1 = require$$0$2;
  tslib_1.__exportStar(requireCrypto(), exports2);
  tslib_1.__exportStar(requireEnv(), exports2);
})(cjs);
function payloadId(entropy = 3) {
  const date = Date.now() * Math.pow(10, entropy);
  const extra = Math.floor(Math.random() * Math.pow(10, entropy));
  return date + extra;
}
function getBigIntRpcId(entropy = 6) {
  return BigInt(payloadId(entropy));
}
function formatJsonRpcRequest(method, params, id2) {
  return {
    id: id2 || payloadId(),
    jsonrpc: "2.0",
    method,
    params
  };
}
function formatJsonRpcResult(id2, result) {
  return {
    id: id2,
    jsonrpc: "2.0",
    result
  };
}
function formatJsonRpcError(id2, error, data2) {
  return {
    id: id2,
    jsonrpc: "2.0",
    error: formatErrorMessage(error)
  };
}
function formatErrorMessage(error, data2) {
  if (typeof error === "undefined") {
    return getError(INTERNAL_ERROR);
  }
  if (typeof error === "string") {
    error = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: error });
  }
  if (isReservedErrorCode(error.code)) {
    error = getErrorByCode(error.code);
  }
  return error;
}
let e$6 = class e2 {
};
let n$7 = class n3 extends e$6 {
  constructor() {
    super();
  }
};
let r$6 = class r2 extends n$7 {
  constructor(c2) {
    super();
  }
};
const HTTP_REGEX = "^https?:";
const WS_REGEX = "^wss?:";
function getUrlProtocol(url) {
  const matches = url.match(new RegExp(/^\w+:/, "gi"));
  if (!matches || !matches.length)
    return;
  return matches[0];
}
function matchRegexProtocol(url, regex2) {
  const protocol = getUrlProtocol(url);
  if (typeof protocol === "undefined")
    return false;
  return new RegExp(regex2).test(protocol);
}
function isHttpUrl(url) {
  return matchRegexProtocol(url, HTTP_REGEX);
}
function isWsUrl(url) {
  return matchRegexProtocol(url, WS_REGEX);
}
function isLocalhostUrl(url) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(url);
}
function isJsonRpcPayload(payload) {
  return typeof payload === "object" && "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
}
function isJsonRpcRequest(payload) {
  return isJsonRpcPayload(payload) && "method" in payload;
}
function isJsonRpcResponse(payload) {
  return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
}
function isJsonRpcResult(payload) {
  return "result" in payload;
}
function isJsonRpcError(payload) {
  return "error" in payload;
}
let o$9 = class o2 extends r$6 {
  constructor(t2) {
    super(t2), this.events = new eventsExports.EventEmitter(), this.hasRegisteredEventListeners = false, this.connection = this.setConnection(t2), this.connection.connected && this.registerEventListeners();
  }
  async connect(t2 = this.connection) {
    await this.open(t2);
  }
  async disconnect() {
    await this.close();
  }
  on(t2, e3) {
    this.events.on(t2, e3);
  }
  once(t2, e3) {
    this.events.once(t2, e3);
  }
  off(t2, e3) {
    this.events.off(t2, e3);
  }
  removeListener(t2, e3) {
    this.events.removeListener(t2, e3);
  }
  async request(t2, e3) {
    return this.requestStrict(formatJsonRpcRequest(t2.method, t2.params || [], t2.id || getBigIntRpcId().toString()), e3);
  }
  async requestStrict(t2, e3) {
    return new Promise(async (i4, s2) => {
      if (!this.connection.connected) try {
        await this.open();
      } catch (n5) {
        s2(n5);
      }
      this.events.on(`${t2.id}`, (n5) => {
        isJsonRpcError(n5) ? s2(n5.error) : i4(n5.result);
      });
      try {
        await this.connection.send(t2, e3);
      } catch (n5) {
        s2(n5);
      }
    });
  }
  setConnection(t2 = this.connection) {
    return t2;
  }
  onPayload(t2) {
    this.events.emit("payload", t2), isJsonRpcResponse(t2) ? this.events.emit(`${t2.id}`, t2) : this.events.emit("message", { type: t2.method, data: t2.params });
  }
  onClose(t2) {
    t2 && t2.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${t2.code} ${t2.reason ? `(${t2.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(t2 = this.connection) {
    this.connection === t2 && this.connection.connected || (this.connection.connected && this.close(), typeof t2 == "string" && (await this.connection.open(t2), t2 = this.connection), this.connection = this.setConnection(t2), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (t2) => this.onPayload(t2)), this.connection.on("close", (t2) => this.onClose(t2)), this.connection.on("error", (t2) => this.events.emit("error", t2)), this.connection.on("register_error", (t2) => this.onClose()), this.hasRegisteredEventListeners = true);
  }
};
const v$6 = () => typeof WebSocket < "u" ? WebSocket : typeof global$1 < "u" && typeof global$1.WebSocket < "u" ? global$1.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require("ws"), w$3 = () => typeof WebSocket < "u" || typeof global$1 < "u" && typeof global$1.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u", d$5 = (r3) => r3.split("?")[0], h$6 = 10, b$5 = v$6();
let f$7 = class f3 {
  constructor(e3) {
    if (this.url = e3, this.events = new eventsExports.EventEmitter(), this.registering = false, !isWsUrl(e3)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e3}`);
    this.url = e3;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e3, t2) {
    this.events.on(e3, t2);
  }
  once(e3, t2) {
    this.events.once(e3, t2);
  }
  off(e3, t2) {
    this.events.off(e3, t2);
  }
  removeListener(e3, t2) {
    this.events.removeListener(e3, t2);
  }
  async open(e3 = this.url) {
    await this.register(e3);
  }
  async close() {
    return new Promise((e3, t2) => {
      if (typeof this.socket > "u") {
        t2(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (n5) => {
        this.onClose(n5), e3();
      }, this.socket.close();
    });
  }
  async send(e3) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(safeJsonStringify(e3));
    } catch (t2) {
      this.onError(e3.id, t2);
    }
  }
  register(e3 = this.url) {
    if (!isWsUrl(e3)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e3}`);
    if (this.registering) {
      const t2 = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= t2 || this.events.listenerCount("open") >= t2) && this.events.setMaxListeners(t2 + 1), new Promise((n5, s2) => {
        this.events.once("register_error", (o3) => {
          this.resetMaxListeners(), s2(o3);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u") return s2(new Error("WebSocket connection is missing or invalid"));
          n5(this.socket);
        });
      });
    }
    return this.url = e3, this.registering = true, new Promise((t2, n5) => {
      const s2 = cjs.isReactNative() ? void 0 : { rejectUnauthorized: !isLocalhostUrl(e3) }, o3 = new b$5(e3, [], s2);
      w$3() ? o3.onerror = (i4) => {
        const a2 = i4;
        n5(this.emitError(a2.error));
      } : o3.on("error", (i4) => {
        n5(this.emitError(i4));
      }), o3.onopen = () => {
        this.onOpen(o3), t2(o3);
      };
    });
  }
  onOpen(e3) {
    e3.onmessage = (t2) => this.onPayload(t2), e3.onclose = (t2) => this.onClose(t2), this.socket = e3, this.registering = false, this.events.emit("open");
  }
  onClose(e3) {
    this.socket = void 0, this.registering = false, this.events.emit("close", e3);
  }
  onPayload(e3) {
    if (typeof e3.data > "u") return;
    const t2 = typeof e3.data == "string" ? safeJsonParse(e3.data) : e3.data;
    this.events.emit("payload", t2);
  }
  onError(e3, t2) {
    const n5 = this.parseError(t2), s2 = n5.message || n5.toString(), o3 = formatJsonRpcError(e3, s2);
    this.events.emit("payload", o3);
  }
  parseError(e3, t2 = this.url) {
    return parseConnectionError(e3, d$5(t2), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > h$6 && this.events.setMaxListeners(h$6);
  }
  emitError(e3) {
    const t2 = this.parseError(new Error((e3 == null ? void 0 : e3.message) || `WebSocket connection failed for host: ${d$5(this.url)}`));
    return this.events.emit("register_error", t2), t2;
  }
};
var lodash_isequal = { exports: {} };
lodash_isequal.exports;
(function(module, exports2) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var freeExports = exports2 && !exports2.nodeType && exports2;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal.process;
  var nodeUtil = function() {
    try {
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e3) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  function arrayFilter(array, predicate) {
    var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index2 < length) {
      var value = array[index2];
      if (predicate(value, index2, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  function arrayPush(array, values) {
    var index2 = -1, length = values.length, offset = array.length;
    while (++index2 < length) {
      array[offset + index2] = values[index2];
    }
    return array;
  }
  function arraySome(array, predicate) {
    var index2 = -1, length = array == null ? 0 : array.length;
    while (++index2 < length) {
      if (predicate(array[index2], index2, array)) {
        return true;
      }
    }
    return false;
  }
  function baseTimes(n5, iteratee) {
    var index2 = -1, result = Array(n5);
    while (++index2 < n5) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  function cacheHas(cache, key2) {
    return cache.has(key2);
  }
  function getValue2(object2, key2) {
    return object2 == null ? void 0 : object2[key2];
  }
  function mapToArray(map) {
    var index2 = -1, result = Array(map.size);
    map.forEach(function(value, key2) {
      result[++index2] = [key2, value];
    });
    return result;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  function setToArray(set2) {
    var index2 = -1, result = Array(set2.size);
    set2.forEach(function(value) {
      result[++index2] = value;
    });
    return result;
  }
  var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var maskSrcKey = function() {
    var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid2 ? "Symbol(src)_1." + uid2 : "";
  }();
  var nativeObjectToString = objectProto.toString;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var Buffer2 = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
  var DataView2 = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
  var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function Hash3(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  function hashDelete(key2) {
    var result = this.has(key2) && delete this.__data__[key2];
    this.size -= result ? 1 : 0;
    return result;
  }
  function hashGet(key2) {
    var data2 = this.__data__;
    if (nativeCreate) {
      var result = data2[key2];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty.call(data2, key2) ? data2[key2] : void 0;
  }
  function hashHas(key2) {
    var data2 = this.__data__;
    return nativeCreate ? data2[key2] !== void 0 : hasOwnProperty.call(data2, key2);
  }
  function hashSet(key2, value) {
    var data2 = this.__data__;
    this.size += this.has(key2) ? 0 : 1;
    data2[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash3.prototype.clear = hashClear;
  Hash3.prototype["delete"] = hashDelete;
  Hash3.prototype.get = hashGet;
  Hash3.prototype.has = hashHas;
  Hash3.prototype.set = hashSet;
  function ListCache(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  function listCacheDelete(key2) {
    var data2 = this.__data__, index2 = assocIndexOf(data2, key2);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data2.length - 1;
    if (index2 == lastIndex) {
      data2.pop();
    } else {
      splice.call(data2, index2, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet(key2) {
    var data2 = this.__data__, index2 = assocIndexOf(data2, key2);
    return index2 < 0 ? void 0 : data2[index2][1];
  }
  function listCacheHas(key2) {
    return assocIndexOf(this.__data__, key2) > -1;
  }
  function listCacheSet(key2, value) {
    var data2 = this.__data__, index2 = assocIndexOf(data2, key2);
    if (index2 < 0) {
      ++this.size;
      data2.push([key2, value]);
    } else {
      data2[index2][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash3(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash3()
    };
  }
  function mapCacheDelete(key2) {
    var result = getMapData(this, key2)["delete"](key2);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet(key2) {
    return getMapData(this, key2).get(key2);
  }
  function mapCacheHas(key2) {
    return getMapData(this, key2).has(key2);
  }
  function mapCacheSet(key2, value) {
    var data2 = getMapData(this, key2), size2 = data2.size;
    data2.set(key2, value);
    this.size += data2.size == size2 ? 0 : 1;
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function SetCache(values) {
    var index2 = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache();
    while (++index2 < length) {
      this.add(values[index2]);
    }
  }
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function Stack(entries) {
    var data2 = this.__data__ = new ListCache(entries);
    this.size = data2.size;
  }
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  function stackDelete(key2) {
    var data2 = this.__data__, result = data2["delete"](key2);
    this.size = data2.size;
    return result;
  }
  function stackGet(key2) {
    return this.__data__.get(key2);
  }
  function stackHas(key2) {
    return this.__data__.has(key2);
  }
  function stackSet(key2, value) {
    var data2 = this.__data__;
    if (data2 instanceof ListCache) {
      var pairs = data2.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key2, value]);
        this.size = ++data2.size;
        return this;
      }
      data2 = this.__data__ = new MapCache(pairs);
    }
    data2.set(key2, value);
    this.size = data2.size;
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key2 in value) {
      if (hasOwnProperty.call(value, key2) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
      isIndex(key2, length)))) {
        result.push(key2);
      }
    }
    return result;
  }
  function assocIndexOf(array, key2) {
    var length = array.length;
    while (length--) {
      if (eq6(array[length][0], key2)) {
        return length;
      }
    }
    return -1;
  }
  function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
    var result = keysFunc(object2);
    return isArray(object2) ? result : arrayPush(result, symbolsFunc(object2));
  }
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray(object2), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag2(object2), othTag = othIsArr ? arrayTag : getTag2(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer(object2)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray2(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
  }
  function baseIsNative(value) {
    if (!isObject2(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  function baseKeys(object2) {
    if (!isPrototype(object2)) {
      return nativeKeys(object2);
    }
    var result = [];
    for (var key2 in Object(object2)) {
      if (hasOwnProperty.call(object2, key2) && key2 != "constructor") {
        result.push(key2);
      }
    }
    return result;
  }
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
    stack.set(array, other);
    stack.set(other, array);
    while (++index2 < arrLength) {
      var arrValue = array[index2], othValue = other[index2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
  }
  function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
          return false;
        }
        object2 = object2.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
      case numberTag:
        return eq6(+object2, +other);
      case errorTag:
        return object2.name == other.name && object2.message == other.message;
      case regexpTag:
      case stringTag:
        return object2 == other + "";
      case mapTag:
        var convert2 = mapToArray;
      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert2 || (convert2 = setToArray);
        if (object2.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object2);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;
        stack.set(object2, other);
        var result = equalArrays(convert2(object2), convert2(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object2);
        return result;
      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object2) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index2 = objLength;
    while (index2--) {
      var key2 = objProps[index2];
      if (!(isPartial ? key2 in other : hasOwnProperty.call(other, key2))) {
        return false;
      }
    }
    var stacked = stack.get(object2);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack.set(object2, other);
    stack.set(other, object2);
    var skipCtor = isPartial;
    while (++index2 < objLength) {
      key2 = objProps[index2];
      var objValue = object2[key2], othValue = other[key2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key2, other, object2, stack) : customizer(objValue, othValue, key2, object2, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key2 == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object2.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object2);
    stack["delete"](other);
    return result;
  }
  function getAllKeys(object2) {
    return baseGetAllKeys(object2, keys2, getSymbols);
  }
  function getMapData(map, key2) {
    var data2 = map.__data__;
    return isKeyable(key2) ? data2[typeof key2 == "string" ? "string" : "hash"] : data2.map;
  }
  function getNative(object2, key2) {
    var value = getValue2(object2, key2);
    return baseIsNative(value) ? value : void 0;
  }
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e3) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
    if (object2 == null) {
      return [];
    }
    object2 = Object(object2);
    return arrayFilter(nativeGetSymbols(object2), function(symbol) {
      return propertyIsEnumerable.call(object2, symbol);
    });
  };
  var getTag2 = baseGetTag;
  if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag2(new Map2()) != mapTag || Promise2 && getTag2(Promise2.resolve()) != promiseTag || Set2 && getTag2(new Set2()) != setTag || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag) {
    getTag2 = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isKeyable(value) {
    var type2 = typeof value;
    return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  }
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e3) {
      }
      try {
        return func + "";
      } catch (e3) {
      }
    }
    return "";
  }
  function eq6(value, other) {
    return value === other || value !== value && other !== other;
  }
  var isArguments2 = baseIsArguments(/* @__PURE__ */ function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  var isArray = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  var isBuffer = nativeIsBuffer || stubFalse;
  function isEqual(value, other) {
    return baseIsEqual(value, other);
  }
  function isFunction(value) {
    if (!isObject2(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject2(value) {
    var type2 = typeof value;
    return value != null && (type2 == "object" || type2 == "function");
  }
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  function keys2(object2) {
    return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
  }
  function stubArray() {
    return [];
  }
  function stubFalse() {
    return false;
  }
  module.exports = isEqual;
})(lodash_isequal, lodash_isequal.exports);
var lodash_isequalExports = lodash_isequal.exports;
const Ls$6 = /* @__PURE__ */ getDefaultExportFromCjs$1(lodash_isequalExports);
const Oe$5 = "wc", Ae$5 = 2, le$4 = "core", B$5 = `${Oe$5}@2:${le$4}:`, Dt$5 = { logger: "error" }, ft$4 = { database: ":memory:" }, vt$4 = "crypto", Ne$5 = "client_ed25519_seed", _t$6 = cjs$3.ONE_DAY, Et$7 = "keychain", wt$4 = "0.3", It$4 = "messages", Tt$5 = "0.3", $e$6 = cjs$3.SIX_HOURS, Ct$3 = "publisher", Pt$2 = "irn", St$7 = "error", ze$4 = "wss://dev-cross-relay.crosstoken.io/ws", Rt$5 = "relayer", T$5 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" }, xt$5 = "_subscription", L$5 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" }, Ot$4 = 1, De$5 = "2.19.0", Q$2 = { link_mode: "link_mode", relay: "relay" }, At$5 = "0.3", Nt$5 = "WALLETCONNECT_CLIENT_ID", Le$7 = "WALLETCONNECT_LINK_MODE_APPS", $$7 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" }, $t$2 = "subscription", zt$5 = "0.3", Lt$5 = cjs$3.FIVE_SECONDS * 1e3, kt$4 = "pairing", Ut$5 = "0.3", ie$5 = { wc_pairingDelete: { req: { ttl: cjs$3.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: cjs$3.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: cjs$3.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: cjs$3.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: cjs$3.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: cjs$3.ONE_DAY, prompt: false, tag: 0 } } }, se$5 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" }, F$5 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" }, Ft$5 = "history", Mt$5 = "0.3", Kt$5 = "expirer", M$6 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" }, Bt$5 = "0.3", Vt$5 = "verify-api", jt$4 = "https://dev-cross-verify.crosstoken.io", re$5 = "https://cross-verify.crosstoken.io", qt$5 = `${re$5}`, Gt$5 = [jt$4, re$5], Ht$5 = "echo", Yt$5 = "https://echo.walletconnect.com", q$4 = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" }, J$5 = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" }, js$5 = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" }, qs$7 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" }, Gs$5 = { authenticated_session_approve_started: "authenticated_session_approve_started", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve" }, Hs$5 = { no_internet_connection: "no_internet_connection", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" }, Jt$5 = 0.1, Xt$5 = "event-client", Wt$5 = 86400, Zt$5 = "https://pulse.walletconnect.org/batch";
function Ys$5(n5, e3) {
  if (n5.length >= 255) throw new TypeError("Alphabet too long");
  for (var t2 = new Uint8Array(256), s2 = 0; s2 < t2.length; s2++) t2[s2] = 255;
  for (var i4 = 0; i4 < n5.length; i4++) {
    var r3 = n5.charAt(i4), o3 = r3.charCodeAt(0);
    if (t2[o3] !== 255) throw new TypeError(r3 + " is ambiguous");
    t2[o3] = i4;
  }
  var a2 = n5.length, c2 = n5.charAt(0), h5 = Math.log(a2) / Math.log(256), u2 = Math.log(256) / Math.log(a2);
  function g2(l2) {
    if (l2 instanceof Uint8Array || (ArrayBuffer.isView(l2) ? l2 = new Uint8Array(l2.buffer, l2.byteOffset, l2.byteLength) : Array.isArray(l2) && (l2 = Uint8Array.from(l2))), !(l2 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (l2.length === 0) return "";
    for (var y4 = 0, O4 = 0, w2 = 0, f6 = l2.length; w2 !== f6 && l2[w2] === 0; ) w2++, y4++;
    for (var k3 = (f6 - w2) * u2 + 1 >>> 0, I4 = new Uint8Array(k3); w2 !== f6; ) {
      for (var j2 = l2[w2], X2 = 0, K3 = k3 - 1; (j2 !== 0 || X2 < O4) && K3 !== -1; K3--, X2++) j2 += 256 * I4[K3] >>> 0, I4[K3] = j2 % a2 >>> 0, j2 = j2 / a2 >>> 0;
      if (j2 !== 0) throw new Error("Non-zero carry");
      O4 = X2, w2++;
    }
    for (var Y2 = k3 - O4; Y2 !== k3 && I4[Y2] === 0; ) Y2++;
    for (var ge2 = c2.repeat(y4); Y2 < k3; ++Y2) ge2 += n5.charAt(I4[Y2]);
    return ge2;
  }
  function D2(l2) {
    if (typeof l2 != "string") throw new TypeError("Expected String");
    if (l2.length === 0) return new Uint8Array();
    var y4 = 0;
    if (l2[y4] !== " ") {
      for (var O4 = 0, w2 = 0; l2[y4] === c2; ) O4++, y4++;
      for (var f6 = (l2.length - y4) * h5 + 1 >>> 0, k3 = new Uint8Array(f6); l2[y4]; ) {
        var I4 = t2[l2.charCodeAt(y4)];
        if (I4 === 255) return;
        for (var j2 = 0, X2 = f6 - 1; (I4 !== 0 || j2 < w2) && X2 !== -1; X2--, j2++) I4 += a2 * k3[X2] >>> 0, k3[X2] = I4 % 256 >>> 0, I4 = I4 / 256 >>> 0;
        if (I4 !== 0) throw new Error("Non-zero carry");
        w2 = j2, y4++;
      }
      if (l2[y4] !== " ") {
        for (var K3 = f6 - w2; K3 !== f6 && k3[K3] === 0; ) K3++;
        for (var Y2 = new Uint8Array(O4 + (f6 - K3)), ge2 = O4; K3 !== f6; ) Y2[ge2++] = k3[K3++];
        return Y2;
      }
    }
  }
  function A2(l2) {
    var y4 = D2(l2);
    if (y4) return y4;
    throw new Error(`Non-${e3} character`);
  }
  return { encode: g2, decodeUnsafe: D2, decode: A2 };
}
var Js$5 = Ys$5, Xs$5 = Js$5;
const Qt$5 = (n5) => {
  if (n5 instanceof Uint8Array && n5.constructor.name === "Uint8Array") return n5;
  if (n5 instanceof ArrayBuffer) return new Uint8Array(n5);
  if (ArrayBuffer.isView(n5)) return new Uint8Array(n5.buffer, n5.byteOffset, n5.byteLength);
  throw new Error("Unknown type, must be binary type");
}, Ws$5 = (n5) => new TextEncoder().encode(n5), Zs$5 = (n5) => new TextDecoder().decode(n5);
let Qs$5 = class Qs2 {
  constructor(e3, t2, s2) {
    this.name = e3, this.prefix = t2, this.baseEncode = s2;
  }
  encode(e3) {
    if (e3 instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e3)}`;
    throw Error("Unknown type, must be binary type");
  }
};
let er$5 = class er2 {
  constructor(e3, t2, s2) {
    if (this.name = e3, this.prefix = t2, t2.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t2.codePointAt(0), this.baseDecode = s2;
  }
  decode(e3) {
    if (typeof e3 == "string") {
      if (e3.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e3)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e3.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e3) {
    return ei$5(this, e3);
  }
};
let tr$5 = class tr2 {
  constructor(e3) {
    this.decoders = e3;
  }
  or(e3) {
    return ei$5(this, e3);
  }
  decode(e3) {
    const t2 = e3[0], s2 = this.decoders[t2];
    if (s2) return s2.decode(e3);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e3)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
const ei$5 = (n5, e3) => new tr$5({ ...n5.decoders || { [n5.prefix]: n5 }, ...e3.decoders || { [e3.prefix]: e3 } });
let ir$5 = class ir2 {
  constructor(e3, t2, s2, i4) {
    this.name = e3, this.prefix = t2, this.baseEncode = s2, this.baseDecode = i4, this.encoder = new Qs$5(e3, t2, s2), this.decoder = new er$5(e3, t2, i4);
  }
  encode(e3) {
    return this.encoder.encode(e3);
  }
  decode(e3) {
    return this.decoder.decode(e3);
  }
};
const fe$2 = ({ name: n5, prefix: e3, encode: t2, decode: s2 }) => new ir$5(n5, e3, t2, s2), ue$4 = ({ prefix: n5, name: e3, alphabet: t2 }) => {
  const { encode: s2, decode: i4 } = Xs$5(t2, e3);
  return fe$2({ prefix: n5, name: e3, encode: s2, decode: (r3) => Qt$5(i4(r3)) });
}, sr$5 = (n5, e3, t2, s2) => {
  const i4 = {};
  for (let u2 = 0; u2 < e3.length; ++u2) i4[e3[u2]] = u2;
  let r3 = n5.length;
  for (; n5[r3 - 1] === "="; ) --r3;
  const o3 = new Uint8Array(r3 * t2 / 8 | 0);
  let a2 = 0, c2 = 0, h5 = 0;
  for (let u2 = 0; u2 < r3; ++u2) {
    const g2 = i4[n5[u2]];
    if (g2 === void 0) throw new SyntaxError(`Non-${s2} character`);
    c2 = c2 << t2 | g2, a2 += t2, a2 >= 8 && (a2 -= 8, o3[h5++] = 255 & c2 >> a2);
  }
  if (a2 >= t2 || 255 & c2 << 8 - a2) throw new SyntaxError("Unexpected end of data");
  return o3;
}, rr$5 = (n5, e3, t2) => {
  const s2 = e3[e3.length - 1] === "=", i4 = (1 << t2) - 1;
  let r3 = "", o3 = 0, a2 = 0;
  for (let c2 = 0; c2 < n5.length; ++c2) for (a2 = a2 << 8 | n5[c2], o3 += 8; o3 > t2; ) o3 -= t2, r3 += e3[i4 & a2 >> o3];
  if (o3 && (r3 += e3[i4 & a2 << t2 - o3]), s2) for (; r3.length * t2 & 7; ) r3 += "=";
  return r3;
}, C$5 = ({ name: n5, prefix: e3, bitsPerChar: t2, alphabet: s2 }) => fe$2({ prefix: e3, name: n5, encode(i4) {
  return rr$5(i4, s2, t2);
}, decode(i4) {
  return sr$5(i4, s2, t2, n5);
} }), nr$5 = fe$2({ prefix: "\0", name: "identity", encode: (n5) => Zs$5(n5), decode: (n5) => Ws$5(n5) });
var or$5 = Object.freeze({ __proto__: null, identity: nr$5 });
const ar$5 = C$5({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var cr$5 = Object.freeze({ __proto__: null, base2: ar$5 });
const hr$5 = C$5({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var lr$5 = Object.freeze({ __proto__: null, base8: hr$5 });
const ur$5 = ue$4({ prefix: "9", name: "base10", alphabet: "0123456789" });
var dr$5 = Object.freeze({ __proto__: null, base10: ur$5 });
const pr$5 = C$5({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), gr$5 = C$5({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var yr$5 = Object.freeze({ __proto__: null, base16: pr$5, base16upper: gr$5 });
const mr$5 = C$5({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), br$5 = C$5({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), Dr$4 = C$5({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), fr$5 = C$5({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), vr$5 = C$5({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), _r$5 = C$5({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), Er$5 = C$5({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), wr$5 = C$5({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), Ir$5 = C$5({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Tr$5 = Object.freeze({ __proto__: null, base32: mr$5, base32upper: br$5, base32pad: Dr$4, base32padupper: fr$5, base32hex: vr$5, base32hexupper: _r$5, base32hexpad: Er$5, base32hexpadupper: wr$5, base32z: Ir$5 });
const Cr$4 = ue$4({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), Pr$4 = ue$4({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Sr$5 = Object.freeze({ __proto__: null, base36: Cr$4, base36upper: Pr$4 });
const Rr$5 = ue$4({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), xr$5 = ue$4({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Or$5 = Object.freeze({ __proto__: null, base58btc: Rr$5, base58flickr: xr$5 });
const Ar$5 = C$5({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), Nr$5 = C$5({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), $r$5 = C$5({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), zr$5 = C$5({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Lr$4 = Object.freeze({ __proto__: null, base64: Ar$5, base64pad: Nr$5, base64url: $r$5, base64urlpad: zr$5 });
const ti$5 = Array.from(""), kr$4 = ti$5.reduce((n5, e3, t2) => (n5[t2] = e3, n5), []), Ur$5 = ti$5.reduce((n5, e3, t2) => (n5[e3.codePointAt(0)] = t2, n5), []);
function Fr$5(n5) {
  return n5.reduce((e3, t2) => (e3 += kr$4[t2], e3), "");
}
function Mr$5(n5) {
  const e3 = [];
  for (const t2 of n5) {
    const s2 = Ur$5[t2.codePointAt(0)];
    if (s2 === void 0) throw new Error(`Non-base256emoji character: ${t2}`);
    e3.push(s2);
  }
  return new Uint8Array(e3);
}
const Kr$5 = fe$2({ prefix: "", name: "base256emoji", encode: Fr$5, decode: Mr$5 });
var Br$4 = Object.freeze({ __proto__: null, base256emoji: Kr$5 }), Vr$5 = si$5, ii$5 = 128, qr$5 = -128, Gr$5 = Math.pow(2, 31);
function si$5(n5, e3, t2) {
  e3 = e3 || [], t2 = t2 || 0;
  for (var s2 = t2; n5 >= Gr$5; ) e3[t2++] = n5 & 255 | ii$5, n5 /= 128;
  for (; n5 & qr$5; ) e3[t2++] = n5 & 255 | ii$5, n5 >>>= 7;
  return e3[t2] = n5 | 0, si$5.bytes = t2 - s2 + 1, e3;
}
var Hr$5 = ke$7, Yr$5 = 128, ri$5 = 127;
function ke$7(n5, s2) {
  var t2 = 0, s2 = s2 || 0, i4 = 0, r3 = s2, o3, a2 = n5.length;
  do {
    if (r3 >= a2) throw ke$7.bytes = 0, new RangeError("Could not decode varint");
    o3 = n5[r3++], t2 += i4 < 28 ? (o3 & ri$5) << i4 : (o3 & ri$5) * Math.pow(2, i4), i4 += 7;
  } while (o3 >= Yr$5);
  return ke$7.bytes = r3 - s2, t2;
}
var Jr$5 = Math.pow(2, 7), Xr$5 = Math.pow(2, 14), Wr$5 = Math.pow(2, 21), Zr$5 = Math.pow(2, 28), Qr$5 = Math.pow(2, 35), en$5 = Math.pow(2, 42), tn$5 = Math.pow(2, 49), sn$5 = Math.pow(2, 56), rn$5 = Math.pow(2, 63), nn$5 = function(n5) {
  return n5 < Jr$5 ? 1 : n5 < Xr$5 ? 2 : n5 < Wr$5 ? 3 : n5 < Zr$5 ? 4 : n5 < Qr$5 ? 5 : n5 < en$5 ? 6 : n5 < tn$5 ? 7 : n5 < sn$5 ? 8 : n5 < rn$5 ? 9 : 10;
}, on$5 = { encode: Vr$5, decode: Hr$5, encodingLength: nn$5 }, ni$5 = on$5;
const oi$5 = (n5, e3, t2 = 0) => (ni$5.encode(n5, e3, t2), e3), ai$5 = (n5) => ni$5.encodingLength(n5), Ue$7 = (n5, e3) => {
  const t2 = e3.byteLength, s2 = ai$5(n5), i4 = s2 + ai$5(t2), r3 = new Uint8Array(i4 + t2);
  return oi$5(n5, r3, 0), oi$5(t2, r3, s2), r3.set(e3, i4), new an$5(n5, t2, e3, r3);
};
let an$5 = class an2 {
  constructor(e3, t2, s2, i4) {
    this.code = e3, this.size = t2, this.digest = s2, this.bytes = i4;
  }
};
const ci$5 = ({ name: n5, code: e3, encode: t2 }) => new cn$5(n5, e3, t2);
let cn$5 = class cn2 {
  constructor(e3, t2, s2) {
    this.name = e3, this.code = t2, this.encode = s2;
  }
  digest(e3) {
    if (e3 instanceof Uint8Array) {
      const t2 = this.encode(e3);
      return t2 instanceof Uint8Array ? Ue$7(this.code, t2) : t2.then((s2) => Ue$7(this.code, s2));
    } else throw Error("Unknown type, must be binary type");
  }
};
const hi$5 = (n5) => async (e3) => new Uint8Array(await crypto.subtle.digest(n5, e3)), hn$5 = ci$5({ name: "sha2-256", code: 18, encode: hi$5("SHA-256") }), ln$5 = ci$5({ name: "sha2-512", code: 19, encode: hi$5("SHA-512") });
var un$5 = Object.freeze({ __proto__: null, sha256: hn$5, sha512: ln$5 });
const li$5 = 0, dn$5 = "identity", ui$5 = Qt$5, pn$5 = (n5) => Ue$7(li$5, ui$5(n5)), gn$5 = { code: li$5, name: dn$5, encode: ui$5, digest: pn$5 };
var yn$5 = Object.freeze({ __proto__: null, identity: gn$5 });
new TextEncoder(), new TextDecoder();
const di$5 = { ...or$5, ...cr$5, ...lr$5, ...dr$5, ...yr$5, ...Tr$5, ...Sr$5, ...Or$5, ...Lr$4, ...Br$4 };
({ ...un$5, ...yn$5 });
function mn$5(n5 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(n5) : new Uint8Array(n5);
}
function pi$5(n5, e3, t2, s2) {
  return { name: n5, prefix: e3, encoder: { name: n5, prefix: e3, encode: t2 }, decoder: { decode: s2 } };
}
const gi$5 = pi$5("utf8", "u", (n5) => "u" + new TextDecoder("utf8").decode(n5), (n5) => new TextEncoder().encode(n5.substring(1))), Fe$7 = pi$5("ascii", "a", (n5) => {
  let e3 = "a";
  for (let t2 = 0; t2 < n5.length; t2++) e3 += String.fromCharCode(n5[t2]);
  return e3;
}, (n5) => {
  n5 = n5.substring(1);
  const e3 = mn$5(n5.length);
  for (let t2 = 0; t2 < n5.length; t2++) e3[t2] = n5.charCodeAt(t2);
  return e3;
}), bn$5 = { utf8: gi$5, "utf-8": gi$5, hex: di$5.base16, latin1: Fe$7, ascii: Fe$7, binary: Fe$7, ...di$5 };
function Dn$5(n5, e3 = "utf8") {
  const t2 = bn$5[e3];
  if (!t2) throw new Error(`Unsupported encoding "${e3}"`);
  return (e3 === "utf8" || e3 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(n5, "utf8") : t2.decoder.decode(`${t2.prefix}${n5}`);
}
var fn$5 = Object.defineProperty, vn$5 = (n5, e3, t2) => e3 in n5 ? fn$5(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, G$4 = (n5, e3, t2) => vn$5(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let yi$5 = class yi2 {
  constructor(e3, t2) {
    this.core = e3, this.logger = t2, G$4(this, "keychain", /* @__PURE__ */ new Map()), G$4(this, "name", Et$7), G$4(this, "version", wt$4), G$4(this, "initialized", false), G$4(this, "storagePrefix", B$5), G$4(this, "init", async () => {
      if (!this.initialized) {
        const s2 = await this.getKeyChain();
        typeof s2 < "u" && (this.keychain = s2), this.initialized = true;
      }
    }), G$4(this, "has", (s2) => (this.isInitialized(), this.keychain.has(s2))), G$4(this, "set", async (s2, i4) => {
      this.isInitialized(), this.keychain.set(s2, i4), await this.persist();
    }), G$4(this, "get", (s2) => {
      this.isInitialized();
      const i4 = this.keychain.get(s2);
      if (typeof i4 > "u") {
        const { message: r3 } = te$4("NO_MATCHING_KEY", `${this.name}: ${s2}`);
        throw new Error(r3);
      }
      return i4;
    }), G$4(this, "del", async (s2) => {
      this.isInitialized(), this.keychain.delete(s2), await this.persist();
    }), this.core = e3, this.logger = E$7(t2, this.name);
  }
  get context() {
    return y$6(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e3) {
    await this.core.storage.setItem(this.storageKey, no$6(e3));
  }
  async getKeyChain() {
    const e3 = await this.core.storage.getItem(this.storageKey);
    return typeof e3 < "u" ? ro$6(e3) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e3 } = te$4("NOT_INITIALIZED", this.name);
      throw new Error(e3);
    }
  }
};
var _n$5 = Object.defineProperty, En$5 = (n5, e3, t2) => e3 in n5 ? _n$5(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, P$3 = (n5, e3, t2) => En$5(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let mi$5 = class mi2 {
  constructor(e3, t2, s2) {
    this.core = e3, this.logger = t2, P$3(this, "name", vt$4), P$3(this, "keychain"), P$3(this, "randomSessionIdentifier", ni$6()), P$3(this, "initialized", false), P$3(this, "init", async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }), P$3(this, "hasKeys", (i4) => (this.isInitialized(), this.keychain.has(i4))), P$3(this, "getClientId", async () => {
      this.isInitialized();
      const i4 = await this.getClientSeed(), r3 = Po$5(i4);
      return Qe$5(r3.publicKey);
    }), P$3(this, "generateKeyPair", () => {
      this.isInitialized();
      const i4 = ti$6();
      return this.setPrivateKey(i4.publicKey, i4.privateKey);
    }), P$3(this, "signJWT", async (i4) => {
      this.isInitialized();
      const r3 = await this.getClientSeed(), o3 = Po$5(r3), a2 = this.randomSessionIdentifier, c2 = _t$6;
      return await Qo$5(a2, i4, c2, o3);
    }), P$3(this, "generateSharedKey", (i4, r3, o3) => {
      this.isInitialized();
      const a2 = this.getPrivateKey(i4), c2 = ri$6(a2, r3);
      return this.setSymKey(c2, o3);
    }), P$3(this, "setSymKey", async (i4, r3) => {
      this.isInitialized();
      const o3 = r3 || oi$6(i4);
      return await this.keychain.set(o3, i4), o3;
    }), P$3(this, "deleteKeyPair", async (i4) => {
      this.isInitialized(), await this.keychain.del(i4);
    }), P$3(this, "deleteSymKey", async (i4) => {
      this.isInitialized(), await this.keychain.del(i4);
    }), P$3(this, "encode", async (i4, r3, o3) => {
      this.isInitialized();
      const a2 = rr$6(o3), c2 = safeJsonStringify(r3);
      if (di$6(a2)) return ai$6(c2, o3 == null ? void 0 : o3.encoding);
      if (li$6(a2)) {
        const D2 = a2.senderPublicKey, A2 = a2.receiverPublicKey;
        i4 = await this.generateSharedKey(D2, A2);
      }
      const h5 = this.getSymKey(i4), { type: u2, senderPublicKey: g2 } = a2;
      return ii$6({ type: u2, symKey: h5, message: c2, senderPublicKey: g2, encoding: o3 == null ? void 0 : o3.encoding });
    }), P$3(this, "decode", async (i4, r3, o3) => {
      this.isInitialized();
      const a2 = fi$6(r3, o3);
      if (di$6(a2)) {
        const c2 = ui$6(r3, o3 == null ? void 0 : o3.encoding);
        return safeJsonParse(c2);
      }
      if (li$6(a2)) {
        const c2 = a2.receiverPublicKey, h5 = a2.senderPublicKey;
        i4 = await this.generateSharedKey(c2, h5);
      }
      try {
        const c2 = this.getSymKey(i4), h5 = ci$6({ symKey: c2, encoded: r3, encoding: o3 == null ? void 0 : o3.encoding });
        return safeJsonParse(h5);
      } catch (c2) {
        this.logger.error(`Failed to decode message from topic: '${i4}', clientId: '${await this.getClientId()}'`), this.logger.error(c2);
      }
    }), P$3(this, "getPayloadType", (i4, r3 = At$6) => {
      const o3 = Fe$8({ encoded: i4, encoding: r3 });
      return fe$3(o3.type);
    }), P$3(this, "getPayloadSenderPublicKey", (i4, r3 = At$6) => {
      const o3 = Fe$8({ encoded: i4, encoding: r3 });
      return o3.senderPublicKey ? toString$1(o3.senderPublicKey, V$9) : void 0;
    }), this.core = e3, this.logger = E$7(t2, this.name), this.keychain = s2 || new yi$5(this.core, this.logger);
  }
  get context() {
    return y$6(this.logger);
  }
  async setPrivateKey(e3, t2) {
    return await this.keychain.set(e3, t2), e3;
  }
  getPrivateKey(e3) {
    return this.keychain.get(e3);
  }
  async getClientSeed() {
    let e3 = "";
    try {
      e3 = this.keychain.get(Ne$5);
    } catch {
      e3 = ni$6(), await this.keychain.set(Ne$5, e3);
    }
    return Dn$5(e3, "base16");
  }
  getSymKey(e3) {
    return this.keychain.get(e3);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e3 } = te$4("NOT_INITIALIZED", this.name);
      throw new Error(e3);
    }
  }
};
var wn$5 = Object.defineProperty, In$5 = (n5, e3, t2) => e3 in n5 ? wn$5(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, H$5 = (n5, e3, t2) => In$5(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let bi$5 = class bi2 extends y$4 {
  constructor(e3, t2) {
    super(e3, t2), this.logger = e3, this.core = t2, H$5(this, "messages", /* @__PURE__ */ new Map()), H$5(this, "name", It$4), H$5(this, "version", Tt$5), H$5(this, "initialized", false), H$5(this, "storagePrefix", B$5), H$5(this, "init", async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const s2 = await this.getRelayerMessages();
          typeof s2 < "u" && (this.messages = s2), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (s2) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(s2);
        } finally {
          this.initialized = true;
        }
      }
    }), H$5(this, "set", async (s2, i4) => {
      this.isInitialized();
      const r3 = si$6(i4);
      let o3 = this.messages.get(s2);
      return typeof o3 > "u" && (o3 = {}), typeof o3[r3] < "u" || (o3[r3] = i4, this.messages.set(s2, o3), await this.persist()), r3;
    }), H$5(this, "get", (s2) => {
      this.isInitialized();
      let i4 = this.messages.get(s2);
      return typeof i4 > "u" && (i4 = {}), i4;
    }), H$5(this, "has", (s2, i4) => {
      this.isInitialized();
      const r3 = this.get(s2), o3 = si$6(i4);
      return typeof r3[o3] < "u";
    }), H$5(this, "del", async (s2) => {
      this.isInitialized(), this.messages.delete(s2), await this.persist();
    }), this.logger = E$7(e3, this.name), this.core = t2;
  }
  get context() {
    return y$6(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e3) {
    await this.core.storage.setItem(this.storageKey, no$6(e3));
  }
  async getRelayerMessages() {
    const e3 = await this.core.storage.getItem(this.storageKey);
    return typeof e3 < "u" ? ro$6(e3) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e3 } = te$4("NOT_INITIALIZED", this.name);
      throw new Error(e3);
    }
  }
};
var Tn$5 = Object.defineProperty, Cn$5 = Object.defineProperties, Pn$5 = Object.getOwnPropertyDescriptors, Di$5 = Object.getOwnPropertySymbols, Sn$5 = Object.prototype.hasOwnProperty, Rn$5 = Object.prototype.propertyIsEnumerable, Me$7 = (n5, e3, t2) => e3 in n5 ? Tn$5(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, ve$2 = (n5, e3) => {
  for (var t2 in e3 || (e3 = {})) Sn$5.call(e3, t2) && Me$7(n5, t2, e3[t2]);
  if (Di$5) for (var t2 of Di$5(e3)) Rn$5.call(e3, t2) && Me$7(n5, t2, e3[t2]);
  return n5;
}, Ke$7 = (n5, e3) => Cn$5(n5, Pn$5(e3)), V$8 = (n5, e3, t2) => Me$7(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let xn$5 = class xn3 extends m$1 {
  constructor(e3, t2) {
    super(e3, t2), this.relayer = e3, this.logger = t2, V$8(this, "events", new eventsExports.EventEmitter()), V$8(this, "name", Ct$3), V$8(this, "queue", /* @__PURE__ */ new Map()), V$8(this, "publishTimeout", cjs$3.toMiliseconds(cjs$3.ONE_MINUTE)), V$8(this, "initialPublishTimeout", cjs$3.toMiliseconds(cjs$3.ONE_SECOND * 15)), V$8(this, "needsTransportRestart", false), V$8(this, "publish", async (s2, i4, r3) => {
      var o3;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: s2, message: i4, opts: r3 } });
      const a2 = (r3 == null ? void 0 : r3.ttl) || $e$6, c2 = yi$6(r3), h5 = (r3 == null ? void 0 : r3.prompt) || false, u2 = (r3 == null ? void 0 : r3.tag) || 0, g2 = (r3 == null ? void 0 : r3.id) || getBigIntRpcId().toString(), D2 = { topic: s2, message: i4, opts: { ttl: a2, relay: c2, prompt: h5, tag: u2, id: g2, attestation: r3 == null ? void 0 : r3.attestation, tvf: r3 == null ? void 0 : r3.tvf } }, A2 = `Failed to publish payload, please try again. id:${g2} tag:${u2}`;
      try {
        const l2 = new Promise(async (y4) => {
          const O4 = ({ id: f6 }) => {
            D2.opts.id === f6 && (this.removeRequestFromQueue(f6), this.relayer.events.removeListener(T$5.publish, O4), y4(D2));
          };
          this.relayer.events.on(T$5.publish, O4);
          const w2 = ao$6(new Promise((f6, k3) => {
            this.rpcPublish({ topic: s2, message: i4, ttl: a2, prompt: h5, tag: u2, id: g2, attestation: r3 == null ? void 0 : r3.attestation, tvf: r3 == null ? void 0 : r3.tvf }).then(f6).catch((I4) => {
              this.logger.warn(I4, I4 == null ? void 0 : I4.message), k3(I4);
            });
          }), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${g2} tag:${u2}`);
          try {
            await w2, this.events.removeListener(T$5.publish, O4);
          } catch (f6) {
            this.queue.set(g2, Ke$7(ve$2({}, D2), { attempt: 1 })), this.logger.warn(f6, f6 == null ? void 0 : f6.message);
          }
        });
        this.logger.trace({ type: "method", method: "publish", params: { id: g2, topic: s2, message: i4, opts: r3 } }), await ao$6(l2, this.publishTimeout, A2);
      } catch (l2) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(l2), (o3 = r3 == null ? void 0 : r3.internal) != null && o3.throwOnFailedPublish) throw l2;
      } finally {
        this.queue.delete(g2);
      }
    }), V$8(this, "on", (s2, i4) => {
      this.events.on(s2, i4);
    }), V$8(this, "once", (s2, i4) => {
      this.events.once(s2, i4);
    }), V$8(this, "off", (s2, i4) => {
      this.events.off(s2, i4);
    }), V$8(this, "removeListener", (s2, i4) => {
      this.events.removeListener(s2, i4);
    }), this.relayer = e3, this.logger = E$7(t2, this.name), this.registerEventListeners();
  }
  get context() {
    return y$6(this.logger);
  }
  async rpcPublish(e3) {
    var t2, s2, i4, r3;
    const { topic: o3, message: a2, ttl: c2 = $e$6, prompt: h5, tag: u2, id: g2, attestation: D2, tvf: A2 } = e3, l2 = { method: mi$6(yi$6().protocol).publish, params: ve$2({ topic: o3, message: a2, ttl: c2, prompt: h5, tag: u2, attestation: D2 }, A2), id: g2 };
    ae$6((t2 = l2.params) == null ? void 0 : t2.prompt) && ((s2 = l2.params) == null || delete s2.prompt), ae$6((i4 = l2.params) == null ? void 0 : i4.tag) && ((r3 = l2.params) == null || delete r3.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: l2 });
    const y4 = await this.relayer.request(l2);
    return this.relayer.events.emit(T$5.publish, e3), this.logger.debug("Successfully Published Payload"), y4;
  }
  removeRequestFromQueue(e3) {
    this.queue.delete(e3);
  }
  checkQueue() {
    this.queue.forEach(async (e3, t2) => {
      const s2 = e3.attempt + 1;
      this.queue.set(t2, Ke$7(ve$2({}, e3), { attempt: s2 }));
      const { topic: i4, message: r3, opts: o3, attestation: a2 } = e3;
      this.logger.warn({}, `Publisher: queue->publishing: ${e3.opts.id}, tag: ${e3.opts.tag}, attempt: ${s2}`), await this.rpcPublish(Ke$7(ve$2({}, e3), { topic: i4, message: r3, ttl: o3.ttl, prompt: o3.prompt, tag: o3.tag, id: o3.id, attestation: a2, tvf: o3.tvf })), this.logger.warn({}, `Publisher: queue->published: ${e3.opts.id}`);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r$8.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(T$5.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(T$5.message_ack, (e3) => {
      this.removeRequestFromQueue(e3.id.toString());
    });
  }
};
var On$5 = Object.defineProperty, An$5 = (n5, e3, t2) => e3 in n5 ? On$5(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, ne$5 = (n5, e3, t2) => An$5(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let Nn$5 = class Nn2 {
  constructor() {
    ne$5(this, "map", /* @__PURE__ */ new Map()), ne$5(this, "set", (e3, t2) => {
      const s2 = this.get(e3);
      this.exists(e3, t2) || this.map.set(e3, [...s2, t2]);
    }), ne$5(this, "get", (e3) => this.map.get(e3) || []), ne$5(this, "exists", (e3, t2) => this.get(e3).includes(t2)), ne$5(this, "delete", (e3, t2) => {
      if (typeof t2 > "u") {
        this.map.delete(e3);
        return;
      }
      if (!this.map.has(e3)) return;
      const s2 = this.get(e3);
      if (!this.exists(e3, t2)) return;
      const i4 = s2.filter((r3) => r3 !== t2);
      if (!i4.length) {
        this.map.delete(e3);
        return;
      }
      this.map.set(e3, i4);
    }), ne$5(this, "clear", () => {
      this.map.clear();
    });
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var $n$5 = Object.defineProperty, zn$5 = Object.defineProperties, Ln$5 = Object.getOwnPropertyDescriptors, fi$5 = Object.getOwnPropertySymbols, kn$5 = Object.prototype.hasOwnProperty, Un$5 = Object.prototype.propertyIsEnumerable, Be$5 = (n5, e3, t2) => e3 in n5 ? $n$5(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, de$4 = (n5, e3) => {
  for (var t2 in e3 || (e3 = {})) kn$5.call(e3, t2) && Be$5(n5, t2, e3[t2]);
  if (fi$5) for (var t2 of fi$5(e3)) Un$5.call(e3, t2) && Be$5(n5, t2, e3[t2]);
  return n5;
}, Ve$5 = (n5, e3) => zn$5(n5, Ln$5(e3)), b$4 = (n5, e3, t2) => Be$5(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let vi$5 = class vi2 extends P$5 {
  constructor(e3, t2) {
    super(e3, t2), this.relayer = e3, this.logger = t2, b$4(this, "subscriptions", /* @__PURE__ */ new Map()), b$4(this, "topicMap", new Nn$5()), b$4(this, "events", new eventsExports.EventEmitter()), b$4(this, "name", $t$2), b$4(this, "version", zt$5), b$4(this, "pending", /* @__PURE__ */ new Map()), b$4(this, "cached", []), b$4(this, "initialized", false), b$4(this, "pendingSubscriptionWatchLabel", "pending_sub_watch_label"), b$4(this, "pollingInterval", 20), b$4(this, "storagePrefix", B$5), b$4(this, "subscribeTimeout", cjs$3.toMiliseconds(cjs$3.ONE_MINUTE)), b$4(this, "initialSubscribeTimeout", cjs$3.toMiliseconds(cjs$3.ONE_SECOND * 15)), b$4(this, "clientId"), b$4(this, "batchSubscribeTopicsLimit", 500), b$4(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), await this.restore()), this.initialized = true;
    }), b$4(this, "subscribe", async (s2, i4) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s2, opts: i4 } });
      try {
        const r3 = yi$6(i4), o3 = { topic: s2, relay: r3, transportType: i4 == null ? void 0 : i4.transportType };
        this.pending.set(s2, o3);
        const a2 = await this.rpcSubscribe(s2, r3, i4);
        return typeof a2 == "string" && (this.onSubscribe(a2, o3), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s2, opts: i4 } })), a2;
      } catch (r3) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(r3), r3;
      }
    }), b$4(this, "unsubscribe", async (s2, i4) => {
      this.isInitialized(), typeof (i4 == null ? void 0 : i4.id) < "u" ? await this.unsubscribeById(s2, i4.id, i4) : await this.unsubscribeByTopic(s2, i4);
    }), b$4(this, "isSubscribed", async (s2) => {
      if (this.topics.includes(s2)) return true;
      const i4 = `${this.pendingSubscriptionWatchLabel}_${s2}`;
      return await new Promise((r3, o3) => {
        const a2 = new cjs$3.Watch();
        a2.start(i4);
        const c2 = setInterval(() => {
          (!this.pending.has(s2) && this.topics.includes(s2) || this.cached.some((h5) => h5.topic === s2)) && (clearInterval(c2), a2.stop(i4), r3(true)), a2.elapsed(i4) >= Lt$5 && (clearInterval(c2), a2.stop(i4), o3(new Error("Subscription resolution timeout")));
        }, this.pollingInterval);
      }).catch(() => false);
    }), b$4(this, "on", (s2, i4) => {
      this.events.on(s2, i4);
    }), b$4(this, "once", (s2, i4) => {
      this.events.once(s2, i4);
    }), b$4(this, "off", (s2, i4) => {
      this.events.off(s2, i4);
    }), b$4(this, "removeListener", (s2, i4) => {
      this.events.removeListener(s2, i4);
    }), b$4(this, "start", async () => {
      await this.onConnect();
    }), b$4(this, "stop", async () => {
      await this.onDisconnect();
    }), b$4(this, "restart", async () => {
      await this.restore(), await this.onRestart();
    }), b$4(this, "checkPending", async () => {
      if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) return;
      const s2 = [];
      this.pending.forEach((i4) => {
        s2.push(i4);
      }), await this.batchSubscribe(s2);
    }), b$4(this, "registerEventListeners", () => {
      this.relayer.core.heartbeat.on(r$8.pulse, async () => {
        await this.checkPending();
      }), this.events.on($$7.created, async (s2) => {
        const i4 = $$7.created;
        this.logger.info(`Emitting ${i4}`), this.logger.debug({ type: "event", event: i4, data: s2 }), await this.persist();
      }), this.events.on($$7.deleted, async (s2) => {
        const i4 = $$7.deleted;
        this.logger.info(`Emitting ${i4}`), this.logger.debug({ type: "event", event: i4, data: s2 }), await this.persist();
      });
    }), this.relayer = e3, this.logger = E$7(t2, this.name), this.clientId = "";
  }
  get context() {
    return y$6(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  get hasAnyTopics() {
    return this.topicMap.topics.length > 0 || this.pending.size > 0 || this.cached.length > 0 || this.subscriptions.size > 0;
  }
  hasSubscription(e3, t2) {
    let s2 = false;
    try {
      s2 = this.getSubscription(e3).topic === t2;
    } catch {
    }
    return s2;
  }
  reset() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e3, t2) {
    const s2 = this.topicMap.get(e3);
    await Promise.all(s2.map(async (i4) => await this.unsubscribeById(e3, i4, t2)));
  }
  async unsubscribeById(e3, t2, s2) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e3, id: t2, opts: s2 } });
    try {
      const i4 = yi$6(s2);
      await this.restartToComplete({ topic: e3, id: t2, relay: i4 }), await this.rpcUnsubscribe(e3, t2, i4);
      const r3 = de$5("USER_DISCONNECTED", `${this.name}, ${e3}`);
      await this.onUnsubscribe(e3, t2, r3), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e3, id: t2, opts: s2 } });
    } catch (i4) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(i4), i4;
    }
  }
  async rpcSubscribe(e3, t2, s2) {
    var i4;
    (!s2 || (s2 == null ? void 0 : s2.transportType) === Q$2.relay) && await this.restartToComplete({ topic: e3, id: e3, relay: t2 });
    const r3 = { method: mi$6(t2.protocol).subscribe, params: { topic: e3 } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: r3 });
    const o3 = (i4 = s2 == null ? void 0 : s2.internal) == null ? void 0 : i4.throwOnFailedPublish;
    try {
      const a2 = await this.getSubscriptionId(e3);
      if ((s2 == null ? void 0 : s2.transportType) === Q$2.link_mode) return setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(r3).catch((u2) => this.logger.warn(u2));
      }, cjs$3.toMiliseconds(cjs$3.ONE_SECOND)), a2;
      const c2 = new Promise(async (u2) => {
        const g2 = (D2) => {
          D2.topic === e3 && (this.events.removeListener($$7.created, g2), u2(D2.id));
        };
        this.events.on($$7.created, g2);
        try {
          const D2 = await ao$6(new Promise((A2, l2) => {
            this.relayer.request(r3).catch((y4) => {
              this.logger.warn(y4, y4 == null ? void 0 : y4.message), l2(y4);
            }).then(A2);
          }), this.initialSubscribeTimeout, `Subscribing to ${e3} failed, please try again`);
          this.events.removeListener($$7.created, g2), u2(D2);
        } catch {
        }
      }), h5 = await ao$6(c2, this.subscribeTimeout, `Subscribing to ${e3} failed, please try again`);
      if (!h5 && o3) throw new Error(`Subscribing to ${e3} failed, please try again`);
      return h5 ? a2 : null;
    } catch (a2) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(T$5.connection_stalled), o3) throw a2;
    }
    return null;
  }
  async rpcBatchSubscribe(e3) {
    if (!e3.length) return;
    const t2 = e3[0].relay, s2 = { method: mi$6(t2.protocol).batchSubscribe, params: { topics: e3.map((i4) => i4.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 });
    try {
      await await ao$6(new Promise((i4) => {
        this.relayer.request(s2).catch((r3) => this.logger.warn(r3)).then(i4);
      }), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again");
    } catch {
      this.relayer.events.emit(T$5.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e3) {
    if (!e3.length) return;
    const t2 = e3[0].relay, s2 = { method: mi$6(t2.protocol).batchFetchMessages, params: { topics: e3.map((r3) => r3.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 });
    let i4;
    try {
      i4 = await await ao$6(new Promise((r3, o3) => {
        this.relayer.request(s2).catch((a2) => {
          this.logger.warn(a2), o3(a2);
        }).then(r3);
      }), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again");
    } catch {
      this.relayer.events.emit(T$5.connection_stalled);
    }
    return i4;
  }
  rpcUnsubscribe(e3, t2, s2) {
    const i4 = { method: mi$6(s2.protocol).unsubscribe, params: { topic: e3, id: t2 } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i4 }), this.relayer.request(i4);
  }
  onSubscribe(e3, t2) {
    this.setSubscription(e3, Ve$5(de$4({}, t2), { id: e3 })), this.pending.delete(t2.topic);
  }
  onBatchSubscribe(e3) {
    e3.length && e3.forEach((t2) => {
      this.setSubscription(t2.id, de$4({}, t2)), this.pending.delete(t2.topic);
    });
  }
  async onUnsubscribe(e3, t2, s2) {
    this.events.removeAllListeners(t2), this.hasSubscription(t2, e3) && this.deleteSubscription(t2, s2), await this.relayer.messages.del(e3);
  }
  async setRelayerSubscriptions(e3) {
    await this.relayer.core.storage.setItem(this.storageKey, e3);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e3, t2) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e3, subscription: t2 }), this.addSubscription(e3, t2);
  }
  addSubscription(e3, t2) {
    this.subscriptions.set(e3, de$4({}, t2)), this.topicMap.set(t2.topic, e3), this.events.emit($$7.created, t2);
  }
  getSubscription(e3) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e3 });
    const t2 = this.subscriptions.get(e3);
    if (!t2) {
      const { message: s2 } = te$4("NO_MATCHING_KEY", `${this.name}: ${e3}`);
      throw new Error(s2);
    }
    return t2;
  }
  deleteSubscription(e3, t2) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e3, reason: t2 });
    const s2 = this.getSubscription(e3);
    this.subscriptions.delete(e3), this.topicMap.delete(s2.topic, e3), this.events.emit($$7.deleted, Ve$5(de$4({}, s2), { reason: t2 }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit($$7.sync);
  }
  async onRestart() {
    if (this.cached.length) {
      const e3 = [...this.cached], t2 = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let s2 = 0; s2 < t2; s2++) {
        const i4 = e3.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(i4);
      }
    }
    this.events.emit($$7.resubscribed);
  }
  async restore() {
    try {
      const e3 = await this.getRelayerSubscriptions();
      if (typeof e3 > "u" || !e3.length) return;
      if (this.subscriptions.size) {
        const { message: t2 } = te$4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t2), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t2);
      }
      this.cached = e3, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e3) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e3);
    }
  }
  async batchSubscribe(e3) {
    e3.length && (await this.rpcBatchSubscribe(e3), this.onBatchSubscribe(await Promise.all(e3.map(async (t2) => Ve$5(de$4({}, t2), { id: await this.getSubscriptionId(t2.topic) })))));
  }
  async batchFetchMessages(e3) {
    if (!e3.length) return;
    this.logger.trace(`Fetching batch messages for ${e3.length} subscriptions`);
    const t2 = await this.rpcBatchFetchMessages(e3);
    t2 && t2.messages && (await vo$4(cjs$3.toMiliseconds(cjs$3.ONE_SECOND)), await this.relayer.handleBatchMessageEvents(t2.messages));
  }
  async onConnect() {
    await this.restart(), this.reset();
  }
  onDisconnect() {
    this.onDisable();
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e3 } = te$4("NOT_INITIALIZED", this.name);
      throw new Error(e3);
    }
  }
  async restartToComplete(e3) {
    if (!this.relayer.connected && !this.relayer.connecting) {
      this.cached.push(e3);
      try {
        if (!await (async () => await Promise.resolve().then(() => index_es$1)).then((t2) => t2.isOnline())) return;
      } catch {
      }
      await this.relayer.transportOpen();
    }
  }
  async getClientId() {
    return this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()), this.clientId;
  }
  async getSubscriptionId(e3) {
    return si$6(e3 + await this.getClientId());
  }
};
var Fn$5 = Object.defineProperty, _i$5 = Object.getOwnPropertySymbols, Mn$5 = Object.prototype.hasOwnProperty, Kn$5 = Object.prototype.propertyIsEnumerable, je$5 = (n5, e3, t2) => e3 in n5 ? Fn$5(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, Ei$5 = (n5, e3) => {
  for (var t2 in e3 || (e3 = {})) Mn$5.call(e3, t2) && je$5(n5, t2, e3[t2]);
  if (_i$5) for (var t2 of _i$5(e3)) Kn$5.call(e3, t2) && je$5(n5, t2, e3[t2]);
  return n5;
}, p$7 = (n5, e3, t2) => je$5(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let wi$5 = class wi2 extends d$6 {
  constructor(e3) {
    super(e3), p$7(this, "protocol", "wc"), p$7(this, "version", 2), p$7(this, "core"), p$7(this, "logger"), p$7(this, "events", new eventsExports.EventEmitter()), p$7(this, "provider"), p$7(this, "messages"), p$7(this, "subscriber"), p$7(this, "publisher"), p$7(this, "name", Rt$5), p$7(this, "transportExplicitlyClosed", false), p$7(this, "initialized", false), p$7(this, "connectionAttemptInProgress", false), p$7(this, "relayUrl"), p$7(this, "projectId"), p$7(this, "packageName"), p$7(this, "bundleId"), p$7(this, "hasExperiencedNetworkDisruption", false), p$7(this, "pingTimeout"), p$7(this, "heartBeatTimeout", cjs$3.toMiliseconds(cjs$3.THIRTY_SECONDS + cjs$3.FIVE_SECONDS)), p$7(this, "reconnectTimeout"), p$7(this, "connectPromise"), p$7(this, "reconnectInProgress", false), p$7(this, "requestsInFlight", []), p$7(this, "connectTimeout", cjs$3.toMiliseconds(cjs$3.ONE_SECOND * 15)), p$7(this, "request", async (t2) => {
      var s2, i4;
      this.logger.debug("Publishing Request Payload");
      const r3 = t2.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        this.logger.trace({ id: r3, method: t2.method, topic: (s2 = t2.params) == null ? void 0 : s2.topic }, "relayer.request - publishing...");
        const o3 = `${r3}:${((i4 = t2.params) == null ? void 0 : i4.tag) || ""}`;
        this.requestsInFlight.push(o3);
        const a2 = await this.provider.request(t2);
        return this.requestsInFlight = this.requestsInFlight.filter((c2) => c2 !== o3), a2;
      } catch (o3) {
        throw this.logger.debug(`Failed to Publish Request: ${r3}`), o3;
      }
    }), p$7(this, "resetPingTimeout", () => {
      if (et$4()) try {
        clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
          var t2, s2, i4;
          this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."), (i4 = (s2 = (t2 = this.provider) == null ? void 0 : t2.connection) == null ? void 0 : s2.socket) == null || i4.terminate();
        }, this.heartBeatTimeout);
      } catch (t2) {
        this.logger.warn(t2, t2 == null ? void 0 : t2.message);
      }
    }), p$7(this, "onPayloadHandler", (t2) => {
      this.onProviderPayload(t2), this.resetPingTimeout();
    }), p$7(this, "onConnectHandler", () => {
      this.logger.warn({}, "Relayer connected "), this.startPingTimeout(), this.events.emit(T$5.connect);
    }), p$7(this, "onDisconnectHandler", () => {
      this.logger.warn({}, "Relayer disconnected "), this.requestsInFlight = [], this.onProviderDisconnect();
    }), p$7(this, "onProviderErrorHandler", (t2) => {
      this.logger.fatal(`Fatal socket error: ${t2.message}`), this.events.emit(T$5.error, t2), this.logger.fatal("Fatal socket error received, closing transport"), this.transportClose();
    }), p$7(this, "registerProviderListeners", () => {
      this.provider.on(L$5.payload, this.onPayloadHandler), this.provider.on(L$5.connect, this.onConnectHandler), this.provider.on(L$5.disconnect, this.onDisconnectHandler), this.provider.on(L$5.error, this.onProviderErrorHandler);
    }), this.core = e3.core, this.logger = typeof e3.logger < "u" && typeof e3.logger != "string" ? E$7(e3.logger, this.name) : gt$3(k$7({ level: e3.logger || St$7 })), this.messages = new bi$5(this.logger, e3.core), this.subscriber = new vi$5(this, this.logger), this.publisher = new xn$5(this, this.logger), this.relayUrl = (e3 == null ? void 0 : e3.relayUrl) || ze$4, this.projectId = e3.projectId, Wr$6() ? this.packageName = Jr$6() : zr$6() && (this.bundleId = Jr$6()), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = true, this.subscriber.hasAnyTopics) try {
      await this.transportOpen();
    } catch (e3) {
      this.logger.warn(e3, e3 == null ? void 0 : e3.message);
    }
  }
  get context() {
    return y$6(this.logger);
  }
  get connected() {
    var e3, t2, s2;
    return ((s2 = (t2 = (e3 = this.provider) == null ? void 0 : e3.connection) == null ? void 0 : t2.socket) == null ? void 0 : s2.readyState) === 1 || false;
  }
  get connecting() {
    var e3, t2, s2;
    return ((s2 = (t2 = (e3 = this.provider) == null ? void 0 : e3.connection) == null ? void 0 : t2.socket) == null ? void 0 : s2.readyState) === 0 || this.connectPromise !== void 0 || this.connectionAttemptInProgress === true || false;
  }
  async publish(e3, t2, s2) {
    this.isInitialized(), await this.publisher.publish(e3, t2, s2), await this.recordMessageEvent({ topic: e3, message: t2, publishedAt: Date.now(), transportType: Q$2.relay });
  }
  async subscribe(e3, t2) {
    var s2, i4, r3;
    this.isInitialized(), (!(t2 != null && t2.transportType) || (t2 == null ? void 0 : t2.transportType) === "relay") && await this.toEstablishConnection();
    const o3 = typeof ((s2 = t2 == null ? void 0 : t2.internal) == null ? void 0 : s2.throwOnFailedPublish) > "u" ? true : (i4 = t2 == null ? void 0 : t2.internal) == null ? void 0 : i4.throwOnFailedPublish;
    let a2 = ((r3 = this.subscriber.topicMap.get(e3)) == null ? void 0 : r3[0]) || "", c2;
    const h5 = (u2) => {
      u2.topic === e3 && (this.subscriber.off($$7.created, h5), c2());
    };
    return await Promise.all([new Promise((u2) => {
      c2 = u2, this.subscriber.on($$7.created, h5);
    }), new Promise(async (u2, g2) => {
      a2 = await this.subscriber.subscribe(e3, Ei$5({ internal: { throwOnFailedPublish: o3 } }, t2)).catch((D2) => {
        o3 && g2(D2);
      }) || a2, u2();
    })]), a2;
  }
  async unsubscribe(e3, t2) {
    this.isInitialized(), await this.subscriber.unsubscribe(e3, t2);
  }
  on(e3, t2) {
    this.events.on(e3, t2);
  }
  once(e3, t2) {
    this.events.once(e3, t2);
  }
  off(e3, t2) {
    this.events.off(e3, t2);
  }
  removeListener(e3, t2) {
    this.events.removeListener(e3, t2);
  }
  async transportDisconnect() {
    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await ao$6(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, await this.transportDisconnect();
  }
  async transportOpen(e3) {
    if (!this.subscriber.hasAnyTopics) {
      this.logger.warn("Starting WS connection skipped because the client has no topics to work with.");
      return;
    }
    if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."), await this.connectPromise, this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise(async (t2, s2) => {
      await this.connect(e3).then(t2).catch(s2).finally(() => {
        this.connectPromise = void 0;
      });
    }), await this.connectPromise), !this.connected) throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);
  }
  async restartTransport(e3) {
    this.logger.debug({}, "Restarting transport..."), !this.connectionAttemptInProgress && (this.relayUrl = e3 || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await Yi$4()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e3) {
    if ((e3 == null ? void 0 : e3.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const t2 = e3.sort((s2, i4) => s2.publishedAt - i4.publishedAt);
    this.logger.debug(`Batch of ${t2.length} message events sorted`);
    for (const s2 of t2) try {
      await this.onMessageEvent(s2);
    } catch (i4) {
      this.logger.warn(i4, "Error while processing batch message event: " + (i4 == null ? void 0 : i4.message));
    }
    this.logger.trace(`Batch of ${t2.length} message events processed`);
  }
  async onLinkMessageEvent(e3, t2) {
    const { topic: s2 } = e3;
    if (!t2.sessionExists) {
      const i4 = ho$4(cjs$3.FIVE_MINUTES), r3 = { topic: s2, expiry: i4, relay: { protocol: "irn" }, active: false };
      await this.core.pairing.pairings.set(s2, r3);
    }
    this.events.emit(T$5.message, e3), await this.recordMessageEvent(e3);
  }
  async connect(e3) {
    await this.confirmOnlineStateOrThrow(), e3 && e3 !== this.relayUrl && (this.relayUrl = e3, await this.transportDisconnect()), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
    let t2 = 1;
    for (; t2 < 6; ) {
      try {
        if (this.transportExplicitlyClosed) break;
        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t2}...`), await this.createProvider(), await new Promise(async (s2, i4) => {
          const r3 = () => {
            i4(new Error("Connection interrupted while trying to subscribe"));
          };
          this.provider.once(L$5.disconnect, r3), await ao$6(new Promise((o3, a2) => {
            this.provider.connect().then(o3).catch(a2);
          }), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch((o3) => {
            i4(o3);
          }).finally(() => {
            this.provider.off(L$5.disconnect, r3), clearTimeout(this.reconnectTimeout);
          }), await new Promise(async (o3, a2) => {
            const c2 = () => {
              a2(new Error("Connection interrupted while trying to subscribe"));
            };
            this.provider.once(L$5.disconnect, c2), await this.subscriber.start().then(o3).catch(a2).finally(() => {
              this.provider.off(L$5.disconnect, c2);
            });
          }), this.hasExperiencedNetworkDisruption = false, s2();
        });
      } catch (s2) {
        await this.subscriber.stop();
        const i4 = s2;
        this.logger.warn({}, i4.message), this.hasExperiencedNetworkDisruption = true;
      } finally {
        this.connectionAttemptInProgress = false;
      }
      if (this.connected) {
        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t2}`);
        break;
      }
      await new Promise((s2) => setTimeout(s2, cjs$3.toMiliseconds(t2 * 1))), t2++;
    }
  }
  startPingTimeout() {
    var e3, t2, s2, i4, r3;
    if (et$4()) try {
      (t2 = (e3 = this.provider) == null ? void 0 : e3.connection) != null && t2.socket && ((r3 = (i4 = (s2 = this.provider) == null ? void 0 : s2.connection) == null ? void 0 : i4.socket) == null || r3.on("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (o3) {
      this.logger.warn(o3, o3 == null ? void 0 : o3.message);
    }
  }
  async createProvider() {
    try {
      this.provider.connection && this.unregisterProviderListeners();
      const e3 = await this.core.crypto.signJWT(this.relayUrl), t2 = Zr$6({ sdkVersion: De$5, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e3, useOnCloseEvent: true, bundleId: this.bundleId, packageName: this.packageName });
      console.log("[Relayer] WS connect URL:", t2);
      const s2 = new f$7(t2);
      this.provider = new o$9(s2), this.registerProviderListeners();
    } catch (e3) {
      throw this.logger.error(`error on ws connection: ${e3 == null ? void 0 : e3.message}`), e3;
    }
  }
  async recordMessageEvent(e3) {
    const { topic: t2, message: s2 } = e3;
    await this.messages.set(t2, s2);
  }
  async shouldIgnoreMessageEvent(e3) {
    const { topic: t2, message: s2 } = e3;
    if (!s2 || s2.length === 0) return this.logger.warn(`Ignoring invalid/empty message: ${s2}`), true;
    if (!await this.subscriber.isSubscribed(t2)) return this.logger.warn(`Ignoring message for non-subscribed topic ${t2}`), true;
    const i4 = this.messages.has(t2, s2);
    return i4 && this.logger.warn(`Ignoring duplicate message: ${s2}`), i4;
  }
  async onProviderPayload(e3) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e3 }), isJsonRpcRequest(e3)) {
      if (!e3.method.endsWith(xt$5)) return;
      const t2 = e3.params, { topic: s2, message: i4, publishedAt: r3, attestation: o3 } = t2.data, a2 = { topic: s2, message: i4, publishedAt: r3, transportType: Q$2.relay, attestation: o3 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Ei$5({ type: "event", event: t2.id }, a2)), this.events.emit(t2.id, a2), await this.acknowledgePayload(e3), await this.onMessageEvent(a2);
    } else isJsonRpcResponse(e3) && this.events.emit(T$5.message_ack, e3);
  }
  async onMessageEvent(e3) {
    await this.shouldIgnoreMessageEvent(e3) || (this.events.emit(T$5.message, e3), await this.recordMessageEvent(e3));
  }
  async acknowledgePayload(e3) {
    const t2 = formatJsonRpcResult(e3.id, true);
    await this.provider.connection.send(t2);
  }
  unregisterProviderListeners() {
    this.provider.off(L$5.payload, this.onPayloadHandler), this.provider.off(L$5.connect, this.onConnectHandler), this.provider.off(L$5.disconnect, this.onDisconnectHandler), this.provider.off(L$5.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e3 = await Yi$4();
    Xi$4(async (t2) => {
      if (e3 !== t2) if (e3 = t2, !t2) this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false, clearTimeout(this.reconnectTimeout), this.reconnectTimeout = void 0, this.reconnectInProgress = false;
      else {
        if (this.connecting || this.reconnectInProgress || this.connectPromise) return;
        await this.transportOpen().catch((s2) => this.logger.error(s2, s2 == null ? void 0 : s2.message));
      }
    });
  }
  async onProviderDisconnect() {
    if (clearTimeout(this.pingTimeout), this.events.emit(T$5.disconnect), this.connectionAttemptInProgress = false, !this.reconnectInProgress && (this.reconnectInProgress = true, await this.subscriber.stop(), !!this.subscriber.hasAnyTopics && !this.transportExplicitlyClosed)) {
      try {
        if (!await Yi$4()) {
          clearTimeout(this.reconnectTimeout), this.reconnectTimeout = void 0, this.reconnectInProgress = false;
          return;
        }
      } catch {
      }
      this.reconnectTimeout = setTimeout(async () => {
        await this.transportOpen().catch((e3) => this.logger.error(e3, e3 == null ? void 0 : e3.message)), this.reconnectTimeout = void 0, this.reconnectInProgress = false;
      }, cjs$3.toMiliseconds(Ot$4));
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e3 } = te$4("NOT_INITIALIZED", this.name);
      throw new Error(e3);
    }
  }
  async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow(), !this.connected && (this.connecting || this.reconnectInProgress || this.connectPromise || await this.transportOpen());
  }
};
var Bn$5 = Object.defineProperty, Ii$5 = Object.getOwnPropertySymbols, Vn$5 = Object.prototype.hasOwnProperty, jn$5 = Object.prototype.propertyIsEnumerable, qe$5 = (n5, e3, t2) => e3 in n5 ? Bn$5(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, Ti$5 = (n5, e3) => {
  for (var t2 in e3 || (e3 = {})) Vn$5.call(e3, t2) && qe$5(n5, t2, e3[t2]);
  if (Ii$5) for (var t2 of Ii$5(e3)) jn$5.call(e3, t2) && qe$5(n5, t2, e3[t2]);
  return n5;
}, z$8 = (n5, e3, t2) => qe$5(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let Ci$5 = class Ci2 extends f$9 {
  constructor(e3, t2, s2, i4 = B$5, r3 = void 0) {
    super(e3, t2, s2, i4), this.core = e3, this.logger = t2, this.name = s2, z$8(this, "map", /* @__PURE__ */ new Map()), z$8(this, "version", At$5), z$8(this, "cached", []), z$8(this, "initialized", false), z$8(this, "getKey"), z$8(this, "storagePrefix", B$5), z$8(this, "recentlyDeleted", []), z$8(this, "recentlyDeletedLimit", 200), z$8(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o3) => {
        this.getKey && o3 !== null && !ae$6(o3) ? this.map.set(this.getKey(o3), o3) : Pi$6(o3) ? this.map.set(o3.id, o3) : Li$6(o3) && this.map.set(o3.topic, o3);
      }), this.cached = [], this.initialized = true);
    }), z$8(this, "set", async (o3, a2) => {
      this.isInitialized(), this.map.has(o3) ? await this.update(o3, a2) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o3, value: a2 }), this.map.set(o3, a2), await this.persist());
    }), z$8(this, "get", (o3) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o3 }), this.getData(o3))), z$8(this, "getAll", (o3) => (this.isInitialized(), o3 ? this.values.filter((a2) => Object.keys(o3).every((c2) => Ls$6(a2[c2], o3[c2]))) : this.values)), z$8(this, "update", async (o3, a2) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o3, update: a2 });
      const c2 = Ti$5(Ti$5({}, this.getData(o3)), a2);
      this.map.set(o3, c2), await this.persist();
    }), z$8(this, "delete", async (o3, a2) => {
      this.isInitialized(), this.map.has(o3) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o3, reason: a2 }), this.map.delete(o3), this.addToRecentlyDeleted(o3), await this.persist());
    }), this.logger = E$7(t2, this.name), this.storagePrefix = i4, this.getKey = r3;
  }
  get context() {
    return y$6(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e3) {
    this.recentlyDeleted.push(e3), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e3) {
    await this.core.storage.setItem(this.storageKey, e3);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e3) {
    const t2 = this.map.get(e3);
    if (!t2) {
      if (this.recentlyDeleted.includes(e3)) {
        const { message: i4 } = te$4("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e3}`);
        throw this.logger.error(i4), new Error(i4);
      }
      const { message: s2 } = te$4("NO_MATCHING_KEY", `${this.name}: ${e3}`);
      throw this.logger.error(s2), new Error(s2);
    }
    return t2;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e3 = await this.getDataStore();
      if (typeof e3 > "u" || !e3.length) return;
      if (this.map.size) {
        const { message: t2 } = te$4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t2), new Error(t2);
      }
      this.cached = e3, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e3) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e3);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e3 } = te$4("NOT_INITIALIZED", this.name);
      throw new Error(e3);
    }
  }
};
var qn$5 = Object.defineProperty, Gn$5 = (n5, e3, t2) => e3 in n5 ? qn$5(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, d$4 = (n5, e3, t2) => Gn$5(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let Pi$5 = class Pi2 {
  constructor(e3, t2) {
    this.core = e3, this.logger = t2, d$4(this, "name", kt$4), d$4(this, "version", Ut$5), d$4(this, "events", new wt$7()), d$4(this, "pairings"), d$4(this, "initialized", false), d$4(this, "storagePrefix", B$5), d$4(this, "ignoredPayloadTypes", [Ie$4]), d$4(this, "registeredMethods", []), d$4(this, "init", async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }), d$4(this, "register", ({ methods: s2 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...s2])];
    }), d$4(this, "create", async (s2) => {
      this.isInitialized();
      const i4 = ni$6(), r3 = await this.core.crypto.setSymKey(i4), o3 = ho$4(cjs$3.FIVE_MINUTES), a2 = { protocol: Pt$2 }, c2 = { topic: r3, expiry: o3, relay: a2, active: false, methods: s2 == null ? void 0 : s2.methods }, h5 = wi$6({ protocol: this.core.protocol, version: this.core.version, topic: r3, symKey: i4, relay: a2, expiryTimestamp: o3, methods: s2 == null ? void 0 : s2.methods });
      return this.events.emit(se$5.create, c2), this.core.expirer.set(r3, o3), await this.pairings.set(r3, c2), await this.core.relayer.subscribe(r3, { transportType: s2 == null ? void 0 : s2.transportType }), { topic: r3, uri: h5 };
    }), d$4(this, "pair", async (s2) => {
      this.isInitialized();
      const i4 = this.core.eventClient.createEvent({ properties: { topic: s2 == null ? void 0 : s2.uri, trace: [q$4.pairing_started] } });
      this.isValidPair(s2, i4);
      const { topic: r3, symKey: o3, relay: a2, expiryTimestamp: c2, methods: h5 } = bi$6(s2.uri);
      i4.props.properties.topic = r3, i4.addTrace(q$4.pairing_uri_validation_success), i4.addTrace(q$4.pairing_uri_not_expired);
      let u2;
      if (this.pairings.keys.includes(r3)) {
        if (u2 = this.pairings.get(r3), i4.addTrace(q$4.existing_pairing), u2.active) throw i4.setError(J$5.active_pairing_already_exists), new Error(`Pairing already exists: ${r3}. Please try again with a new connection URI.`);
        i4.addTrace(q$4.pairing_not_expired);
      }
      const g2 = c2 || ho$4(cjs$3.FIVE_MINUTES), D2 = { topic: r3, relay: a2, expiry: g2, active: false, methods: h5 };
      this.core.expirer.set(r3, g2), await this.pairings.set(r3, D2), i4.addTrace(q$4.store_new_pairing), s2.activatePairing && await this.activate({ topic: r3 }), this.events.emit(se$5.create, D2), i4.addTrace(q$4.emit_inactive_pairing), this.core.crypto.keychain.has(r3) || await this.core.crypto.setSymKey(o3, r3), i4.addTrace(q$4.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        i4.setError(J$5.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(r3, { relay: a2 });
      } catch (A2) {
        throw i4.setError(J$5.subscribe_pairing_topic_failure), A2;
      }
      return i4.addTrace(q$4.subscribe_pairing_topic_success), D2;
    }), d$4(this, "activate", async ({ topic: s2 }) => {
      this.isInitialized();
      const i4 = ho$4(cjs$3.FIVE_MINUTES);
      this.core.expirer.set(s2, i4), await this.pairings.update(s2, { active: true, expiry: i4 });
    }), d$4(this, "ping", async (s2) => {
      this.isInitialized(), await this.isValidPing(s2), this.logger.warn("ping() is deprecated and will be removed in the next major release.");
      const { topic: i4 } = s2;
      if (this.pairings.keys.includes(i4)) {
        const r3 = await this.sendRequest(i4, "wc_pairingPing", {}), { done: o3, resolve: a2, reject: c2 } = co$4();
        this.events.once(go$4("pairing_ping", r3), ({ error: h5 }) => {
          h5 ? c2(h5) : a2();
        }), await o3();
      }
    }), d$4(this, "updateExpiry", async ({ topic: s2, expiry: i4 }) => {
      this.isInitialized(), await this.pairings.update(s2, { expiry: i4 });
    }), d$4(this, "updateMetadata", async ({ topic: s2, metadata: i4 }) => {
      this.isInitialized(), await this.pairings.update(s2, { peerMetadata: i4 });
    }), d$4(this, "getPairings", () => (this.isInitialized(), this.pairings.values)), d$4(this, "disconnect", async (s2) => {
      this.isInitialized(), await this.isValidDisconnect(s2);
      const { topic: i4 } = s2;
      this.pairings.keys.includes(i4) && (await this.sendRequest(i4, "wc_pairingDelete", de$5("USER_DISCONNECTED")), await this.deletePairing(i4));
    }), d$4(this, "formatUriFromPairing", (s2) => {
      this.isInitialized();
      const { topic: i4, relay: r3, expiry: o3, methods: a2 } = s2, c2 = this.core.crypto.keychain.get(i4);
      return wi$6({ protocol: this.core.protocol, version: this.core.version, topic: i4, symKey: c2, relay: r3, expiryTimestamp: o3, methods: a2 });
    }), d$4(this, "sendRequest", async (s2, i4, r3) => {
      const o3 = formatJsonRpcRequest(i4, r3), a2 = await this.core.crypto.encode(s2, o3), c2 = ie$5[i4].req;
      return this.core.history.set(s2, o3), this.core.relayer.publish(s2, a2, c2), o3.id;
    }), d$4(this, "sendResult", async (s2, i4, r3) => {
      const o3 = formatJsonRpcResult(s2, r3), a2 = await this.core.crypto.encode(i4, o3), c2 = (await this.core.history.get(i4, s2)).request.method, h5 = ie$5[c2].res;
      await this.core.relayer.publish(i4, a2, h5), await this.core.history.resolve(o3);
    }), d$4(this, "sendError", async (s2, i4, r3) => {
      const o3 = formatJsonRpcError(s2, r3), a2 = await this.core.crypto.encode(i4, o3), c2 = (await this.core.history.get(i4, s2)).request.method, h5 = ie$5[c2] ? ie$5[c2].res : ie$5.unregistered_method.res;
      await this.core.relayer.publish(i4, a2, h5), await this.core.history.resolve(o3);
    }), d$4(this, "deletePairing", async (s2, i4) => {
      await this.core.relayer.unsubscribe(s2), await Promise.all([this.pairings.delete(s2, de$5("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(s2), i4 ? Promise.resolve() : this.core.expirer.del(s2)]);
    }), d$4(this, "cleanup", async () => {
      const s2 = this.pairings.getAll().filter((i4) => po$4(i4.expiry));
      await Promise.all(s2.map((i4) => this.deletePairing(i4.topic)));
    }), d$4(this, "onRelayEventRequest", (s2) => {
      const { topic: i4, payload: r3 } = s2;
      switch (r3.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(i4, r3);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(i4, r3);
        default:
          return this.onUnknownRpcMethodRequest(i4, r3);
      }
    }), d$4(this, "onRelayEventResponse", async (s2) => {
      const { topic: i4, payload: r3 } = s2, o3 = (await this.core.history.get(i4, r3.id)).request.method;
      switch (o3) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(i4, r3);
        default:
          return this.onUnknownRpcMethodResponse(o3);
      }
    }), d$4(this, "onPairingPingRequest", async (s2, i4) => {
      const { id: r3 } = i4;
      try {
        this.isValidPing({ topic: s2 }), await this.sendResult(r3, s2, true), this.events.emit(se$5.ping, { id: r3, topic: s2 });
      } catch (o3) {
        await this.sendError(r3, s2, o3), this.logger.error(o3);
      }
    }), d$4(this, "onPairingPingResponse", (s2, i4) => {
      const { id: r3 } = i4;
      setTimeout(() => {
        isJsonRpcResult(i4) ? this.events.emit(go$4("pairing_ping", r3), {}) : isJsonRpcError(i4) && this.events.emit(go$4("pairing_ping", r3), { error: i4.error });
      }, 500);
    }), d$4(this, "onPairingDeleteRequest", async (s2, i4) => {
      const { id: r3 } = i4;
      try {
        this.isValidDisconnect({ topic: s2 }), await this.deletePairing(s2), this.events.emit(se$5.delete, { id: r3, topic: s2 });
      } catch (o3) {
        await this.sendError(r3, s2, o3), this.logger.error(o3);
      }
    }), d$4(this, "onUnknownRpcMethodRequest", async (s2, i4) => {
      const { id: r3, method: o3 } = i4;
      try {
        if (this.registeredMethods.includes(o3)) return;
        const a2 = de$5("WC_METHOD_UNSUPPORTED", o3);
        await this.sendError(r3, s2, a2), this.logger.error(a2);
      } catch (a2) {
        await this.sendError(r3, s2, a2), this.logger.error(a2);
      }
    }), d$4(this, "onUnknownRpcMethodResponse", (s2) => {
      this.registeredMethods.includes(s2) || this.logger.error(de$5("WC_METHOD_UNSUPPORTED", s2));
    }), d$4(this, "isValidPair", (s2, i4) => {
      var r3;
      if (!Di$6(s2)) {
        const { message: a2 } = te$4("MISSING_OR_INVALID", `pair() params: ${s2}`);
        throw i4.setError(J$5.malformed_pairing_uri), new Error(a2);
      }
      if (!Ri$6(s2.uri)) {
        const { message: a2 } = te$4("MISSING_OR_INVALID", `pair() uri: ${s2.uri}`);
        throw i4.setError(J$5.malformed_pairing_uri), new Error(a2);
      }
      const o3 = bi$6(s2 == null ? void 0 : s2.uri);
      if (!((r3 = o3 == null ? void 0 : o3.relay) != null && r3.protocol)) {
        const { message: a2 } = te$4("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw i4.setError(J$5.malformed_pairing_uri), new Error(a2);
      }
      if (!(o3 != null && o3.symKey)) {
        const { message: a2 } = te$4("MISSING_OR_INVALID", "pair() uri#symKey");
        throw i4.setError(J$5.malformed_pairing_uri), new Error(a2);
      }
      if (o3 != null && o3.expiryTimestamp && cjs$3.toMiliseconds(o3 == null ? void 0 : o3.expiryTimestamp) < Date.now()) {
        i4.setError(J$5.pairing_expired);
        const { message: a2 } = te$4("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a2);
      }
    }), d$4(this, "isValidPing", async (s2) => {
      if (!Di$6(s2)) {
        const { message: r3 } = te$4("MISSING_OR_INVALID", `ping() params: ${s2}`);
        throw new Error(r3);
      }
      const { topic: i4 } = s2;
      await this.isValidPairingTopic(i4);
    }), d$4(this, "isValidDisconnect", async (s2) => {
      if (!Di$6(s2)) {
        const { message: r3 } = te$4("MISSING_OR_INVALID", `disconnect() params: ${s2}`);
        throw new Error(r3);
      }
      const { topic: i4 } = s2;
      await this.isValidPairingTopic(i4);
    }), d$4(this, "isValidPairingTopic", async (s2) => {
      if (!q$5(s2, false)) {
        const { message: i4 } = te$4("MISSING_OR_INVALID", `pairing topic should be a string: ${s2}`);
        throw new Error(i4);
      }
      if (!this.pairings.keys.includes(s2)) {
        const { message: i4 } = te$4("NO_MATCHING_KEY", `pairing topic doesn't exist: ${s2}`);
        throw new Error(i4);
      }
      if (po$4(this.pairings.get(s2).expiry)) {
        await this.deletePairing(s2);
        const { message: i4 } = te$4("EXPIRED", `pairing topic: ${s2}`);
        throw new Error(i4);
      }
    }), this.core = e3, this.logger = E$7(t2, this.name), this.pairings = new Ci$5(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y$6(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e3 } = te$4("NOT_INITIALIZED", this.name);
      throw new Error(e3);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(T$5.message, async (e3) => {
      const { topic: t2, message: s2, transportType: i4 } = e3;
      if (!this.pairings.keys.includes(t2) || i4 === Q$2.link_mode || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s2))) return;
      const r3 = await this.core.crypto.decode(t2, s2);
      try {
        isJsonRpcRequest(r3) ? (this.core.history.set(t2, r3), this.onRelayEventRequest({ topic: t2, payload: r3 })) : isJsonRpcResponse(r3) && (await this.core.history.resolve(r3), await this.onRelayEventResponse({ topic: t2, payload: r3 }), this.core.history.delete(t2, r3.id));
      } catch (o3) {
        this.logger.error(o3);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(M$6.expired, async (e3) => {
      const { topic: t2 } = lo$4(e3.target);
      t2 && this.pairings.keys.includes(t2) && (await this.deletePairing(t2, true), this.events.emit(se$5.expire, { topic: t2 }));
    });
  }
};
var Hn$5 = Object.defineProperty, Yn$5 = (n5, e3, t2) => e3 in n5 ? Hn$5(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, S$5 = (n5, e3, t2) => Yn$5(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let Si$5 = class Si2 extends I$4 {
  constructor(e3, t2) {
    super(e3, t2), this.core = e3, this.logger = t2, S$5(this, "records", /* @__PURE__ */ new Map()), S$5(this, "events", new eventsExports.EventEmitter()), S$5(this, "name", Ft$5), S$5(this, "version", Mt$5), S$5(this, "cached", []), S$5(this, "initialized", false), S$5(this, "storagePrefix", B$5), S$5(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s2) => this.records.set(s2.id, s2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), S$5(this, "set", (s2, i4, r3) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: s2, request: i4, chainId: r3 }), this.records.has(i4.id)) return;
      const o3 = { id: i4.id, topic: s2, request: { method: i4.method, params: i4.params || null }, chainId: r3, expiry: ho$4(cjs$3.THIRTY_DAYS) };
      this.records.set(o3.id, o3), this.persist(), this.events.emit(F$5.created, o3);
    }), S$5(this, "resolve", async (s2) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: s2 }), !this.records.has(s2.id)) return;
      const i4 = await this.getRecord(s2.id);
      typeof i4.response > "u" && (i4.response = isJsonRpcError(s2) ? { error: s2.error } : { result: s2.result }, this.records.set(i4.id, i4), this.persist(), this.events.emit(F$5.updated, i4));
    }), S$5(this, "get", async (s2, i4) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: s2, id: i4 }), await this.getRecord(i4))), S$5(this, "delete", (s2, i4) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: i4 }), this.values.forEach((r3) => {
        if (r3.topic === s2) {
          if (typeof i4 < "u" && r3.id !== i4) return;
          this.records.delete(r3.id), this.events.emit(F$5.deleted, r3);
        }
      }), this.persist();
    }), S$5(this, "exists", async (s2, i4) => (this.isInitialized(), this.records.has(i4) ? (await this.getRecord(i4)).topic === s2 : false)), S$5(this, "on", (s2, i4) => {
      this.events.on(s2, i4);
    }), S$5(this, "once", (s2, i4) => {
      this.events.once(s2, i4);
    }), S$5(this, "off", (s2, i4) => {
      this.events.off(s2, i4);
    }), S$5(this, "removeListener", (s2, i4) => {
      this.events.removeListener(s2, i4);
    }), this.logger = E$7(t2, this.name);
  }
  get context() {
    return y$6(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e3 = [];
    return this.values.forEach((t2) => {
      if (typeof t2.response < "u") return;
      const s2 = { topic: t2.topic, request: formatJsonRpcRequest(t2.request.method, t2.request.params, t2.id), chainId: t2.chainId };
      return e3.push(s2);
    }), e3;
  }
  async setJsonRpcRecords(e3) {
    await this.core.storage.setItem(this.storageKey, e3);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e3) {
    this.isInitialized();
    const t2 = this.records.get(e3);
    if (!t2) {
      const { message: s2 } = te$4("NO_MATCHING_KEY", `${this.name}: ${e3}`);
      throw new Error(s2);
    }
    return t2;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(F$5.sync);
  }
  async restore() {
    try {
      const e3 = await this.getJsonRpcRecords();
      if (typeof e3 > "u" || !e3.length) return;
      if (this.records.size) {
        const { message: t2 } = te$4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t2), new Error(t2);
      }
      this.cached = e3, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e3) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e3);
    }
  }
  registerEventListeners() {
    this.events.on(F$5.created, (e3) => {
      const t2 = F$5.created;
      this.logger.info(`Emitting ${t2}`), this.logger.debug({ type: "event", event: t2, record: e3 });
    }), this.events.on(F$5.updated, (e3) => {
      const t2 = F$5.updated;
      this.logger.info(`Emitting ${t2}`), this.logger.debug({ type: "event", event: t2, record: e3 });
    }), this.events.on(F$5.deleted, (e3) => {
      const t2 = F$5.deleted;
      this.logger.info(`Emitting ${t2}`), this.logger.debug({ type: "event", event: t2, record: e3 });
    }), this.core.heartbeat.on(r$8.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e3 = false;
      this.records.forEach((t2) => {
        cjs$3.toMiliseconds(t2.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t2.id}`), this.records.delete(t2.id), this.events.emit(F$5.deleted, t2, false), e3 = true);
      }), e3 && this.persist();
    } catch (e3) {
      this.logger.warn(e3);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e3 } = te$4("NOT_INITIALIZED", this.name);
      throw new Error(e3);
    }
  }
};
var Jn$5 = Object.defineProperty, Xn$5 = (n5, e3, t2) => e3 in n5 ? Jn$5(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, x$5 = (n5, e3, t2) => Xn$5(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let Ri$5 = class Ri2 extends S$6 {
  constructor(e3, t2) {
    super(e3, t2), this.core = e3, this.logger = t2, x$5(this, "expirations", /* @__PURE__ */ new Map()), x$5(this, "events", new eventsExports.EventEmitter()), x$5(this, "name", Kt$5), x$5(this, "version", Bt$5), x$5(this, "cached", []), x$5(this, "initialized", false), x$5(this, "storagePrefix", B$5), x$5(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s2) => this.expirations.set(s2.target, s2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), x$5(this, "has", (s2) => {
      try {
        const i4 = this.formatTarget(s2);
        return typeof this.getExpiration(i4) < "u";
      } catch {
        return false;
      }
    }), x$5(this, "set", (s2, i4) => {
      this.isInitialized();
      const r3 = this.formatTarget(s2), o3 = { target: r3, expiry: i4 };
      this.expirations.set(r3, o3), this.checkExpiry(r3, o3), this.events.emit(M$6.created, { target: r3, expiration: o3 });
    }), x$5(this, "get", (s2) => {
      this.isInitialized();
      const i4 = this.formatTarget(s2);
      return this.getExpiration(i4);
    }), x$5(this, "del", (s2) => {
      if (this.isInitialized(), this.has(s2)) {
        const i4 = this.formatTarget(s2), r3 = this.getExpiration(i4);
        this.expirations.delete(i4), this.events.emit(M$6.deleted, { target: i4, expiration: r3 });
      }
    }), x$5(this, "on", (s2, i4) => {
      this.events.on(s2, i4);
    }), x$5(this, "once", (s2, i4) => {
      this.events.once(s2, i4);
    }), x$5(this, "off", (s2, i4) => {
      this.events.off(s2, i4);
    }), x$5(this, "removeListener", (s2, i4) => {
      this.events.removeListener(s2, i4);
    }), this.logger = E$7(t2, this.name);
  }
  get context() {
    return y$6(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e3) {
    if (typeof e3 == "string") return uo$4(e3);
    if (typeof e3 == "number") return fo$4(e3);
    const { message: t2 } = te$4("UNKNOWN_TYPE", `Target type: ${typeof e3}`);
    throw new Error(t2);
  }
  async setExpirations(e3) {
    await this.core.storage.setItem(this.storageKey, e3);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(M$6.sync);
  }
  async restore() {
    try {
      const e3 = await this.getExpirations();
      if (typeof e3 > "u" || !e3.length) return;
      if (this.expirations.size) {
        const { message: t2 } = te$4("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t2), new Error(t2);
      }
      this.cached = e3, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e3) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e3);
    }
  }
  getExpiration(e3) {
    const t2 = this.expirations.get(e3);
    if (!t2) {
      const { message: s2 } = te$4("NO_MATCHING_KEY", `${this.name}: ${e3}`);
      throw this.logger.warn(s2), new Error(s2);
    }
    return t2;
  }
  checkExpiry(e3, t2) {
    const { expiry: s2 } = t2;
    cjs$3.toMiliseconds(s2) - Date.now() <= 0 && this.expire(e3, t2);
  }
  expire(e3, t2) {
    this.expirations.delete(e3), this.events.emit(M$6.expired, { target: e3, expiration: t2 });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e3, t2) => this.checkExpiry(t2, e3));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r$8.pulse, () => this.checkExpirations()), this.events.on(M$6.created, (e3) => {
      const t2 = M$6.created;
      this.logger.info(`Emitting ${t2}`), this.logger.debug({ type: "event", event: t2, data: e3 }), this.persist();
    }), this.events.on(M$6.expired, (e3) => {
      const t2 = M$6.expired;
      this.logger.info(`Emitting ${t2}`), this.logger.debug({ type: "event", event: t2, data: e3 }), this.persist();
    }), this.events.on(M$6.deleted, (e3) => {
      const t2 = M$6.deleted;
      this.logger.info(`Emitting ${t2}`), this.logger.debug({ type: "event", event: t2, data: e3 }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e3 } = te$4("NOT_INITIALIZED", this.name);
      throw new Error(e3);
    }
  }
};
var Wn$5 = Object.defineProperty, Zn$5 = (n5, e3, t2) => e3 in n5 ? Wn$5(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, _$7 = (n5, e3, t2) => Zn$5(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let xi$5 = class xi2 extends M$9 {
  constructor(e3, t2, s2) {
    super(e3, t2, s2), this.core = e3, this.logger = t2, this.store = s2, _$7(this, "name", Vt$5), _$7(this, "abortController"), _$7(this, "isDevEnv"), _$7(this, "verifyUrlV3", qt$5), _$7(this, "storagePrefix", B$5), _$7(this, "version", Ae$5), _$7(this, "publicKey"), _$7(this, "fetchPromise"), _$7(this, "init", async () => {
      var i4;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && cjs$3.toMiliseconds((i4 = this.publicKey) == null ? void 0 : i4.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }), _$7(this, "register", async (i4) => {
      if (!Ae$6() || this.isDevEnv) return;
      const r3 = window.location.origin, { id: o3, decryptedId: a2 } = i4, c2 = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${r3}&id=${o3}&decryptedId=${a2}`;
      try {
        const h5 = getDocument_1(), u2 = this.startAbortTimer(cjs$3.ONE_SECOND * 5), g2 = await new Promise((D2, A2) => {
          const l2 = () => {
            window.removeEventListener("message", O4), h5.body.removeChild(y4), A2("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", l2);
          const y4 = h5.createElement("iframe");
          y4.src = c2, y4.style.display = "none", y4.addEventListener("error", l2, { signal: this.abortController.signal });
          const O4 = (w2) => {
            if (w2.data && typeof w2.data == "string") try {
              const f6 = JSON.parse(w2.data);
              if (f6.type === "verify_attestation") {
                if (sn$7(f6.attestation).payload.id !== o3) return;
                clearInterval(u2), h5.body.removeChild(y4), this.abortController.signal.removeEventListener("abort", l2), window.removeEventListener("message", O4), D2(f6.attestation === null ? "" : f6.attestation);
              }
            } catch (f6) {
              this.logger.warn(f6);
            }
          };
          h5.body.appendChild(y4), window.addEventListener("message", O4, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", g2), g2;
      } catch (h5) {
        this.logger.warn(h5);
      }
      return "";
    }), _$7(this, "resolve", async (i4) => {
      if (this.isDevEnv) return "";
      const { attestationId: r3, hash: o3, encryptedId: a2 } = i4;
      if (r3 === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (r3) {
        if (sn$7(r3).payload.id !== a2) return;
        const h5 = await this.isValidJwtAttestation(r3);
        if (h5) {
          if (!h5.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return h5;
        }
      }
      if (!o3) return;
      const c2 = this.getVerifyUrl(i4 == null ? void 0 : i4.verifyUrl);
      return this.fetchAttestation(o3, c2);
    }), _$7(this, "fetchAttestation", async (i4, r3) => {
      this.logger.debug(`resolving attestation: ${i4} from url: ${r3}`);
      const o3 = this.startAbortTimer(cjs$3.ONE_SECOND * 5), a2 = await fetch(`${r3}/attestation/${i4}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(o3), a2.status === 200 ? await a2.json() : void 0;
    }), _$7(this, "getVerifyUrl", (i4) => {
      let r3 = i4 || re$5;
      return Gt$5.includes(r3) || (this.logger.info(`verify url: ${r3}, not included in trusted list, assigning default: ${re$5}`), r3 = re$5), r3;
    }), _$7(this, "fetchPublicKey", async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const i4 = this.startAbortTimer(cjs$3.FIVE_SECONDS), r3 = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(i4), await r3.json();
      } catch (i4) {
        this.logger.warn(i4);
      }
    }), _$7(this, "persistPublicKey", async (i4) => {
      this.logger.debug("persisting public key to local storage", i4), await this.store.setItem(this.storeKey, i4), this.publicKey = i4;
    }), _$7(this, "removePublicKey", async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }), _$7(this, "isValidJwtAttestation", async (i4) => {
      const r3 = await this.getPublicKey();
      try {
        if (r3) return this.validateAttestation(i4, r3);
      } catch (a2) {
        this.logger.error(a2), this.logger.warn("error validating attestation");
      }
      const o3 = await this.fetchAndPersistPublicKey();
      try {
        if (o3) return this.validateAttestation(i4, o3);
      } catch (a2) {
        this.logger.error(a2), this.logger.warn("error validating attestation");
      }
    }), _$7(this, "getPublicKey", async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()), _$7(this, "fetchAndPersistPublicKey", async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (r3) => {
        const o3 = await this.fetchPublicKey();
        o3 && (await this.persistPublicKey(o3), r3(o3));
      });
      const i4 = await this.fetchPromise;
      return this.fetchPromise = void 0, i4;
    }), _$7(this, "validateAttestation", (i4, r3) => {
      const o3 = gi$6(i4, r3.publicKey), a2 = { hasExpired: cjs$3.toMiliseconds(o3.exp) < Date.now(), payload: o3 };
      if (a2.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a2.payload.origin, isScam: a2.payload.isScam, isVerified: a2.payload.isVerified };
    }), this.logger = E$7(t2, this.name), this.abortController = new AbortController(), this.isDevEnv = Eo$4(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y$6(this.logger);
  }
  startAbortTimer(e3) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), cjs$3.toMiliseconds(e3));
  }
};
var Qn$5 = Object.defineProperty, eo$5 = (n5, e3, t2) => e3 in n5 ? Qn$5(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, Oi$5 = (n5, e3, t2) => eo$5(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let Ai$5 = class Ai2 extends O$4 {
  constructor(e3, t2) {
    super(e3, t2), this.projectId = e3, this.logger = t2, Oi$5(this, "context", Ht$5), Oi$5(this, "registerDeviceToken", async (s2) => {
      const { clientId: i4, token: r3, notificationType: o3, enableEncrypted: a2 = false } = s2, c2 = `${Yt$5}/${this.projectId}/clients`;
      await fetch(c2, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: i4, type: o3, token: r3, always_raw: a2 }) });
    }), this.logger = E$7(t2, this.context);
  }
};
var to$5 = Object.defineProperty, Ni$5 = Object.getOwnPropertySymbols, io$5 = Object.prototype.hasOwnProperty, so$5 = Object.prototype.propertyIsEnumerable, Ge$5 = (n5, e3, t2) => e3 in n5 ? to$5(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, pe$3 = (n5, e3) => {
  for (var t2 in e3 || (e3 = {})) io$5.call(e3, t2) && Ge$5(n5, t2, e3[t2]);
  if (Ni$5) for (var t2 of Ni$5(e3)) so$5.call(e3, t2) && Ge$5(n5, t2, e3[t2]);
  return n5;
}, E$5 = (n5, e3, t2) => Ge$5(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let $i$5 = class $i2 extends R$5 {
  constructor(e3, t2, s2 = true) {
    super(e3, t2, s2), this.core = e3, this.logger = t2, E$5(this, "context", Xt$5), E$5(this, "storagePrefix", B$5), E$5(this, "storageVersion", Jt$5), E$5(this, "events", /* @__PURE__ */ new Map()), E$5(this, "shouldPersist", false), E$5(this, "init", async () => {
      if (!Eo$4()) try {
        const i4 = { eventId: wo$4(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: Yt$6(this.core.relayer.protocol, this.core.relayer.version, De$5) } } };
        await this.sendEvent([i4]);
      } catch (i4) {
        this.logger.warn(i4);
      }
    }), E$5(this, "createEvent", (i4) => {
      const { event: r3 = "ERROR", type: o3 = "", properties: { topic: a2, trace: c2 } } = i4, h5 = wo$4(), u2 = this.core.projectId || "", g2 = Date.now(), D2 = pe$3({ eventId: h5, timestamp: g2, props: { event: r3, type: o3, properties: { topic: a2, trace: c2 } }, bundleId: u2, domain: this.getAppDomain() }, this.setMethods(h5));
      return this.telemetryEnabled && (this.events.set(h5, D2), this.shouldPersist = true), D2;
    }), E$5(this, "getEvent", (i4) => {
      const { eventId: r3, topic: o3 } = i4;
      if (r3) return this.events.get(r3);
      const a2 = Array.from(this.events.values()).find((c2) => c2.props.properties.topic === o3);
      if (a2) return pe$3(pe$3({}, a2), this.setMethods(a2.eventId));
    }), E$5(this, "deleteEvent", (i4) => {
      const { eventId: r3 } = i4;
      this.events.delete(r3), this.shouldPersist = true;
    }), E$5(this, "setEventListeners", () => {
      this.core.heartbeat.on(r$8.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((i4) => {
          cjs$3.fromMiliseconds(Date.now()) - cjs$3.fromMiliseconds(i4.timestamp) > Wt$5 && (this.events.delete(i4.eventId), this.shouldPersist = true);
        });
      });
    }), E$5(this, "setMethods", (i4) => ({ addTrace: (r3) => this.addTrace(i4, r3), setError: (r3) => this.setError(i4, r3) })), E$5(this, "addTrace", (i4, r3) => {
      const o3 = this.events.get(i4);
      o3 && (o3.props.properties.trace.push(r3), this.events.set(i4, o3), this.shouldPersist = true);
    }), E$5(this, "setError", (i4, r3) => {
      const o3 = this.events.get(i4);
      o3 && (o3.props.type = r3, o3.timestamp = Date.now(), this.events.set(i4, o3), this.shouldPersist = true);
    }), E$5(this, "persist", async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = false;
    }), E$5(this, "restore", async () => {
      try {
        const i4 = await this.core.storage.getItem(this.storageKey) || [];
        if (!i4.length) return;
        i4.forEach((r3) => {
          this.events.set(r3.eventId, pe$3(pe$3({}, r3), this.setMethods(r3.eventId)));
        });
      } catch (i4) {
        this.logger.warn(i4);
      }
    }), E$5(this, "submit", async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const i4 = [];
      for (const [r3, o3] of this.events) o3.props.type && i4.push(o3);
      if (i4.length !== 0) try {
        if ((await this.sendEvent(i4)).ok) for (const r3 of i4) this.events.delete(r3.eventId), this.shouldPersist = true;
      } catch (r3) {
        this.logger.warn(r3);
      }
    }), E$5(this, "sendEvent", async (i4) => {
      const r3 = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${Zt$5}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${De$5}${r3}`, { method: "POST", body: JSON.stringify(i4) });
    }), E$5(this, "getAppDomain", () => Yr$6().url), this.logger = E$7(t2, this.context), this.telemetryEnabled = s2, s2 ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
};
var ro$5 = Object.defineProperty, zi$5 = Object.getOwnPropertySymbols, no$5 = Object.prototype.hasOwnProperty, oo$5 = Object.prototype.propertyIsEnumerable, He$5 = (n5, e3, t2) => e3 in n5 ? ro$5(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, Li$5 = (n5, e3) => {
  for (var t2 in e3 || (e3 = {})) no$5.call(e3, t2) && He$5(n5, t2, e3[t2]);
  if (zi$5) for (var t2 of zi$5(e3)) oo$5.call(e3, t2) && He$5(n5, t2, e3[t2]);
  return n5;
}, v$5 = (n5, e3, t2) => He$5(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let _e$7 = class _e2 extends h$7 {
  constructor(e3) {
    var t2;
    super(e3), v$5(this, "protocol", Oe$5), v$5(this, "version", Ae$5), v$5(this, "name", le$4), v$5(this, "relayUrl"), v$5(this, "projectId"), v$5(this, "customStoragePrefix"), v$5(this, "events", new eventsExports.EventEmitter()), v$5(this, "logger"), v$5(this, "heartbeat"), v$5(this, "relayer"), v$5(this, "crypto"), v$5(this, "storage"), v$5(this, "history"), v$5(this, "expirer"), v$5(this, "pairing"), v$5(this, "verify"), v$5(this, "echoClient"), v$5(this, "linkModeSupportedApps"), v$5(this, "eventClient"), v$5(this, "initialized", false), v$5(this, "logChunkController"), v$5(this, "on", (o3, a2) => this.events.on(o3, a2)), v$5(this, "once", (o3, a2) => this.events.once(o3, a2)), v$5(this, "off", (o3, a2) => this.events.off(o3, a2)), v$5(this, "removeListener", (o3, a2) => this.events.removeListener(o3, a2)), v$5(this, "dispatchEnvelope", ({ topic: o3, message: a2, sessionExists: c2 }) => {
      if (!o3 || !a2) return;
      const h5 = { topic: o3, message: a2, publishedAt: Date.now(), transportType: Q$2.link_mode };
      this.relayer.onLinkMessageEvent(h5, { sessionExists: c2 });
    }), this.projectId = e3 == null ? void 0 : e3.projectId, this.relayUrl = (e3 == null ? void 0 : e3.relayUrl) || ze$4, this.customStoragePrefix = e3 != null && e3.customStoragePrefix ? `:${e3.customStoragePrefix}` : "";
    const s2 = k$7({ level: typeof (e3 == null ? void 0 : e3.logger) == "string" && e3.logger ? e3.logger : Dt$5.logger, name: le$4 }), { logger: i4, chunkLoggerController: r3 } = A$4({ opts: s2, maxSizeInBytes: e3 == null ? void 0 : e3.maxLogBlobSizeInBytes, loggerOverride: e3 == null ? void 0 : e3.logger });
    this.logChunkController = r3, (t2 = this.logChunkController) != null && t2.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var o3, a2;
      (o3 = this.logChunkController) != null && o3.downloadLogsBlobInBrowser && ((a2 = this.logChunkController) == null || a2.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E$7(i4, this.name), this.heartbeat = new i$6(), this.crypto = new mi$5(this, this.logger, e3 == null ? void 0 : e3.keychain), this.history = new Si$5(this, this.logger), this.expirer = new Ri$5(this, this.logger), this.storage = e3 != null && e3.storage ? e3.storage : new h$8(Li$5(Li$5({}, ft$4), e3 == null ? void 0 : e3.storageOptions)), this.relayer = new wi$5({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Pi$5(this, this.logger), this.verify = new xi$5(this, this.logger, this.storage), this.echoClient = new Ai$5(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new $i$5(this, this.logger, e3 == null ? void 0 : e3.telemetryEnabled);
  }
  static async init(e3) {
    const t2 = new _e2(e3);
    await t2.initialize();
    const s2 = await t2.crypto.getClientId();
    return await t2.storage.setItem(Nt$5, s2), t2;
  }
  get context() {
    return y$6(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e3;
    return (e3 = this.logChunkController) == null ? void 0 : e3.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e3) {
    this.linkModeSupportedApps.includes(e3) || (this.linkModeSupportedApps.push(e3), await this.storage.setItem(Le$7, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.linkModeSupportedApps = await this.storage.getItem(Le$7) || [], this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e3) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e3), this.logger.error(e3.message), e3;
    }
  }
};
const ao$5 = _e$7;
const xe$5 = "wc", Le$6 = 2, ke$6 = "client", we$5 = `${xe$5}@${Le$6}:${ke$6}:`, _e$6 = { name: ke$6, logger: "error" }, Me$6 = "WALLETCONNECT_DEEPLINK_CHOICE", pt$4 = "proposal", $e$5 = "Proposal expired", ht$4 = "session", z$7 = cjs$3.SEVEN_DAYS, dt$4 = "engine", N$4 = { wc_sessionPropose: { req: { ttl: cjs$3.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: cjs$3.FIVE_MINUTES, prompt: false, tag: 1101 }, reject: { ttl: cjs$3.FIVE_MINUTES, prompt: false, tag: 1120 }, autoReject: { ttl: cjs$3.FIVE_MINUTES, prompt: false, tag: 1121 } }, wc_sessionSettle: { req: { ttl: cjs$3.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: cjs$3.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: cjs$3.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: cjs$3.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: cjs$3.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: cjs$3.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: cjs$3.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: cjs$3.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: cjs$3.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: cjs$3.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: cjs$3.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: cjs$3.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: cjs$3.ONE_DAY, prompt: false, tag: 1114 }, res: { ttl: cjs$3.ONE_DAY, prompt: false, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: cjs$3.ONE_HOUR, prompt: true, tag: 1116 }, res: { ttl: cjs$3.ONE_HOUR, prompt: false, tag: 1117 }, reject: { ttl: cjs$3.FIVE_MINUTES, prompt: false, tag: 1118 }, autoReject: { ttl: cjs$3.FIVE_MINUTES, prompt: false, tag: 1119 } } }, Se$5 = { min: cjs$3.FIVE_MINUTES, max: cjs$3.SEVEN_DAYS }, $$6 = { idle: "IDLE", active: "ACTIVE" }, Fe$6 = { eth_sendTransaction: { key: "" }, eth_sendRawTransaction: { key: "" }, wallet_sendCalls: { key: "" }, solana_signTransaction: { key: "signature" }, solana_signAllTransactions: { key: "transactions" }, solana_signAndSendTransaction: { key: "signature" } }, ut$5 = "request", yt$2 = "wc", mt$2 = "auth", wt$3 = "authKeys", _t$5 = "pairingTopics", St$6 = "requests", ae$5 = `${yt$2}@${1.5}:${mt$2}:`, ce$4 = `${ae$5}:PUB_KEY`;
var fs$5 = Object.defineProperty, vs$5 = Object.defineProperties, Is$5 = Object.getOwnPropertyDescriptors, Et$6 = Object.getOwnPropertySymbols, Rs$5 = Object.prototype.hasOwnProperty, Ts$5 = Object.prototype.propertyIsEnumerable, Ue$6 = (E2, r3, e3) => r3 in E2 ? fs$5(E2, r3, { enumerable: true, configurable: true, writable: true, value: e3 }) : E2[r3] = e3, R$4 = (E2, r3) => {
  for (var e3 in r3 || (r3 = {})) Rs$5.call(r3, e3) && Ue$6(E2, e3, r3[e3]);
  if (Et$6) for (var e3 of Et$6(r3)) Ts$5.call(r3, e3) && Ue$6(E2, e3, r3[e3]);
  return E2;
}, V$7 = (E2, r3) => vs$5(E2, Is$5(r3)), c$6 = (E2, r3, e3) => Ue$6(E2, typeof r3 != "symbol" ? r3 + "" : r3, e3);
let qs$6 = class qs2 extends V$a {
  constructor(r3) {
    super(r3), c$6(this, "name", dt$4), c$6(this, "events", new wt$7()), c$6(this, "initialized", false), c$6(this, "requestQueue", { state: $$6.idle, queue: [] }), c$6(this, "sessionRequestQueue", { state: $$6.idle, queue: [] }), c$6(this, "requestQueueDelay", cjs$3.ONE_SECOND), c$6(this, "expectedPairingMethodMap", /* @__PURE__ */ new Map()), c$6(this, "recentlyDeletedMap", /* @__PURE__ */ new Map()), c$6(this, "recentlyDeletedLimit", 200), c$6(this, "relayMessageCache", []), c$6(this, "pendingSessions", /* @__PURE__ */ new Map()), c$6(this, "lastSessionCheckTime"), c$6(this, "isCheckingSession", false), c$6(this, "sessionCreationTimes", /* @__PURE__ */ new Map()), c$6(this, "firstDAppEntryAfterSession", /* @__PURE__ */ new Map()), c$6(this, "init", async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(N$4) }), this.initializeMobileSessionDetection(), this.initialized = true, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, cjs$3.toMiliseconds(this.requestQueueDelay)));
    }), c$6(this, "connect", async (e3) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const t2 = V$7(R$4({}, e3), { requiredNamespaces: e3.requiredNamespaces || {}, optionalNamespaces: e3.optionalNamespaces || {} });
      await this.isValidConnect(t2);
      const { pairingTopic: s2, requiredNamespaces: i4, optionalNamespaces: n5, sessionProperties: o3, relays: a2 } = t2;
      let l2 = s2, h5, g2 = false;
      try {
        if (l2) {
          const f6 = this.client.core.pairing.pairings.get(l2);
          this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."), g2 = f6.active;
        }
      } catch (f6) {
        throw this.client.logger.error(`connect() -> pairing.get(${l2}) failed`), f6;
      }
      if (!l2 || !g2) {
        const { topic: f6, uri: x2 } = await this.client.core.pairing.create();
        l2 = f6, h5 = x2;
      }
      if (!l2) {
        const { message: f6 } = te$4("NO_MATCHING_KEY", `connect() pairing topic: ${l2}`);
        throw new Error(f6);
      }
      const d4 = await this.client.core.crypto.generateKeyPair(), u2 = N$4.wc_sessionPropose.req.ttl || cjs$3.FIVE_MINUTES, y4 = ho$4(u2), w2 = V$7(R$4({ requiredNamespaces: i4, optionalNamespaces: n5, relays: a2 ?? [{ protocol: Pt$2 }], proposer: { publicKey: d4, metadata: this.client.metadata }, expiryTimestamp: y4, pairingTopic: l2 }, o3 && { sessionProperties: o3 }), { id: payloadId() }), I4 = go$4("session_connect", w2.id), { reject: p2, resolve: S4, done: D2 } = co$4(u2, $e$5), T2 = ({ id: f6 }) => {
        f6 === w2.id && (this.client.events.off("proposal_expire", T2), this.pendingSessions.delete(w2.id), this.events.emit(I4, { error: { message: $e$5, code: 0 } }));
      };
      return this.client.events.on("proposal_expire", T2), this.events.once(I4, ({ error: f6, session: x2 }) => {
        this.client.events.off("proposal_expire", T2), f6 ? p2(f6) : x2 && S4(x2);
      }), await this.sendRequest({ topic: l2, method: "wc_sessionPropose", params: w2, throwOnFailedPublish: true, clientRpcId: w2.id }), await this.setProposal(w2.id, w2), { uri: h5, approval: D2 };
    }), c$6(this, "pair", async (e3) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(e3);
      } catch (t2) {
        throw this.client.logger.error("pair() failed"), t2;
      }
    }), c$6(this, "approve", async (e3) => {
      var t2, s2, i4;
      const n5 = this.client.core.eventClient.createEvent({ properties: { topic: (t2 = e3 == null ? void 0 : e3.id) == null ? void 0 : t2.toString(), trace: [js$5.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (P3) {
        throw n5.setError(qs$7.no_internet_connection), P3;
      }
      try {
        await this.isValidProposalId(e3 == null ? void 0 : e3.id);
      } catch (P3) {
        throw this.client.logger.error(`approve() -> proposal.get(${e3 == null ? void 0 : e3.id}) failed`), n5.setError(qs$7.proposal_not_found), P3;
      }
      try {
        await this.isValidApprove(e3);
      } catch (P3) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), n5.setError(qs$7.session_approve_namespace_validation_failure), P3;
      }
      const { id: o3, relayProtocol: a2, namespaces: l2, sessionProperties: h5, sessionConfig: g2 } = e3, d4 = this.client.proposal.get(o3);
      this.client.core.eventClient.deleteEvent({ eventId: n5.eventId });
      const { pairingTopic: u2, proposer: y4, requiredNamespaces: w2, optionalNamespaces: I4 } = d4;
      let p2 = (s2 = this.client.core.eventClient) == null ? void 0 : s2.getEvent({ topic: u2 });
      p2 || (p2 = (i4 = this.client.core.eventClient) == null ? void 0 : i4.createEvent({ type: js$5.session_approve_started, properties: { topic: u2, trace: [js$5.session_approve_started, js$5.session_namespaces_validation_success] } }));
      const S4 = await this.client.core.crypto.generateKeyPair(), D2 = y4.publicKey, T2 = await this.client.core.crypto.generateSharedKey(S4, D2), f6 = R$4(R$4({ relay: { protocol: a2 ?? "irn" }, namespaces: l2, controller: { publicKey: S4, metadata: this.client.metadata }, expiry: ho$4(z$7) }, h5 && { sessionProperties: h5 }), g2 && { sessionConfig: g2 }), x2 = Q$2.relay;
      p2.addTrace(js$5.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(T2, { transportType: x2 });
      } catch (P3) {
        throw p2.setError(qs$7.subscribe_session_topic_failure), P3;
      }
      p2.addTrace(js$5.subscribe_session_topic_success);
      const Z3 = V$7(R$4({}, f6), { topic: T2, requiredNamespaces: w2, optionalNamespaces: I4, pairingTopic: u2, acknowledged: false, self: f6.controller, peer: { publicKey: y4.publicKey, metadata: y4.metadata }, controller: S4, transportType: Q$2.relay });
      await this.client.session.set(T2, Z3), p2.addTrace(js$5.store_session);
      try {
        p2.addTrace(js$5.publishing_session_settle), await this.sendRequest({ topic: T2, method: "wc_sessionSettle", params: f6, throwOnFailedPublish: true }).catch((P3) => {
          throw p2 == null ? void 0 : p2.setError(qs$7.session_settle_publish_failure), P3;
        }), p2.addTrace(js$5.session_settle_publish_success), p2.addTrace(js$5.publishing_session_approve), await this.sendResult({ id: o3, topic: u2, result: { relay: { protocol: a2 ?? "irn" }, responderPublicKey: S4 }, throwOnFailedPublish: true }).catch((P3) => {
          throw p2 == null ? void 0 : p2.setError(qs$7.session_approve_publish_failure), P3;
        }), p2.addTrace(js$5.session_approve_publish_success);
      } catch (P3) {
        throw this.client.logger.error(P3), this.client.session.delete(T2, de$5("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(T2), P3;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: p2.eventId }), await this.client.core.pairing.updateMetadata({ topic: u2, metadata: y4.metadata }), await this.client.proposal.delete(o3, de$5("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: u2 }), await this.setExpiry(T2, ho$4(z$7)), { topic: T2, acknowledged: () => Promise.resolve(this.client.session.get(T2)) };
    }), c$6(this, "reject", async (e3) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(e3);
      } catch (n5) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), n5;
      }
      const { id: t2, reason: s2 } = e3;
      let i4;
      try {
        i4 = this.client.proposal.get(t2).pairingTopic;
      } catch (n5) {
        throw this.client.logger.error(`reject() -> proposal.get(${t2}) failed`), n5;
      }
      i4 && (await this.sendError({ id: t2, topic: i4, error: s2, rpcOpts: N$4.wc_sessionPropose.reject }), await this.client.proposal.delete(t2, de$5("USER_DISCONNECTED")));
    }), c$6(this, "update", async (e3) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(e3);
      } catch (g2) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), g2;
      }
      const { topic: t2, namespaces: s2 } = e3, { done: i4, resolve: n5, reject: o3 } = co$4(), a2 = payloadId(), l2 = getBigIntRpcId().toString(), h5 = this.client.session.get(t2).namespaces;
      return this.events.once(go$4("session_update", a2), ({ error: g2 }) => {
        g2 ? o3(g2) : n5();
      }), await this.client.session.update(t2, { namespaces: s2 }), await this.sendRequest({ topic: t2, method: "wc_sessionUpdate", params: { namespaces: s2 }, throwOnFailedPublish: true, clientRpcId: a2, relayRpcId: l2 }).catch((g2) => {
        this.client.logger.error(g2), this.client.session.update(t2, { namespaces: h5 }), o3(g2);
      }), { acknowledged: i4 };
    }), c$6(this, "extend", async (e3) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(e3);
      } catch (a2) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), a2;
      }
      const { topic: t2 } = e3, s2 = payloadId(), { done: i4, resolve: n5, reject: o3 } = co$4();
      return this.events.once(go$4("session_extend", s2), ({ error: a2 }) => {
        a2 ? o3(a2) : n5();
      }), await this.setExpiry(t2, ho$4(z$7)), this.sendRequest({ topic: t2, method: "wc_sessionExtend", params: {}, clientRpcId: s2, throwOnFailedPublish: true }).catch((a2) => {
        o3(a2);
      }), { acknowledged: i4 };
    }), c$6(this, "request", async (e3) => {
      this.isInitialized();
      try {
        await this.isValidRequest(e3);
      } catch (p2) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), p2;
      }
      const { chainId: t2, request: s2, topic: i4, expiry: n5 = N$4.wc_sessionRequest.req.ttl } = e3, o3 = this.client.session.get(i4);
      (o3 == null ? void 0 : o3.transportType) === Q$2.relay && await this.confirmOnlineStateOrThrow();
      const a2 = payloadId(), l2 = getBigIntRpcId().toString(), { done: h5, resolve: g2, reject: d4 } = co$4(n5, "Request expired. Please try again.");
      this.events.once(go$4("session_request", a2), ({ error: p2, result: S4 }) => {
        p2 ? d4(p2) : g2(S4);
      });
      const u2 = "wc_sessionRequest", y4 = this.getAppLinkIfEnabled(o3.peer.metadata, o3.transportType);
      if (y4) return await this.sendRequest({ clientRpcId: a2, relayRpcId: l2, topic: i4, method: u2, params: { request: V$7(R$4({}, s2), { expiryTimestamp: ho$4(n5) }), chainId: t2 }, expiry: n5, throwOnFailedPublish: true, appLink: y4 }).catch((p2) => d4(p2)), this.client.events.emit("session_request_sent", { topic: i4, request: s2, chainId: t2, id: a2 }), await h5();
      const w2 = { request: V$7(R$4({}, s2), { expiryTimestamp: ho$4(n5) }), chainId: t2 }, I4 = this.shouldSetTVF(u2, w2);
      return await Promise.all([new Promise(async (p2) => {
        await this.sendRequest(R$4({ clientRpcId: a2, relayRpcId: l2, topic: i4, method: u2, params: w2, expiry: n5, throwOnFailedPublish: true }, I4 && { tvf: this.getTVFParams(a2, w2) })).catch((S4) => d4(S4)), this.client.events.emit("session_request_sent", { topic: i4, request: s2, chainId: t2, id: a2 }), p2();
      }), new Promise(async (p2) => {
        var S4;
        if (!((S4 = o3.sessionConfig) != null && S4.disableDeepLink)) {
          const D2 = await mo$4(this.client.core.storage, Me$6);
          await yo$4({ id: a2, topic: i4, wcDeepLink: D2 });
        }
        p2();
      }), h5()]).then((p2) => p2[2]);
    }), c$6(this, "respond", async (e3) => {
      this.isInitialized(), await this.isValidRespond(e3);
      const { topic: t2, response: s2 } = e3, { id: i4 } = s2, n5 = this.client.session.get(t2);
      n5.transportType === Q$2.relay && await this.confirmOnlineStateOrThrow();
      const o3 = this.getAppLinkIfEnabled(n5.peer.metadata, n5.transportType);
      isJsonRpcResult(s2) ? await this.sendResult({ id: i4, topic: t2, result: s2.result, throwOnFailedPublish: true, appLink: o3 }) : isJsonRpcError(s2) && await this.sendError({ id: i4, topic: t2, error: s2.error, appLink: o3 }), this.cleanupAfterResponse(e3);
    }), c$6(this, "ping", async (e3) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(e3);
      } catch (s2) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), s2;
      }
      const { topic: t2 } = e3;
      if (this.client.session.keys.includes(t2)) {
        const s2 = payloadId(), i4 = getBigIntRpcId().toString(), { done: n5, resolve: o3, reject: a2 } = co$4();
        this.events.once(go$4("session_ping", s2), ({ error: l2 }) => {
          l2 ? a2(l2) : o3();
        }), await Promise.all([this.sendRequest({ topic: t2, method: "wc_sessionPing", params: {}, throwOnFailedPublish: true, clientRpcId: s2, relayRpcId: i4 }), n5()]);
      } else this.client.core.pairing.pairings.keys.includes(t2) && (this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."), await this.client.core.pairing.ping({ topic: t2 }));
    }), c$6(this, "emit", async (e3) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(e3);
      const { topic: t2, event: s2, chainId: i4 } = e3, n5 = getBigIntRpcId().toString(), o3 = payloadId();
      await this.sendRequest({ topic: t2, method: "wc_sessionEvent", params: { event: s2, chainId: i4 }, throwOnFailedPublish: true, relayRpcId: n5, clientRpcId: o3 });
    }), c$6(this, "disconnect", async (e3) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(e3);
      const { topic: t2 } = e3;
      if (this.client.session.keys.includes(t2)) await this.sendRequest({ topic: t2, method: "wc_sessionDelete", params: de$5("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession({ topic: t2, emitEvent: false });
      else if (this.client.core.pairing.pairings.keys.includes(t2)) await this.client.core.pairing.disconnect({ topic: t2 });
      else {
        const { message: s2 } = te$4("MISMATCHED_TOPIC", `Session or pairing topic not found: ${t2}`);
        throw new Error(s2);
      }
    }), c$6(this, "find", (e3) => (this.isInitialized(), this.client.session.getAll().filter((t2) => $i$6(t2, e3)))), c$6(this, "getPendingSessionRequests", () => this.client.pendingRequest.getAll()), c$6(this, "authenticate", async (e3, t2) => {
      var s2;
      this.isInitialized(), this.isValidAuthenticate(e3);
      const i4 = t2 && this.client.core.linkModeSupportedApps.includes(t2) && ((s2 = this.client.metadata.redirect) == null ? void 0 : s2.linkMode), n5 = i4 ? Q$2.link_mode : Q$2.relay;
      n5 === Q$2.relay && await this.confirmOnlineStateOrThrow();
      const { chains: o3, statement: a2 = "", uri: l2, domain: h5, nonce: g2, type: d4, exp: u2, nbf: y4, methods: w2 = [], expiry: I4 } = e3, p2 = [...e3.resources || []], { topic: S4, uri: D2 } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: n5 });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: S4, uri: D2 } });
      const T2 = await this.client.core.crypto.generateKeyPair(), f6 = oi$6(T2);
      if (await Promise.all([this.client.auth.authKeys.set(ce$4, { responseTopic: f6, publicKey: T2 }), this.client.auth.pairingTopics.set(f6, { topic: f6, pairingTopic: S4 })]), await this.client.core.relayer.subscribe(f6, { transportType: n5 }), this.client.logger.info(`sending request to new pairing topic: ${S4}`), w2.length > 0) {
        const { namespace: A2 } = Ye$4(o3[0]);
        let L4 = ts$4(A2, "request", w2);
        Me$8(p2) && (L4 = ns$4(L4, p2.pop())), p2.push(L4);
      }
      const x2 = I4 && I4 > N$4.wc_sessionAuthenticate.req.ttl ? I4 : N$4.wc_sessionAuthenticate.req.ttl, Z3 = { authPayload: { type: d4 ?? "caip122", chains: o3, statement: a2, aud: l2, domain: h5, version: "1", nonce: g2, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: u2, nbf: y4, resources: p2 }, requester: { publicKey: T2, metadata: this.client.metadata }, expiryTimestamp: ho$4(x2) }, P3 = { eip155: { chains: o3, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...w2])], events: ["chainChanged", "accountsChanged"] } }, X2 = { requiredNamespaces: {}, optionalNamespaces: P3, relays: [{ protocol: "irn" }], pairingTopic: S4, proposer: { publicKey: T2, metadata: this.client.metadata }, expiryTimestamp: ho$4(N$4.wc_sessionPropose.req.ttl), id: payloadId() }, { done: vt2, resolve: Ge2, reject: fe2 } = co$4(x2, "Request expired"), ee2 = payloadId(), le2 = go$4("session_connect", X2.id), ve2 = go$4("session_request", ee2), pe2 = async ({ error: A2, session: L4 }) => {
        this.events.off(ve2, Ie2), A2 ? fe2(A2) : L4 && Ge2({ session: L4 });
      }, Ie2 = async (A2) => {
        var L4, je2, Qe2;
        if (await this.deletePendingAuthRequest(ee2, { message: "fulfilled", code: 0 }), A2.error) {
          const se2 = de$5("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return A2.error.code === se2.code ? void 0 : (this.events.off(le2, pe2), fe2(A2.error.message));
        }
        await this.deleteProposal(X2.id), this.events.off(le2, pe2);
        const { cacaos: Ye2, responder: Q2 } = A2.result, Te2 = [], He2 = [];
        for (const se2 of Ye2) {
          await Yo$4({ cacao: se2, projectId: this.client.core.projectId }) || (this.client.logger.error(se2, "Signature verification failed"), fe2(de$5("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: qe2 } = se2, Ne2 = Me$8(qe2.resources), ze2 = [On$6(qe2.iss)], It2 = ut$6(qe2.iss);
          if (Ne2) {
            const Pe2 = rs$4(Ne2), Rt2 = os$4(Ne2);
            Te2.push(...Pe2), ze2.push(...Rt2);
          }
          for (const Pe2 of ze2) He2.push(`${Pe2}:${It2}`);
        }
        const te2 = await this.client.core.crypto.generateSharedKey(T2, Q2.publicKey);
        let he2;
        Te2.length > 0 && (he2 = { topic: te2, acknowledged: true, self: { publicKey: T2, metadata: this.client.metadata }, peer: Q2, controller: Q2.publicKey, expiry: ho$4(z$7), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: S4, namespaces: Ti$6([...new Set(Te2)], [...new Set(He2)]), transportType: n5 }, await this.client.core.relayer.subscribe(te2, { transportType: n5 }), await this.client.session.set(te2, he2), S4 && await this.client.core.pairing.updateMetadata({ topic: S4, metadata: Q2.metadata }), he2 = this.client.session.get(te2)), (L4 = this.client.metadata.redirect) != null && L4.linkMode && (je2 = Q2.metadata.redirect) != null && je2.linkMode && (Qe2 = Q2.metadata.redirect) != null && Qe2.universal && t2 && (this.client.core.addLinkModeSupportedApp(Q2.metadata.redirect.universal), this.client.session.update(te2, { transportType: Q$2.link_mode })), Ge2({ auths: Ye2, session: he2 });
      };
      this.events.once(le2, pe2), this.events.once(ve2, Ie2);
      let Re2;
      try {
        if (i4) {
          const A2 = formatJsonRpcRequest("wc_sessionAuthenticate", Z3, ee2);
          this.client.core.history.set(S4, A2);
          const L4 = await this.client.core.crypto.encode("", A2, { type: _e$8, encoding: Qs$6 });
          Re2 = Ei$6(t2, S4, L4);
        } else await Promise.all([this.sendRequest({ topic: S4, method: "wc_sessionAuthenticate", params: Z3, expiry: e3.expiry, throwOnFailedPublish: true, clientRpcId: ee2 }), this.sendRequest({ topic: S4, method: "wc_sessionPropose", params: X2, expiry: N$4.wc_sessionPropose.req.ttl, throwOnFailedPublish: true, clientRpcId: X2.id })]);
      } catch (A2) {
        throw this.events.off(le2, pe2), this.events.off(ve2, Ie2), A2;
      }
      return await this.setProposal(X2.id, X2), await this.setAuthRequest(ee2, { request: V$7(R$4({}, Z3), { verifyContext: {} }), pairingTopic: S4, transportType: n5 }), { uri: Re2 ?? D2, response: vt2 };
    }), c$6(this, "approveSessionAuthenticate", async (e3) => {
      const { id: t2, auths: s2 } = e3, i4 = this.client.core.eventClient.createEvent({ properties: { topic: t2.toString(), trace: [Gs$5.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (I4) {
        throw i4.setError(Hs$5.no_internet_connection), I4;
      }
      const n5 = this.getPendingAuthRequest(t2);
      if (!n5) throw i4.setError(Hs$5.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${t2}`);
      const o3 = n5.transportType || Q$2.relay;
      o3 === Q$2.relay && await this.confirmOnlineStateOrThrow();
      const a2 = n5.requester.publicKey, l2 = await this.client.core.crypto.generateKeyPair(), h5 = oi$6(a2), g2 = { type: Ie$4, receiverPublicKey: a2, senderPublicKey: l2 }, d4 = [], u2 = [];
      for (const I4 of s2) {
        if (!await Yo$4({ cacao: I4, projectId: this.client.core.projectId })) {
          i4.setError(Hs$5.invalid_cacao);
          const f6 = de$5("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: t2, topic: h5, error: f6, encodeOpts: g2 }), new Error(f6.message);
        }
        i4.addTrace(Gs$5.cacaos_verified);
        const { p: p2 } = I4, S4 = Me$8(p2.resources), D2 = [On$6(p2.iss)], T2 = ut$6(p2.iss);
        if (S4) {
          const f6 = rs$4(S4), x2 = os$4(S4);
          d4.push(...f6), D2.push(...x2);
        }
        for (const f6 of D2) u2.push(`${f6}:${T2}`);
      }
      const y4 = await this.client.core.crypto.generateSharedKey(l2, a2);
      i4.addTrace(Gs$5.create_authenticated_session_topic);
      let w2;
      if ((d4 == null ? void 0 : d4.length) > 0) {
        w2 = { topic: y4, acknowledged: true, self: { publicKey: l2, metadata: this.client.metadata }, peer: { publicKey: a2, metadata: n5.requester.metadata }, controller: a2, expiry: ho$4(z$7), authentication: s2, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: n5.pairingTopic, namespaces: Ti$6([...new Set(d4)], [...new Set(u2)]), transportType: o3 }, i4.addTrace(Gs$5.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(y4, { transportType: o3 });
        } catch (I4) {
          throw i4.setError(Hs$5.subscribe_authenticated_session_topic_failure), I4;
        }
        i4.addTrace(Gs$5.subscribe_authenticated_session_topic_success), await this.client.session.set(y4, w2), i4.addTrace(Gs$5.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: n5.pairingTopic, metadata: n5.requester.metadata });
      }
      i4.addTrace(Gs$5.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: h5, id: t2, result: { cacaos: s2, responder: { publicKey: l2, metadata: this.client.metadata } }, encodeOpts: g2, throwOnFailedPublish: true, appLink: this.getAppLinkIfEnabled(n5.requester.metadata, o3) });
      } catch (I4) {
        throw i4.setError(Hs$5.authenticated_session_approve_publish_failure), I4;
      }
      return await this.client.auth.requests.delete(t2, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: n5.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: i4.eventId }), { session: w2 };
    }), c$6(this, "rejectSessionAuthenticate", async (e3) => {
      this.isInitialized();
      const { id: t2, reason: s2 } = e3, i4 = this.getPendingAuthRequest(t2);
      if (!i4) throw new Error(`Could not find pending auth request with id ${t2}`);
      i4.transportType === Q$2.relay && await this.confirmOnlineStateOrThrow();
      const n5 = i4.requester.publicKey, o3 = await this.client.core.crypto.generateKeyPair(), a2 = oi$6(n5), l2 = { type: Ie$4, receiverPublicKey: n5, senderPublicKey: o3 };
      await this.sendError({ id: t2, topic: a2, error: s2, encodeOpts: l2, rpcOpts: N$4.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(i4.requester.metadata, i4.transportType) }), await this.client.auth.requests.delete(t2, { message: "rejected", code: 0 }), await this.client.proposal.delete(t2, de$5("USER_DISCONNECTED"));
    }), c$6(this, "formatAuthMessage", (e3) => {
      this.isInitialized();
      const { request: t2, iss: s2 } = e3;
      return In$6(t2, s2);
    }), c$6(this, "processRelayMessageCache", () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
          const e3 = this.relayMessageCache.shift();
          e3 && await this.onRelayMessage(e3);
        } catch (e3) {
          this.client.logger.error(e3);
        }
      }, 50);
    }), c$6(this, "cleanupDuplicatePairings", async (e3) => {
      if (e3.pairingTopic) try {
        const t2 = this.client.core.pairing.pairings.get(e3.pairingTopic), s2 = this.client.core.pairing.pairings.getAll().filter((i4) => {
          var n5, o3;
          return ((n5 = i4.peerMetadata) == null ? void 0 : n5.url) && ((o3 = i4.peerMetadata) == null ? void 0 : o3.url) === e3.peer.metadata.url && i4.topic && i4.topic !== t2.topic;
        });
        if (s2.length === 0) return;
        this.client.logger.info(`Cleaning up ${s2.length} duplicate pairing(s)`), await Promise.all(s2.map((i4) => this.client.core.pairing.disconnect({ topic: i4.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (t2) {
        this.client.logger.error(t2);
      }
    }), c$6(this, "deleteSession", async (e3) => {
      var t2;
      const { topic: s2, expirerHasDeleted: i4 = false, emitEvent: n5 = true, id: o3 = 0 } = e3, { self: a2 } = this.client.session.get(s2);
      await this.client.core.relayer.unsubscribe(s2), await this.client.session.delete(s2, de$5("USER_DISCONNECTED")), this.cleanupSessionActivity(s2), this.addToRecentlyDeleted(s2, "session"), this.client.core.crypto.keychain.has(a2.publicKey) && await this.client.core.crypto.deleteKeyPair(a2.publicKey), this.client.core.crypto.keychain.has(s2) && await this.client.core.crypto.deleteSymKey(s2), i4 || this.client.core.expirer.del(s2), this.client.core.storage.removeItem(Me$6).catch((l2) => this.client.logger.warn(l2)), this.getPendingSessionRequests().forEach((l2) => {
        l2.topic === s2 && this.deletePendingSessionRequest(l2.id, de$5("USER_DISCONNECTED"));
      }), s2 === ((t2 = this.sessionRequestQueue.queue[0]) == null ? void 0 : t2.topic) && (this.sessionRequestQueue.state = $$6.idle), n5 && this.client.events.emit("session_delete", { id: o3, topic: s2 });
    }), c$6(this, "deleteProposal", async (e3, t2) => {
      if (t2) try {
        const s2 = this.client.proposal.get(e3), i4 = this.client.core.eventClient.getEvent({ topic: s2.pairingTopic });
        i4 == null ? void 0 : i4.setError(qs$7.proposal_expired);
      } catch {
      }
      await Promise.all([this.client.proposal.delete(e3, de$5("USER_DISCONNECTED")), t2 ? Promise.resolve() : this.client.core.expirer.del(e3)]), this.addToRecentlyDeleted(e3, "proposal");
    }), c$6(this, "deletePendingSessionRequest", async (e3, t2, s2 = false) => {
      await Promise.all([this.client.pendingRequest.delete(e3, t2), s2 ? Promise.resolve() : this.client.core.expirer.del(e3)]), this.addToRecentlyDeleted(e3, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i4) => i4.id !== e3), s2 && (this.sessionRequestQueue.state = $$6.idle, this.client.events.emit("session_request_expire", { id: e3 }));
    }), c$6(this, "deletePendingAuthRequest", async (e3, t2, s2 = false) => {
      await Promise.all([this.client.auth.requests.delete(e3, t2), s2 ? Promise.resolve() : this.client.core.expirer.del(e3)]);
    }), c$6(this, "setExpiry", async (e3, t2) => {
      this.client.session.keys.includes(e3) && (this.client.core.expirer.set(e3, t2), await this.client.session.update(e3, { expiry: t2 }));
    }), c$6(this, "setProposal", async (e3, t2) => {
      this.client.core.expirer.set(e3, ho$4(N$4.wc_sessionPropose.req.ttl)), await this.client.proposal.set(e3, t2);
    }), c$6(this, "setAuthRequest", async (e3, t2) => {
      const { request: s2, pairingTopic: i4, transportType: n5 = Q$2.relay } = t2;
      this.client.core.expirer.set(e3, s2.expiryTimestamp), await this.client.auth.requests.set(e3, { authPayload: s2.authPayload, requester: s2.requester, expiryTimestamp: s2.expiryTimestamp, id: e3, pairingTopic: i4, verifyContext: s2.verifyContext, transportType: n5 });
    }), c$6(this, "setPendingSessionRequest", async (e3) => {
      const { id: t2, topic: s2, params: i4, verifyContext: n5 } = e3, o3 = i4.request.expiryTimestamp || ho$4(N$4.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(t2, o3), await this.client.pendingRequest.set(t2, { id: t2, topic: s2, params: i4, verifyContext: n5 });
    }), c$6(this, "sendRequest", async (e3) => {
      const { topic: t2, method: s2, params: i4, expiry: n5, relayRpcId: o3, clientRpcId: a2, throwOnFailedPublish: l2, appLink: h5, tvf: g2 } = e3, d4 = formatJsonRpcRequest(s2, i4, a2);
      let u2;
      const y4 = !!h5;
      try {
        const p2 = y4 ? Qs$6 : At$6;
        u2 = await this.client.core.crypto.encode(t2, d4, { encoding: p2 });
      } catch (p2) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t2} failed`), p2;
      }
      let w2;
      const I4 = N$4[s2].req;
      if (I4.attestation = w2, n5 && (I4.ttl = n5), o3 && (I4.id = o3), this.client.core.history.set(t2, d4), y4) {
        if (t2 && h5) {
          const p2 = Ei$6(h5, t2, u2);
          await global$1.Linking.openURL(p2, this.client.name);
        }
      } else {
        const p2 = N$4[s2].req;
        n5 && (p2.ttl = n5), o3 && (p2.id = o3), p2.tvf = V$7(R$4({}, g2), { correlationId: d4.id }), l2 ? (p2.internal = V$7(R$4({}, p2.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(t2, u2, p2)) : this.client.core.relayer.publish(t2, u2, p2).catch((S4) => this.client.logger.error(S4));
      }
      return d4.id;
    }), c$6(this, "sendResult", async (e3) => {
      const { id: t2, topic: s2, result: i4, throwOnFailedPublish: n5, encodeOpts: o3, appLink: a2 } = e3, l2 = formatJsonRpcResult(t2, i4);
      let h5;
      const g2 = a2 && typeof (global$1 == null ? void 0 : global$1.Linking) < "u";
      try {
        const y4 = g2 ? Qs$6 : At$6;
        h5 = await this.client.core.crypto.encode(s2, l2, V$7(R$4({}, o3 || {}), { encoding: y4 }));
      } catch (y4) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s2} failed`), y4;
      }
      let d4, u2;
      try {
        d4 = await this.client.core.history.get(s2, t2);
        const y4 = d4.request;
        try {
          this.shouldSetTVF(y4.method, y4.params) && (u2 = this.getTVFParams(t2, y4.params, i4));
        } catch (w2) {
          this.client.logger.warn("sendResult() -> getTVFParams() failed", w2);
        }
      } catch (y4) {
        throw this.client.logger.error(`sendResult() -> history.get(${s2}, ${t2}) failed`), y4;
      }
      if (g2) {
        if (s2 && a2) {
          const y4 = Ei$6(a2, s2, h5);
          await global$1.Linking.openURL(y4, this.client.name);
        }
      } else {
        const y4 = d4.request.method, w2 = N$4[y4].res;
        w2.tvf = V$7(R$4({}, u2), { correlationId: t2 }), n5 ? (w2.internal = V$7(R$4({}, w2.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s2, h5, w2)) : this.client.core.relayer.publish(s2, h5, w2).catch((I4) => this.client.logger.error(I4));
      }
      await this.client.core.history.resolve(l2);
    }), c$6(this, "sendError", async (e3) => {
      const { id: t2, topic: s2, error: i4, encodeOpts: n5, rpcOpts: o3, appLink: a2 } = e3, l2 = formatJsonRpcError(t2, i4);
      let h5;
      const g2 = a2 && typeof (global$1 == null ? void 0 : global$1.Linking) < "u";
      try {
        const u2 = g2 ? Qs$6 : At$6;
        h5 = await this.client.core.crypto.encode(s2, l2, V$7(R$4({}, n5 || {}), { encoding: u2 }));
      } catch (u2) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s2} failed`), u2;
      }
      let d4;
      try {
        d4 = await this.client.core.history.get(s2, t2);
      } catch (u2) {
        throw this.client.logger.error(`sendError() -> history.get(${s2}, ${t2}) failed`), u2;
      }
      if (g2) {
        if (s2 && a2) {
          const u2 = Ei$6(a2, s2, h5);
          await global$1.Linking.openURL(u2, this.client.name);
        }
      } else {
        const u2 = d4.request.method, y4 = o3 || N$4[u2].res;
        this.client.core.relayer.publish(s2, h5, y4);
      }
      await this.client.core.history.resolve(l2);
    }), c$6(this, "cleanup", async () => {
      const e3 = [], t2 = [], s2 = this.client.session.getAll();
      for (const i4 of s2) {
        let n5 = false;
        po$4(i4.expiry) && (n5 = true, this.client.logger.info(`Session ${i4.topic} expired`)), this.client.core.crypto.keychain.has(i4.topic) || (n5 = true, this.client.logger.info(`Session ${i4.topic} missing crypto keys`)), n5 ? e3.push(i4.topic) : console.log(` [ENGINE] Session ${i4.topic.substring(0, 8)}... passed all validations`);
      }
      this.client.proposal.getAll().forEach((i4) => {
        po$4(i4.expiryTimestamp) && t2.push(i4.id);
      }), e3.length > 0 && (this.client.logger.info(`Cleaning up ${e3.length} invalid sessions`), await Promise.all([...e3.map((i4) => this.deleteSession({ topic: i4 })), ...t2.map((i4) => this.deleteProposal(i4))]));
    }), c$6(this, "onRelayEventRequest", async (e3) => {
      this.requestQueue.queue.push(e3), await this.processRequestsQueue();
    }), c$6(this, "processRequestsQueue", async () => {
      if (this.requestQueue.state === $$6.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = $$6.active;
        const e3 = this.requestQueue.queue.shift();
        if (e3) try {
          await this.processRequest(e3), console.log("Processing request done, now iterate");
        } catch (t2) {
          this.client.logger.warn(`Error processing request: ${t2}`);
        }
      }
      this.requestQueue.state = $$6.idle, console.log(`Processing request queue finised, state; ${this.requestQueue.state}`);
    }), c$6(this, "processRequest", async (e3) => {
      const { topic: t2, payload: s2, attestation: i4, transportType: n5, encryptedId: o3 } = e3, a2 = s2.method;
      if (!this.shouldIgnorePairingRequest({ topic: t2, requestMethod: a2 })) switch (a2) {
        case "wc_sessionPropose":
          return await this.onSessionProposeRequest({ topic: t2, payload: s2, attestation: i4, encryptedId: o3 });
        case "wc_sessionSettle":
          return await this.onSessionSettleRequest(t2, s2);
        case "wc_sessionUpdate":
          return await this.onSessionUpdateRequest(t2, s2);
        case "wc_sessionExtend":
          return await this.onSessionExtendRequest(t2, s2);
        case "wc_sessionPing":
          return await this.onSessionPingRequest(t2, s2);
        case "wc_sessionDelete":
          return await this.onSessionDeleteRequest(t2, s2);
        case "wc_sessionRequest":
          return await this.onSessionRequest({ topic: t2, payload: s2, attestation: i4, encryptedId: o3, transportType: n5 });
        case "wc_sessionEvent":
          return await this.onSessionEventRequest(t2, s2);
        case "wc_sessionAuthenticate":
          return await this.onSessionAuthenticateRequest({ topic: t2, payload: s2, attestation: i4, encryptedId: o3, transportType: n5 });
        default:
          return this.client.logger.info(`Unsupported request method ${a2}`);
      }
    }), c$6(this, "onRelayEventResponse", async (e3) => {
      const { topic: t2, payload: s2, transportType: i4 } = e3, n5 = (await this.client.core.history.get(t2, s2.id)).request.method;
      switch (n5) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(t2, s2, i4);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(t2, s2);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(t2, s2);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(t2, s2);
        case "wc_sessionPing":
          return this.onSessionPingResponse(t2, s2);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(t2, s2);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(t2, s2);
        default:
          return this.client.logger.info(`Unsupported response method ${n5}`);
      }
    }), c$6(this, "onRelayEventUnknownPayload", (e3) => {
      const { topic: t2 } = e3, { message: s2 } = te$4("MISSING_OR_INVALID", `Decoded payload on topic ${t2} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(s2);
    }), c$6(this, "shouldIgnorePairingRequest", (e3) => {
      const { topic: t2, requestMethod: s2 } = e3, i4 = this.expectedPairingMethodMap.get(t2);
      return !i4 || i4.includes(s2) ? false : !!(i4.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }), c$6(this, "onSessionProposeRequest", async (e3) => {
      const { topic: t2, payload: s2, attestation: i4, encryptedId: n5 } = e3, { params: o3, id: a2 } = s2;
      try {
        const l2 = this.client.core.eventClient.getEvent({ topic: t2 });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), l2 == null ? void 0 : l2.setError(J$5.proposal_listener_not_found)), this.isValidConnect(R$4({}, s2.params));
        const h5 = o3.expiryTimestamp || ho$4(N$4.wc_sessionPropose.req.ttl), g2 = R$4({ id: a2, pairingTopic: t2, expiryTimestamp: h5 }, o3);
        await this.setProposal(a2, g2);
        const d4 = await this.getVerifyContext({ attestationId: i4, hash: si$6(JSON.stringify(s2)), encryptedId: n5, metadata: g2.proposer.metadata });
        l2 == null ? void 0 : l2.addTrace(q$4.emit_session_proposal), this.client.events.emit("session_proposal", { id: a2, params: g2, verifyContext: d4 });
      } catch (l2) {
        await this.sendError({ id: a2, topic: t2, error: l2, rpcOpts: N$4.wc_sessionPropose.autoReject }), this.client.logger.error(l2);
      }
    }), c$6(this, "onSessionProposeResponse", async (e3, t2, s2) => {
      const { id: i4 } = t2;
      if (isJsonRpcResult(t2)) {
        const { result: n5 } = t2;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: n5 });
        const o3 = this.client.proposal.get(i4);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: o3 });
        const a2 = o3.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: a2 });
        const l2 = n5.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: l2 });
        const h5 = await this.client.core.crypto.generateSharedKey(a2, l2);
        this.pendingSessions.set(i4, { sessionTopic: h5, pairingTopic: e3, proposalId: i4, publicKey: a2 });
        const g2 = await this.client.core.relayer.subscribe(h5, { transportType: s2 });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: g2 }), await this.client.core.pairing.activate({ topic: e3 });
      } else if (isJsonRpcError(t2)) {
        await this.client.proposal.delete(i4, de$5("USER_DISCONNECTED"));
        const n5 = go$4("session_connect", i4);
        if (this.events.listenerCount(n5) === 0) throw new Error(`emitting ${n5} without any listeners, 954`);
        this.events.emit(n5, { error: t2.error });
      }
    }), c$6(this, "onSessionSettleRequest", async (e3, t2) => {
      const { id: s2, params: i4 } = t2;
      try {
        this.isValidSessionSettleRequest(i4);
        const { relay: n5, controller: o3, expiry: a2, namespaces: l2, sessionProperties: h5, sessionConfig: g2 } = t2.params, d4 = [...this.pendingSessions.values()].find((w2) => w2.sessionTopic === e3);
        if (!d4) return this.client.logger.error(`Pending session not found for topic ${e3}`);
        const u2 = this.client.proposal.get(d4.proposalId), y4 = V$7(R$4(R$4({ topic: e3, relay: n5, expiry: a2, namespaces: l2, acknowledged: true, pairingTopic: d4.pairingTopic, requiredNamespaces: u2.requiredNamespaces, optionalNamespaces: u2.optionalNamespaces, controller: o3.publicKey, self: { publicKey: d4.publicKey, metadata: this.client.metadata }, peer: { publicKey: o3.publicKey, metadata: o3.metadata } }, h5 && { sessionProperties: h5 }), g2 && { sessionConfig: g2 }), { transportType: Q$2.relay });
        await this.client.session.set(y4.topic, y4), await this.setExpiry(y4.topic, y4.expiry), await this.client.core.pairing.updateMetadata({ topic: d4.pairingTopic, metadata: y4.peer.metadata }), this.client.events.emit("session_connect", { session: y4 }), this.events.emit(go$4("session_connect", d4.proposalId), { session: y4 }), this.updateSessionActivity(y4.topic), this.pendingSessions.delete(d4.proposalId), this.deleteProposal(d4.proposalId, false), this.cleanupDuplicatePairings(y4), await this.sendResult({ id: t2.id, topic: e3, result: true, throwOnFailedPublish: true });
      } catch (n5) {
        await this.sendError({ id: s2, topic: e3, error: n5 }), this.client.logger.error(n5);
      }
    }), c$6(this, "onSessionSettleResponse", async (e3, t2) => {
      const { id: s2 } = t2;
      isJsonRpcResult(t2) ? (await this.client.session.update(e3, { acknowledged: true }), this.sessionCreationTimes.set(e3, Date.now()), this.firstDAppEntryAfterSession.set(e3, true), this.events.emit(go$4("session_approve", s2), {})) : isJsonRpcError(t2) && (await this.client.session.delete(e3, de$5("USER_DISCONNECTED")), this.events.emit(go$4("session_approve", s2), { error: t2.error }));
    }), c$6(this, "onSessionUpdateRequest", async (e3, t2) => {
      const { params: s2, id: i4 } = t2;
      try {
        const n5 = `${e3}_session_update`, o3 = Zi$4.get(n5);
        if (o3 && this.isRequestOutOfSync(o3, i4)) {
          this.client.logger.warn(`Discarding out of sync request - ${i4}`), this.sendError({ id: i4, topic: e3, error: de$5("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(R$4({ topic: e3 }, s2));
        try {
          Zi$4.set(n5, i4), await this.client.session.update(e3, { namespaces: s2.namespaces }), await this.sendResult({ id: i4, topic: e3, result: true, throwOnFailedPublish: true });
        } catch (a2) {
          throw Zi$4.delete(n5), a2;
        }
        this.client.events.emit("session_update", { id: i4, topic: e3, params: s2 });
      } catch (n5) {
        await this.sendError({ id: i4, topic: e3, error: n5 }), this.client.logger.error(n5);
      }
    }), c$6(this, "isRequestOutOfSync", (e3, t2) => t2.toString().slice(0, -3) < e3.toString().slice(0, -3)), c$6(this, "onSessionUpdateResponse", (e3, t2) => {
      const { id: s2 } = t2, i4 = go$4("session_update", s2);
      if (this.events.listenerCount(i4) === 0) throw new Error(`emitting ${i4} without any listeners`);
      isJsonRpcResult(t2) ? this.events.emit(go$4("session_update", s2), {}) : isJsonRpcError(t2) && this.events.emit(go$4("session_update", s2), { error: t2.error });
    }), c$6(this, "onSessionExtendRequest", async (e3, t2) => {
      const { id: s2 } = t2;
      try {
        this.isValidExtend({ topic: e3 }), await this.setExpiry(e3, ho$4(z$7)), await this.sendResult({ id: s2, topic: e3, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_extend", { id: s2, topic: e3 });
      } catch (i4) {
        await this.sendError({ id: s2, topic: e3, error: i4 }), this.client.logger.error(i4);
      }
    }), c$6(this, "onSessionExtendResponse", (e3, t2) => {
      const { id: s2 } = t2, i4 = go$4("session_extend", s2);
      if (this.events.listenerCount(i4) === 0) throw new Error(`emitting ${i4} without any listeners`);
      isJsonRpcResult(t2) ? this.events.emit(go$4("session_extend", s2), {}) : isJsonRpcError(t2) && this.events.emit(go$4("session_extend", s2), { error: t2.error });
    }), c$6(this, "onSessionPingRequest", async (e3, t2) => {
      const { id: s2 } = t2;
      try {
        this.isValidPing({ topic: e3 }), await this.sendResult({ id: s2, topic: e3, result: true, throwOnFailedPublish: true }), this.updateSessionActivity(e3), this.client.events.emit("session_ping", { id: s2, topic: e3 });
      } catch (i4) {
        await this.sendError({ id: s2, topic: e3, error: i4 }), this.client.logger.error(i4);
      }
    }), c$6(this, "onSessionPingResponse", (e3, t2) => {
      const { id: s2 } = t2, i4 = go$4("session_ping", s2);
      if (this.events.listenerCount(i4) === 0) throw new Error(`emitting ${i4} without any listeners`);
      setTimeout(() => {
        isJsonRpcResult(t2) ? this.events.emit(go$4("session_ping", s2), {}) : isJsonRpcError(t2) && this.events.emit(go$4("session_ping", s2), { error: t2.error });
      }, 500);
    }), c$6(this, "onSessionDeleteRequest", async (e3, t2) => {
      const { id: s2 } = t2;
      try {
        this.isValidDisconnect({ topic: e3, reason: t2.params }), await Promise.all([new Promise((i4) => {
          this.client.core.relayer.once(T$5.publish, async () => {
            await this.deleteSession({ topic: e3, id: s2, emitEvent: false }), this.sessionCreationTimes.delete(e3), this.firstDAppEntryAfterSession.delete(e3), this.events.emit("session_disconnected", { error: void 0, result: { topic: e3, reason: "wallet_disconnect", timestamp: Date.now() } }), i4(true);
          });
        }), this.sendResult({ id: s2, topic: e3, result: true, throwOnFailedPublish: true }), this.cleanupPendingSentRequestsForTopic({ topic: e3, error: de$5("USER_DISCONNECTED") })]).catch((i4) => this.client.logger.error(i4));
      } catch (i4) {
        this.client.logger.error(i4);
      }
    }), c$6(this, "onSessionRequest", async (e3) => {
      var t2, s2, i4;
      const { topic: n5, payload: o3, attestation: a2, encryptedId: l2, transportType: h5 } = e3, { id: g2, params: d4 } = o3;
      try {
        await this.isValidRequest(R$4({ topic: n5 }, d4));
        const u2 = this.client.session.get(n5), y4 = await this.getVerifyContext({ attestationId: a2, hash: si$6(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", d4, g2))), encryptedId: l2, metadata: u2.peer.metadata, transportType: h5 }), w2 = { id: g2, topic: n5, params: d4, verifyContext: y4 };
        await this.setPendingSessionRequest(w2), h5 === Q$2.link_mode && (t2 = u2.peer.metadata.redirect) != null && t2.universal && this.client.core.addLinkModeSupportedApp((s2 = u2.peer.metadata.redirect) == null ? void 0 : s2.universal), this.updateSessionActivity(n5), (i4 = this.client.signConfig) != null && i4.disableRequestQueue ? this.emitSessionRequest(w2) : (this.addSessionRequestToSessionRequestQueue(w2), this.processSessionRequestQueue());
      } catch (u2) {
        await this.sendError({ id: g2, topic: n5, error: u2 }), this.client.logger.error(u2);
      }
    }), c$6(this, "onSessionRequestResponse", (e3, t2) => {
      const { id: s2 } = t2, i4 = go$4("session_request", s2);
      if (this.events.listenerCount(i4) === 0) throw new Error(`emitting ${i4} without any listeners`);
      isJsonRpcResult(t2) ? this.events.emit(go$4("session_request", s2), { result: t2.result }) : isJsonRpcError(t2) && this.events.emit(go$4("session_request", s2), { error: t2.error });
    }), c$6(this, "onSessionEventRequest", async (e3, t2) => {
      const { id: s2, params: i4 } = t2;
      try {
        const n5 = `${e3}_session_event_${i4.event.name}`, o3 = Zi$4.get(n5);
        if (o3 && this.isRequestOutOfSync(o3, s2)) {
          this.client.logger.info(`Discarding out of sync request - ${s2}`);
          return;
        }
        this.isValidEmit(R$4({ topic: e3 }, i4)), this.client.events.emit("session_event", { id: s2, topic: e3, params: i4 }), Zi$4.set(n5, s2);
      } catch (n5) {
        await this.sendError({ id: s2, topic: e3, error: n5 }), this.client.logger.error(n5);
      }
    }), c$6(this, "onSessionAuthenticateResponse", (e3, t2) => {
      const { id: s2 } = t2;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: e3, payload: t2 }), isJsonRpcResult(t2) ? this.events.emit(go$4("session_request", s2), { result: t2.result }) : isJsonRpcError(t2) && this.events.emit(go$4("session_request", s2), { error: t2.error });
    }), c$6(this, "onSessionAuthenticateRequest", async (e3) => {
      var t2;
      const { topic: s2, payload: i4, attestation: n5, encryptedId: o3, transportType: a2 } = e3;
      try {
        const { requester: l2, authPayload: h5, expiryTimestamp: g2 } = i4.params, d4 = await this.getVerifyContext({ attestationId: n5, hash: si$6(JSON.stringify(i4)), encryptedId: o3, metadata: l2.metadata, transportType: a2 }), u2 = { requester: l2, pairingTopic: s2, id: i4.id, authPayload: h5, verifyContext: d4, expiryTimestamp: g2 };
        await this.setAuthRequest(i4.id, { request: u2, pairingTopic: s2, transportType: a2 }), a2 === Q$2.link_mode && (t2 = l2.metadata.redirect) != null && t2.universal && this.client.core.addLinkModeSupportedApp(l2.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: s2, params: i4.params, id: i4.id, verifyContext: d4 });
      } catch (l2) {
        this.client.logger.error(l2);
        const h5 = i4.params.requester.publicKey, g2 = await this.client.core.crypto.generateKeyPair(), d4 = this.getAppLinkIfEnabled(i4.params.requester.metadata, a2), u2 = { type: Ie$4, receiverPublicKey: h5, senderPublicKey: g2 };
        await this.sendError({ id: i4.id, topic: s2, error: l2, encodeOpts: u2, rpcOpts: N$4.wc_sessionAuthenticate.autoReject, appLink: d4 });
      }
    }), c$6(this, "addSessionRequestToSessionRequestQueue", (e3) => {
      this.sessionRequestQueue.queue.push(e3);
    }), c$6(this, "cleanupAfterResponse", (e3) => {
      this.deletePendingSessionRequest(e3.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = $$6.idle, this.processSessionRequestQueue();
      }, cjs$3.toMiliseconds(this.requestQueueDelay));
    }), c$6(this, "cleanupPendingSentRequestsForTopic", ({ topic: e3, error: t2 }) => {
      const s2 = this.client.core.history.pending;
      s2.length > 0 && s2.filter((i4) => i4.topic === e3 && i4.request.method === "wc_sessionRequest").forEach((i4) => {
        const n5 = i4.request.id, o3 = go$4("session_request", n5);
        if (this.events.listenerCount(o3) === 0) throw new Error(`emitting ${o3} without any listeners`);
        this.events.emit(go$4("session_request", i4.request.id), { error: t2 });
      });
    }), c$6(this, "processSessionRequestQueue", () => {
      if (this.sessionRequestQueue.state === $$6.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const e3 = this.sessionRequestQueue.queue[0];
      if (!e3) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = $$6.active, this.emitSessionRequest(e3);
      } catch (t2) {
        this.client.logger.error(t2);
      }
    }), c$6(this, "emitSessionRequest", (e3) => {
      this.client.events.emit("session_request", e3);
    }), c$6(this, "onPairingCreated", (e3) => {
      if (e3.methods && this.expectedPairingMethodMap.set(e3.topic, e3.methods), e3.active) return;
      const t2 = this.client.proposal.getAll().find((s2) => s2.pairingTopic === e3.topic);
      t2 && this.onSessionProposeRequest({ topic: e3.topic, payload: formatJsonRpcRequest("wc_sessionPropose", { requiredNamespaces: t2.requiredNamespaces, optionalNamespaces: t2.optionalNamespaces, relays: t2.relays, proposer: t2.proposer, sessionProperties: t2.sessionProperties }, t2.id) });
    }), c$6(this, "isValidConnect", async (e3) => {
      if (!Di$6(e3)) {
        const { message: a2 } = te$4("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e3)}`);
        throw new Error(a2);
      }
      const { pairingTopic: t2, requiredNamespaces: s2, optionalNamespaces: i4, sessionProperties: n5, relays: o3 } = e3;
      if (ae$6(t2) || await this.isValidPairingTopic(t2), !Ci$6(o3, true)) {
        const { message: a2 } = te$4("MISSING_OR_INVALID", `connect() relays: ${o3}`);
        throw new Error(a2);
      }
      !ae$6(s2) && qe$6(s2) !== 0 && this.validateNamespaces(s2, "requiredNamespaces"), !ae$6(i4) && qe$6(i4) !== 0 && this.validateNamespaces(i4, "optionalNamespaces"), ae$6(n5) || this.validateSessionProps(n5, "sessionProperties");
    }), c$6(this, "validateNamespaces", (e3, t2) => {
      const s2 = ji$4(e3, "connect()", t2);
      if (s2) throw new Error(s2.message);
    }), c$6(this, "isValidApprove", async (e3) => {
      if (!Di$6(e3)) throw new Error(te$4("MISSING_OR_INVALID", `approve() params: ${e3}`).message);
      const { id: t2, namespaces: s2, relayProtocol: i4, sessionProperties: n5 } = e3;
      this.checkRecentlyDeleted(t2), await this.isValidProposalId(t2);
      const o3 = this.client.proposal.get(t2), a2 = Ir$6(s2, "approve()");
      if (a2) throw new Error(a2.message);
      const l2 = Nr$6(o3.requiredNamespaces, s2, "approve()");
      if (l2) throw new Error(l2.message);
      if (!q$5(i4, true)) {
        const { message: h5 } = te$4("MISSING_OR_INVALID", `approve() relayProtocol: ${i4}`);
        throw new Error(h5);
      }
      ae$6(n5) || this.validateSessionProps(n5, "sessionProperties");
    }), c$6(this, "isValidReject", async (e3) => {
      if (!Di$6(e3)) {
        const { message: i4 } = te$4("MISSING_OR_INVALID", `reject() params: ${e3}`);
        throw new Error(i4);
      }
      const { id: t2, reason: s2 } = e3;
      if (this.checkRecentlyDeleted(t2), await this.isValidProposalId(t2), !Mi$4(s2)) {
        const { message: i4 } = te$4("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s2)}`);
        throw new Error(i4);
      }
    }), c$6(this, "isValidSessionSettleRequest", (e3) => {
      if (!Di$6(e3)) {
        const { message: l2 } = te$4("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e3}`);
        throw new Error(l2);
      }
      const { relay: t2, controller: s2, namespaces: i4, expiry: n5 } = e3;
      if (!Ar$6(t2)) {
        const { message: l2 } = te$4("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(l2);
      }
      const o3 = Bi$4(s2, "onSessionSettleRequest()");
      if (o3) throw new Error(o3.message);
      const a2 = Ir$6(i4, "onSessionSettleRequest()");
      if (a2) throw new Error(a2.message);
      if (po$4(n5)) {
        const { message: l2 } = te$4("EXPIRED", "onSessionSettleRequest()");
        throw new Error(l2);
      }
    }), c$6(this, "isValidUpdate", async (e3) => {
      if (!Di$6(e3)) {
        const { message: a2 } = te$4("MISSING_OR_INVALID", `update() params: ${e3}`);
        throw new Error(a2);
      }
      const { topic: t2, namespaces: s2 } = e3;
      this.checkRecentlyDeleted(t2), await this.isValidSessionTopic(t2);
      const i4 = this.client.session.get(t2), n5 = Ir$6(s2, "update()");
      if (n5) throw new Error(n5.message);
      const o3 = Nr$6(i4.requiredNamespaces, s2, "update()");
      if (o3) throw new Error(o3.message);
    }), c$6(this, "isValidExtend", async (e3) => {
      if (!Di$6(e3)) {
        const { message: s2 } = te$4("MISSING_OR_INVALID", `extend() params: ${e3}`);
        throw new Error(s2);
      }
      const { topic: t2 } = e3;
      this.checkRecentlyDeleted(t2), await this.isValidSessionTopic(t2);
    }), c$6(this, "isValidRequest", async (e3) => {
      if (!Di$6(e3)) {
        const { message: a2 } = te$4("MISSING_OR_INVALID", `request() params: ${e3}`);
        throw new Error(a2);
      }
      const { topic: t2, request: s2, chainId: i4, expiry: n5 } = e3;
      this.checkRecentlyDeleted(t2), await this.isValidSessionTopic(t2);
      const { namespaces: o3 } = this.client.session.get(t2);
      if (!Fi$4(o3, i4)) {
        const { message: a2 } = te$4("MISSING_OR_INVALID", `request() chainId: ${i4}`);
        throw new Error(a2);
      }
      if (!Vi$4(s2)) {
        const { message: a2 } = te$4("MISSING_OR_INVALID", `request() ${JSON.stringify(s2)}`);
        throw new Error(a2);
      }
      if (!qi$4(o3, i4, s2.method)) {
        const { message: a2 } = te$4("MISSING_OR_INVALID", `request() method: ${s2.method}`);
        throw new Error(a2);
      }
      if (n5 && !Ji$4(n5, Se$5)) {
        const { message: a2 } = te$4("MISSING_OR_INVALID", `request() expiry: ${n5}. Expiry must be a number (in seconds) between ${Se$5.min} and ${Se$5.max}`);
        throw new Error(a2);
      }
    }), c$6(this, "isValidRespond", async (e3) => {
      var t2;
      if (!Di$6(e3)) {
        const { message: n5 } = te$4("MISSING_OR_INVALID", `respond() params: ${e3}`);
        throw new Error(n5);
      }
      const { topic: s2, response: i4 } = e3;
      try {
        await this.isValidSessionTopic(s2);
      } catch (n5) {
        throw (t2 = e3 == null ? void 0 : e3.response) != null && t2.id && this.cleanupAfterResponse(e3), n5;
      }
      if (!Hi$4(i4)) {
        const { message: n5 } = te$4("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i4)}`);
        throw new Error(n5);
      }
    }), c$6(this, "isValidPing", async (e3) => {
      if (!Di$6(e3)) {
        const { message: s2 } = te$4("MISSING_OR_INVALID", `ping() params: ${e3}`);
        throw new Error(s2);
      }
      const { topic: t2 } = e3;
      await this.isValidSessionOrPairingTopic(t2);
    }), c$6(this, "isValidEmit", async (e3) => {
      if (!Di$6(e3)) {
        const { message: o3 } = te$4("MISSING_OR_INVALID", `emit() params: ${e3}`);
        throw new Error(o3);
      }
      const { topic: t2, event: s2, chainId: i4 } = e3;
      await this.isValidSessionTopic(t2);
      const { namespaces: n5 } = this.client.session.get(t2);
      if (!Fi$4(n5, i4)) {
        const { message: o3 } = te$4("MISSING_OR_INVALID", `emit() chainId: ${i4}`);
        throw new Error(o3);
      }
      if (!Ki$4(s2)) {
        const { message: o3 } = te$4("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s2)}`);
        throw new Error(o3);
      }
      if (!Gi$4(n5, i4, s2.name)) {
        const { message: o3 } = te$4("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s2)}`);
        throw new Error(o3);
      }
    }), c$6(this, "isValidDisconnect", async (e3) => {
      if (!Di$6(e3)) {
        const { message: s2 } = te$4("MISSING_OR_INVALID", `disconnect() params: ${e3}`);
        throw new Error(s2);
      }
      const { topic: t2 } = e3;
      await this.isValidSessionOrPairingTopic(t2);
    }), c$6(this, "isValidAuthenticate", (e3) => {
      const { chains: t2, uri: s2, domain: i4, nonce: n5 } = e3;
      if (!Array.isArray(t2) || t2.length === 0) throw new Error("chains is required and must be a non-empty array");
      if (!q$5(s2, false)) throw new Error("uri is required parameter");
      if (!q$5(i4, false)) throw new Error("domain is required parameter");
      if (!q$5(n5, false)) throw new Error("nonce is required parameter");
      if ([...new Set(t2.map((a2) => Ye$4(a2).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: o3 } = Ye$4(t2[0]);
      if (o3 !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }), c$6(this, "getVerifyContext", async (e3) => {
      const { attestationId: t2, hash: s2, encryptedId: i4, metadata: n5, transportType: o3 } = e3, a2 = { verified: { verifyUrl: n5.verifyUrl || re$5, validation: "UNKNOWN", origin: n5.url || "" } };
      try {
        if (o3 === Q$2.link_mode) {
          const h5 = this.getAppLinkIfEnabled(n5, o3);
          return a2.verified.validation = h5 && new URL(h5).origin === new URL(n5.url).origin ? "VALID" : "INVALID", a2;
        }
        const l2 = await this.client.core.verify.resolve({ attestationId: t2, hash: s2, encryptedId: i4, verifyUrl: n5.verifyUrl });
        l2 && (a2.verified.origin = l2.origin, a2.verified.isScam = l2.isScam, a2.verified.validation = l2.origin === new URL(n5.url).origin ? "VALID" : "INVALID");
      } catch (l2) {
        this.client.logger.warn(l2);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(a2)}`), a2;
    }), c$6(this, "validateSessionProps", (e3, t2) => {
      Object.values(e3).forEach((s2) => {
        if (!q$5(s2, false)) {
          const { message: i4 } = te$4("MISSING_OR_INVALID", `${t2} must be in Record<string, string> format. Received: ${JSON.stringify(s2)}`);
          throw new Error(i4);
        }
      });
    }), c$6(this, "getPendingAuthRequest", (e3) => {
      const t2 = this.client.auth.requests.get(e3);
      return typeof t2 == "object" ? t2 : void 0;
    }), c$6(this, "addToRecentlyDeleted", (e3, t2) => {
      if (this.recentlyDeletedMap.set(e3, t2), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let s2 = 0;
        const i4 = this.recentlyDeletedLimit / 2;
        for (const n5 of this.recentlyDeletedMap.keys()) {
          if (s2 >= i4) break;
          this.recentlyDeletedMap.delete(n5), s2 += 1;
        }
      }
    }), c$6(this, "checkRecentlyDeleted", (e3) => {
      const t2 = this.recentlyDeletedMap.get(e3);
      if (t2) {
        const { message: s2 } = te$4("MISSING_OR_INVALID", `Record was recently deleted - ${t2}: ${e3}`);
        throw new Error(s2);
      }
    }), c$6(this, "isLinkModeEnabled", (e3, t2) => {
      var s2, i4, n5, o3, a2, l2, h5, g2, d4;
      return !e3 || t2 !== Q$2.link_mode ? false : ((i4 = (s2 = this.client.metadata) == null ? void 0 : s2.redirect) == null ? void 0 : i4.linkMode) === true && ((o3 = (n5 = this.client.metadata) == null ? void 0 : n5.redirect) == null ? void 0 : o3.universal) !== void 0 && ((l2 = (a2 = this.client.metadata) == null ? void 0 : a2.redirect) == null ? void 0 : l2.universal) !== "" && ((h5 = e3 == null ? void 0 : e3.redirect) == null ? void 0 : h5.universal) !== void 0 && ((g2 = e3 == null ? void 0 : e3.redirect) == null ? void 0 : g2.universal) !== "" && ((d4 = e3 == null ? void 0 : e3.redirect) == null ? void 0 : d4.linkMode) === true && this.client.core.linkModeSupportedApps.includes(e3.redirect.universal) && typeof (global$1 == null ? void 0 : global$1.Linking) < "u";
    }), c$6(this, "getAppLinkIfEnabled", (e3, t2) => {
      var s2;
      return this.isLinkModeEnabled(e3, t2) ? (s2 = e3 == null ? void 0 : e3.redirect) == null ? void 0 : s2.universal : void 0;
    }), c$6(this, "handleLinkModeMessage", ({ url: e3 }) => {
      if (!e3 || !e3.includes("wc_ev") || !e3.includes("topic")) return;
      const t2 = bo$4(e3, "topic") || "", s2 = decodeURIComponent(bo$4(e3, "wc_ev") || ""), i4 = this.client.session.keys.includes(t2);
      i4 && this.client.session.update(t2, { transportType: Q$2.link_mode }), this.client.core.dispatchEnvelope({ topic: t2, message: s2, sessionExists: i4 });
    }), c$6(this, "registerLinkModeListeners", async () => {
      var e3;
      if (Eo$4() || ne$6() && (e3 = this.client.metadata.redirect) != null && e3.linkMode) {
        const t2 = global$1 == null ? void 0 : global$1.Linking;
        if (typeof t2 < "u") {
          t2.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const s2 = await t2.getInitialURL();
          s2 && setTimeout(() => {
            this.handleLinkModeMessage({ url: s2 });
          }, 50);
        }
      }
    }), c$6(this, "shouldSetTVF", (e3, t2) => {
      if (!t2 || e3 !== "wc_sessionRequest") return false;
      const { request: s2 } = t2;
      return Object.keys(Fe$6).includes(s2.method);
    }), c$6(this, "getTVFParams", (e3, t2, s2) => {
      var i4, n5;
      try {
        const o3 = t2.request.method, a2 = this.extractTxHashesFromResult(o3, s2);
        return V$7(R$4({ correlationId: e3, rpcMethods: [o3], chainId: t2.chainId }, this.isValidContractData(t2.request.params) && { contractAddresses: [(n5 = (i4 = t2.request.params) == null ? void 0 : i4[0]) == null ? void 0 : n5.to] }), { txHashes: a2 });
      } catch (o3) {
        this.client.logger.warn("Error getting TVF params", o3);
      }
      return {};
    }), c$6(this, "isValidContractData", (e3) => {
      var t2;
      if (!e3) return false;
      try {
        const s2 = (e3 == null ? void 0 : e3.data) || ((t2 = e3 == null ? void 0 : e3[0]) == null ? void 0 : t2.data);
        if (!s2.startsWith("0x")) return false;
        const i4 = s2.slice(2);
        return /^[0-9a-fA-F]*$/.test(i4) ? i4.length % 2 === 0 : false;
      } catch {
      }
      return false;
    }), c$6(this, "extractTxHashesFromResult", (e3, t2) => {
      try {
        const s2 = Fe$6[e3];
        if (typeof t2 == "string") return [t2];
        const i4 = t2[s2.key];
        if ($e$7(i4)) return i4;
        if (typeof i4 == "string") return [i4];
      } catch (s2) {
        this.client.logger.warn("Error extracting tx hashes from result", s2);
      }
      return [];
    }), c$6(this, "initializeMobileSessionDetection", () => {
      if (typeof window > "u") {
        console.log(" [ENGINE] Window is undefined, skipping mobile session detection initialization");
        return;
      }
      console.log(" [ENGINE] Mobile session management delegated to DApp"), console.log(" [ENGINE] Use engine.validateAndCleanupSessions(isSessionCheck) for session validation");
    }), c$6(this, "validateAndCleanupSessions", async (e3 = false) => {
      const t2 = Date.now();
      if (!e3 && this.lastSessionCheckTime && t2 - this.lastSessionCheckTime < 1e4) {
        console.log(" [ENGINE] Skipping session check - too frequent (last check was", t2 - this.lastSessionCheckTime, "ms ago)");
        return;
      }
      this.lastSessionCheckTime = t2, this.isCheckingSession = true;
      try {
        const s2 = this.client.session.getAll();
        if (e3) {
          await this.cleanup();
          const n5 = this.client.session.getAll();
          console.log(" [ENGINE] Found", n5.length, "active sessions after cleanup");
        }
        const i4 = s2.map(async (n5) => {
          const o3 = this.firstDAppEntryAfterSession.get(n5.topic);
          try {
            return await this.ping({ topic: n5.topic }), o3 ? (this.firstDAppEntryAfterSession.set(n5.topic, false), { success: true, topic: n5.topic }) : (this.client.session.get(n5.topic) ? console.log(" [DEBUG] Session validation passed for:", `${n5.topic.substring(0, 8)}...`) : await this.deleteSession({ topic: n5.topic, emitEvent: false }), { success: true, topic: n5.topic });
          } catch (a2) {
            try {
              await this.deleteSession({ topic: n5.topic, emitEvent: false }), this.events.emit("session_disconnected", { error: void 0, result: { topic: n5.topic, reason: "ping_failure", timestamp: Date.now() } });
            } catch (l2) {
              console.error(" [ENGINE] Failed to disconnect session:", n5.topic, l2);
            }
            return { success: false, topic: n5.topic, error: a2 };
          }
        });
        await Promise.allSettled(i4);
      } catch (s2) {
        console.error(" [ENGINE] Error checking session status:", s2);
      } finally {
        this.isCheckingSession = false;
      }
    }), c$6(this, "getSessionStatus", async () => {
      if (this.isCheckingSession) {
        const e3 = this.client.session.getAll();
        return { total: e3.length, healthy: e3.length, disconnected: 0, sessions: e3.map((t2) => ({ topic: t2.topic, status: "healthy" })), note: "Status returned while session check in progress" };
      }
      this.isCheckingSession = true;
      try {
        const e3 = this.client.session.getAll(), t2 = [];
        let s2 = 0, i4 = 0;
        const n5 = e3.map(async (o3) => {
          try {
            return await this.ping({ topic: o3.topic }), { topic: o3.topic, status: "healthy" };
          } catch (a2) {
            return { topic: o3.topic, status: "disconnected", error: (a2 == null ? void 0 : a2.message) || "Ping failed" };
          }
        });
        return (await Promise.allSettled(n5)).forEach((o3) => {
          o3.status === "fulfilled" ? (t2.push(o3.value), o3.value.status === "healthy" ? s2 += 1 : i4 += 1) : (i4 += 1, t2.push({ topic: "unknown", status: "disconnected", error: "Unexpected error during ping" }));
        }), { total: e3.length, healthy: s2, disconnected: i4, sessions: t2 };
      } catch (e3) {
        return { total: 0, healthy: 0, disconnected: 0, sessions: [], error: (e3 == null ? void 0 : e3.message) || "Unknown error" };
      } finally {
        this.isCheckingSession = false;
      }
    }), c$6(this, "validateSessionAndGetStatus", async (e3, t2 = false) => {
      var s2;
      try {
        await this.validateAndCleanupSessions(t2);
        const i4 = await this.getSessionStatus();
        if (e3 && (s2 = i4 == null ? void 0 : i4.sessions) != null && s2.length) {
          const n5 = i4.sessions.find((o3) => o3.topic === e3);
          return (n5 == null ? void 0 : n5.status) === "healthy";
        }
        return !!(i4 && i4.total > 0 && i4.healthy > 0);
      } catch (i4) {
        return console.error(" [ENGINE] Error checking session active status:", i4), false;
      }
    });
  }
  updateSessionActivity(r3) {
    var e3;
    try {
      const t2 = `session_activity_${r3}`, s2 = Date.now();
      if (this.client.logger.debug(` [ACTIVITY] Updating activity record for session: ${r3}`), !((e3 = this.client.core) != null && e3.storage)) {
        this.client.logger.warn(` [ACTIVITY] Storage system not available for session: ${r3}`);
        return;
      }
      this.client.core.storage.setItem(t2, s2.toString()), this.client.logger.info(` [ACTIVITY] Updated session activity for ${r3} at ${new Date(s2).toISOString()}`);
    } catch (t2) {
      this.client.logger.error(` [ACTIVITY] Error updating session activity for ${r3}:`, t2);
    }
  }
  cleanupSessionActivity(r3) {
    var e3;
    try {
      const t2 = `session_activity_${r3}`;
      if (this.client.logger.debug(` [ACTIVITY] Cleaning up activity record for session: ${r3}`), !((e3 = this.client.core) != null && e3.storage)) {
        this.client.logger.warn(` [ACTIVITY] Storage system not available for session: ${r3}`);
        return;
      }
      this.client.core.storage.removeItem(t2), this.client.logger.info(` [ACTIVITY] Cleaned up session activity for ${r3}`);
    } catch (t2) {
      this.client.logger.error(` [ACTIVITY] Error cleaning up session activity for ${r3}:`, t2);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: r3 } = te$4("NOT_INITIALIZED", this.name);
      throw new Error(r3);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(T$5.message, (r3) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(r3) : this.onRelayMessage(r3);
    });
  }
  async onRelayMessage(r3) {
    const { topic: e3, message: t2, attestation: s2, transportType: i4 } = r3, { publicKey: n5 } = this.client.auth.authKeys.keys.includes(ce$4) ? this.client.auth.authKeys.get(ce$4) : { publicKey: void 0 }, o3 = await this.client.core.crypto.decode(e3, t2, { receiverPublicKey: n5, encoding: i4 === Q$2.link_mode ? Qs$6 : At$6 });
    try {
      isJsonRpcRequest(o3) ? (this.client.core.history.set(e3, o3), this.onRelayEventRequest({ topic: e3, payload: o3, attestation: s2, transportType: i4, encryptedId: si$6(t2) })) : isJsonRpcResponse(o3) ? (await this.client.core.history.resolve(o3), await this.onRelayEventResponse({ topic: e3, payload: o3, transportType: i4 }), this.client.core.history.delete(e3, o3.id)) : this.onRelayEventUnknownPayload({ topic: e3, payload: o3, transportType: i4 });
    } catch (a2) {
      this.client.logger.error(a2);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(M$6.expired, async (r3) => {
      const { topic: e3, id: t2 } = lo$4(r3.target);
      if (t2 && this.client.pendingRequest.keys.includes(t2)) return await this.deletePendingSessionRequest(t2, te$4("EXPIRED"), true);
      if (t2 && this.client.auth.requests.keys.includes(t2)) return await this.deletePendingAuthRequest(t2, te$4("EXPIRED"), true);
      e3 ? this.client.session.keys.includes(e3) && (await this.deleteSession({ topic: e3, expirerHasDeleted: true }), this.client.events.emit("session_expire", { topic: e3 })) : t2 && (await this.deleteProposal(t2, true), this.client.events.emit("proposal_expire", { id: t2 }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(se$5.create, (r3) => this.onPairingCreated(r3)), this.client.core.pairing.events.on(se$5.delete, (r3) => {
      this.addToRecentlyDeleted(r3.topic, "pairing");
    });
  }
  isValidPairingTopic(r3) {
    if (!q$5(r3, false)) {
      const { message: e3 } = te$4("MISSING_OR_INVALID", `pairing topic should be a string: ${r3}`);
      throw new Error(e3);
    }
    if (!this.client.core.pairing.pairings.keys.includes(r3)) {
      const { message: e3 } = te$4("NO_MATCHING_KEY", `pairing topic doesn't exist: ${r3}`);
      throw new Error(e3);
    }
    if (po$4(this.client.core.pairing.pairings.get(r3).expiry)) {
      const { message: e3 } = te$4("EXPIRED", `pairing topic: ${r3}`);
      throw new Error(e3);
    }
  }
  async isValidSessionTopic(r3) {
    if (!q$5(r3, false)) {
      const { message: e3 } = te$4("MISSING_OR_INVALID", `session topic should be a string: ${r3}`);
      throw new Error(e3);
    }
    if (this.checkRecentlyDeleted(r3), !this.client.session.keys.includes(r3)) {
      const { message: e3 } = te$4("NO_MATCHING_KEY", `session topic doesn't exist: ${r3}`);
      throw new Error(e3);
    }
    if (po$4(this.client.session.get(r3).expiry)) {
      await this.deleteSession({ topic: r3 });
      const { message: e3 } = te$4("EXPIRED", `session topic: ${r3}`);
      throw new Error(e3);
    }
    if (!this.client.core.crypto.keychain.has(r3)) {
      const { message: e3 } = te$4("MISSING_OR_INVALID", `session topic does not exist in keychain: ${r3}`);
      throw await this.deleteSession({ topic: r3 }), new Error(e3);
    }
  }
  async isValidSessionOrPairingTopic(r3) {
    if (this.checkRecentlyDeleted(r3), this.client.session.keys.includes(r3)) await this.isValidSessionTopic(r3);
    else if (this.client.core.pairing.pairings.keys.includes(r3)) this.isValidPairingTopic(r3);
    else if (q$5(r3, false)) {
      const { message: e3 } = te$4("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${r3}`);
      throw new Error(e3);
    } else {
      const { message: e3 } = te$4("MISSING_OR_INVALID", `session or pairing topic should be a string: ${r3}`);
      throw new Error(e3);
    }
  }
  async isValidProposalId(r3) {
    if (!ki$4(r3)) {
      const { message: e3 } = te$4("MISSING_OR_INVALID", `proposal id should be a number: ${r3}`);
      throw new Error(e3);
    }
    if (!this.client.proposal.keys.includes(r3)) {
      const { message: e3 } = te$4("NO_MATCHING_KEY", `proposal id doesn't exist: ${r3}`);
      throw new Error(e3);
    }
    if (po$4(this.client.proposal.get(r3).expiryTimestamp)) {
      await this.deleteProposal(r3);
      const { message: e3 } = te$4("EXPIRED", `proposal id: ${r3}`);
      throw new Error(e3);
    }
  }
};
let Ns$5 = class Ns2 extends Ci$5 {
  constructor(r3, e3) {
    super(r3, e3, pt$4, we$5), this.core = r3, this.logger = e3;
  }
};
let ft$3 = class ft2 extends Ci$5 {
  constructor(r3, e3) {
    super(r3, e3, ht$4, we$5), this.core = r3, this.logger = e3;
  }
};
let Ps$5 = class Ps2 extends Ci$5 {
  constructor(r3, e3) {
    super(r3, e3, ut$5, we$5, (t2) => t2.id), this.core = r3, this.logger = e3;
  }
};
let Os$5 = class Os2 extends Ci$5 {
  constructor(r3, e3) {
    super(r3, e3, wt$3, ae$5, () => ce$4), this.core = r3, this.logger = e3;
  }
};
let As$5 = class As2 extends Ci$5 {
  constructor(r3, e3) {
    super(r3, e3, _t$5, ae$5), this.core = r3, this.logger = e3;
  }
};
let bs$5 = class bs2 extends Ci$5 {
  constructor(r3, e3) {
    super(r3, e3, St$6, ae$5, (t2) => t2.id), this.core = r3, this.logger = e3;
  }
};
var Cs$5 = Object.defineProperty, Vs$5 = (E2, r3, e3) => r3 in E2 ? Cs$5(E2, r3, { enumerable: true, configurable: true, writable: true, value: e3 }) : E2[r3] = e3, Ke$6 = (E2, r3, e3) => Vs$5(E2, typeof r3 != "symbol" ? r3 + "" : r3, e3);
let Ds$5 = class Ds2 {
  constructor(r3, e3) {
    this.core = r3, this.logger = e3, Ke$6(this, "authKeys"), Ke$6(this, "pairingTopics"), Ke$6(this, "requests"), this.authKeys = new Os$5(this.core, this.logger), this.pairingTopics = new As$5(this.core, this.logger), this.requests = new bs$5(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
};
var xs$5 = Object.defineProperty, Ls$5 = (E2, r3, e3) => r3 in E2 ? xs$5(E2, r3, { enumerable: true, configurable: true, writable: true, value: e3 }) : E2[r3] = e3, _$6 = (E2, r3, e3) => Ls$5(E2, typeof r3 != "symbol" ? r3 + "" : r3, e3);
let Ee$5 = class Ee2 extends J$8 {
  constructor(r3) {
    super(r3), _$6(this, "protocol", xe$5), _$6(this, "version", Le$6), _$6(this, "name", _e$6.name), _$6(this, "metadata"), _$6(this, "core"), _$6(this, "logger"), _$6(this, "events", new eventsExports.EventEmitter()), _$6(this, "engine"), _$6(this, "session"), _$6(this, "proposal"), _$6(this, "pendingRequest"), _$6(this, "auth"), _$6(this, "signConfig"), _$6(this, "on", (t2, s2) => this.events.on(t2, s2)), _$6(this, "once", (t2, s2) => this.events.once(t2, s2)), _$6(this, "off", (t2, s2) => this.events.off(t2, s2)), _$6(this, "removeListener", (t2, s2) => this.events.removeListener(t2, s2)), _$6(this, "removeAllListeners", (t2) => this.events.removeAllListeners(t2)), _$6(this, "connect", async (t2) => {
      try {
        return await this.engine.connect(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), _$6(this, "pair", async (t2) => {
      try {
        return await this.engine.pair(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), _$6(this, "approve", async (t2) => {
      try {
        return await this.engine.approve(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), _$6(this, "reject", async (t2) => {
      try {
        return await this.engine.reject(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), _$6(this, "update", async (t2) => {
      try {
        return await this.engine.update(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), _$6(this, "extend", async (t2) => {
      try {
        return await this.engine.extend(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), _$6(this, "request", async (t2) => {
      try {
        return await this.engine.request(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), _$6(this, "respond", async (t2) => {
      try {
        return await this.engine.respond(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), _$6(this, "ping", async (t2) => {
      try {
        return await this.engine.ping(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), _$6(this, "emit", async (t2) => {
      try {
        return await this.engine.emit(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), _$6(this, "disconnect", async (t2) => {
      try {
        return await this.engine.disconnect(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), _$6(this, "find", (t2) => {
      try {
        return this.engine.find(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), _$6(this, "getPendingSessionRequests", () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (t2) {
        throw this.logger.error(t2.message), t2;
      }
    }), _$6(this, "authenticate", async (t2, s2) => {
      try {
        return await this.engine.authenticate(t2, s2);
      } catch (i4) {
        throw this.logger.error(i4.message), i4;
      }
    }), _$6(this, "formatAuthMessage", (t2) => {
      try {
        return this.engine.formatAuthMessage(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), _$6(this, "approveSessionAuthenticate", async (t2) => {
      try {
        return await this.engine.approveSessionAuthenticate(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), _$6(this, "rejectSessionAuthenticate", async (t2) => {
      try {
        return await this.engine.rejectSessionAuthenticate(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), this.name = (r3 == null ? void 0 : r3.name) || _e$6.name, this.metadata = (r3 == null ? void 0 : r3.metadata) || Yr$6(), this.signConfig = r3 == null ? void 0 : r3.signConfig;
    const e3 = typeof (r3 == null ? void 0 : r3.logger) < "u" && typeof (r3 == null ? void 0 : r3.logger) != "string" ? r3.logger : gt$3(k$7({ level: (r3 == null ? void 0 : r3.logger) || _e$6.logger }));
    this.core = (r3 == null ? void 0 : r3.core) || new ao$5(r3), this.logger = E$7(e3, this.name), this.session = new ft$3(this.core, this.logger), this.proposal = new Ns$5(this.core, this.logger), this.pendingRequest = new Ps$5(this.core, this.logger), this.engine = new qs$6(this), this.auth = new Ds$5(this.core, this.logger);
  }
  static async init(r3) {
    const e3 = new Ee2(r3);
    return await e3.initialize(), e3;
  }
  get context() {
    return y$6(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success"), setTimeout(() => {
        this.engine.processRelayMessageCache();
      }, cjs$3.toMiliseconds(cjs$3.ONE_SECOND));
    } catch (r3) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(r3.message), r3;
    }
  }
};
var browserPonyfill = { exports: {} };
(function(module, exports2) {
  var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof commonjsGlobal !== "undefined" && commonjsGlobal;
  var __globalThis__ = function() {
    function F2() {
      this.fetch = false;
      this.DOMException = __global__.DOMException;
    }
    F2.prototype = __global__;
    return new F2();
  }();
  (function(globalThis2) {
    (function(exports3) {
      var g2 = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
      typeof commonjsGlobal !== "undefined" && commonjsGlobal || {};
      var support = {
        searchParams: "URLSearchParams" in g2,
        iterable: "Symbol" in g2 && "iterator" in Symbol,
        blob: "FileReader" in g2 && "Blob" in g2 && function() {
          try {
            new Blob();
            return true;
          } catch (e3) {
            return false;
          }
        }(),
        formData: "FormData" in g2,
        arrayBuffer: "ArrayBuffer" in g2
      };
      function isDataView(obj) {
        return obj && DataView.prototype.isPrototypeOf(obj);
      }
      if (support.arrayBuffer) {
        var viewClasses = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ];
        var isArrayBufferView = ArrayBuffer.isView || function(obj) {
          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
        };
      }
      function normalizeName(name) {
        if (typeof name !== "string") {
          name = String(name);
        }
        if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
          throw new TypeError('Invalid character in header field name: "' + name + '"');
        }
        return name.toLowerCase();
      }
      function normalizeValue(value) {
        if (typeof value !== "string") {
          value = String(value);
        }
        return value;
      }
      function iteratorFor(items) {
        var iterator = {
          next: function() {
            var value = items.shift();
            return { done: value === void 0, value };
          }
        };
        if (support.iterable) {
          iterator[Symbol.iterator] = function() {
            return iterator;
          };
        }
        return iterator;
      }
      function Headers2(headers) {
        this.map = {};
        if (headers instanceof Headers2) {
          headers.forEach(function(value, name) {
            this.append(name, value);
          }, this);
        } else if (Array.isArray(headers)) {
          headers.forEach(function(header) {
            if (header.length != 2) {
              throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
            }
            this.append(header[0], header[1]);
          }, this);
        } else if (headers) {
          Object.getOwnPropertyNames(headers).forEach(function(name) {
            this.append(name, headers[name]);
          }, this);
        }
      }
      Headers2.prototype.append = function(name, value) {
        name = normalizeName(name);
        value = normalizeValue(value);
        var oldValue = this.map[name];
        this.map[name] = oldValue ? oldValue + ", " + value : value;
      };
      Headers2.prototype["delete"] = function(name) {
        delete this.map[normalizeName(name)];
      };
      Headers2.prototype.get = function(name) {
        name = normalizeName(name);
        return this.has(name) ? this.map[name] : null;
      };
      Headers2.prototype.has = function(name) {
        return this.map.hasOwnProperty(normalizeName(name));
      };
      Headers2.prototype.set = function(name, value) {
        this.map[normalizeName(name)] = normalizeValue(value);
      };
      Headers2.prototype.forEach = function(callback, thisArg) {
        for (var name in this.map) {
          if (this.map.hasOwnProperty(name)) {
            callback.call(thisArg, this.map[name], name, this);
          }
        }
      };
      Headers2.prototype.keys = function() {
        var items = [];
        this.forEach(function(value, name) {
          items.push(name);
        });
        return iteratorFor(items);
      };
      Headers2.prototype.values = function() {
        var items = [];
        this.forEach(function(value) {
          items.push(value);
        });
        return iteratorFor(items);
      };
      Headers2.prototype.entries = function() {
        var items = [];
        this.forEach(function(value, name) {
          items.push([name, value]);
        });
        return iteratorFor(items);
      };
      if (support.iterable) {
        Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
      }
      function consumed(body) {
        if (body._noBody) return;
        if (body.bodyUsed) {
          return Promise.reject(new TypeError("Already read"));
        }
        body.bodyUsed = true;
      }
      function fileReaderReady(reader) {
        return new Promise(function(resolve, reject) {
          reader.onload = function() {
            resolve(reader.result);
          };
          reader.onerror = function() {
            reject(reader.error);
          };
        });
      }
      function readBlobAsArrayBuffer(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsArrayBuffer(blob);
        return promise;
      }
      function readBlobAsText(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
        var encoding = match ? match[1] : "utf-8";
        reader.readAsText(blob, encoding);
        return promise;
      }
      function readArrayBufferAsText(buf) {
        var view = new Uint8Array(buf);
        var chars = new Array(view.length);
        for (var i4 = 0; i4 < view.length; i4++) {
          chars[i4] = String.fromCharCode(view[i4]);
        }
        return chars.join("");
      }
      function bufferClone(buf) {
        if (buf.slice) {
          return buf.slice(0);
        } else {
          var view = new Uint8Array(buf.byteLength);
          view.set(new Uint8Array(buf));
          return view.buffer;
        }
      }
      function Body() {
        this.bodyUsed = false;
        this._initBody = function(body) {
          this.bodyUsed = this.bodyUsed;
          this._bodyInit = body;
          if (!body) {
            this._noBody = true;
            this._bodyText = "";
          } else if (typeof body === "string") {
            this._bodyText = body;
          } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
            this._bodyBlob = body;
          } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
            this._bodyFormData = body;
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this._bodyText = body.toString();
          } else if (support.arrayBuffer && support.blob && isDataView(body)) {
            this._bodyArrayBuffer = bufferClone(body.buffer);
            this._bodyInit = new Blob([this._bodyArrayBuffer]);
          } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
            this._bodyArrayBuffer = bufferClone(body);
          } else {
            this._bodyText = body = Object.prototype.toString.call(body);
          }
          if (!this.headers.get("content-type")) {
            if (typeof body === "string") {
              this.headers.set("content-type", "text/plain;charset=UTF-8");
            } else if (this._bodyBlob && this._bodyBlob.type) {
              this.headers.set("content-type", this._bodyBlob.type);
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
            }
          }
        };
        if (support.blob) {
          this.blob = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return Promise.resolve(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as blob");
            } else {
              return Promise.resolve(new Blob([this._bodyText]));
            }
          };
        }
        this.arrayBuffer = function() {
          if (this._bodyArrayBuffer) {
            var isConsumed = consumed(this);
            if (isConsumed) {
              return isConsumed;
            } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
              return Promise.resolve(
                this._bodyArrayBuffer.buffer.slice(
                  this._bodyArrayBuffer.byteOffset,
                  this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                )
              );
            } else {
              return Promise.resolve(this._bodyArrayBuffer);
            }
          } else if (support.blob) {
            return this.blob().then(readBlobAsArrayBuffer);
          } else {
            throw new Error("could not read as ArrayBuffer");
          }
        };
        this.text = function() {
          var rejected = consumed(this);
          if (rejected) {
            return rejected;
          }
          if (this._bodyBlob) {
            return readBlobAsText(this._bodyBlob);
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
          } else if (this._bodyFormData) {
            throw new Error("could not read FormData body as text");
          } else {
            return Promise.resolve(this._bodyText);
          }
        };
        if (support.formData) {
          this.formData = function() {
            return this.text().then(decode2);
          };
        }
        this.json = function() {
          return this.text().then(JSON.parse);
        };
        return this;
      }
      var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
      function normalizeMethod(method) {
        var upcased = method.toUpperCase();
        return methods.indexOf(upcased) > -1 ? upcased : method;
      }
      function Request2(input, options) {
        if (!(this instanceof Request2)) {
          throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
        }
        options = options || {};
        var body = options.body;
        if (input instanceof Request2) {
          if (input.bodyUsed) {
            throw new TypeError("Already read");
          }
          this.url = input.url;
          this.credentials = input.credentials;
          if (!options.headers) {
            this.headers = new Headers2(input.headers);
          }
          this.method = input.method;
          this.mode = input.mode;
          this.signal = input.signal;
          if (!body && input._bodyInit != null) {
            body = input._bodyInit;
            input.bodyUsed = true;
          }
        } else {
          this.url = String(input);
        }
        this.credentials = options.credentials || this.credentials || "same-origin";
        if (options.headers || !this.headers) {
          this.headers = new Headers2(options.headers);
        }
        this.method = normalizeMethod(options.method || this.method || "GET");
        this.mode = options.mode || this.mode || null;
        this.signal = options.signal || this.signal || function() {
          if ("AbortController" in g2) {
            var ctrl = new AbortController();
            return ctrl.signal;
          }
        }();
        this.referrer = null;
        if ((this.method === "GET" || this.method === "HEAD") && body) {
          throw new TypeError("Body not allowed for GET or HEAD requests");
        }
        this._initBody(body);
        if (this.method === "GET" || this.method === "HEAD") {
          if (options.cache === "no-store" || options.cache === "no-cache") {
            var reParamSearch = /([?&])_=[^&]*/;
            if (reParamSearch.test(this.url)) {
              this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
            } else {
              var reQueryString = /\?/;
              this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
            }
          }
        }
      }
      Request2.prototype.clone = function() {
        return new Request2(this, { body: this._bodyInit });
      };
      function decode2(body) {
        var form = new FormData();
        body.trim().split("&").forEach(function(bytes2) {
          if (bytes2) {
            var split2 = bytes2.split("=");
            var name = split2.shift().replace(/\+/g, " ");
            var value = split2.join("=").replace(/\+/g, " ");
            form.append(decodeURIComponent(name), decodeURIComponent(value));
          }
        });
        return form;
      }
      function parseHeaders(rawHeaders) {
        var headers = new Headers2();
        var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
        preProcessedHeaders.split("\r").map(function(header) {
          return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
        }).forEach(function(line) {
          var parts = line.split(":");
          var key2 = parts.shift().trim();
          if (key2) {
            var value = parts.join(":").trim();
            try {
              headers.append(key2, value);
            } catch (error) {
              console.warn("Response " + error.message);
            }
          }
        });
        return headers;
      }
      Body.call(Request2.prototype);
      function Response2(bodyInit, options) {
        if (!(this instanceof Response2)) {
          throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
        }
        if (!options) {
          options = {};
        }
        this.type = "default";
        this.status = options.status === void 0 ? 200 : options.status;
        if (this.status < 200 || this.status > 599) {
          throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
        }
        this.ok = this.status >= 200 && this.status < 300;
        this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
        this.headers = new Headers2(options.headers);
        this.url = options.url || "";
        this._initBody(bodyInit);
      }
      Body.call(Response2.prototype);
      Response2.prototype.clone = function() {
        return new Response2(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new Headers2(this.headers),
          url: this.url
        });
      };
      Response2.error = function() {
        var response = new Response2(null, { status: 200, statusText: "" });
        response.ok = false;
        response.status = 0;
        response.type = "error";
        return response;
      };
      var redirectStatuses = [301, 302, 303, 307, 308];
      Response2.redirect = function(url, status) {
        if (redirectStatuses.indexOf(status) === -1) {
          throw new RangeError("Invalid status code");
        }
        return new Response2(null, { status, headers: { location: url } });
      };
      exports3.DOMException = g2.DOMException;
      try {
        new exports3.DOMException();
      } catch (err) {
        exports3.DOMException = function(message, name) {
          this.message = message;
          this.name = name;
          var error = Error(message);
          this.stack = error.stack;
        };
        exports3.DOMException.prototype = Object.create(Error.prototype);
        exports3.DOMException.prototype.constructor = exports3.DOMException;
      }
      function fetch2(input, init4) {
        return new Promise(function(resolve, reject) {
          var request = new Request2(input, init4);
          if (request.signal && request.signal.aborted) {
            return reject(new exports3.DOMException("Aborted", "AbortError"));
          }
          var xhr = new XMLHttpRequest();
          function abortXhr() {
            xhr.abort();
          }
          xhr.onload = function() {
            var options = {
              statusText: xhr.statusText,
              headers: parseHeaders(xhr.getAllResponseHeaders() || "")
            };
            if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
              options.status = 200;
            } else {
              options.status = xhr.status;
            }
            options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
            var body = "response" in xhr ? xhr.response : xhr.responseText;
            setTimeout(function() {
              resolve(new Response2(body, options));
            }, 0);
          };
          xhr.onerror = function() {
            setTimeout(function() {
              reject(new TypeError("Network request failed"));
            }, 0);
          };
          xhr.ontimeout = function() {
            setTimeout(function() {
              reject(new TypeError("Network request timed out"));
            }, 0);
          };
          xhr.onabort = function() {
            setTimeout(function() {
              reject(new exports3.DOMException("Aborted", "AbortError"));
            }, 0);
          };
          function fixUrl(url) {
            try {
              return url === "" && g2.location.href ? g2.location.href : url;
            } catch (e3) {
              return url;
            }
          }
          xhr.open(request.method, fixUrl(request.url), true);
          if (request.credentials === "include") {
            xhr.withCredentials = true;
          } else if (request.credentials === "omit") {
            xhr.withCredentials = false;
          }
          if ("responseType" in xhr) {
            if (support.blob) {
              xhr.responseType = "blob";
            } else if (support.arrayBuffer) {
              xhr.responseType = "arraybuffer";
            }
          }
          if (init4 && typeof init4.headers === "object" && !(init4.headers instanceof Headers2 || g2.Headers && init4.headers instanceof g2.Headers)) {
            var names2 = [];
            Object.getOwnPropertyNames(init4.headers).forEach(function(name) {
              names2.push(normalizeName(name));
              xhr.setRequestHeader(name, normalizeValue(init4.headers[name]));
            });
            request.headers.forEach(function(value, name) {
              if (names2.indexOf(name) === -1) {
                xhr.setRequestHeader(name, value);
              }
            });
          } else {
            request.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value);
            });
          }
          if (request.signal) {
            request.signal.addEventListener("abort", abortXhr);
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                request.signal.removeEventListener("abort", abortXhr);
              }
            };
          }
          xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
        });
      }
      fetch2.polyfill = true;
      if (!g2.fetch) {
        g2.fetch = fetch2;
        g2.Headers = Headers2;
        g2.Request = Request2;
        g2.Response = Response2;
      }
      exports3.Headers = Headers2;
      exports3.Request = Request2;
      exports3.Response = Response2;
      exports3.fetch = fetch2;
      Object.defineProperty(exports3, "__esModule", { value: true });
      return exports3;
    })({});
  })(__globalThis__);
  __globalThis__.fetch.ponyfill = true;
  delete __globalThis__.fetch.polyfill;
  var ctx = __global__.fetch ? __global__ : __globalThis__;
  exports2 = ctx.fetch;
  exports2.default = ctx.fetch;
  exports2.fetch = ctx.fetch;
  exports2.Headers = ctx.Headers;
  exports2.Request = ctx.Request;
  exports2.Response = ctx.Response;
  module.exports = exports2;
})(browserPonyfill, browserPonyfill.exports);
var browserPonyfillExports = browserPonyfill.exports;
const o$8 = /* @__PURE__ */ getDefaultExportFromCjs$1(browserPonyfillExports);
var P$2 = Object.defineProperty, w$2 = Object.defineProperties, E$4 = Object.getOwnPropertyDescriptors, c$5 = Object.getOwnPropertySymbols, L$4 = Object.prototype.hasOwnProperty, O$3 = Object.prototype.propertyIsEnumerable, l$2 = (r3, t2, e3) => t2 in r3 ? P$2(r3, t2, { enumerable: true, configurable: true, writable: true, value: e3 }) : r3[t2] = e3, p$6 = (r3, t2) => {
  for (var e3 in t2 || (t2 = {})) L$4.call(t2, e3) && l$2(r3, e3, t2[e3]);
  if (c$5) for (var e3 of c$5(t2)) O$3.call(t2, e3) && l$2(r3, e3, t2[e3]);
  return r3;
}, v$4 = (r3, t2) => w$2(r3, E$4(t2));
const j$3 = { Accept: "application/json", "Content-Type": "application/json" }, T$4 = "POST", d$3 = { headers: j$3, method: T$4 }, g$3 = 10;
let f$6 = class f4 {
  constructor(t2, e3 = false) {
    if (this.url = t2, this.disableProviderPing = e3, this.events = new eventsExports.EventEmitter(), this.isAvailable = false, this.registering = false, !isHttpUrl(t2)) throw new Error(`Provided URL is not compatible with HTTP connection: ${t2}`);
    this.url = t2, this.disableProviderPing = e3;
  }
  get connected() {
    return this.isAvailable;
  }
  get connecting() {
    return this.registering;
  }
  on(t2, e3) {
    this.events.on(t2, e3);
  }
  once(t2, e3) {
    this.events.once(t2, e3);
  }
  off(t2, e3) {
    this.events.off(t2, e3);
  }
  removeListener(t2, e3) {
    this.events.removeListener(t2, e3);
  }
  async open(t2 = this.url) {
    await this.register(t2);
  }
  async close() {
    if (!this.isAvailable) throw new Error("Connection already closed");
    this.onClose();
  }
  async send(t2) {
    this.isAvailable || await this.register();
    try {
      const e3 = safeJsonStringify(t2), s2 = await (await o$8(this.url, v$4(p$6({}, d$3), { body: e3 }))).json();
      this.onPayload({ data: s2 });
    } catch (e3) {
      this.onError(t2.id, e3);
    }
  }
  async register(t2 = this.url) {
    if (!isHttpUrl(t2)) throw new Error(`Provided URL is not compatible with HTTP connection: ${t2}`);
    if (this.registering) {
      const e3 = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= e3 || this.events.listenerCount("open") >= e3) && this.events.setMaxListeners(e3 + 1), new Promise((s2, i4) => {
        this.events.once("register_error", (n5) => {
          this.resetMaxListeners(), i4(n5);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.isAvailable > "u") return i4(new Error("HTTP connection is missing or invalid"));
          s2();
        });
      });
    }
    this.url = t2, this.registering = true;
    try {
      if (!this.disableProviderPing) {
        const e3 = safeJsonStringify({ id: 1, jsonrpc: "2.0", method: "test", params: [] });
        await o$8(t2, v$4(p$6({}, d$3), { body: e3 }));
      }
      this.onOpen();
    } catch (e3) {
      const s2 = this.parseError(e3);
      throw this.events.emit("register_error", s2), this.onClose(), s2;
    }
  }
  onOpen() {
    this.isAvailable = true, this.registering = false, this.events.emit("open");
  }
  onClose() {
    this.isAvailable = false, this.registering = false, this.events.emit("close");
  }
  onPayload(t2) {
    if (typeof t2.data > "u") return;
    const e3 = typeof t2.data == "string" ? safeJsonParse(t2.data) : t2.data;
    this.events.emit("payload", e3);
  }
  onError(t2, e3) {
    const s2 = this.parseError(e3), i4 = s2.message || s2.toString(), n5 = formatJsonRpcError(t2, i4);
    this.events.emit("payload", n5);
  }
  parseError(t2, e3 = this.url) {
    return parseConnectionError(t2, e3, "HTTP");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > g$3 && this.events.setMaxListeners(g$3);
  }
};
const be$2 = "error", _t$4 = "wss://relay.walletconnect.org", Ct$2 = "wc", It$3 = "universal_provider", $e$4 = `${Ct$2}@2:${It$3}:`, ye$1 = "https://rpc.walletconnect.org/v1/", w$1 = "generic", Ot$3 = `${ye$1}bundler`, f$5 = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
var G$3 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global$1 < "u" ? global$1 : typeof self < "u" ? self : {};
function At$4() {
  this.__data__ = [], this.size = 0;
}
var jt$3 = At$4;
function Ht$4(r3, e3) {
  return r3 === e3 || r3 !== r3 && e3 !== e3;
}
var z$6 = Ht$4, Et$5 = z$6;
function St$5(r3, e3) {
  for (var t2 = r3.length; t2--; ) if (Et$5(r3[t2][0], e3)) return t2;
  return -1;
}
var k$3 = St$5, Nt$4 = k$3, Tt$4 = Array.prototype, Dt$4 = Tt$4.splice;
function qt$4(r3) {
  var e3 = this.__data__, t2 = Nt$4(e3, r3);
  if (t2 < 0) return false;
  var i4 = e3.length - 1;
  return t2 == i4 ? e3.pop() : Dt$4.call(e3, t2, 1), --this.size, true;
}
var Rt$4 = qt$4, xt$4 = k$3;
function Lt$4(r3) {
  var e3 = this.__data__, t2 = xt$4(e3, r3);
  return t2 < 0 ? void 0 : e3[t2][1];
}
var Ut$4 = Lt$4, Ft$4 = k$3;
function Mt$4(r3) {
  return Ft$4(this.__data__, r3) > -1;
}
var Gt$4 = Mt$4, zt$4 = k$3;
function kt$3(r3, e3) {
  var t2 = this.__data__, i4 = zt$4(t2, r3);
  return i4 < 0 ? (++this.size, t2.push([r3, e3])) : t2[i4][1] = e3, this;
}
var Bt$4 = kt$3, Vt$4 = jt$3, Jt$4 = Rt$4, Kt$4 = Ut$4, Wt$4 = Gt$4, Xt$4 = Bt$4;
function _$5(r3) {
  var e3 = -1, t2 = r3 == null ? 0 : r3.length;
  for (this.clear(); ++e3 < t2; ) {
    var i4 = r3[e3];
    this.set(i4[0], i4[1]);
  }
}
_$5.prototype.clear = Vt$4, _$5.prototype.delete = Jt$4, _$5.prototype.get = Kt$4, _$5.prototype.has = Wt$4, _$5.prototype.set = Xt$4;
var B$4 = _$5, Yt$4 = B$4;
function Zt$4() {
  this.__data__ = new Yt$4(), this.size = 0;
}
var Qt$4 = Zt$4;
function er$4(r3) {
  var e3 = this.__data__, t2 = e3.delete(r3);
  return this.size = e3.size, t2;
}
var tr$4 = er$4;
function rr$4(r3) {
  return this.__data__.get(r3);
}
var ir$4 = rr$4;
function sr$4(r3) {
  return this.__data__.has(r3);
}
var nr$4 = sr$4, ar$4 = typeof G$3 == "object" && G$3 && G$3.Object === Object && G$3, we$4 = ar$4, or$4 = we$4, cr$4 = typeof self == "object" && self && self.Object === Object && self, hr$4 = or$4 || cr$4 || Function("return this")(), C$4 = hr$4, pr$4 = C$4, ur$4 = pr$4.Symbol, _e$5 = ur$4, Ce$3 = _e$5, Ie$3 = Object.prototype, lr$4 = Ie$3.hasOwnProperty, dr$4 = Ie$3.toString, F$4 = Ce$3 ? Ce$3.toStringTag : void 0;
function vr$4(r3) {
  var e3 = lr$4.call(r3, F$4), t2 = r3[F$4];
  try {
    r3[F$4] = void 0;
    var i4 = true;
  } catch {
  }
  var s2 = dr$4.call(r3);
  return i4 && (e3 ? r3[F$4] = t2 : delete r3[F$4]), s2;
}
var fr$4 = vr$4, mr$4 = Object.prototype, gr$4 = mr$4.toString;
function Pr$3(r3) {
  return gr$4.call(r3);
}
var br$4 = Pr$3, Oe$4 = _e$5, $r$4 = fr$4, yr$4 = br$4, wr$4 = "[object Null]", _r$4 = "[object Undefined]", Ae$4 = Oe$4 ? Oe$4.toStringTag : void 0;
function Cr$3(r3) {
  return r3 == null ? r3 === void 0 ? _r$4 : wr$4 : Ae$4 && Ae$4 in Object(r3) ? $r$4(r3) : yr$4(r3);
}
var V$6 = Cr$3;
function Ir$4(r3) {
  var e3 = typeof r3;
  return r3 != null && (e3 == "object" || e3 == "function");
}
var $$5 = Ir$4, Or$4 = V$6, Ar$4 = $$5, jr$2 = "[object AsyncFunction]", Hr$4 = "[object Function]", Er$4 = "[object GeneratorFunction]", Sr$4 = "[object Proxy]";
function Nr$4(r3) {
  if (!Ar$4(r3)) return false;
  var e3 = Or$4(r3);
  return e3 == Hr$4 || e3 == Er$4 || e3 == jr$2 || e3 == Sr$4;
}
var te$3 = Nr$4, Tr$4 = C$4, Dr$3 = Tr$4["__core-js_shared__"], qr$4 = Dr$3, re$4 = qr$4, je$4 = function() {
  var r3 = /[^.]+$/.exec(re$4 && re$4.keys && re$4.keys.IE_PROTO || "");
  return r3 ? "Symbol(src)_1." + r3 : "";
}();
function Rr$4(r3) {
  return !!je$4 && je$4 in r3;
}
var xr$4 = Rr$4, Lr$3 = Function.prototype, Ur$4 = Lr$3.toString;
function Fr$4(r3) {
  if (r3 != null) {
    try {
      return Ur$4.call(r3);
    } catch {
    }
    try {
      return r3 + "";
    } catch {
    }
  }
  return "";
}
var Mr$4 = Fr$4, Gr$4 = te$3, zr$4 = xr$4, kr$3 = $$5, Br$3 = Mr$4, Vr$4 = /[\\^$.*+?()[\]{}|]/g, Jr$4 = /^\[object .+?Constructor\]$/, Kr$4 = Function.prototype, Wr$4 = Object.prototype, Xr$4 = Kr$4.toString, Yr$4 = Wr$4.hasOwnProperty, Zr$4 = RegExp("^" + Xr$4.call(Yr$4).replace(Vr$4, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function Qr$4(r3) {
  if (!kr$3(r3) || zr$4(r3)) return false;
  var e3 = Gr$4(r3) ? Zr$4 : Jr$4;
  return e3.test(Br$3(r3));
}
var ei$4 = Qr$4;
function ti$4(r3, e3) {
  return r3 == null ? void 0 : r3[e3];
}
var ri$4 = ti$4, ii$4 = ei$4, si$4 = ri$4;
function ni$4(r3, e3) {
  var t2 = si$4(r3, e3);
  return ii$4(t2) ? t2 : void 0;
}
var ie$4 = ni$4, ai$4 = ie$4, oi$4 = C$4, ci$4 = ai$4(oi$4, "Map"), He$4 = ci$4, hi$4 = ie$4, pi$4 = hi$4(Object, "create"), J$4 = pi$4, Ee$4 = J$4;
function ui$4() {
  this.__data__ = Ee$4 ? Ee$4(null) : {}, this.size = 0;
}
var li$4 = ui$4;
function di$4(r3) {
  var e3 = this.has(r3) && delete this.__data__[r3];
  return this.size -= e3 ? 1 : 0, e3;
}
var vi$4 = di$4, fi$4 = J$4, mi$4 = "__lodash_hash_undefined__", gi$4 = Object.prototype, Pi$4 = gi$4.hasOwnProperty;
function bi$4(r3) {
  var e3 = this.__data__;
  if (fi$4) {
    var t2 = e3[r3];
    return t2 === mi$4 ? void 0 : t2;
  }
  return Pi$4.call(e3, r3) ? e3[r3] : void 0;
}
var $i$4 = bi$4, yi$4 = J$4, wi$4 = Object.prototype, _i$4 = wi$4.hasOwnProperty;
function Ci$4(r3) {
  var e3 = this.__data__;
  return yi$4 ? e3[r3] !== void 0 : _i$4.call(e3, r3);
}
var Ii$4 = Ci$4, Oi$4 = J$4, Ai$4 = "__lodash_hash_undefined__";
function ji$3(r3, e3) {
  var t2 = this.__data__;
  return this.size += this.has(r3) ? 0 : 1, t2[r3] = Oi$4 && e3 === void 0 ? Ai$4 : e3, this;
}
var Hi$3 = ji$3, Ei$4 = li$4, Si$4 = vi$4, Ni$4 = $i$4, Ti$4 = Ii$4, Di$4 = Hi$3;
function I$3(r3) {
  var e3 = -1, t2 = r3 == null ? 0 : r3.length;
  for (this.clear(); ++e3 < t2; ) {
    var i4 = r3[e3];
    this.set(i4[0], i4[1]);
  }
}
I$3.prototype.clear = Ei$4, I$3.prototype.delete = Si$4, I$3.prototype.get = Ni$4, I$3.prototype.has = Ti$4, I$3.prototype.set = Di$4;
var qi$3 = I$3, Se$4 = qi$3, Ri$4 = B$4, xi$4 = He$4;
function Li$4() {
  this.size = 0, this.__data__ = { hash: new Se$4(), map: new (xi$4 || Ri$4)(), string: new Se$4() };
}
var Ui$3 = Li$4;
function Fi$3(r3) {
  var e3 = typeof r3;
  return e3 == "string" || e3 == "number" || e3 == "symbol" || e3 == "boolean" ? r3 !== "__proto__" : r3 === null;
}
var Mi$3 = Fi$3, Gi$3 = Mi$3;
function zi$4(r3, e3) {
  var t2 = r3.__data__;
  return Gi$3(e3) ? t2[typeof e3 == "string" ? "string" : "hash"] : t2.map;
}
var K$2 = zi$4, ki$3 = K$2;
function Bi$3(r3) {
  var e3 = ki$3(this, r3).delete(r3);
  return this.size -= e3 ? 1 : 0, e3;
}
var Vi$3 = Bi$3, Ji$3 = K$2;
function Ki$3(r3) {
  return Ji$3(this, r3).get(r3);
}
var Wi$3 = Ki$3, Xi$3 = K$2;
function Yi$3(r3) {
  return Xi$3(this, r3).has(r3);
}
var Zi$3 = Yi$3, Qi$2 = K$2;
function es$3(r3, e3) {
  var t2 = Qi$2(this, r3), i4 = t2.size;
  return t2.set(r3, e3), this.size += t2.size == i4 ? 0 : 1, this;
}
var ts$3 = es$3, rs$3 = Ui$3, is$3 = Vi$3, ss$3 = Wi$3, ns$3 = Zi$3, as$3 = ts$3;
function O$2(r3) {
  var e3 = -1, t2 = r3 == null ? 0 : r3.length;
  for (this.clear(); ++e3 < t2; ) {
    var i4 = r3[e3];
    this.set(i4[0], i4[1]);
  }
}
O$2.prototype.clear = rs$3, O$2.prototype.delete = is$3, O$2.prototype.get = ss$3, O$2.prototype.has = ns$3, O$2.prototype.set = as$3;
var os$3 = O$2, cs$3 = B$4, hs$3 = He$4, ps$3 = os$3, us$3 = 200;
function ls$3(r3, e3) {
  var t2 = this.__data__;
  if (t2 instanceof cs$3) {
    var i4 = t2.__data__;
    if (!hs$3 || i4.length < us$3 - 1) return i4.push([r3, e3]), this.size = ++t2.size, this;
    t2 = this.__data__ = new ps$3(i4);
  }
  return t2.set(r3, e3), this.size = t2.size, this;
}
var ds$3 = ls$3, vs$4 = B$4, fs$4 = Qt$4, ms$3 = tr$4, gs$3 = ir$4, Ps$4 = nr$4, bs$4 = ds$3;
function A$3(r3) {
  var e3 = this.__data__ = new vs$4(r3);
  this.size = e3.size;
}
A$3.prototype.clear = fs$4, A$3.prototype.delete = ms$3, A$3.prototype.get = gs$3, A$3.prototype.has = Ps$4, A$3.prototype.set = bs$4;
var $s$3 = A$3, ys$3 = ie$4, ws$3 = function() {
  try {
    var r3 = ys$3(Object, "defineProperty");
    return r3({}, "", {}), r3;
  } catch {
  }
}(), Ne$4 = ws$3, Te$3 = Ne$4;
function _s$3(r3, e3, t2) {
  e3 == "__proto__" && Te$3 ? Te$3(r3, e3, { configurable: true, enumerable: true, value: t2, writable: true }) : r3[e3] = t2;
}
var se$4 = _s$3, Cs$4 = se$4, Is$4 = z$6;
function Os$4(r3, e3, t2) {
  (t2 !== void 0 && !Is$4(r3[e3], t2) || t2 === void 0 && !(e3 in r3)) && Cs$4(r3, e3, t2);
}
var De$4 = Os$4;
function As$4(r3) {
  return function(e3, t2, i4) {
    for (var s2 = -1, n5 = Object(e3), a2 = i4(e3), o3 = a2.length; o3--; ) {
      var c2 = a2[r3 ? o3 : ++s2];
      if (t2(n5[c2], c2, n5) === false) break;
    }
    return e3;
  };
}
var js$4 = As$4, Hs$4 = js$4, Es$3 = Hs$4(), Ss$3 = Es$3, ne$4 = { exports: {} };
(function(r3, e3) {
  var t2 = C$4, i4 = e3 && !e3.nodeType && e3, s2 = i4 && true && r3 && !r3.nodeType && r3, n5 = s2 && s2.exports === i4, a2 = n5 ? t2.Buffer : void 0, o3 = a2 ? a2.allocUnsafe : void 0;
  function c2(u2, l2) {
    if (l2) return u2.slice();
    var P3 = u2.length, d4 = o3 ? o3(P3) : new u2.constructor(P3);
    return u2.copy(d4), d4;
  }
  r3.exports = c2;
})(ne$4, ne$4.exports);
var Ns$4 = C$4, Ts$4 = Ns$4.Uint8Array, Ds$4 = Ts$4, qe$4 = Ds$4;
function qs$5(r3) {
  var e3 = new r3.constructor(r3.byteLength);
  return new qe$4(e3).set(new qe$4(r3)), e3;
}
var Rs$4 = qs$5, xs$4 = Rs$4;
function Ls$4(r3, e3) {
  var t2 = e3 ? xs$4(r3.buffer) : r3.buffer;
  return new r3.constructor(t2, r3.byteOffset, r3.length);
}
var Us$3 = Ls$4;
function Fs$3(r3, e3) {
  var t2 = -1, i4 = r3.length;
  for (e3 || (e3 = Array(i4)); ++t2 < i4; ) e3[t2] = r3[t2];
  return e3;
}
var Ms$3 = Fs$3, Gs$4 = $$5, Re$3 = Object.create, zs$3 = /* @__PURE__ */ function() {
  function r3() {
  }
  return function(e3) {
    if (!Gs$4(e3)) return {};
    if (Re$3) return Re$3(e3);
    r3.prototype = e3;
    var t2 = new r3();
    return r3.prototype = void 0, t2;
  };
}(), ks$3 = zs$3;
function Bs$3(r3, e3) {
  return function(t2) {
    return r3(e3(t2));
  };
}
var Vs$4 = Bs$3, Js$4 = Vs$4, Ks$3 = Js$4(Object.getPrototypeOf, Object), xe$4 = Ks$3, Ws$4 = Object.prototype;
function Xs$4(r3) {
  var e3 = r3 && r3.constructor, t2 = typeof e3 == "function" && e3.prototype || Ws$4;
  return r3 === t2;
}
var Le$5 = Xs$4, Ys$4 = ks$3, Zs$4 = xe$4, Qs$4 = Le$5;
function en$4(r3) {
  return typeof r3.constructor == "function" && !Qs$4(r3) ? Ys$4(Zs$4(r3)) : {};
}
var tn$4 = en$4;
function rn$4(r3) {
  return r3 != null && typeof r3 == "object";
}
var M$5 = rn$4, sn$4 = V$6, nn$4 = M$5, an$4 = "[object Arguments]";
function on$4(r3) {
  return nn$4(r3) && sn$4(r3) == an$4;
}
var cn$4 = on$4, Ue$5 = cn$4, hn$4 = M$5, Fe$5 = Object.prototype, pn$4 = Fe$5.hasOwnProperty, un$4 = Fe$5.propertyIsEnumerable, ln$4 = Ue$5(/* @__PURE__ */ function() {
  return arguments;
}()) ? Ue$5 : function(r3) {
  return hn$4(r3) && pn$4.call(r3, "callee") && !un$4.call(r3, "callee");
}, Me$5 = ln$4, dn$4 = Array.isArray, Ge$4 = dn$4, vn$4 = 9007199254740991;
function fn$4(r3) {
  return typeof r3 == "number" && r3 > -1 && r3 % 1 == 0 && r3 <= vn$4;
}
var ze$3 = fn$4, mn$4 = te$3, gn$4 = ze$3;
function Pn$4(r3) {
  return r3 != null && gn$4(r3.length) && !mn$4(r3);
}
var ae$4 = Pn$4, bn$4 = ae$4, $n$4 = M$5;
function yn$4(r3) {
  return $n$4(r3) && bn$4(r3);
}
var wn$4 = yn$4, W$2 = { exports: {} };
function _n$4() {
  return false;
}
var Cn$4 = _n$4;
(function(r3, e3) {
  var t2 = C$4, i4 = Cn$4, s2 = e3 && !e3.nodeType && e3, n5 = s2 && true && r3 && !r3.nodeType && r3, a2 = n5 && n5.exports === s2, o3 = a2 ? t2.Buffer : void 0, c2 = o3 ? o3.isBuffer : void 0, u2 = c2 || i4;
  r3.exports = u2;
})(W$2, W$2.exports);
var In$4 = V$6, On$4 = xe$4, An$4 = M$5, jn$4 = "[object Object]", Hn$4 = Function.prototype, En$4 = Object.prototype, ke$5 = Hn$4.toString, Sn$4 = En$4.hasOwnProperty, Nn$4 = ke$5.call(Object);
function Tn$4(r3) {
  if (!An$4(r3) || In$4(r3) != jn$4) return false;
  var e3 = On$4(r3);
  if (e3 === null) return true;
  var t2 = Sn$4.call(e3, "constructor") && e3.constructor;
  return typeof t2 == "function" && t2 instanceof t2 && ke$5.call(t2) == Nn$4;
}
var Dn$4 = Tn$4, qn$4 = V$6, Rn$4 = ze$3, xn$4 = M$5, Ln$4 = "[object Arguments]", Un$4 = "[object Array]", Fn$4 = "[object Boolean]", Mn$4 = "[object Date]", Gn$4 = "[object Error]", zn$4 = "[object Function]", kn$4 = "[object Map]", Bn$4 = "[object Number]", Vn$4 = "[object Object]", Jn$4 = "[object RegExp]", Kn$4 = "[object Set]", Wn$4 = "[object String]", Xn$4 = "[object WeakMap]", Yn$4 = "[object ArrayBuffer]", Zn$4 = "[object DataView]", Qn$4 = "[object Float32Array]", ea$2 = "[object Float64Array]", ta$2 = "[object Int8Array]", ra$2 = "[object Int16Array]", ia$2 = "[object Int32Array]", sa$2 = "[object Uint8Array]", na$2 = "[object Uint8ClampedArray]", aa$2 = "[object Uint16Array]", oa$2 = "[object Uint32Array]", p$5 = {};
p$5[Qn$4] = p$5[ea$2] = p$5[ta$2] = p$5[ra$2] = p$5[ia$2] = p$5[sa$2] = p$5[na$2] = p$5[aa$2] = p$5[oa$2] = true, p$5[Ln$4] = p$5[Un$4] = p$5[Yn$4] = p$5[Fn$4] = p$5[Zn$4] = p$5[Mn$4] = p$5[Gn$4] = p$5[zn$4] = p$5[kn$4] = p$5[Bn$4] = p$5[Vn$4] = p$5[Jn$4] = p$5[Kn$4] = p$5[Wn$4] = p$5[Xn$4] = false;
function ca$2(r3) {
  return xn$4(r3) && Rn$4(r3.length) && !!p$5[qn$4(r3)];
}
var ha$2 = ca$2;
function pa$2(r3) {
  return function(e3) {
    return r3(e3);
  };
}
var ua$2 = pa$2, oe$3 = { exports: {} };
(function(r3, e3) {
  var t2 = we$4, i4 = e3 && !e3.nodeType && e3, s2 = i4 && true && r3 && !r3.nodeType && r3, n5 = s2 && s2.exports === i4, a2 = n5 && t2.process, o3 = function() {
    try {
      var c2 = s2 && s2.require && s2.require("util").types;
      return c2 || a2 && a2.binding && a2.binding("util");
    } catch {
    }
  }();
  r3.exports = o3;
})(oe$3, oe$3.exports);
var la$2 = ha$2, da$2 = ua$2, Be$4 = oe$3.exports, Ve$4 = Be$4 && Be$4.isTypedArray, va$2 = Ve$4 ? da$2(Ve$4) : la$2, Je$2 = va$2;
function fa$2(r3, e3) {
  if (!(e3 === "constructor" && typeof r3[e3] == "function") && e3 != "__proto__") return r3[e3];
}
var Ke$5 = fa$2, ma$2 = se$4, ga$2 = z$6, Pa$2 = Object.prototype, ba$2 = Pa$2.hasOwnProperty;
function $a$2(r3, e3, t2) {
  var i4 = r3[e3];
  (!(ba$2.call(r3, e3) && ga$2(i4, t2)) || t2 === void 0 && !(e3 in r3)) && ma$2(r3, e3, t2);
}
var ya$2 = $a$2, wa$2 = ya$2, _a$2 = se$4;
function Ca$2(r3, e3, t2, i4) {
  var s2 = !t2;
  t2 || (t2 = {});
  for (var n5 = -1, a2 = e3.length; ++n5 < a2; ) {
    var o3 = e3[n5], c2 = i4 ? i4(t2[o3], r3[o3], o3, t2, r3) : void 0;
    c2 === void 0 && (c2 = r3[o3]), s2 ? _a$2(t2, o3, c2) : wa$2(t2, o3, c2);
  }
  return t2;
}
var Ia$2 = Ca$2;
function Oa$2(r3, e3) {
  for (var t2 = -1, i4 = Array(r3); ++t2 < r3; ) i4[t2] = e3(t2);
  return i4;
}
var Aa$2 = Oa$2, ja$2 = 9007199254740991, Ha$2 = /^(?:0|[1-9]\d*)$/;
function Ea$2(r3, e3) {
  var t2 = typeof r3;
  return e3 = e3 ?? ja$2, !!e3 && (t2 == "number" || t2 != "symbol" && Ha$2.test(r3)) && r3 > -1 && r3 % 1 == 0 && r3 < e3;
}
var We$2 = Ea$2, Sa$2 = Aa$2, Na$2 = Me$5, Ta$2 = Ge$4, Da$2 = W$2.exports, qa$2 = We$2, Ra$2 = Je$2, xa$2 = Object.prototype, La$2 = xa$2.hasOwnProperty;
function Ua$2(r3, e3) {
  var t2 = Ta$2(r3), i4 = !t2 && Na$2(r3), s2 = !t2 && !i4 && Da$2(r3), n5 = !t2 && !i4 && !s2 && Ra$2(r3), a2 = t2 || i4 || s2 || n5, o3 = a2 ? Sa$2(r3.length, String) : [], c2 = o3.length;
  for (var u2 in r3) (e3 || La$2.call(r3, u2)) && !(a2 && (u2 == "length" || s2 && (u2 == "offset" || u2 == "parent") || n5 && (u2 == "buffer" || u2 == "byteLength" || u2 == "byteOffset") || qa$2(u2, c2))) && o3.push(u2);
  return o3;
}
var Fa$2 = Ua$2;
function Ma$2(r3) {
  var e3 = [];
  if (r3 != null) for (var t2 in Object(r3)) e3.push(t2);
  return e3;
}
var Ga$2 = Ma$2, za$2 = $$5, ka$2 = Le$5, Ba$2 = Ga$2, Va$2 = Object.prototype, Ja$2 = Va$2.hasOwnProperty;
function Ka$2(r3) {
  if (!za$2(r3)) return Ba$2(r3);
  var e3 = ka$2(r3), t2 = [];
  for (var i4 in r3) i4 == "constructor" && (e3 || !Ja$2.call(r3, i4)) || t2.push(i4);
  return t2;
}
var Wa$2 = Ka$2, Xa$2 = Fa$2, Ya$2 = Wa$2, Za$2 = ae$4;
function Qa$2(r3) {
  return Za$2(r3) ? Xa$2(r3, true) : Ya$2(r3);
}
var Xe$3 = Qa$2, eo$4 = Ia$2, to$4 = Xe$3;
function ro$4(r3) {
  return eo$4(r3, to$4(r3));
}
var io$4 = ro$4, Ye$3 = De$4, so$4 = ne$4.exports, no$4 = Us$3, ao$4 = Ms$3, oo$4 = tn$4, Ze$3 = Me$5, Qe$3 = Ge$4, co$3 = wn$4, ho$3 = W$2.exports, po$3 = te$3, uo$3 = $$5, lo$3 = Dn$4, vo$3 = Je$2, et$3 = Ke$5, fo$3 = io$4;
function mo$3(r3, e3, t2, i4, s2, n5, a2) {
  var o3 = et$3(r3, t2), c2 = et$3(e3, t2), u2 = a2.get(c2);
  if (u2) {
    Ye$3(r3, t2, u2);
    return;
  }
  var l2 = n5 ? n5(o3, c2, t2 + "", r3, e3, a2) : void 0, P3 = l2 === void 0;
  if (P3) {
    var d4 = Qe$3(c2), Q2 = !d4 && ho$3(c2), ve2 = !d4 && !Q2 && vo$3(c2);
    l2 = c2, d4 || Q2 || ve2 ? Qe$3(o3) ? l2 = o3 : co$3(o3) ? l2 = ao$4(o3) : Q2 ? (P3 = false, l2 = so$4(c2, true)) : ve2 ? (P3 = false, l2 = no$4(c2, true)) : l2 = [] : lo$3(c2) || Ze$3(c2) ? (l2 = o3, Ze$3(o3) ? l2 = fo$3(o3) : (!uo$3(o3) || po$3(o3)) && (l2 = oo$4(c2))) : P3 = false;
  }
  P3 && (a2.set(c2, l2), s2(l2, c2, i4, n5, a2), a2.delete(c2)), Ye$3(r3, t2, l2);
}
var go$3 = mo$3, Po$3 = $s$3, bo$3 = De$4, $o$3 = Ss$3, yo$3 = go$3, wo$3 = $$5, _o$3 = Xe$3, Co$3 = Ke$5;
function tt$3(r3, e3, t2, i4, s2) {
  r3 !== e3 && $o$3(e3, function(n5, a2) {
    if (s2 || (s2 = new Po$3()), wo$3(n5)) yo$3(r3, e3, a2, t2, tt$3, i4, s2);
    else {
      var o3 = i4 ? i4(Co$3(r3, a2), n5, a2 + "", r3, e3, s2) : void 0;
      o3 === void 0 && (o3 = n5), bo$3(r3, a2, o3);
    }
  }, _o$3);
}
var Io$3 = tt$3;
function Oo$3(r3) {
  return r3;
}
var rt$3 = Oo$3;
function Ao$3(r3, e3, t2) {
  switch (t2.length) {
    case 0:
      return r3.call(e3);
    case 1:
      return r3.call(e3, t2[0]);
    case 2:
      return r3.call(e3, t2[0], t2[1]);
    case 3:
      return r3.call(e3, t2[0], t2[1], t2[2]);
  }
  return r3.apply(e3, t2);
}
var jo$3 = Ao$3, Ho$3 = jo$3, it$3 = Math.max;
function Eo$3(r3, e3, t2) {
  return e3 = it$3(e3 === void 0 ? r3.length - 1 : e3, 0), function() {
    for (var i4 = arguments, s2 = -1, n5 = it$3(i4.length - e3, 0), a2 = Array(n5); ++s2 < n5; ) a2[s2] = i4[e3 + s2];
    s2 = -1;
    for (var o3 = Array(e3 + 1); ++s2 < e3; ) o3[s2] = i4[s2];
    return o3[e3] = t2(a2), Ho$3(r3, this, o3);
  };
}
var So$3 = Eo$3;
function No$3(r3) {
  return function() {
    return r3;
  };
}
var To$3 = No$3, Do$3 = To$3, st$3 = Ne$4, qo$3 = rt$3, Ro$3 = st$3 ? function(r3, e3) {
  return st$3(r3, "toString", { configurable: true, enumerable: false, value: Do$3(e3), writable: true });
} : qo$3, xo$3 = Ro$3, Lo$3 = 800, Uo$3 = 16, Fo$3 = Date.now;
function Mo$3(r3) {
  var e3 = 0, t2 = 0;
  return function() {
    var i4 = Fo$3(), s2 = Uo$3 - (i4 - t2);
    if (t2 = i4, s2 > 0) {
      if (++e3 >= Lo$3) return arguments[0];
    } else e3 = 0;
    return r3.apply(void 0, arguments);
  };
}
var Go$3 = Mo$3, zo$3 = xo$3, ko$3 = Go$3, Bo$3 = ko$3(zo$3), Vo$3 = Bo$3, Jo$3 = rt$3, Ko$3 = So$3, Wo$3 = Vo$3;
function Xo$3(r3, e3) {
  return Wo$3(Ko$3(r3, e3, Jo$3), r3 + "");
}
var Yo$3 = Xo$3, Zo$3 = z$6, Qo$3 = ae$4, ec$2 = We$2, tc$2 = $$5;
function rc$2(r3, e3, t2) {
  if (!tc$2(t2)) return false;
  var i4 = typeof e3;
  return (i4 == "number" ? Qo$3(t2) && ec$2(e3, t2.length) : i4 == "string" && e3 in t2) ? Zo$3(t2[e3], r3) : false;
}
var ic$2 = rc$2, sc$2 = Yo$3, nc$2 = ic$2;
function ac$2(r3) {
  return sc$2(function(e3, t2) {
    var i4 = -1, s2 = t2.length, n5 = s2 > 1 ? t2[s2 - 1] : void 0, a2 = s2 > 2 ? t2[2] : void 0;
    for (n5 = r3.length > 3 && typeof n5 == "function" ? (s2--, n5) : void 0, a2 && nc$2(t2[0], t2[1], a2) && (n5 = s2 < 3 ? void 0 : n5, s2 = 1), e3 = Object(e3); ++i4 < s2; ) {
      var o3 = t2[i4];
      o3 && r3(e3, o3, i4, n5);
    }
    return e3;
  });
}
var oc$2 = ac$2, cc$2 = Io$3, hc$2 = oc$2, pc$1 = hc$2(function(r3, e3, t2) {
  cc$2(r3, e3, t2);
}), uc$1 = pc$1, lc$1 = Object.defineProperty, dc$1 = Object.defineProperties, vc$1 = Object.getOwnPropertyDescriptors, nt$2 = Object.getOwnPropertySymbols, fc$1 = Object.prototype.hasOwnProperty, mc$1 = Object.prototype.propertyIsEnumerable, at$2 = (r3, e3, t2) => e3 in r3 ? lc$1(r3, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r3[e3] = t2, X$1 = (r3, e3) => {
  for (var t2 in e3 || (e3 = {})) fc$1.call(e3, t2) && at$2(r3, t2, e3[t2]);
  if (nt$2) for (var t2 of nt$2(e3)) mc$1.call(e3, t2) && at$2(r3, t2, e3[t2]);
  return r3;
}, gc$1 = (r3, e3) => dc$1(r3, vc$1(e3));
function v$3(r3, e3, t2) {
  var i4;
  const s2 = Ye$4(r3);
  return ((i4 = e3.rpcMap) == null ? void 0 : i4[s2.reference]) || `${ye$1}?chainId=${s2.namespace}:${s2.reference}&projectId=${t2}`;
}
function y$3(r3) {
  return r3.includes(":") ? r3.split(":")[1] : r3;
}
function ot$2(r3) {
  return r3.map((e3) => `${e3.split(":")[0]}:${e3.split(":")[1]}`);
}
function Pc$1(r3, e3) {
  const t2 = Object.keys(e3.namespaces).filter((s2) => s2.includes(r3));
  if (!t2.length) return [];
  const i4 = [];
  return t2.forEach((s2) => {
    const n5 = e3.namespaces[s2].accounts;
    i4.push(...n5);
  }), i4;
}
function ce$3(r3 = {}, e3 = {}) {
  const t2 = ct$2(r3), i4 = ct$2(e3);
  return uc$1(t2, i4);
}
function ct$2(r3) {
  var e3, t2, i4, s2;
  const n5 = {};
  if (!qe$6(r3)) return n5;
  for (const [a2, o3] of Object.entries(r3)) {
    const c2 = Tt$6(a2) ? [a2] : o3.chains, u2 = o3.methods || [], l2 = o3.events || [], P3 = o3.rpcMap || {}, d4 = pr$6(a2);
    n5[d4] = gc$1(X$1(X$1({}, n5[d4]), o3), { chains: Q$3(c2, (e3 = n5[d4]) == null ? void 0 : e3.chains), methods: Q$3(u2, (t2 = n5[d4]) == null ? void 0 : t2.methods), events: Q$3(l2, (i4 = n5[d4]) == null ? void 0 : i4.events), rpcMap: X$1(X$1({}, P3), (s2 = n5[d4]) == null ? void 0 : s2.rpcMap) });
  }
  return n5;
}
function bc$1(r3) {
  return r3.includes(":") ? r3.split(":")[2] : r3;
}
function ht$3(r3) {
  const e3 = {};
  for (const [t2, i4] of Object.entries(r3)) {
    const s2 = i4.methods || [], n5 = i4.events || [], a2 = i4.accounts || [], o3 = Tt$6(t2) ? [t2] : i4.chains ? i4.chains : ot$2(i4.accounts);
    e3[t2] = { chains: o3, methods: s2, events: n5, accounts: a2 };
  }
  return e3;
}
function he$1(r3) {
  return typeof r3 == "number" ? r3 : r3.includes("0x") ? parseInt(r3, 16) : (r3 = r3.includes(":") ? r3.split(":")[1] : r3, isNaN(Number(r3)) ? r3 : Number(r3));
}
const pt$3 = {}, h$5 = (r3) => pt$3[r3], pe$2 = (r3, e3) => {
  pt$3[r3] = e3;
};
var $c$1 = Object.defineProperty, yc$1 = (r3, e3, t2) => e3 in r3 ? $c$1(r3, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r3[e3] = t2, j$2 = (r3, e3, t2) => yc$1(r3, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let wc$1 = class wc2 {
  constructor(e3) {
    j$2(this, "name", "polkadot"), j$2(this, "client"), j$2(this, "httpProviders"), j$2(this, "events"), j$2(this, "namespace"), j$2(this, "chainId"), this.namespace = e3.namespace, this.events = h$5("events"), this.client = h$5("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e3) {
    this.namespace = Object.assign(this.namespace, e3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e3 = this.namespace.chains[0];
    if (!e3) throw new Error("ChainId not found");
    return e3.split(":")[1];
  }
  request(e3) {
    return this.namespace.methods.includes(e3.request.method) ? this.client.request(e3) : this.getHttpProvider().request(e3.request);
  }
  setDefaultChain(e3, t2) {
    this.httpProviders[e3] || this.setHttpProvider(e3, t2), this.chainId = e3, this.events.emit(f$5.DEFAULT_CHAIN_CHANGED, `${this.name}:${e3}`);
  }
  getAccounts() {
    const e3 = this.namespace.accounts;
    return e3 ? e3.filter((t2) => t2.split(":")[1] === this.chainId.toString()).map((t2) => t2.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const e3 = {};
    return this.namespace.chains.forEach((t2) => {
      var i4;
      const s2 = y$3(t2);
      e3[s2] = this.createHttpProvider(s2, (i4 = this.namespace.rpcMap) == null ? void 0 : i4[t2]);
    }), e3;
  }
  getHttpProvider() {
    const e3 = `${this.name}:${this.chainId}`, t2 = this.httpProviders[e3];
    if (typeof t2 > "u") throw new Error(`JSON-RPC provider for ${e3} not found`);
    return t2;
  }
  setHttpProvider(e3, t2) {
    const i4 = this.createHttpProvider(e3, t2);
    i4 && (this.httpProviders[e3] = i4);
  }
  createHttpProvider(e3, t2) {
    const i4 = t2 || v$3(e3, this.namespace, this.client.core.projectId);
    if (!i4) throw new Error(`No RPC url provided for chainId: ${e3}`);
    return new o$9(new f$6(i4, h$5("disableProviderPing")));
  }
};
var _c$1 = Object.defineProperty, Cc$1 = Object.defineProperties, Ic$1 = Object.getOwnPropertyDescriptors, ut$4 = Object.getOwnPropertySymbols, Oc$1 = Object.prototype.hasOwnProperty, Ac$1 = Object.prototype.propertyIsEnumerable, ue$3 = (r3, e3, t2) => e3 in r3 ? _c$1(r3, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r3[e3] = t2, lt$2 = (r3, e3) => {
  for (var t2 in e3 || (e3 = {})) Oc$1.call(e3, t2) && ue$3(r3, t2, e3[t2]);
  if (ut$4) for (var t2 of ut$4(e3)) Ac$1.call(e3, t2) && ue$3(r3, t2, e3[t2]);
  return r3;
}, dt$3 = (r3, e3) => Cc$1(r3, Ic$1(e3)), H$4 = (r3, e3, t2) => ue$3(r3, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let jc$1 = class jc2 {
  constructor(e3) {
    H$4(this, "name", "eip155"), H$4(this, "client"), H$4(this, "chainId"), H$4(this, "namespace"), H$4(this, "httpProviders"), H$4(this, "events"), this.namespace = e3.namespace, this.events = h$5("events"), this.client = h$5("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
  }
  async request(e3) {
    switch (e3.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(e3);
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
      case "wallet_getCapabilities":
        return await this.getCapabilities(e3);
      case "wallet_getCallsStatus":
        return await this.getCallStatus(e3);
    }
    return this.namespace.methods.includes(e3.request.method) ? await this.client.request(e3) : this.getHttpProvider().request(e3.request);
  }
  updateNamespace(e3) {
    this.namespace = Object.assign(this.namespace, e3);
  }
  setDefaultChain(e3, t2) {
    this.httpProviders[e3] || this.setHttpProvider(parseInt(e3), t2), this.chainId = parseInt(e3), this.events.emit(f$5.DEFAULT_CHAIN_CHANGED, `${this.name}:${e3}`);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId.toString();
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e3 = this.namespace.chains[0];
    if (!e3) throw new Error("ChainId not found");
    return e3.split(":")[1];
  }
  createHttpProvider(e3, t2) {
    const i4 = t2 || v$3(`${this.name}:${e3}`, this.namespace, this.client.core.projectId);
    if (!i4) throw new Error(`No RPC url provided for chainId: ${e3}`);
    return new o$9(new f$6(i4, h$5("disableProviderPing")));
  }
  setHttpProvider(e3, t2) {
    const i4 = this.createHttpProvider(e3, t2);
    i4 && (this.httpProviders[e3] = i4);
  }
  createHttpProviders() {
    const e3 = {};
    return this.namespace.chains.forEach((t2) => {
      var i4;
      const s2 = parseInt(y$3(t2));
      e3[s2] = this.createHttpProvider(s2, (i4 = this.namespace.rpcMap) == null ? void 0 : i4[t2]);
    }), e3;
  }
  getAccounts() {
    const e3 = this.namespace.accounts;
    return e3 ? [...new Set(e3.filter((t2) => t2.split(":")[1] === this.chainId.toString()).map((t2) => t2.split(":")[2]))] : [];
  }
  getHttpProvider() {
    const e3 = this.chainId, t2 = this.httpProviders[e3];
    if (typeof t2 > "u") throw new Error(`JSON-RPC provider for ${e3} not found`);
    return t2;
  }
  async handleSwitchChain(e3) {
    var t2, i4;
    let s2 = e3.request.params ? (t2 = e3.request.params[0]) == null ? void 0 : t2.chainId : "0x0";
    s2 = s2.startsWith("0x") ? s2 : `0x${s2}`;
    const n5 = parseInt(s2, 16);
    if (this.isChainApproved(n5)) this.setDefaultChain(`${n5}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({ topic: e3.topic, request: { method: e3.request.method, params: [{ chainId: s2 }] }, chainId: (i4 = this.namespace.chains) == null ? void 0 : i4[0] }), this.setDefaultChain(`${n5}`);
    else throw new Error(`Failed to switch to chain 'eip155:${n5}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
    return null;
  }
  isChainApproved(e3) {
    return this.namespace.chains.includes(`${this.name}:${e3}`);
  }
  async getCapabilities(e3) {
    var t2, i4, s2;
    const n5 = (i4 = (t2 = e3.request) == null ? void 0 : t2.params) == null ? void 0 : i4[0];
    if (!n5) throw new Error("Missing address parameter in `wallet_getCapabilities` request");
    const a2 = this.client.session.get(e3.topic), o3 = ((s2 = a2 == null ? void 0 : a2.sessionProperties) == null ? void 0 : s2.capabilities) || {};
    if (o3 != null && o3[n5]) return o3 == null ? void 0 : o3[n5];
    const c2 = await this.client.request(e3);
    try {
      await this.client.session.update(e3.topic, { sessionProperties: dt$3(lt$2({}, a2.sessionProperties || {}), { capabilities: dt$3(lt$2({}, o3 || {}), { [n5]: c2 }) }) });
    } catch (u2) {
      console.warn("Failed to update session with capabilities", u2);
    }
    return c2;
  }
  async getCallStatus(e3) {
    var t2, i4;
    const s2 = this.client.session.get(e3.topic), n5 = (t2 = s2.sessionProperties) == null ? void 0 : t2.bundler_name;
    if (n5) {
      const o3 = this.getBundlerUrl(e3.chainId, n5);
      try {
        return await this.getUserOperationReceipt(o3, e3);
      } catch (c2) {
        console.warn("Failed to fetch call status from bundler", c2, o3);
      }
    }
    const a2 = (i4 = s2.sessionProperties) == null ? void 0 : i4.bundler_url;
    if (a2) try {
      return await this.getUserOperationReceipt(a2, e3);
    } catch (o3) {
      console.warn("Failed to fetch call status from custom bundler", o3, a2);
    }
    if (this.namespace.methods.includes(e3.request.method)) return await this.client.request(e3);
    throw new Error("Fetching call status not approved by the wallet.");
  }
  async getUserOperationReceipt(e3, t2) {
    var i4;
    const s2 = new URL(e3), n5 = await fetch(s2, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(formatJsonRpcRequest("eth_getUserOperationReceipt", [(i4 = t2.request.params) == null ? void 0 : i4[0]])) });
    if (!n5.ok) throw new Error(`Failed to fetch user operation receipt - ${n5.status}`);
    return await n5.json();
  }
  getBundlerUrl(e3, t2) {
    return `${Ot$3}?projectId=${this.client.core.projectId}&chainId=${e3}&bundler=${t2}`;
  }
};
var Hc$1 = Object.defineProperty, Ec$1 = (r3, e3, t2) => e3 in r3 ? Hc$1(r3, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r3[e3] = t2, E$3 = (r3, e3, t2) => Ec$1(r3, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let Sc$1 = class Sc2 {
  constructor(e3) {
    E$3(this, "name", "solana"), E$3(this, "client"), E$3(this, "httpProviders"), E$3(this, "events"), E$3(this, "namespace"), E$3(this, "chainId"), this.namespace = e3.namespace, this.events = h$5("events"), this.client = h$5("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e3) {
    this.namespace = Object.assign(this.namespace, e3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e3) {
    return this.namespace.methods.includes(e3.request.method) ? this.client.request(e3) : this.getHttpProvider().request(e3.request);
  }
  setDefaultChain(e3, t2) {
    this.httpProviders[e3] || this.setHttpProvider(e3, t2), this.chainId = e3, this.events.emit(f$5.DEFAULT_CHAIN_CHANGED, `${this.name}:${e3}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e3 = this.namespace.chains[0];
    if (!e3) throw new Error("ChainId not found");
    return e3.split(":")[1];
  }
  getAccounts() {
    const e3 = this.namespace.accounts;
    return e3 ? [...new Set(e3.filter((t2) => t2.split(":")[1] === this.chainId.toString()).map((t2) => t2.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e3 = {};
    return this.namespace.chains.forEach((t2) => {
      var i4;
      const s2 = y$3(t2);
      e3[s2] = this.createHttpProvider(s2, (i4 = this.namespace.rpcMap) == null ? void 0 : i4[t2]);
    }), e3;
  }
  getHttpProvider() {
    const e3 = `${this.name}:${this.chainId}`, t2 = this.httpProviders[e3];
    if (typeof t2 > "u") throw new Error(`JSON-RPC provider for ${e3} not found`);
    return t2;
  }
  setHttpProvider(e3, t2) {
    const i4 = this.createHttpProvider(e3, t2);
    i4 && (this.httpProviders[e3] = i4);
  }
  createHttpProvider(e3, t2) {
    const i4 = t2 || v$3(e3, this.namespace, this.client.core.projectId);
    if (!i4) throw new Error(`No RPC url provided for chainId: ${e3}`);
    return new o$9(new f$6(i4, h$5("disableProviderPing")));
  }
};
var Nc$1 = Object.defineProperty, Tc$1 = (r3, e3, t2) => e3 in r3 ? Nc$1(r3, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r3[e3] = t2, S$4 = (r3, e3, t2) => Tc$1(r3, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let Dc$1 = class Dc2 {
  constructor(e3) {
    S$4(this, "name", "cosmos"), S$4(this, "client"), S$4(this, "httpProviders"), S$4(this, "events"), S$4(this, "namespace"), S$4(this, "chainId"), this.namespace = e3.namespace, this.events = h$5("events"), this.client = h$5("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e3) {
    this.namespace = Object.assign(this.namespace, e3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e3 = this.namespace.chains[0];
    if (!e3) throw new Error("ChainId not found");
    return e3.split(":")[1];
  }
  request(e3) {
    return this.namespace.methods.includes(e3.request.method) ? this.client.request(e3) : this.getHttpProvider().request(e3.request);
  }
  setDefaultChain(e3, t2) {
    this.httpProviders[e3] || this.setHttpProvider(e3, t2), this.chainId = e3, this.events.emit(f$5.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e3 = this.namespace.accounts;
    return e3 ? [...new Set(e3.filter((t2) => t2.split(":")[1] === this.chainId.toString()).map((t2) => t2.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e3 = {};
    return this.namespace.chains.forEach((t2) => {
      var i4;
      const s2 = y$3(t2);
      e3[s2] = this.createHttpProvider(s2, (i4 = this.namespace.rpcMap) == null ? void 0 : i4[t2]);
    }), e3;
  }
  getHttpProvider() {
    const e3 = `${this.name}:${this.chainId}`, t2 = this.httpProviders[e3];
    if (typeof t2 > "u") throw new Error(`JSON-RPC provider for ${e3} not found`);
    return t2;
  }
  setHttpProvider(e3, t2) {
    const i4 = this.createHttpProvider(e3, t2);
    i4 && (this.httpProviders[e3] = i4);
  }
  createHttpProvider(e3, t2) {
    const i4 = t2 || v$3(e3, this.namespace, this.client.core.projectId);
    if (!i4) throw new Error(`No RPC url provided for chainId: ${e3}`);
    return new o$9(new f$6(i4, h$5("disableProviderPing")));
  }
};
var qc$1 = Object.defineProperty, Rc$1 = (r3, e3, t2) => e3 in r3 ? qc$1(r3, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r3[e3] = t2, N$3 = (r3, e3, t2) => Rc$1(r3, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let xc$1 = class xc2 {
  constructor(e3) {
    N$3(this, "name", "algorand"), N$3(this, "client"), N$3(this, "httpProviders"), N$3(this, "events"), N$3(this, "namespace"), N$3(this, "chainId"), this.namespace = e3.namespace, this.events = h$5("events"), this.client = h$5("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e3) {
    this.namespace = Object.assign(this.namespace, e3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e3) {
    return this.namespace.methods.includes(e3.request.method) ? this.client.request(e3) : this.getHttpProvider().request(e3.request);
  }
  setDefaultChain(e3, t2) {
    if (!this.httpProviders[e3]) {
      const i4 = t2 || v$3(`${this.name}:${e3}`, this.namespace, this.client.core.projectId);
      if (!i4) throw new Error(`No RPC url provided for chainId: ${e3}`);
      this.setHttpProvider(e3, i4);
    }
    this.chainId = e3, this.events.emit(f$5.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e3 = this.namespace.chains[0];
    if (!e3) throw new Error("ChainId not found");
    return e3.split(":")[1];
  }
  getAccounts() {
    const e3 = this.namespace.accounts;
    return e3 ? [...new Set(e3.filter((t2) => t2.split(":")[1] === this.chainId.toString()).map((t2) => t2.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e3 = {};
    return this.namespace.chains.forEach((t2) => {
      var i4;
      e3[t2] = this.createHttpProvider(t2, (i4 = this.namespace.rpcMap) == null ? void 0 : i4[t2]);
    }), e3;
  }
  getHttpProvider() {
    const e3 = `${this.name}:${this.chainId}`, t2 = this.httpProviders[e3];
    if (typeof t2 > "u") throw new Error(`JSON-RPC provider for ${e3} not found`);
    return t2;
  }
  setHttpProvider(e3, t2) {
    const i4 = this.createHttpProvider(e3, t2);
    i4 && (this.httpProviders[e3] = i4);
  }
  createHttpProvider(e3, t2) {
    const i4 = t2 || v$3(e3, this.namespace, this.client.core.projectId);
    return typeof i4 > "u" ? void 0 : new o$9(new f$6(i4, h$5("disableProviderPing")));
  }
};
var Lc$1 = Object.defineProperty, Uc$1 = (r3, e3, t2) => e3 in r3 ? Lc$1(r3, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r3[e3] = t2, T$3 = (r3, e3, t2) => Uc$1(r3, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let Fc$1 = class Fc2 {
  constructor(e3) {
    T$3(this, "name", "cip34"), T$3(this, "client"), T$3(this, "httpProviders"), T$3(this, "events"), T$3(this, "namespace"), T$3(this, "chainId"), this.namespace = e3.namespace, this.events = h$5("events"), this.client = h$5("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e3) {
    this.namespace = Object.assign(this.namespace, e3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e3 = this.namespace.chains[0];
    if (!e3) throw new Error("ChainId not found");
    return e3.split(":")[1];
  }
  request(e3) {
    return this.namespace.methods.includes(e3.request.method) ? this.client.request(e3) : this.getHttpProvider().request(e3.request);
  }
  setDefaultChain(e3, t2) {
    this.httpProviders[e3] || this.setHttpProvider(e3, t2), this.chainId = e3, this.events.emit(f$5.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e3 = this.namespace.accounts;
    return e3 ? [...new Set(e3.filter((t2) => t2.split(":")[1] === this.chainId.toString()).map((t2) => t2.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e3 = {};
    return this.namespace.chains.forEach((t2) => {
      const i4 = this.getCardanoRPCUrl(t2), s2 = y$3(t2);
      e3[s2] = this.createHttpProvider(s2, i4);
    }), e3;
  }
  getHttpProvider() {
    const e3 = `${this.name}:${this.chainId}`, t2 = this.httpProviders[e3];
    if (typeof t2 > "u") throw new Error(`JSON-RPC provider for ${e3} not found`);
    return t2;
  }
  getCardanoRPCUrl(e3) {
    const t2 = this.namespace.rpcMap;
    if (t2) return t2[e3];
  }
  setHttpProvider(e3, t2) {
    const i4 = this.createHttpProvider(e3, t2);
    i4 && (this.httpProviders[e3] = i4);
  }
  createHttpProvider(e3, t2) {
    const i4 = t2 || this.getCardanoRPCUrl(e3);
    if (!i4) throw new Error(`No RPC url provided for chainId: ${e3}`);
    return new o$9(new f$6(i4, h$5("disableProviderPing")));
  }
};
var Mc$1 = Object.defineProperty, Gc$1 = (r3, e3, t2) => e3 in r3 ? Mc$1(r3, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r3[e3] = t2, D$1 = (r3, e3, t2) => Gc$1(r3, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let zc$1 = class zc2 {
  constructor(e3) {
    D$1(this, "name", "elrond"), D$1(this, "client"), D$1(this, "httpProviders"), D$1(this, "events"), D$1(this, "namespace"), D$1(this, "chainId"), this.namespace = e3.namespace, this.events = h$5("events"), this.client = h$5("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e3) {
    this.namespace = Object.assign(this.namespace, e3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e3) {
    return this.namespace.methods.includes(e3.request.method) ? this.client.request(e3) : this.getHttpProvider().request(e3.request);
  }
  setDefaultChain(e3, t2) {
    this.httpProviders[e3] || this.setHttpProvider(e3, t2), this.chainId = e3, this.events.emit(f$5.DEFAULT_CHAIN_CHANGED, `${this.name}:${e3}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e3 = this.namespace.chains[0];
    if (!e3) throw new Error("ChainId not found");
    return e3.split(":")[1];
  }
  getAccounts() {
    const e3 = this.namespace.accounts;
    return e3 ? [...new Set(e3.filter((t2) => t2.split(":")[1] === this.chainId.toString()).map((t2) => t2.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e3 = {};
    return this.namespace.chains.forEach((t2) => {
      var i4;
      const s2 = y$3(t2);
      e3[s2] = this.createHttpProvider(s2, (i4 = this.namespace.rpcMap) == null ? void 0 : i4[t2]);
    }), e3;
  }
  getHttpProvider() {
    const e3 = `${this.name}:${this.chainId}`, t2 = this.httpProviders[e3];
    if (typeof t2 > "u") throw new Error(`JSON-RPC provider for ${e3} not found`);
    return t2;
  }
  setHttpProvider(e3, t2) {
    const i4 = this.createHttpProvider(e3, t2);
    i4 && (this.httpProviders[e3] = i4);
  }
  createHttpProvider(e3, t2) {
    const i4 = t2 || v$3(e3, this.namespace, this.client.core.projectId);
    if (!i4) throw new Error(`No RPC url provided for chainId: ${e3}`);
    return new o$9(new f$6(i4, h$5("disableProviderPing")));
  }
};
var kc$1 = Object.defineProperty, Bc$1 = (r3, e3, t2) => e3 in r3 ? kc$1(r3, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r3[e3] = t2, q$3 = (r3, e3, t2) => Bc$1(r3, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let Vc$1 = class Vc2 {
  constructor(e3) {
    q$3(this, "name", "multiversx"), q$3(this, "client"), q$3(this, "httpProviders"), q$3(this, "events"), q$3(this, "namespace"), q$3(this, "chainId"), this.namespace = e3.namespace, this.events = h$5("events"), this.client = h$5("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e3) {
    this.namespace = Object.assign(this.namespace, e3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e3) {
    return this.namespace.methods.includes(e3.request.method) ? this.client.request(e3) : this.getHttpProvider().request(e3.request);
  }
  setDefaultChain(e3, t2) {
    this.httpProviders[e3] || this.setHttpProvider(e3, t2), this.chainId = e3, this.events.emit(f$5.DEFAULT_CHAIN_CHANGED, `${this.name}:${e3}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e3 = this.namespace.chains[0];
    if (!e3) throw new Error("ChainId not found");
    return e3.split(":")[1];
  }
  getAccounts() {
    const e3 = this.namespace.accounts;
    return e3 ? [...new Set(e3.filter((t2) => t2.split(":")[1] === this.chainId.toString()).map((t2) => t2.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e3 = {};
    return this.namespace.chains.forEach((t2) => {
      var i4;
      const s2 = y$3(t2);
      e3[s2] = this.createHttpProvider(s2, (i4 = this.namespace.rpcMap) == null ? void 0 : i4[t2]);
    }), e3;
  }
  getHttpProvider() {
    const e3 = `${this.name}:${this.chainId}`, t2 = this.httpProviders[e3];
    if (typeof t2 > "u") throw new Error(`JSON-RPC provider for ${e3} not found`);
    return t2;
  }
  setHttpProvider(e3, t2) {
    const i4 = this.createHttpProvider(e3, t2);
    i4 && (this.httpProviders[e3] = i4);
  }
  createHttpProvider(e3, t2) {
    const i4 = t2 || v$3(e3, this.namespace, this.client.core.projectId);
    if (!i4) throw new Error(`No RPC url provided for chainId: ${e3}`);
    return new o$9(new f$6(i4, h$5("disableProviderPing")));
  }
};
var Jc$1 = Object.defineProperty, Kc$1 = (r3, e3, t2) => e3 in r3 ? Jc$1(r3, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r3[e3] = t2, R$3 = (r3, e3, t2) => Kc$1(r3, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let Wc$1 = class Wc2 {
  constructor(e3) {
    R$3(this, "name", "near"), R$3(this, "client"), R$3(this, "httpProviders"), R$3(this, "events"), R$3(this, "namespace"), R$3(this, "chainId"), this.namespace = e3.namespace, this.events = h$5("events"), this.client = h$5("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e3) {
    this.namespace = Object.assign(this.namespace, e3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e3 = this.namespace.chains[0];
    if (!e3) throw new Error("ChainId not found");
    return e3.split(":")[1];
  }
  request(e3) {
    return this.namespace.methods.includes(e3.request.method) ? this.client.request(e3) : this.getHttpProvider().request(e3.request);
  }
  setDefaultChain(e3, t2) {
    if (this.chainId = e3, !this.httpProviders[e3]) {
      const i4 = t2 || v$3(`${this.name}:${e3}`, this.namespace);
      if (!i4) throw new Error(`No RPC url provided for chainId: ${e3}`);
      this.setHttpProvider(e3, i4);
    }
    this.events.emit(f$5.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e3 = this.namespace.accounts;
    return e3 ? e3.filter((t2) => t2.split(":")[1] === this.chainId.toString()).map((t2) => t2.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const e3 = {};
    return this.namespace.chains.forEach((t2) => {
      var i4;
      e3[t2] = this.createHttpProvider(t2, (i4 = this.namespace.rpcMap) == null ? void 0 : i4[t2]);
    }), e3;
  }
  getHttpProvider() {
    const e3 = `${this.name}:${this.chainId}`, t2 = this.httpProviders[e3];
    if (typeof t2 > "u") throw new Error(`JSON-RPC provider for ${e3} not found`);
    return t2;
  }
  setHttpProvider(e3, t2) {
    const i4 = this.createHttpProvider(e3, t2);
    i4 && (this.httpProviders[e3] = i4);
  }
  createHttpProvider(e3, t2) {
    const i4 = t2 || v$3(e3, this.namespace);
    return typeof i4 > "u" ? void 0 : new o$9(new f$6(i4, h$5("disableProviderPing")));
  }
};
var Xc$1 = Object.defineProperty, Yc$1 = (r3, e3, t2) => e3 in r3 ? Xc$1(r3, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r3[e3] = t2, x$4 = (r3, e3, t2) => Yc$1(r3, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let Zc$1 = class Zc2 {
  constructor(e3) {
    x$4(this, "name", "tezos"), x$4(this, "client"), x$4(this, "httpProviders"), x$4(this, "events"), x$4(this, "namespace"), x$4(this, "chainId"), this.namespace = e3.namespace, this.events = h$5("events"), this.client = h$5("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e3) {
    this.namespace = Object.assign(this.namespace, e3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e3 = this.namespace.chains[0];
    if (!e3) throw new Error("ChainId not found");
    return e3.split(":")[1];
  }
  request(e3) {
    return this.namespace.methods.includes(e3.request.method) ? this.client.request(e3) : this.getHttpProvider().request(e3.request);
  }
  setDefaultChain(e3, t2) {
    if (this.chainId = e3, !this.httpProviders[e3]) {
      const i4 = t2 || v$3(`${this.name}:${e3}`, this.namespace);
      if (!i4) throw new Error(`No RPC url provided for chainId: ${e3}`);
      this.setHttpProvider(e3, i4);
    }
    this.events.emit(f$5.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e3 = this.namespace.accounts;
    return e3 ? e3.filter((t2) => t2.split(":")[1] === this.chainId.toString()).map((t2) => t2.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const e3 = {};
    return this.namespace.chains.forEach((t2) => {
      e3[t2] = this.createHttpProvider(t2);
    }), e3;
  }
  getHttpProvider() {
    const e3 = `${this.name}:${this.chainId}`, t2 = this.httpProviders[e3];
    if (typeof t2 > "u") throw new Error(`JSON-RPC provider for ${e3} not found`);
    return t2;
  }
  setHttpProvider(e3, t2) {
    const i4 = this.createHttpProvider(e3, t2);
    i4 && (this.httpProviders[e3] = i4);
  }
  createHttpProvider(e3, t2) {
    const i4 = t2 || v$3(e3, this.namespace);
    return typeof i4 > "u" ? void 0 : new o$9(new f$6(i4));
  }
};
var Qc$1 = Object.defineProperty, eh$1 = (r3, e3, t2) => e3 in r3 ? Qc$1(r3, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r3[e3] = t2, L$3 = (r3, e3, t2) => eh$1(r3, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let th$1 = class th2 {
  constructor(e3) {
    L$3(this, "name", w$1), L$3(this, "client"), L$3(this, "httpProviders"), L$3(this, "events"), L$3(this, "namespace"), L$3(this, "chainId"), this.namespace = e3.namespace, this.events = h$5("events"), this.client = h$5("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e3) {
    this.namespace.chains = [...new Set((this.namespace.chains || []).concat(e3.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(e3.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(e3.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(e3.events || []))], this.httpProviders = this.createHttpProviders();
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e3) {
    return this.namespace.methods.includes(e3.request.method) ? this.client.request(e3) : this.getHttpProvider(e3.chainId).request(e3.request);
  }
  setDefaultChain(e3, t2) {
    this.httpProviders[e3] || this.setHttpProvider(e3, t2), this.chainId = e3, this.events.emit(f$5.DEFAULT_CHAIN_CHANGED, `${this.name}:${e3}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e3 = this.namespace.chains[0];
    if (!e3) throw new Error("ChainId not found");
    return e3.split(":")[1];
  }
  getAccounts() {
    const e3 = this.namespace.accounts;
    return e3 ? [...new Set(e3.filter((t2) => t2.split(":")[1] === this.chainId.toString()).map((t2) => t2.split(":")[2]))] : [];
  }
  createHttpProviders() {
    var e3, t2;
    const i4 = {};
    return (t2 = (e3 = this.namespace) == null ? void 0 : e3.accounts) == null || t2.forEach((s2) => {
      const n5 = Ye$4(s2);
      i4[`${n5.namespace}:${n5.reference}`] = this.createHttpProvider(s2);
    }), i4;
  }
  getHttpProvider(e3) {
    const t2 = this.httpProviders[e3];
    if (typeof t2 > "u") throw new Error(`JSON-RPC provider for ${e3} not found`);
    return t2;
  }
  setHttpProvider(e3, t2) {
    const i4 = this.createHttpProvider(e3, t2);
    i4 && (this.httpProviders[e3] = i4);
  }
  createHttpProvider(e3, t2) {
    const i4 = t2 || v$3(e3, this.namespace, this.client.core.projectId);
    if (!i4) throw new Error(`No RPC url provided for chainId: ${e3}`);
    return new o$9(new f$6(i4, h$5("disableProviderPing")));
  }
};
var rh$1 = Object.defineProperty, ih$1 = Object.defineProperties, sh$1 = Object.getOwnPropertyDescriptors, vt$3 = Object.getOwnPropertySymbols, nh$1 = Object.prototype.hasOwnProperty, ah$1 = Object.prototype.propertyIsEnumerable, le$3 = (r3, e3, t2) => e3 in r3 ? rh$1(r3, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r3[e3] = t2, Y$2 = (r3, e3) => {
  for (var t2 in e3 || (e3 = {})) nh$1.call(e3, t2) && le$3(r3, t2, e3[t2]);
  if (vt$3) for (var t2 of vt$3(e3)) ah$1.call(e3, t2) && le$3(r3, t2, e3[t2]);
  return r3;
}, de$3 = (r3, e3) => ih$1(r3, sh$1(e3)), g$2 = (r3, e3, t2) => le$3(r3, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let Z$1 = class Z2 {
  constructor(e3) {
    g$2(this, "client"), g$2(this, "namespaces"), g$2(this, "optionalNamespaces"), g$2(this, "sessionProperties"), g$2(this, "events", new wt$7()), g$2(this, "rpcProviders", {}), g$2(this, "session"), g$2(this, "providerOpts"), g$2(this, "logger"), g$2(this, "uri"), g$2(this, "disableProviderPing", false), this.providerOpts = e3, this.logger = typeof (e3 == null ? void 0 : e3.logger) < "u" && typeof (e3 == null ? void 0 : e3.logger) != "string" ? e3.logger : gt$3(k$7({ level: (e3 == null ? void 0 : e3.logger) || be$2 })), this.disableProviderPing = (e3 == null ? void 0 : e3.disableProviderPing) || false;
  }
  static async init(e3) {
    const t2 = new Z2(e3);
    return await t2.initialize(), t2;
  }
  async request(e3, t2, i4) {
    const [s2, n5] = this.validateChain(t2);
    if (!this.session) throw new Error("Please call connect() before request()");
    return await this.getProvider(s2).request({ request: Y$2({}, e3), chainId: `${s2}:${n5}`, topic: this.session.topic, expiry: i4 });
  }
  sendAsync(e3, t2, i4, s2) {
    const n5 = (/* @__PURE__ */ new Date()).getTime();
    this.request(e3, i4, s2).then((a2) => t2(null, formatJsonRpcResult(n5, a2))).catch((a2) => t2(a2, void 0));
  }
  async enable() {
    if (!this.client) throw new Error("Sign Client not initialized");
    return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties }), await this.requestAccounts();
  }
  async disconnect() {
    var e3;
    if (!this.session) throw new Error("Please call connect() before enable()");
    await this.client.disconnect({ topic: (e3 = this.session) == null ? void 0 : e3.topic, reason: de$5("USER_DISCONNECTED") }), await this.cleanup();
  }
  async connect(e3) {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (this.setNamespaces(e3), await this.cleanupPendingPairings(), !e3.skipPairing) return await this.pair(e3.pairingTopic);
  }
  async authenticate(e3, t2) {
    if (!this.client) throw new Error("Sign Client not initialized");
    this.setNamespaces(e3), await this.cleanupPendingPairings();
    const { uri: i4, response: s2 } = await this.client.authenticate(e3, t2);
    i4 && (this.uri = i4, this.events.emit("display_uri", i4));
    const n5 = await s2();
    if (this.session = n5.session, this.session) {
      const a2 = ht$3(this.session.namespaces);
      this.namespaces = ce$3(this.namespaces, a2), this.persist("namespaces", this.namespaces), this.onConnect();
    }
    return n5;
  }
  on(e3, t2) {
    this.events.on(e3, t2);
  }
  once(e3, t2) {
    this.events.once(e3, t2);
  }
  removeListener(e3, t2) {
    this.events.removeListener(e3, t2);
  }
  off(e3, t2) {
    this.events.off(e3, t2);
  }
  get isWalletConnect() {
    return true;
  }
  async pair(e3) {
    const { uri: t2, approval: i4 } = await this.client.connect({ pairingTopic: e3, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties });
    t2 && (this.uri = t2, this.events.emit("display_uri", t2));
    const s2 = await i4();
    this.session = s2;
    const n5 = ht$3(s2.namespaces);
    return this.namespaces = ce$3(this.namespaces, n5), this.persist("namespaces", this.namespaces), this.onConnect(), this.session;
  }
  setDefaultChain(e3, t2) {
    try {
      if (!this.session) return;
      const [i4, s2] = this.validateChain(e3), n5 = this.getProvider(i4);
      n5.name === w$1 ? n5.setDefaultChain(`${i4}:${s2}`, t2) : n5.setDefaultChain(s2, t2);
    } catch (i4) {
      if (!/Please call connect/.test(i4.message)) throw i4;
    }
  }
  async cleanupPendingPairings(e3 = {}) {
    this.logger.info("Cleaning up inactive pairings...");
    const t2 = this.client.pairing.getAll();
    if ($e$7(t2)) {
      for (const i4 of t2) e3.deletePairings ? this.client.core.expirer.set(i4.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(i4.topic);
      this.logger.info(`Inactive pairings cleared: ${t2.length}`);
    }
  }
  abortPairingAttempt() {
    this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.");
  }
  async checkStorage() {
    if (this.namespaces = await this.getFromStore("namespaces"), this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.client.session.length) {
      const e3 = this.client.session.keys.length - 1;
      this.session = this.client.session.get(this.client.session.keys[e3]), this.createProviders();
    }
  }
  async initialize() {
    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
  }
  async createClient() {
    this.client = this.providerOpts.client || await Ee$5.init({ core: this.providerOpts.core, logger: this.providerOpts.logger || be$2, relayUrl: this.providerOpts.relayUrl || _t$4, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, storage: this.providerOpts.storage, name: this.providerOpts.name, customStoragePrefix: this.providerOpts.customStoragePrefix, telemetryEnabled: this.providerOpts.telemetryEnabled }), this.logger.trace("SignClient Initialized");
  }
  createProviders() {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
    const e3 = [...new Set(Object.keys(this.session.namespaces).map((t2) => pr$6(t2)))];
    pe$2("client", this.client), pe$2("events", this.events), pe$2("disableProviderPing", this.disableProviderPing), e3.forEach((t2) => {
      if (!this.session) return;
      const i4 = Pc$1(t2, this.session), s2 = ot$2(i4), n5 = ce$3(this.namespaces, this.optionalNamespaces), a2 = de$3(Y$2({}, n5[t2]), { accounts: i4, chains: s2 });
      switch (t2) {
        case "eip155":
          this.rpcProviders[t2] = new jc$1({ namespace: a2 });
          break;
        case "algorand":
          this.rpcProviders[t2] = new xc$1({ namespace: a2 });
          break;
        case "solana":
          this.rpcProviders[t2] = new Sc$1({ namespace: a2 });
          break;
        case "cosmos":
          this.rpcProviders[t2] = new Dc$1({ namespace: a2 });
          break;
        case "polkadot":
          this.rpcProviders[t2] = new wc$1({ namespace: a2 });
          break;
        case "cip34":
          this.rpcProviders[t2] = new Fc$1({ namespace: a2 });
          break;
        case "elrond":
          this.rpcProviders[t2] = new zc$1({ namespace: a2 });
          break;
        case "multiversx":
          this.rpcProviders[t2] = new Vc$1({ namespace: a2 });
          break;
        case "near":
          this.rpcProviders[t2] = new Wc$1({ namespace: a2 });
          break;
        case "tezos":
          this.rpcProviders[t2] = new Zc$1({ namespace: a2 });
          break;
        default:
          this.rpcProviders[w$1] ? this.rpcProviders[w$1].updateNamespace(a2) : this.rpcProviders[w$1] = new th$1({ namespace: a2 });
      }
    });
  }
  registerEventListeners() {
    if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", (e3) => {
      this.events.emit("session_ping", e3);
    }), this.client.on("session_event", (e3) => {
      const { params: t2 } = e3, { event: i4 } = t2;
      if (i4.name === "accountsChanged") {
        const s2 = i4.data;
        s2 && $e$7(s2) && this.events.emit("accountsChanged", s2.map(bc$1));
      } else if (i4.name === "chainChanged") {
        const s2 = t2.chainId, n5 = t2.event.data, a2 = pr$6(s2), o3 = he$1(s2) !== he$1(n5) ? `${a2}:${he$1(n5)}` : s2;
        this.onChainChanged(o3);
      } else this.events.emit(i4.name, i4.data);
      this.events.emit("session_event", e3);
    }), this.client.on("session_update", ({ topic: e3, params: t2 }) => {
      var i4;
      const { namespaces: s2 } = t2, n5 = (i4 = this.client) == null ? void 0 : i4.session.get(e3);
      this.session = de$3(Y$2({}, n5), { namespaces: s2 }), this.onSessionUpdate(), this.events.emit("session_update", { topic: e3, params: t2 });
    }), this.client.on("session_delete", async (e3) => {
      await this.cleanup(), this.events.emit("session_delete", e3), this.events.emit("disconnect", de$3(Y$2({}, de$5("USER_DISCONNECTED")), { data: e3.topic }));
    }), this.on(f$5.DEFAULT_CHAIN_CHANGED, (e3) => {
      this.onChainChanged(e3, true);
    });
  }
  getProvider(e3) {
    return this.rpcProviders[e3] || this.rpcProviders[w$1];
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach((e3) => {
      var t2;
      this.getProvider(e3).updateNamespace((t2 = this.session) == null ? void 0 : t2.namespaces[e3]);
    });
  }
  setNamespaces(e3) {
    const { namespaces: t2, optionalNamespaces: i4, sessionProperties: s2 } = e3;
    t2 && Object.keys(t2).length && (this.namespaces = t2), i4 && Object.keys(i4).length && (this.optionalNamespaces = i4), this.sessionProperties = s2, this.persist("namespaces", t2), this.persist("optionalNamespaces", i4);
  }
  validateChain(e3) {
    const [t2, i4] = (e3 == null ? void 0 : e3.split(":")) || ["", ""];
    if (!this.namespaces || !Object.keys(this.namespaces).length) return [t2, i4];
    if (t2 && !Object.keys(this.namespaces || {}).map((a2) => pr$6(a2)).includes(t2)) throw new Error(`Namespace '${t2}' is not configured. Please call connect() first with namespace config.`);
    if (t2 && i4) return [t2, i4];
    const s2 = pr$6(Object.keys(this.namespaces)[0]), n5 = this.rpcProviders[s2].getDefaultChain();
    return [s2, n5];
  }
  async requestAccounts() {
    const [e3] = this.validateChain();
    return await this.getProvider(e3).requestAccounts();
  }
  onChainChanged(e3, t2 = false) {
    if (!this.namespaces) return;
    const [i4, s2] = this.validateChain(e3);
    s2 && (t2 || this.getProvider(i4).setDefaultChain(s2), this.namespaces[i4] ? this.namespaces[i4].defaultChain = s2 : this.namespaces[`${i4}:${s2}`] ? this.namespaces[`${i4}:${s2}`].defaultChain = s2 : this.namespaces[`${i4}:${s2}`] = { defaultChain: s2 }, this.persist("namespaces", this.namespaces), this.events.emit("chainChanged", s2));
  }
  onConnect() {
    this.createProviders(), this.events.emit("connect", { session: this.session });
  }
  async cleanup() {
    this.session = void 0, this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, this.persist("namespaces", void 0), this.persist("optionalNamespaces", void 0), this.persist("sessionProperties", void 0), await this.cleanupPendingPairings({ deletePairings: true });
  }
  persist(e3, t2) {
    this.client.core.storage.setItem(`${$e$4}/${e3}`, t2);
  }
  async getFromStore(e3) {
    return await this.client.core.storage.getItem(`${$e$4}/${e3}`);
  }
};
const OptionsUtil = {
  getFeatureValue(key2, features) {
    const optionValue = features == null ? void 0 : features[key2];
    if (optionValue === void 0) {
      return ConstantsUtil$3.DEFAULT_FEATURES[key2];
    }
    return optionValue;
  },
  filterSocialsByPlatform(socials) {
    if (!socials || !socials.length) {
      return socials;
    }
    if (CoreHelperUtil.isTelegram()) {
      if (CoreHelperUtil.isIos()) {
        return socials.filter((s2) => s2 !== "google");
      }
      if (CoreHelperUtil.isMac()) {
        return socials.filter((s2) => s2 !== "x");
      }
      if (CoreHelperUtil.isAndroid()) {
        return socials.filter((s2) => !["facebook", "x"].includes(s2));
      }
    }
    return socials;
  }
};
const state$m = proxy({
  features: ConstantsUtil$3.DEFAULT_FEATURES,
  projectId: "",
  sdkType: "appkit",
  sdkVersion: "html-wagmi-undefined",
  defaultAccountTypes: ConstantsUtil$3.DEFAULT_ACCOUNT_TYPES
});
const OptionsController = {
  state: state$m,
  subscribeKey(key2, callback) {
    return subscribeKey(state$m, key2, callback);
  },
  setOptions(options) {
    Object.assign(state$m, options);
  },
  setFeatures(features) {
    if (!features) {
      return;
    }
    if (!state$m.features) {
      state$m.features = ConstantsUtil$3.DEFAULT_FEATURES;
    }
    const newFeatures = { ...state$m.features, ...features };
    state$m.features = newFeatures;
    if (state$m.features.socials) {
      state$m.features.socials = OptionsUtil.filterSocialsByPlatform(state$m.features.socials);
    }
  },
  setProjectId(projectId) {
    state$m.projectId = projectId;
  },
  setAllWallets(allWallets) {
    state$m.allWallets = allWallets;
  },
  setIncludeWalletIds(includeWalletIds) {
    state$m.includeWalletIds = includeWalletIds;
  },
  setExcludeWalletIds(excludeWalletIds) {
    state$m.excludeWalletIds = excludeWalletIds;
  },
  setFeaturedWalletIds(featuredWalletIds) {
    state$m.featuredWalletIds = featuredWalletIds;
  },
  setTokens(tokens) {
    state$m.tokens = tokens;
  },
  setTermsConditionsUrl(termsConditionsUrl) {
    state$m.termsConditionsUrl = termsConditionsUrl;
  },
  setPrivacyPolicyUrl(privacyPolicyUrl) {
    state$m.privacyPolicyUrl = privacyPolicyUrl;
  },
  setCustomWallets(customWallets) {
    state$m.customWallets = customWallets;
  },
  setIsSiweEnabled(isSiweEnabled) {
    state$m.isSiweEnabled = isSiweEnabled;
  },
  setIsUniversalProvider(isUniversalProvider) {
    state$m.isUniversalProvider = isUniversalProvider;
  },
  setSdkVersion(sdkVersion) {
    state$m.sdkVersion = sdkVersion;
  },
  setMetadata(metadata) {
    state$m.metadata = metadata;
  },
  setDisableAppend(disableAppend) {
    state$m.disableAppend = disableAppend;
  },
  setEIP6963Enabled(enableEIP6963) {
    state$m.enableEIP6963 = enableEIP6963;
  },
  setDebug(debug) {
    state$m.debug = debug;
  },
  setEnableWalletConnect(enableWalletConnect) {
    state$m.enableWalletConnect = enableWalletConnect;
  },
  setEnableWalletGuide(enableWalletGuide) {
    state$m.enableWalletGuide = enableWalletGuide;
  },
  setEnableAuthLogger(enableAuthLogger) {
    state$m.enableAuthLogger = enableAuthLogger;
  },
  setEnableWallets(enableWallets) {
    state$m.enableWallets = enableWallets;
  },
  setHasMultipleAddresses(hasMultipleAddresses) {
    state$m.hasMultipleAddresses = hasMultipleAddresses;
  },
  setSIWX(siwx) {
    state$m.siwx = siwx;
  },
  setConnectMethodsOrder(connectMethodsOrder) {
    state$m.features = {
      ...state$m.features,
      connectMethodsOrder
    };
  },
  setWalletFeaturesOrder(walletFeaturesOrder) {
    state$m.features = {
      ...state$m.features,
      walletFeaturesOrder
    };
  },
  setSocialsOrder(socialsOrder) {
    state$m.features = {
      ...state$m.features,
      socials: socialsOrder
    };
  },
  setCollapseWallets(collapseWallets) {
    state$m.features = {
      ...state$m.features,
      collapseWallets
    };
  },
  setEnableEmbedded(enableEmbedded) {
    state$m.enableEmbedded = enableEmbedded;
  },
  setAllowUnsupportedChain(allowUnsupportedChain) {
    state$m.allowUnsupportedChain = allowUnsupportedChain;
  },
  setUsingInjectedUniversalProvider(useInjectedUniversalProvider) {
    state$m.useInjectedUniversalProvider = useInjectedUniversalProvider;
  },
  setDefaultAccountTypes(defaultAccountType = {}) {
    Object.entries(defaultAccountType).forEach(([namespace, accountType]) => {
      if (accountType) {
        state$m.defaultAccountTypes[namespace] = accountType;
      }
    });
  },
  getSnapshot() {
    return snapshot(state$m);
  }
};
const state$l = proxy({
  message: "",
  variant: "info",
  open: false
});
const AlertController = {
  state: state$l,
  subscribeKey(key2, callback) {
    return subscribeKey(state$l, key2, callback);
  },
  open(message, variant) {
    const { debug } = OptionsController.state;
    const { shortMessage, longMessage } = message;
    if (debug) {
      state$l.message = shortMessage;
      state$l.variant = variant;
      state$l.open = true;
    }
    if (longMessage) {
      console.error(typeof longMessage === "function" ? longMessage() : longMessage);
    }
  },
  close() {
    state$l.open = false;
    state$l.message = "";
    state$l.variant = "info";
  }
};
const baseUrl$3 = CoreHelperUtil.getAnalyticsUrl();
const api$2 = new FetchUtil({ baseUrl: baseUrl$3, clientId: null });
const excluded = ["MODAL_CREATED"];
const state$k = proxy({
  timestamp: Date.now(),
  reportedErrors: {},
  data: {
    type: "track",
    event: "MODAL_CREATED"
  }
});
const EventsController = {
  state: state$k,
  subscribe(callback) {
    return subscribe(state$k, () => callback(state$k));
  },
  getSdkProperties() {
    const { projectId, sdkType, sdkVersion } = OptionsController.state;
    return {
      projectId,
      st: sdkType,
      sv: sdkVersion || "html-wagmi-4.2.2"
    };
  },
  async _sendAnalyticsEvent(payload) {
    try {
      const address = AccountController.state.address;
      if (excluded.includes(payload.data.event) || typeof window === "undefined") {
        return;
      }
      await api$2.post({
        path: "/e",
        params: EventsController.getSdkProperties(),
        body: {
          eventId: CoreHelperUtil.getUUID(),
          url: window.location.href,
          domain: window.location.hostname,
          timestamp: payload.timestamp,
          props: { ...payload.data, address }
        }
      });
      state$k.reportedErrors["FORBIDDEN"] = false;
    } catch (err) {
      const isForbiddenError = err instanceof Error && err.cause instanceof Response && err.cause.status === ConstantsUtil$4.HTTP_STATUS_CODES.FORBIDDEN && !state$k.reportedErrors["FORBIDDEN"];
      if (isForbiddenError) {
        AlertController.open({
          shortMessage: "Invalid App Configuration",
          longMessage: `Origin ${isSafe$1() ? window.origin : "uknown"} not found on Allowlist - update configuration on cloud.reown.com`
        }, "error");
        state$k.reportedErrors["FORBIDDEN"] = true;
      }
    }
  },
  sendEvent(data2) {
    var _a3;
    state$k.timestamp = Date.now();
    state$k.data = data2;
    if ((_a3 = OptionsController.state.features) == null ? void 0 : _a3.analytics) {
      EventsController._sendAnalyticsEvent(state$k);
    }
  }
};
const MobileWalletUtil = {
  /**
   * Handles mobile wallet redirection for wallets that have Universal Links.
   *
   * @param {Object} properties - The properties object.
   * @param {string} properties.name - The name of the wallet.
   */
  handleSolanaDeeplinkRedirect(name) {
    if (ChainController.state.activeChain === ConstantsUtil$4.CHAIN.SOLANA) {
      const href = window.location.href;
      const encodedHref = encodeURIComponent(href);
      if (name === "Phantom" && !("phantom" in window)) {
        const protocol = href.startsWith("https") ? "https" : "http";
        const host = href.split("/")[2];
        const encodedRef = encodeURIComponent(`${protocol}://${host}`);
        window.location.href = `https://phantom.app/ul/browse/${encodedHref}?ref=${encodedRef}`;
      }
      if (name === "Coinbase Wallet" && !("coinbaseSolana" in window)) {
        window.location.href = `https://go.cb-w.com/dapp?cb_url=${encodedHref}`;
      }
    }
  }
};
const state$j = proxy({
  themeMode: "dark",
  themeVariables: {},
  w3mThemeVariables: void 0
});
const ThemeController = {
  state: state$j,
  subscribe(callback) {
    return subscribe(state$j, () => callback(state$j));
  },
  setThemeMode(themeMode) {
    state$j.themeMode = themeMode;
    try {
      const authConnector = ConnectorController.getAuthConnector();
      if (authConnector) {
        const themeVariables = ThemeController.getSnapshot().themeVariables;
        authConnector.provider.syncTheme({
          themeMode,
          themeVariables,
          w3mThemeVariables: getW3mThemeVariables(themeVariables, themeMode)
        });
      }
    } catch {
      console.info("Unable to sync theme to auth connector");
    }
  },
  setThemeVariables(themeVariables) {
    state$j.themeVariables = { ...state$j.themeVariables, ...themeVariables };
    try {
      const authConnector = ConnectorController.getAuthConnector();
      if (authConnector) {
        const themeVariablesSnapshot = ThemeController.getSnapshot().themeVariables;
        authConnector.provider.syncTheme({
          themeVariables: themeVariablesSnapshot,
          w3mThemeVariables: getW3mThemeVariables(state$j.themeVariables, state$j.themeMode)
        });
      }
    } catch {
      console.info("Unable to sync theme to auth connector");
    }
  },
  getSnapshot() {
    return snapshot(state$j);
  }
};
const state$i = proxy({
  allConnectors: [],
  connectors: [],
  activeConnector: void 0,
  filterByNamespace: void 0
});
const ConnectorController = {
  state: state$i,
  subscribe(callback) {
    return subscribe(state$i, () => {
      callback(state$i);
    });
  },
  subscribeKey(key2, callback) {
    return subscribeKey(state$i, key2, callback);
  },
  setActiveConnector(connector) {
    if (connector) {
      state$i.activeConnector = ref$1(connector);
    }
  },
  setConnectors(connectors) {
    const newConnectors = connectors.filter((newConnector) => !state$i.allConnectors.some((existingConnector) => existingConnector.id === newConnector.id && this.getConnectorName(existingConnector.name) === this.getConnectorName(newConnector.name) && existingConnector.chain === newConnector.chain));
    newConnectors.forEach((connector) => {
      if (connector.type !== "MULTI_CHAIN") {
        state$i.allConnectors.push(ref$1(connector));
      }
    });
    state$i.connectors = this.mergeMultiChainConnectors(state$i.allConnectors);
  },
  removeAdapter(namespace) {
    state$i.allConnectors = state$i.allConnectors.filter((connector) => connector.chain !== namespace);
    state$i.connectors = this.mergeMultiChainConnectors(state$i.allConnectors);
  },
  mergeMultiChainConnectors(connectors) {
    const connectorsByNameMap = this.generateConnectorMapByName(connectors);
    const mergedConnectors = [];
    connectorsByNameMap.forEach((keyConnectors) => {
      const firstItem = keyConnectors[0];
      const isAuthConnector = (firstItem == null ? void 0 : firstItem.id) === ConstantsUtil$4.CONNECTOR_ID.AUTH;
      if (keyConnectors.length > 1 && firstItem) {
        mergedConnectors.push({
          name: firstItem.name,
          imageUrl: firstItem.imageUrl,
          imageId: firstItem.imageId,
          connectors: [...keyConnectors],
          type: isAuthConnector ? "AUTH" : "MULTI_CHAIN",
          // These values are just placeholders, we don't use them in multi-chain connector select screen
          chain: "eip155",
          id: (firstItem == null ? void 0 : firstItem.id) || ""
        });
      } else if (firstItem) {
        mergedConnectors.push(firstItem);
      }
    });
    return mergedConnectors;
  },
  generateConnectorMapByName(connectors) {
    const connectorsByNameMap = /* @__PURE__ */ new Map();
    connectors.forEach((connector) => {
      const { name } = connector;
      const connectorName = this.getConnectorName(name);
      if (!connectorName) {
        return;
      }
      const connectorsByName = connectorsByNameMap.get(connectorName) || [];
      const haveSameConnector = connectorsByName.find((c2) => c2.chain === connector.chain);
      if (!haveSameConnector) {
        connectorsByName.push(connector);
      }
      connectorsByNameMap.set(connectorName, connectorsByName);
    });
    return connectorsByNameMap;
  },
  getConnectorName(name) {
    if (!name) {
      return name;
    }
    const nameOverrideMap = {
      "Trust Wallet": "Trust"
    };
    return nameOverrideMap[name] || name;
  },
  getUniqueConnectorsByName(connectors) {
    const uniqueConnectors = [];
    connectors.forEach((c2) => {
      if (!uniqueConnectors.find((uc2) => uc2.chain === c2.chain)) {
        uniqueConnectors.push(c2);
      }
    });
    return uniqueConnectors;
  },
  addConnector(connector) {
    var _a3, _b2, _c3;
    if (connector.id === ConstantsUtil$4.CONNECTOR_ID.AUTH) {
      const authConnector = connector;
      const optionsState = snapshot(OptionsController.state);
      const themeMode = ThemeController.getSnapshot().themeMode;
      const themeVariables = ThemeController.getSnapshot().themeVariables;
      (_b2 = (_a3 = authConnector == null ? void 0 : authConnector.provider) == null ? void 0 : _a3.syncDappData) == null ? void 0 : _b2.call(_a3, {
        metadata: optionsState.metadata,
        sdkVersion: optionsState.sdkVersion,
        projectId: optionsState.projectId,
        sdkType: optionsState.sdkType
      });
      (_c3 = authConnector == null ? void 0 : authConnector.provider) == null ? void 0 : _c3.syncTheme({
        themeMode,
        themeVariables,
        w3mThemeVariables: getW3mThemeVariables(themeVariables, themeMode)
      });
      this.setConnectors([connector]);
    } else {
      this.setConnectors([connector]);
    }
  },
  getAuthConnector(chainNamespace) {
    var _a3;
    const activeNamespace = chainNamespace || ChainController.state.activeChain;
    const authConnector = state$i.connectors.find((c2) => c2.id === ConstantsUtil$4.CONNECTOR_ID.AUTH);
    if (!authConnector) {
      return void 0;
    }
    if ((_a3 = authConnector == null ? void 0 : authConnector.connectors) == null ? void 0 : _a3.length) {
      const connector = authConnector.connectors.find((c2) => c2.chain === activeNamespace);
      return connector;
    }
    return authConnector;
  },
  getAnnouncedConnectorRdns() {
    return state$i.connectors.filter((c2) => c2.type === "ANNOUNCED").map((c2) => {
      var _a3;
      return (_a3 = c2.info) == null ? void 0 : _a3.rdns;
    });
  },
  getConnector(id2, rdns) {
    return state$i.connectors.find((c2) => {
      var _a3;
      return c2.explorerId === id2 || ((_a3 = c2.info) == null ? void 0 : _a3.rdns) === rdns;
    });
  },
  syncIfAuthConnector(connector) {
    var _a3, _b2;
    if (connector.id !== "ID_AUTH") {
      return;
    }
    const authConnector = connector;
    const optionsState = snapshot(OptionsController.state);
    const themeMode = ThemeController.getSnapshot().themeMode;
    const themeVariables = ThemeController.getSnapshot().themeVariables;
    (_b2 = (_a3 = authConnector == null ? void 0 : authConnector.provider) == null ? void 0 : _a3.syncDappData) == null ? void 0 : _b2.call(_a3, {
      metadata: optionsState.metadata,
      sdkVersion: optionsState.sdkVersion,
      sdkType: optionsState.sdkType,
      projectId: optionsState.projectId
    });
    authConnector.provider.syncTheme({
      themeMode,
      themeVariables,
      w3mThemeVariables: getW3mThemeVariables(themeVariables, themeMode)
    });
  },
  /**
   * Returns the connectors filtered by namespace.
   * @param namespace - The namespace to filter the connectors by.
   * @returns ConnectorWithProviders[].
   */
  getConnectorsByNamespace(namespace) {
    const namespaceConnectors = state$i.allConnectors.filter((connector) => connector.chain === namespace);
    return this.mergeMultiChainConnectors(namespaceConnectors);
  },
  selectWalletConnector(wallet) {
    const connector = ConnectorController.getConnector(wallet.id, wallet.rdns);
    if (ChainController.state.activeChain === ConstantsUtil$4.CHAIN.SOLANA) {
      MobileWalletUtil.handleSolanaDeeplinkRedirect((connector == null ? void 0 : connector.name) || wallet.name || "");
    }
    if (connector) {
      RouterController.push("ConnectingExternal", { connector });
    } else {
      RouterController.push("ConnectingWalletConnect", { wallet });
    }
  },
  /**
   * Returns the connectors. If a namespace is provided, the connectors are filtered by namespace.
   * @param namespace - The namespace to filter the connectors by. If not provided, all connectors are returned.
   * @returns ConnectorWithProviders[].
   */
  getConnectors(namespace) {
    if (namespace) {
      return this.getConnectorsByNamespace(namespace);
    }
    return this.mergeMultiChainConnectors(state$i.allConnectors);
  },
  /**
   * Sets the filter by namespace and updates the connectors.
   * @param namespace - The namespace to filter the connectors by.
   */
  setFilterByNamespace(namespace) {
    state$i.filterByNamespace = namespace;
    state$i.connectors = this.getConnectors(namespace);
  },
  clearNamespaceFilter() {
    state$i.filterByNamespace = void 0;
    state$i.connectors = this.getConnectors();
  }
};
const state$h = proxy({
  view: "Connect",
  history: ["Connect"],
  transactionStack: []
});
const RouterController = {
  state: state$h,
  subscribeKey(key2, callback) {
    return subscribeKey(state$h, key2, callback);
  },
  pushTransactionStack(action) {
    state$h.transactionStack.push(action);
  },
  popTransactionStack(cancel) {
    var _a3, _b2;
    const action = state$h.transactionStack.pop();
    if (!action) {
      return;
    }
    if (cancel) {
      this.goBack();
      (_a3 = action == null ? void 0 : action.onCancel) == null ? void 0 : _a3.call(action);
    } else {
      if (action.goBack) {
        this.goBack();
      } else if (action.replace) {
        const history = state$h.history;
        const connectingSiweIndex = history.indexOf("ConnectingSiwe");
        if (connectingSiweIndex > 0) {
          this.goBackToIndex(connectingSiweIndex - 1);
        } else {
          ModalController.close();
          state$h.history = [];
        }
      } else if (action.view) {
        this.reset(action.view);
      }
      (_b2 = action == null ? void 0 : action.onSuccess) == null ? void 0 : _b2.call(action);
    }
  },
  push(view, data2) {
    if (view !== state$h.view) {
      state$h.view = view;
      state$h.history.push(view);
      state$h.data = data2;
    }
  },
  reset(view, data2) {
    state$h.view = view;
    state$h.history = [view];
    state$h.data = data2;
  },
  replace(view, data2) {
    const lastView = state$h.history.at(-1);
    const isSameView = lastView === view;
    if (!isSameView) {
      state$h.view = view;
      state$h.history[state$h.history.length - 1] = view;
      state$h.data = data2;
    }
  },
  goBack() {
    var _a3;
    const shouldReload = !ChainController.state.activeCaipAddress && this.state.view === "ConnectingFarcaster";
    if (state$h.history.length > 1 && !state$h.history.includes("UnsupportedChain")) {
      state$h.history.pop();
      const [last] = state$h.history.slice(-1);
      if (last) {
        state$h.view = last;
      }
    } else {
      ModalController.close();
    }
    if ((_a3 = state$h.data) == null ? void 0 : _a3.wallet) {
      state$h.data.wallet = void 0;
    }
    setTimeout(() => {
      var _a4, _b2, _c3;
      if (shouldReload) {
        AccountController.setFarcasterUrl(void 0, ChainController.state.activeChain);
        const authConnector = ConnectorController.getAuthConnector();
        (_a4 = authConnector == null ? void 0 : authConnector.provider) == null ? void 0 : _a4.reload();
        const optionsState = snapshot(OptionsController.state);
        (_c3 = (_b2 = authConnector == null ? void 0 : authConnector.provider) == null ? void 0 : _b2.syncDappData) == null ? void 0 : _c3.call(_b2, {
          metadata: optionsState.metadata,
          sdkVersion: optionsState.sdkVersion,
          projectId: optionsState.projectId,
          sdkType: optionsState.sdkType
        });
      }
    }, 100);
  },
  goBackToIndex(historyIndex) {
    if (state$h.history.length > 1) {
      state$h.history = state$h.history.slice(0, historyIndex + 1);
      const [last] = state$h.history.slice(-1);
      if (last) {
        state$h.view = last;
      }
    }
  }
};
const DEFAULT_STATE = Object.freeze({
  message: "",
  variant: "success",
  svg: void 0,
  open: false,
  autoClose: true
});
const state$g = proxy({
  ...DEFAULT_STATE
});
const SnackController = {
  state: state$g,
  subscribeKey(key2, callback) {
    return subscribeKey(state$g, key2, callback);
  },
  showLoading(message, options = {}) {
    this._showMessage({ message, variant: "loading", ...options });
  },
  showSuccess(message) {
    this._showMessage({ message, variant: "success" });
  },
  showSvg(message, svg) {
    this._showMessage({ message, svg });
  },
  showError(message) {
    const errorMessage = CoreHelperUtil.parseError(message);
    this._showMessage({ message: errorMessage, variant: "error" });
  },
  hide() {
    state$g.message = DEFAULT_STATE.message;
    state$g.variant = DEFAULT_STATE.variant;
    state$g.svg = DEFAULT_STATE.svg;
    state$g.open = DEFAULT_STATE.open;
    state$g.autoClose = DEFAULT_STATE.autoClose;
  },
  _showMessage({ message, svg, variant = "success", autoClose = DEFAULT_STATE.autoClose }) {
    if (state$g.open) {
      state$g.open = false;
      setTimeout(() => {
        state$g.message = message;
        state$g.variant = variant;
        state$g.svg = svg;
        state$g.open = true;
        state$g.autoClose = autoClose;
      }, 150);
    } else {
      state$g.message = message;
      state$g.variant = variant;
      state$g.svg = svg;
      state$g.open = true;
      state$g.autoClose = autoClose;
    }
  }
};
const SIWXUtil = {
  // Flag to prevent duplicate SIWE modal when manually authenticating
  _isAuthenticating: false,
  getSIWX() {
    return OptionsController.state.siwx;
  },
  async initializeIfEnabled() {
    var _a3;
    console.log(" initializeIfEnabled called, _isAuthenticating:", this._isAuthenticating);
    const siwx = OptionsController.state.siwx;
    const caipAddress = ChainController.getActiveCaipAddress();
    if (!(siwx && caipAddress)) {
      console.log(" No siwx or caipAddress, skipping");
      return;
    }
    const [namespace, chainId, address] = caipAddress.split(":");
    if (!ChainController.checkIfSupportedNetwork(namespace)) {
      console.log(" Network not supported, skipping");
      return;
    }
    if (this._isAuthenticating) {
      console.log(" Skipping auto SIWE modal - manual authentication in progress");
      return;
    }
    try {
      const sessions = await siwx.getSessions(`${namespace}:${chainId}`, address);
      console.log(" Existing sessions:", sessions.length);
      if (sessions.length) {
        console.log(" Session exists, skipping modal");
        return;
      }
      console.log(" Opening SIWE modal - no session found");
      await ModalController.open({
        view: "SIWXSignMessage"
      });
    } catch (error) {
      console.error("SIWXUtil:initializeIfEnabled", error);
      EventsController.sendEvent({
        type: "track",
        event: "SIWX_AUTH_ERROR",
        properties: this.getSIWXEventProperties()
      });
      await ((_a3 = ConnectionController._getClient()) == null ? void 0 : _a3.disconnect().catch(console.error));
      RouterController.reset("Connect");
      SnackController.showError("A problem occurred while trying initialize authentication");
    }
  },
  async requestSignMessage() {
    const siwx = OptionsController.state.siwx;
    const address = CoreHelperUtil.getPlainAddress(ChainController.getActiveCaipAddress());
    const network = ChainController.getActiveCaipNetwork();
    const client = ConnectionController._getClient();
    if (!siwx) {
      throw new Error("SIWX is not enabled");
    }
    if (!address) {
      throw new Error("No ActiveCaipAddress found");
    }
    if (!network) {
      throw new Error("No ActiveCaipNetwork or client found");
    }
    if (!client) {
      throw new Error("No ConnectionController client found");
    }
    try {
      const siwxMessage = await siwx.createMessage({
        chainId: network.caipNetworkId,
        accountAddress: address
      });
      const message = siwxMessage.toString();
      const connectorId = StorageUtil.getConnectedConnectorId(network.chainNamespace);
      if (connectorId === ConstantsUtil$4.CONNECTOR_ID.AUTH) {
        RouterController.pushTransactionStack({
          view: null,
          goBack: false,
          replace: true
        });
      }
      const signature2 = await client.signMessage({
        message
      });
      await siwx.addSession({
        data: siwxMessage,
        message,
        signature: signature2
      });
      ModalController.close();
      EventsController.sendEvent({
        type: "track",
        event: "SIWX_AUTH_SUCCESS",
        properties: this.getSIWXEventProperties()
      });
    } catch (error) {
      const properties = this.getSIWXEventProperties();
      if (!ModalController.state.open || RouterController.state.view === "ApproveTransaction") {
        await ModalController.open({
          view: "SIWXSignMessage"
        });
      }
      if (properties.isSmartAccount) {
        SnackController.showError("This application might not support Smart Accounts");
      } else {
        SnackController.showError("Signature declined");
      }
      EventsController.sendEvent({
        type: "track",
        event: "SIWX_AUTH_ERROR",
        properties
      });
      console.error("SWIXUtil:requestSignMessage", error);
    }
  },
  async cancelSignMessage() {
    var _a3;
    try {
      const siwx = this.getSIWX();
      const required = (_a3 = siwx == null ? void 0 : siwx.getRequired) == null ? void 0 : _a3.call(siwx);
      if (required) {
        await ConnectionController.disconnect();
      } else {
        ModalController.close();
      }
      RouterController.reset("Connect");
      EventsController.sendEvent({
        event: "CLICK_CANCEL_SIWX",
        type: "track",
        properties: this.getSIWXEventProperties()
      });
    } catch (error) {
      console.error("SIWXUtil:cancelSignMessage", error);
    }
  },
  async getSessions() {
    const siwx = OptionsController.state.siwx;
    const address = CoreHelperUtil.getPlainAddress(ChainController.getActiveCaipAddress());
    const network = ChainController.getActiveCaipNetwork();
    if (!(siwx && address && network)) {
      return [];
    }
    return siwx.getSessions(network.caipNetworkId, address);
  },
  async isSIWXCloseDisabled() {
    var _a3;
    const siwx = this.getSIWX();
    if (siwx) {
      const isApproveSignScreen = RouterController.state.view === "ApproveTransaction";
      const isSiwxSignMessage = RouterController.state.view === "SIWXSignMessage";
      if (isApproveSignScreen || isSiwxSignMessage) {
        return ((_a3 = siwx.getRequired) == null ? void 0 : _a3.call(siwx)) && (await this.getSessions()).length === 0;
      }
    }
    return false;
  },
  async universalProviderAuthenticate({ universalProvider, chains, methods }) {
    var _a3, _b2, _c3;
    const siwx = SIWXUtil.getSIWX();
    const namespaces = new Set(chains.map((chain) => chain.split(":")[0]));
    console.log(" SIWX Debug:", {
      hasSIWX: Boolean(siwx),
      namespaceSize: namespaces.size,
      namespaces: Array.from(namespaces),
      hasEIP155: namespaces.has("eip155"),
      chains
    });
    if (!siwx || namespaces.size !== 1 || !namespaces.has("eip155")) {
      console.warn(" Falling back to regular connect (not using sessionAuthenticate)", {
        reason: !siwx ? "No SIWX config" : namespaces.size !== 1 ? "Multiple namespaces" : "Not EIP155"
      });
      return { authenticated: false, sessions: [] };
    }
    this._isAuthenticating = true;
    const siwxMessage = await siwx.createMessage({
      chainId: ((_a3 = ChainController.getActiveCaipNetwork()) == null ? void 0 : _a3.caipNetworkId) || "",
      accountAddress: ""
    });
    universalProvider.once("display_uri", (uri2) => {
      ConnectionController.setUri(uri2);
    });
    SnackController.showLoading("Authenticating...", { autoClose: false });
    const result = await universalProvider.authenticate({
      nonce: siwxMessage.nonce,
      domain: siwxMessage.domain,
      uri: siwxMessage.uri,
      exp: siwxMessage.expirationTime,
      iat: siwxMessage.issuedAt,
      nbf: siwxMessage.notBefore,
      requestId: siwxMessage.requestId,
      version: siwxMessage.version,
      resources: siwxMessage.resources,
      statement: siwxMessage.statement,
      chainId: siwxMessage.chainId,
      methods,
      // The first chainId is what is used for universal provider to build the message
      chains: [siwxMessage.chainId, ...chains.filter((chain) => chain !== siwxMessage.chainId)]
    });
    AccountController.setConnectedWalletInfo({
      ...result.session.peer.metadata,
      name: result.session.peer.metadata.name,
      icon: (_b2 = result.session.peer.metadata.icons) == null ? void 0 : _b2[0],
      type: "WALLET_CONNECT"
    }, Array.from(namespaces)[0]);
    if ((_c3 = result == null ? void 0 : result.auths) == null ? void 0 : _c3.length) {
      const sessions = result.auths.map((cacao) => {
        const message = universalProvider.client.formatAuthMessage({
          request: cacao.p,
          iss: cacao.p.iss
        });
        return {
          data: {
            ...cacao.p,
            accountAddress: cacao.p.iss.split(":").slice(-1).join(""),
            chainId: cacao.p.iss.split(":").slice(2, 4).join(":"),
            uri: cacao.p.aud,
            version: cacao.p.version || siwxMessage.version,
            expirationTime: cacao.p.exp,
            issuedAt: cacao.p.iat,
            notBefore: cacao.p.nbf
          },
          message,
          signature: cacao.s.s,
          cacao
        };
      });
      try {
        await siwx.setSessions(sessions);
        if (sessions.length > 0 && sessions[0]) {
          const firstSession = sessions[0];
          let savedSessions = await siwx.getSessions(firstSession.data.chainId, firstSession.data.accountAddress);
          if (savedSessions.length === 0) {
            console.warn(" Sessions not found immediately after saving, waiting...");
            await new Promise((resolve) => setTimeout(resolve, 100));
            savedSessions = await siwx.getSessions(firstSession.data.chainId, firstSession.data.accountAddress);
            console.log(" Re-checked sessions after delay:", savedSessions.length);
          }
        }
        EventsController.sendEvent({
          type: "track",
          event: "SIWX_AUTH_SUCCESS",
          properties: SIWXUtil.getSIWXEventProperties()
        });
        setTimeout(() => {
          console.log(" Clearing _isAuthenticating flag (delayed)");
          this._isAuthenticating = false;
        }, 200);
        return { authenticated: true, sessions };
      } catch (error) {
        console.error("SIWX:universalProviderAuth - failed to set sessions", error);
        EventsController.sendEvent({
          type: "track",
          event: "SIWX_AUTH_ERROR",
          properties: SIWXUtil.getSIWXEventProperties()
        });
        await universalProvider.disconnect().catch(console.error);
        this._isAuthenticating = false;
        throw error;
      } finally {
        SnackController.hide();
      }
    }
    this._isAuthenticating = false;
    return { authenticated: false, sessions: [] };
  },
  getSIWXEventProperties() {
    var _a3;
    return {
      network: ((_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.caipNetworkId) || "",
      isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
    };
  },
  async clearSessions() {
    const siwx = this.getSIWX();
    if (siwx) {
      await siwx.setSessions([]);
    }
  }
};
const state$f = proxy({
  transactions: [],
  coinbaseTransactions: {},
  transactionsByYear: {},
  lastNetworkInView: void 0,
  loading: false,
  empty: false,
  next: void 0
});
const TransactionsController = {
  state: state$f,
  subscribe(callback) {
    return subscribe(state$f, () => callback(state$f));
  },
  setLastNetworkInView(lastNetworkInView) {
    state$f.lastNetworkInView = lastNetworkInView;
  },
  async fetchTransactions(accountAddress, onramp) {
    var _a3;
    if (!accountAddress) {
      throw new Error("Transactions can't be fetched without an accountAddress");
    }
    state$f.loading = true;
    try {
      const response = await BlockchainApiController.fetchTransactions({
        account: accountAddress,
        cursor: state$f.next,
        onramp,
        // Coinbase transaction history state updates require the latest data
        cache: onramp === "coinbase" ? "no-cache" : void 0,
        chainId: (_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.caipNetworkId
      });
      const nonSpamTransactions = this.filterSpamTransactions(response.data);
      const sameChainTransactions = this.filterByConnectedChain(nonSpamTransactions);
      const filteredTransactions = [...state$f.transactions, ...sameChainTransactions];
      state$f.loading = false;
      if (onramp === "coinbase") {
        state$f.coinbaseTransactions = this.groupTransactionsByYearAndMonth(state$f.coinbaseTransactions, response.data);
      } else {
        state$f.transactions = filteredTransactions;
        state$f.transactionsByYear = this.groupTransactionsByYearAndMonth(state$f.transactionsByYear, sameChainTransactions);
      }
      state$f.empty = filteredTransactions.length === 0;
      state$f.next = response.next ? response.next : void 0;
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "ERROR_FETCH_TRANSACTIONS",
        properties: {
          address: accountAddress,
          projectId: OptionsController.state.projectId,
          cursor: state$f.next,
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
        }
      });
      SnackController.showError("Failed to fetch transactions");
      state$f.loading = false;
      state$f.empty = true;
      state$f.next = void 0;
    }
  },
  groupTransactionsByYearAndMonth(transactionsMap = {}, transactions = []) {
    const grouped = transactionsMap;
    transactions.forEach((transaction) => {
      const year = new Date(transaction.metadata.minedAt).getFullYear();
      const month = new Date(transaction.metadata.minedAt).getMonth();
      const yearTransactions = grouped[year] ?? {};
      const monthTransactions = yearTransactions[month] ?? [];
      const newMonthTransactions = monthTransactions.filter((tx) => tx.id !== transaction.id);
      grouped[year] = {
        ...yearTransactions,
        [month]: [...newMonthTransactions, transaction].sort((a2, b2) => new Date(b2.metadata.minedAt).getTime() - new Date(a2.metadata.minedAt).getTime())
      };
    });
    return grouped;
  },
  filterSpamTransactions(transactions) {
    return transactions.filter((transaction) => {
      const isAllSpam = transaction.transfers.every((transfer) => {
        var _a3;
        return ((_a3 = transfer.nft_info) == null ? void 0 : _a3.flags.is_spam) === true;
      });
      return !isAllSpam;
    });
  },
  filterByConnectedChain(transactions) {
    var _a3;
    const chainId = (_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.caipNetworkId;
    const filteredTransactions = transactions.filter((transaction) => transaction.metadata.chain === chainId);
    return filteredTransactions;
  },
  clearCursor() {
    state$f.next = void 0;
  },
  resetTransactions() {
    state$f.transactions = [];
    state$f.transactionsByYear = {};
    state$f.lastNetworkInView = void 0;
    state$f.loading = false;
    state$f.empty = false;
    state$f.next = void 0;
  }
};
const state$e = proxy({
  wcError: false,
  buffering: false,
  status: "disconnected"
});
let wcConnectionPromise;
const ConnectionController = {
  state: state$e,
  subscribeKey(key2, callback) {
    return subscribeKey(state$e, key2, callback);
  },
  _getClient() {
    return state$e._client;
  },
  setClient(client) {
    state$e._client = ref$1(client);
  },
  async connectWalletConnect() {
    var _a3, _b2, _c3, _d;
    const namespaces = [...ChainController.state.chains.keys()];
    namespaces.forEach((namespace) => {
      StorageUtil.setConnectedConnectorId(namespace, ConstantsUtil$4.CONNECTOR_ID.WALLET_CONNECT);
    });
    if (CoreHelperUtil.isTelegram() || CoreHelperUtil.isSafari() && CoreHelperUtil.isIos()) {
      if (wcConnectionPromise) {
        await wcConnectionPromise;
        wcConnectionPromise = void 0;
        return;
      }
      if (!CoreHelperUtil.isPairingExpired(state$e == null ? void 0 : state$e.wcPairingExpiry)) {
        const link = state$e.wcUri;
        state$e.wcUri = link;
        return;
      }
      wcConnectionPromise = (_b2 = (_a3 = this._getClient()) == null ? void 0 : _a3.connectWalletConnect) == null ? void 0 : _b2.call(_a3).catch(() => void 0);
      this.state.status = "connecting";
      await wcConnectionPromise;
      wcConnectionPromise = void 0;
      state$e.wcPairingExpiry = void 0;
      this.state.status = "connected";
    } else {
      await ((_d = (_c3 = this._getClient()) == null ? void 0 : _c3.connectWalletConnect) == null ? void 0 : _d.call(_c3));
    }
  },
  async authenticateWalletConnect() {
    const namespaces = [...ChainController.state.chains.keys()];
    namespaces.forEach((namespace) => {
      StorageUtil.setConnectedConnectorId(namespace, ConstantsUtil$4.CONNECTOR_ID.WALLET_CONNECT);
    });
    const client = this._getClient();
    if (!(client == null ? void 0 : client.authenticateWalletConnect)) {
      throw new Error("authenticateWalletConnect method is not available");
    }
    this.state.status = "connecting";
    try {
      const result = await client.authenticateWalletConnect();
      if (result && typeof result === "object" && "authenticated" in result) {
        if (result.authenticated) {
          this.state.status = "connected";
          EventsController.sendEvent({
            type: "track",
            event: "CONNECT_SUCCESS",
            properties: {
              method: "qrcode",
              name: "WalletConnect"
            }
          });
          return result;
        }
        this.state.status = "disconnected";
        return result;
      }
      if (result) {
        this.state.status = "connected";
        EventsController.sendEvent({
          type: "track",
          event: "CONNECT_SUCCESS",
          properties: {
            method: "qrcode",
            name: "WalletConnect"
          }
        });
        return true;
      }
      this.state.status = "disconnected";
      return false;
    } catch (error) {
      this.state.status = "disconnected";
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: {
          message: error instanceof Error ? error.message : "Unknown error"
        }
      });
      throw error;
    }
  },
  async connectExternal(options, chain, setChain = true) {
    var _a3;
    const client = this._getClient();
    await ((_a3 = client == null ? void 0 : client.connectExternal) == null ? void 0 : _a3.call(client, options));
    if (setChain) {
      ChainController.setActiveNamespace(chain);
    }
  },
  async reconnectExternal(options) {
    var _a3, _b2;
    await ((_b2 = (_a3 = this._getClient()) == null ? void 0 : _a3.reconnectExternal) == null ? void 0 : _b2.call(_a3, options));
    const namespace = options.chain || ChainController.state.activeChain;
    if (namespace) {
      StorageUtil.setConnectedConnectorId(namespace, options.id);
    }
  },
  async setPreferredAccountType(accountType) {
    var _a3;
    ModalController.setLoading(true);
    const authConnector = ConnectorController.getAuthConnector();
    if (!authConnector) {
      return;
    }
    await (authConnector == null ? void 0 : authConnector.provider.setPreferredAccount(accountType));
    await this.reconnectExternal(authConnector);
    ModalController.setLoading(false);
    EventsController.sendEvent({
      type: "track",
      event: "SET_PREFERRED_ACCOUNT_TYPE",
      properties: {
        accountType,
        network: ((_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.caipNetworkId) || ""
      }
    });
  },
  async signMessage(params) {
    var _a3;
    return (_a3 = this._getClient()) == null ? void 0 : _a3.signMessage(params);
  },
  async etherSignMessage(params) {
    var _a3;
    return (_a3 = this._getClient()) == null ? void 0 : _a3.etherSignMessage(params);
  },
  async signEIP712(args) {
    var _a3;
    return (_a3 = this._getClient()) == null ? void 0 : _a3.signEIP712(args);
  },
  async signTypedDataV4(paramsData, customData) {
    var _a3;
    return (_a3 = this._getClient()) == null ? void 0 : _a3.signTypedDataV4(paramsData, customData);
  },
  parseUnits(value, decimals) {
    var _a3;
    return (_a3 = this._getClient()) == null ? void 0 : _a3.parseUnits(value, decimals);
  },
  formatUnits(value, decimals) {
    var _a3;
    return (_a3 = this._getClient()) == null ? void 0 : _a3.formatUnits(value, decimals);
  },
  async sendTransaction(args) {
    var _a3;
    return (_a3 = this._getClient()) == null ? void 0 : _a3.sendTransaction(args);
  },
  async getCapabilities(params) {
    var _a3;
    return (_a3 = this._getClient()) == null ? void 0 : _a3.getCapabilities(params);
  },
  async grantPermissions(params) {
    var _a3;
    return (_a3 = this._getClient()) == null ? void 0 : _a3.grantPermissions(params);
  },
  async walletGetAssets(params) {
    var _a3;
    return ((_a3 = this._getClient()) == null ? void 0 : _a3.walletGetAssets(params)) ?? {};
  },
  async estimateGas(args) {
    var _a3;
    return (_a3 = this._getClient()) == null ? void 0 : _a3.estimateGas(args);
  },
  async writeContract(args) {
    var _a3;
    return (_a3 = this._getClient()) == null ? void 0 : _a3.writeContract(args);
  },
  async readContract(args) {
    var _a3;
    return (_a3 = this._getClient()) == null ? void 0 : _a3.readContract(args);
  },
  async getEnsAddress(value) {
    var _a3;
    return (_a3 = this._getClient()) == null ? void 0 : _a3.getEnsAddress(value);
  },
  async getEnsAvatar(value) {
    var _a3;
    return (_a3 = this._getClient()) == null ? void 0 : _a3.getEnsAvatar(value);
  },
  checkInstalled(ids) {
    var _a3, _b2;
    return ((_b2 = (_a3 = this._getClient()) == null ? void 0 : _a3.checkInstalled) == null ? void 0 : _b2.call(_a3, ids)) || false;
  },
  resetWcConnection() {
    state$e.wcUri = void 0;
    state$e.wcPairingExpiry = void 0;
    state$e.wcLinking = void 0;
    state$e.recentWallet = void 0;
    state$e.status = "disconnected";
    TransactionsController.resetTransactions();
    StorageUtil.deleteWalletConnectDeepLink();
  },
  setUri(uri2) {
    state$e.wcUri = uri2;
    state$e.wcPairingExpiry = CoreHelperUtil.getPairingExpiry();
  },
  setWcLinking(wcLinking) {
    state$e.wcLinking = wcLinking;
  },
  setWcError(wcError) {
    state$e.wcError = wcError;
    state$e.buffering = false;
  },
  setRecentWallet(wallet) {
    state$e.recentWallet = wallet;
  },
  setBuffering(buffering) {
    state$e.buffering = buffering;
  },
  setStatus(status) {
    state$e.status = status;
  },
  async disconnect() {
    try {
      ModalController.setLoading(true);
      await SIWXUtil.clearSessions();
      await ChainController.disconnect();
      ModalController.setLoading(false);
    } catch (error) {
      throw new Error("Failed to disconnect");
    }
  }
};
const state$d = proxy({
  loading: false,
  open: false,
  selectedNetworkId: void 0,
  activeChain: void 0,
  initialized: false
});
const PublicStateController = {
  state: state$d,
  subscribe(callback) {
    return subscribe(state$d, () => callback(state$d));
  },
  set(newState) {
    Object.assign(state$d, { ...state$d, ...newState });
  }
};
const ERC7811Utils = {
  /**
   * Creates a Balance object from an ERC7811 Asset object
   * @param asset - Asset object to convert
   * @param chainId - Chain ID in CAIP-2 format
   * @returns Balance object
   */
  createBalance(asset, chainId) {
    const metadata = {
      name: asset.metadata["name"] || "",
      symbol: asset.metadata["symbol"] || "",
      decimals: asset.metadata["decimals"] || 0,
      value: asset.metadata["value"] || 0,
      price: asset.metadata["price"] || 0,
      iconUrl: asset.metadata["iconUrl"] || ""
    };
    return {
      name: metadata.name,
      symbol: metadata.symbol,
      chainId,
      address: asset.address === "native" ? void 0 : this.convertAddressToCAIP10Address(asset.address, chainId),
      value: metadata.value,
      price: metadata.price,
      quantity: {
        decimals: metadata.decimals.toString(),
        numeric: this.convertHexToBalance({
          hex: asset.balance,
          decimals: metadata.decimals
        })
      },
      iconUrl: metadata.iconUrl
    };
  },
  /**
   * Converts a hex string to a Balance object
   * @param hex - Hex string to convert
   * @param decimals - Number of decimals to use
   * @returns Balance object
   */
  convertHexToBalance({ hex, decimals }) {
    return formatUnits$1(BigInt(hex), decimals);
  },
  /**
   * Converts an address to a CAIP-10 address
   * @param address - Address to convert
   * @param chainId - Chain ID in CAIP-2 format
   * @returns CAIP-10 address
   */
  convertAddressToCAIP10Address(address, chainId) {
    return `${chainId}:${address}`;
  },
  /**
   *  Creates a CAIP-2 Chain ID from a chain ID and namespace
   * @param chainId  - Chain ID in hex format
   * @param namespace  - Chain namespace
   * @returns
   */
  createCAIP2ChainId(chainId, namespace) {
    return `${namespace}:${parseInt(chainId, 16)}`;
  },
  /**
   * Gets the chain ID in hex format from a CAIP-2 Chain ID
   * @param caip2ChainId - CAIP-2 Chain ID
   * @returns Chain ID in hex format
   */
  getChainIdHexFromCAIP2ChainId(caip2ChainId) {
    const parts = caip2ChainId.split(":");
    if (parts.length < 2 || !parts[1]) {
      return "0x0";
    }
    const chainPart = parts[1];
    const parsed = parseInt(chainPart, 10);
    return isNaN(parsed) ? "0x0" : `0x${parsed.toString(16)}`;
  },
  /**
   * Checks if a response is a valid WalletGetAssetsResponse
   * @param response - The response to check
   * @returns True if the response is a valid WalletGetAssetsResponse, false otherwise
   */
  isWalletGetAssetsResponse(response) {
    if (typeof response !== "object" || response === null) {
      return false;
    }
    return Object.values(response).every((value) => Array.isArray(value) && value.every((asset) => this.isValidAsset(asset)));
  },
  /**
   * Checks if an asset object is valid.
   * @param asset - The asset object to check.
   * @returns True if the asset is valid, false otherwise.
   */
  isValidAsset(asset) {
    return typeof asset === "object" && asset !== null && typeof asset.address === "string" && typeof asset.balance === "string" && (asset.type === "ERC20" || asset.type === "NATIVE") && typeof asset.metadata === "object" && asset.metadata !== null && typeof asset.metadata["name"] === "string" && typeof asset.metadata["symbol"] === "string" && typeof asset.metadata["decimals"] === "number" && typeof asset.metadata["price"] === "number" && typeof asset.metadata["iconUrl"] === "string";
  }
};
const SendApiUtil = {
  async getMyTokensWithBalance(forceUpdate) {
    const address = AccountController.state.address;
    const caipNetwork = ChainController.state.activeCaipNetwork;
    if (!address || !caipNetwork) {
      return [];
    }
    if (caipNetwork.chainNamespace === "eip155") {
      const eip155Balances = await this.getEIP155Balances(address, caipNetwork);
      if (eip155Balances) {
        return this.filterLowQualityTokens(eip155Balances);
      }
    }
    const balances = await ApiController$1.getBalance(address, caipNetwork.caipNetworkId, forceUpdate);
    return this.filterLowQualityTokens(balances);
  },
  async getEIP155Balances(address, caipNetwork) {
    try {
      const chainIdHex = ERC7811Utils.getChainIdHexFromCAIP2ChainId(caipNetwork.caipNetworkId);
      const walletGetAssetsResponse = await ConnectionController.walletGetAssets({
        account: address,
        chainFilter: [chainIdHex]
      });
      if (!ERC7811Utils.isWalletGetAssetsResponse(walletGetAssetsResponse)) {
        return null;
      }
      const assets = walletGetAssetsResponse[chainIdHex] || [];
      return assets.map((asset) => ERC7811Utils.createBalance(asset, caipNetwork.caipNetworkId));
    } catch (error) {
      return null;
    }
  },
  /**
   * The 1Inch API includes many low-quality tokens in the balance response,
   * which appear inconsistently. This filter prevents them from being displayed.
   */
  filterLowQualityTokens(balances) {
    return balances.filter((balance) => balance.quantity.decimals !== "0");
  },
  mapBalancesToSwapTokens(balances) {
    return (balances == null ? void 0 : balances.map((token) => ({
      ...token,
      address: (token == null ? void 0 : token.address) ? token.address : ChainController.getActiveNetworkTokenAddress(),
      decimals: parseInt(token.quantity.decimals, 10),
      logoUri: token.iconUrl,
      eip2612: false
    }))) || [];
  }
};
const state$c = proxy({
  tokenBalances: [],
  loading: false
});
const SendController = {
  state: state$c,
  subscribe(callback) {
    return subscribe(state$c, () => callback(state$c));
  },
  subscribeKey(key2, callback) {
    return subscribeKey(state$c, key2, callback);
  },
  setToken(token) {
    if (token) {
      state$c.token = ref$1(token);
    }
  },
  setTokenAmount(sendTokenAmount) {
    state$c.sendTokenAmount = sendTokenAmount;
  },
  setReceiverAddress(receiverAddress) {
    state$c.receiverAddress = receiverAddress;
  },
  setReceiverProfileImageUrl(receiverProfileImageUrl) {
    state$c.receiverProfileImageUrl = receiverProfileImageUrl;
  },
  setReceiverProfileName(receiverProfileName) {
    state$c.receiverProfileName = receiverProfileName;
  },
  setGasPrice(gasPrice) {
    state$c.gasPrice = gasPrice;
  },
  setGasPriceInUsd(gasPriceInUSD) {
    state$c.gasPriceInUSD = gasPriceInUSD;
  },
  setNetworkBalanceInUsd(networkBalanceInUSD) {
    state$c.networkBalanceInUSD = networkBalanceInUSD;
  },
  setLoading(loading) {
    state$c.loading = loading;
  },
  sendToken() {
    var _a3;
    switch ((_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.chainNamespace) {
      case "eip155":
        this.sendEvmToken();
        return;
      case "solana":
        this.sendSolanaToken();
        return;
      default:
        throw new Error("Unsupported chain");
    }
  },
  sendEvmToken() {
    var _a3, _b2, _c3, _d, _e4;
    if (((_a3 = this.state.token) == null ? void 0 : _a3.address) && this.state.sendTokenAmount && this.state.receiverAddress) {
      EventsController.sendEvent({
        type: "track",
        event: "SEND_INITIATED",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          token: this.state.token.address,
          amount: this.state.sendTokenAmount,
          network: ((_b2 = ChainController.state.activeCaipNetwork) == null ? void 0 : _b2.caipNetworkId) || ""
        }
      });
      this.sendERC20Token({
        receiverAddress: this.state.receiverAddress,
        contractAddress: this.state.token.address,
        sendTokenAmount: this.state.sendTokenAmount,
        decimals: this.state.token.quantity.decimals
      });
    } else if (this.state.receiverAddress && this.state.sendTokenAmount && this.state.gasPrice && ((_c3 = this.state.token) == null ? void 0 : _c3.quantity.decimals)) {
      EventsController.sendEvent({
        type: "track",
        event: "SEND_INITIATED",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          token: (_d = this.state.token) == null ? void 0 : _d.symbol,
          amount: this.state.sendTokenAmount,
          network: ((_e4 = ChainController.state.activeCaipNetwork) == null ? void 0 : _e4.caipNetworkId) || ""
        }
      });
      this.sendNativeToken({
        receiverAddress: this.state.receiverAddress,
        sendTokenAmount: this.state.sendTokenAmount,
        gasPrice: this.state.gasPrice,
        decimals: this.state.token.quantity.decimals
      });
    } else {
      console.log(`invalid token. not native nor erc20`);
    }
  },
  // Not used in the appkit.
  async fetchTokenBalance(onError) {
    var _a3, _b2;
    state$c.loading = true;
    const chainId = (_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.caipNetworkId;
    const chain = (_b2 = ChainController.state.activeCaipNetwork) == null ? void 0 : _b2.chainNamespace;
    const caipAddress = ChainController.state.activeCaipAddress;
    const address = caipAddress ? CoreHelperUtil.getPlainAddress(caipAddress) : void 0;
    if (state$c.lastRetry && !CoreHelperUtil.isAllowedRetry(state$c.lastRetry, 30 * ConstantsUtil$3.ONE_SEC_MS)) {
      state$c.loading = false;
      return [];
    }
    try {
      if (address && chainId && chain) {
        const balances = await SendApiUtil.getMyTokensWithBalance();
        state$c.tokenBalances = balances;
        state$c.lastRetry = void 0;
        return balances;
      }
    } catch (error) {
      state$c.lastRetry = Date.now();
      onError == null ? void 0 : onError(error);
      SnackController.showError("Token Balance Unavailable");
    } finally {
      state$c.loading = false;
    }
    return [];
  },
  fetchNetworkBalance() {
    if (state$c.tokenBalances.length === 0) {
      return;
    }
    const networkTokenBalances = SendApiUtil.mapBalancesToSwapTokens(state$c.tokenBalances);
    if (!networkTokenBalances) {
      return;
    }
    const networkToken = networkTokenBalances.find((token) => token.address === ChainController.getActiveNetworkTokenAddress());
    if (!networkToken) {
      return;
    }
    state$c.networkBalanceInUSD = networkToken ? NumberUtil.multiply(networkToken.quantity.numeric, networkToken.price).toString() : "0";
  },
  isInsufficientNetworkTokenForGas(networkBalanceInUSD, gasPriceInUSD) {
    const gasPrice = gasPriceInUSD || "0";
    if (NumberUtil.bigNumber(networkBalanceInUSD).eq(0)) {
      return true;
    }
    return NumberUtil.bigNumber(NumberUtil.bigNumber(gasPrice)).gt(networkBalanceInUSD);
  },
  hasInsufficientGasFunds() {
    let isInsufficientNetworkTokenForGas = true;
    if (AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT) {
      isInsufficientNetworkTokenForGas = false;
    } else if (state$c.networkBalanceInUSD) {
      isInsufficientNetworkTokenForGas = this.isInsufficientNetworkTokenForGas(state$c.networkBalanceInUSD, state$c.gasPriceInUSD);
    }
    return isInsufficientNetworkTokenForGas;
  },
  async sendNativeToken(params) {
    var _a3, _b2, _c3, _d;
    try {
      RouterController.pushTransactionStack({
        view: "Account",
        goBack: false
      });
      const to2 = params.receiverAddress;
      const address = AccountController.state.address;
      const value = ConnectionController.parseUnits(params.sendTokenAmount.toString(), Number(params.decimals));
      const data2 = params.data ?? "0x";
      const customData = params.customData;
      const type2 = params.type ?? ConstantsUtil$3.TRANSACTION_TYPE.LEGACY;
      const gas = params.gas;
      const gasPrice = params.gasPrice;
      const maxFee = params.maxFee;
      const maxPriorityFee = params.maxPriorityFee;
      const resTx = await ConnectionController.sendTransaction({
        chainNamespace: "eip155",
        to: to2,
        address,
        data: data2,
        value: value ?? BigInt(0),
        gas,
        gasPrice,
        maxFee,
        maxPriorityFee,
        customData,
        type: type2
      });
      SnackController.showSuccess("Transaction started");
      EventsController.sendEvent({
        type: "track",
        event: "SEND_SUCCESS",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          token: ((_a3 = this.state.token) == null ? void 0 : _a3.symbol) || "",
          amount: params.sendTokenAmount,
          network: ((_b2 = ChainController.state.activeCaipNetwork) == null ? void 0 : _b2.caipNetworkId) || ""
        }
      });
      this.resetSend();
      return resTx;
    } catch (error) {
      console.error("SendController:sendNativeToken - failed to send native token", error);
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      EventsController.sendEvent({
        type: "track",
        event: "SEND_ERROR",
        properties: {
          message: errorMessage,
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          token: ((_c3 = this.state.token) == null ? void 0 : _c3.symbol) || "",
          amount: params.sendTokenAmount,
          network: ((_d = ChainController.state.activeCaipNetwork) == null ? void 0 : _d.caipNetworkId) || ""
        }
      });
      SnackController.showError("Something went wrong");
      return null;
    }
  },
  async sendERC20Token(params) {
    var _a3, _b2;
    try {
      RouterController.pushTransactionStack({
        view: "Account",
        goBack: false
      });
      const amount = ConnectionController.parseUnits(params.sendTokenAmount.toString(), Number(params.decimals));
      if (AccountController.state.address && params.sendTokenAmount && params.receiverAddress && params.contractAddress) {
        const contractAddress = CoreHelperUtil.getPlainAddress(params.contractAddress);
        const customData = params.customData;
        const type2 = params.type ?? ConstantsUtil$3.TRANSACTION_TYPE.LEGACY;
        const gas = params.gas;
        const gasPrice = params.gasPrice;
        const maxFee = params.maxFee;
        const maxPriorityFee = params.maxPriorityFee;
        const resTx = await ConnectionController.writeContract({
          fromAddress: AccountController.state.address,
          contractAddress,
          args: [params.receiverAddress, amount ?? BigInt(0)],
          method: "transfer",
          abi: ContractUtil.getERC20Abi(contractAddress),
          chainNamespace: "eip155",
          customData,
          type: type2,
          gas,
          gasPrice,
          maxFee,
          maxPriorityFee
        });
        SnackController.showSuccess("Transaction started");
        this.resetSend();
        return resTx;
      }
      throw new Error("Invalid params to sendERC20Token");
    } catch (error) {
      console.error("SendController:sendERC20Token - failed to send erc20 token", error);
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      EventsController.sendEvent({
        type: "track",
        event: "SEND_ERROR",
        properties: {
          message: errorMessage,
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          token: ((_a3 = this.state.token) == null ? void 0 : _a3.symbol) || "",
          amount: params.sendTokenAmount,
          network: ((_b2 = ChainController.state.activeCaipNetwork) == null ? void 0 : _b2.caipNetworkId) || ""
        }
      });
      SnackController.showError("Something went wrong");
      return null;
    }
  },
  sendSolanaToken() {
    if (!this.state.sendTokenAmount || !this.state.receiverAddress) {
      SnackController.showError("Please enter a valid amount and receiver address");
      return;
    }
    RouterController.pushTransactionStack({
      view: "Account",
      goBack: false
    });
    ConnectionController.sendTransaction({
      chainNamespace: "solana",
      to: this.state.receiverAddress,
      value: this.state.sendTokenAmount
    }).then(() => {
      this.resetSend();
      AccountController.fetchTokenBalance();
    }).catch((error) => {
      SnackController.showError("Failed to send transaction. Please try again.");
      console.error("SendController:sendToken - failed to send solana transaction", error);
    });
  },
  resetSend() {
    state$c.token = void 0;
    state$c.sendTokenAmount = void 0;
    state$c.receiverAddress = void 0;
    state$c.receiverProfileImageUrl = void 0;
    state$c.receiverProfileName = void 0;
    state$c.loading = false;
    state$c.tokenBalances = [];
  }
};
const accountState = {
  currentTab: 0,
  tokenBalance: [],
  smartAccountDeployed: false,
  addressLabels: /* @__PURE__ */ new Map(),
  allAccounts: [],
  user: void 0
};
const networkState = {
  supportsAllNetworks: true,
  smartAccountEnabledNetworks: []
};
const state$b = proxy({
  chains: proxyMap(),
  activeCaipAddress: void 0,
  activeChain: void 0,
  activeCaipNetwork: void 0,
  noAdapters: false,
  universalAdapter: {
    networkControllerClient: void 0,
    connectionControllerClient: void 0
  },
  isSwitchingNamespace: false
});
const ChainController = {
  state: state$b,
  subscribe(callback) {
    return subscribe(state$b, () => {
      callback(state$b);
    });
  },
  subscribeKey(key2, callback) {
    return subscribeKey(state$b, key2, callback);
  },
  subscribeChainProp(property, callback, chain) {
    let prev = void 0;
    return subscribe(state$b.chains, () => {
      var _a3;
      const activeChain = chain || state$b.activeChain;
      if (activeChain) {
        const nextValue = (_a3 = state$b.chains.get(activeChain)) == null ? void 0 : _a3[property];
        if (prev !== nextValue) {
          prev = nextValue;
          callback(nextValue);
        }
      }
    });
  },
  initialize(adapters, caipNetworks, clients) {
    const { chainId: activeChainId, namespace: activeNamespace } = StorageUtil.getActiveNetworkProps();
    const activeCaipNetwork = caipNetworks == null ? void 0 : caipNetworks.find((network) => network.id.toString() === (activeChainId == null ? void 0 : activeChainId.toString()));
    const defaultAdapter = adapters.find((adapter) => (adapter == null ? void 0 : adapter.namespace) === activeNamespace);
    const adapterToActivate = defaultAdapter || (adapters == null ? void 0 : adapters[0]);
    const namespaces = /* @__PURE__ */ new Set([...(caipNetworks == null ? void 0 : caipNetworks.map((network) => network.chainNamespace)) ?? []]);
    if ((adapters == null ? void 0 : adapters.length) === 0 || !adapterToActivate) {
      state$b.noAdapters = true;
    }
    if (!state$b.noAdapters) {
      state$b.activeChain = adapterToActivate == null ? void 0 : adapterToActivate.namespace;
      state$b.activeCaipNetwork = activeCaipNetwork;
      if (state$b.activeChain) {
        PublicStateController.set({ activeChain: adapterToActivate == null ? void 0 : adapterToActivate.namespace });
      }
    }
    namespaces.forEach((namespace) => {
      const namespaceNetworks = caipNetworks == null ? void 0 : caipNetworks.filter((network) => network.chainNamespace === namespace);
      ChainController.state.chains.set(namespace, {
        namespace,
        networkState: proxy(networkState),
        accountState: proxy(accountState),
        caipNetworks: namespaceNetworks ?? [],
        ...clients
      });
      this.setRequestedCaipNetworks(namespaceNetworks ?? [], namespace);
    });
  },
  removeAdapter(namespace) {
    var _a3, _b2;
    if (state$b.activeChain === namespace) {
      const nextAdapter = Array.from(state$b.chains.entries()).find(([chainNamespace]) => chainNamespace !== namespace);
      if (nextAdapter) {
        const caipNetwork = (_b2 = (_a3 = nextAdapter[1]) == null ? void 0 : _a3.caipNetworks) == null ? void 0 : _b2[0];
        if (caipNetwork) {
          this.setActiveCaipNetwork(caipNetwork);
        }
      }
    }
    state$b.chains.delete(namespace);
  },
  addAdapter(adapter, { networkControllerClient, connectionControllerClient }, caipNetworks) {
    state$b.chains.set(adapter.namespace, {
      namespace: adapter.namespace,
      networkState,
      accountState,
      caipNetworks,
      connectionControllerClient,
      networkControllerClient
    });
    this.setRequestedCaipNetworks((caipNetworks == null ? void 0 : caipNetworks.filter((caipNetwork) => caipNetwork.chainNamespace === adapter.namespace)) ?? [], adapter.namespace);
  },
  addNetwork(network) {
    var _a3;
    const chainAdapter = state$b.chains.get(network.chainNamespace);
    if (chainAdapter) {
      const newNetworks = [...chainAdapter.caipNetworks || []];
      if (!((_a3 = chainAdapter.caipNetworks) == null ? void 0 : _a3.find((caipNetwork) => caipNetwork.id === network.id))) {
        newNetworks.push(network);
      }
      state$b.chains.set(network.chainNamespace, { ...chainAdapter, caipNetworks: newNetworks });
      this.setRequestedCaipNetworks(newNetworks, network.chainNamespace);
    }
  },
  removeNetwork(namespace, networkId) {
    var _a3, _b2, _c3;
    const chainAdapter = state$b.chains.get(namespace);
    if (chainAdapter) {
      const isActiveNetwork = ((_a3 = state$b.activeCaipNetwork) == null ? void 0 : _a3.id) === networkId;
      const newCaipNetworksOfAdapter = [
        ...((_b2 = chainAdapter.caipNetworks) == null ? void 0 : _b2.filter((network) => network.id !== networkId)) || []
      ];
      if (isActiveNetwork && ((_c3 = chainAdapter == null ? void 0 : chainAdapter.caipNetworks) == null ? void 0 : _c3[0])) {
        this.setActiveCaipNetwork(chainAdapter.caipNetworks[0]);
      }
      state$b.chains.set(namespace, { ...chainAdapter, caipNetworks: newCaipNetworksOfAdapter });
      this.setRequestedCaipNetworks(newCaipNetworksOfAdapter || [], namespace);
    }
  },
  setAdapterNetworkState(chain, props) {
    const chainAdapter = state$b.chains.get(chain);
    if (chainAdapter) {
      chainAdapter.networkState = {
        ...chainAdapter.networkState || networkState,
        ...props
      };
      state$b.chains.set(chain, chainAdapter);
    }
  },
  setChainAccountData(chain, accountProps, _unknown = true) {
    if (!chain) {
      throw new Error("Chain is required to update chain account data");
    }
    const chainAdapter = state$b.chains.get(chain);
    if (chainAdapter) {
      const newAccountState = { ...chainAdapter.accountState || accountState, ...accountProps };
      state$b.chains.set(chain, { ...chainAdapter, accountState: newAccountState });
      if (state$b.chains.size === 1 || state$b.activeChain === chain) {
        if (accountProps.caipAddress !== void 0) {
          state$b.activeCaipAddress = accountProps.caipAddress;
        }
        AccountController.replaceState(newAccountState);
      }
    }
  },
  // eslint-disable-next-line max-params
  setAccountProp(prop, value, chain, replaceState = true) {
    this.setChainAccountData(chain, { [prop]: value }, replaceState);
  },
  setActiveNamespace(chain) {
    var _a3, _b2;
    state$b.activeChain = chain;
    const newAdapter = chain ? state$b.chains.get(chain) : void 0;
    const caipNetwork = (_a3 = newAdapter == null ? void 0 : newAdapter.networkState) == null ? void 0 : _a3.caipNetwork;
    if ((caipNetwork == null ? void 0 : caipNetwork.id) && chain) {
      state$b.activeCaipAddress = (_b2 = newAdapter == null ? void 0 : newAdapter.accountState) == null ? void 0 : _b2.caipAddress;
      state$b.activeCaipNetwork = caipNetwork;
      StorageUtil.setActiveCaipNetworkId(caipNetwork == null ? void 0 : caipNetwork.caipNetworkId);
      PublicStateController.set({
        activeChain: chain,
        selectedNetworkId: caipNetwork == null ? void 0 : caipNetwork.caipNetworkId
      });
    }
  },
  setActiveCaipNetwork(caipNetwork) {
    var _a3, _b2, _c3;
    console.log(`setActiveCaipNetwork - caipNetwork: ${caipNetwork == null ? void 0 : caipNetwork.id}`);
    if (!caipNetwork) {
      return;
    }
    if (state$b.activeChain !== caipNetwork.chainNamespace) {
      this.setIsSwitchingNamespace(true);
      ConnectorController.setFilterByNamespace(caipNetwork.chainNamespace);
    }
    const newAdapter = state$b.chains.get(caipNetwork.chainNamespace);
    state$b.activeChain = caipNetwork.chainNamespace;
    state$b.activeCaipNetwork = caipNetwork;
    if ((_a3 = newAdapter == null ? void 0 : newAdapter.accountState) == null ? void 0 : _a3.address) {
      state$b.activeCaipAddress = `${caipNetwork.chainNamespace}:${caipNetwork.id}:${(_b2 = newAdapter == null ? void 0 : newAdapter.accountState) == null ? void 0 : _b2.address}`;
    } else {
      state$b.activeCaipAddress = void 0;
    }
    this.setAccountProp("caipAddress", state$b.activeCaipAddress, caipNetwork.chainNamespace);
    if (newAdapter) {
      AccountController.replaceState(newAdapter.accountState);
    }
    SendController.resetSend();
    PublicStateController.set({
      activeChain: state$b.activeChain,
      selectedNetworkId: (_c3 = state$b.activeCaipNetwork) == null ? void 0 : _c3.caipNetworkId
    });
    StorageUtil.setActiveCaipNetworkId(caipNetwork.caipNetworkId);
    const isSupported = this.checkIfSupportedNetwork(caipNetwork.chainNamespace);
    if (!isSupported && !OptionsController.state.allowUnsupportedChain) {
      this.showUnsupportedChainUI();
    }
  },
  addCaipNetwork(caipNetwork) {
    var _a3;
    if (!caipNetwork) {
      return;
    }
    const chain = state$b.chains.get(caipNetwork.chainNamespace);
    if (chain) {
      (_a3 = chain == null ? void 0 : chain.caipNetworks) == null ? void 0 : _a3.push(caipNetwork);
    }
  },
  async switchActiveNetwork(network) {
    var _a3;
    const activeAdapter = ChainController.state.chains.get(ChainController.state.activeChain);
    const unsupportedNetwork = !((_a3 = activeAdapter == null ? void 0 : activeAdapter.caipNetworks) == null ? void 0 : _a3.some((caipNetwork) => {
      var _a4;
      return caipNetwork.id === ((_a4 = state$b.activeCaipNetwork) == null ? void 0 : _a4.id);
    }));
    if (unsupportedNetwork) {
      RouterController.goBack();
    }
    const networkControllerClient = this.getNetworkControllerClient(network.chainNamespace);
    if (networkControllerClient) {
      await networkControllerClient.switchCaipNetwork(network);
      EventsController.sendEvent({
        type: "track",
        event: "SWITCH_NETWORK",
        properties: { network: network.caipNetworkId }
      });
    }
  },
  getNetworkControllerClient(chainNamespace) {
    const chain = chainNamespace || state$b.activeChain;
    const chainAdapter = state$b.chains.get(chain);
    if (!chainAdapter) {
      throw new Error("Chain adapter not found");
    }
    if (!chainAdapter.networkControllerClient) {
      throw new Error("NetworkController client not set");
    }
    return chainAdapter.networkControllerClient;
  },
  getConnectionControllerClient(_chain) {
    const chain = _chain || state$b.activeChain;
    if (!chain) {
      throw new Error("Chain is required to get connection controller client");
    }
    const chainAdapter = state$b.chains.get(chain);
    if (!(chainAdapter == null ? void 0 : chainAdapter.connectionControllerClient)) {
      throw new Error("ConnectionController client not set");
    }
    return chainAdapter.connectionControllerClient;
  },
  getAccountProp(key2, _chain) {
    var _a3;
    let chain = state$b.activeChain;
    if (_chain) {
      chain = _chain;
    }
    if (!chain) {
      return void 0;
    }
    const chainAccountState = (_a3 = state$b.chains.get(chain)) == null ? void 0 : _a3.accountState;
    if (!chainAccountState) {
      return void 0;
    }
    return chainAccountState[key2];
  },
  getNetworkProp(key2, namespace) {
    var _a3;
    const chainNetworkState = (_a3 = state$b.chains.get(namespace)) == null ? void 0 : _a3.networkState;
    if (!chainNetworkState) {
      return void 0;
    }
    return chainNetworkState[key2];
  },
  getRequestedCaipNetworks(chainToFilter) {
    const adapter = state$b.chains.get(chainToFilter);
    const { approvedCaipNetworkIds = [], requestedCaipNetworks = [] } = (adapter == null ? void 0 : adapter.networkState) || {};
    const sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedCaipNetworkIds, requestedCaipNetworks);
    return sortedNetworks;
  },
  getAllRequestedCaipNetworks() {
    const requestedCaipNetworks = [];
    state$b.chains.forEach((chainAdapter) => {
      const caipNetworks = this.getRequestedCaipNetworks(chainAdapter.namespace);
      requestedCaipNetworks.push(...caipNetworks);
    });
    return requestedCaipNetworks;
  },
  setRequestedCaipNetworks(requestedCaipNetworks, chain) {
    this.setAdapterNetworkState(chain, { requestedCaipNetworks });
  },
  getAllApprovedCaipNetworkIds() {
    const approvedCaipNetworkIds = [];
    state$b.chains.forEach((chainAdapter) => {
      const approvedIds = this.getApprovedCaipNetworkIds(chainAdapter.namespace);
      approvedCaipNetworkIds.push(...approvedIds);
    });
    return approvedCaipNetworkIds;
  },
  getActiveCaipNetwork() {
    return state$b.activeCaipNetwork;
  },
  getActiveCaipAddress() {
    return state$b.activeCaipAddress;
  },
  getApprovedCaipNetworkIds(namespace) {
    var _a3;
    const adapter = state$b.chains.get(namespace);
    const approvedCaipNetworkIds = ((_a3 = adapter == null ? void 0 : adapter.networkState) == null ? void 0 : _a3.approvedCaipNetworkIds) || [];
    return approvedCaipNetworkIds;
  },
  async setApprovedCaipNetworksData(namespace) {
    const networkControllerClient = this.getNetworkControllerClient();
    const data2 = await (networkControllerClient == null ? void 0 : networkControllerClient.getApprovedCaipNetworksData());
    this.setAdapterNetworkState(namespace, {
      approvedCaipNetworkIds: data2 == null ? void 0 : data2.approvedCaipNetworkIds,
      supportsAllNetworks: data2 == null ? void 0 : data2.supportsAllNetworks
    });
  },
  checkIfSupportedNetwork(namespace) {
    const activeCaipNetwork = state$b.activeCaipNetwork;
    const requestedCaipNetworks = this.getRequestedCaipNetworks(namespace);
    if (!requestedCaipNetworks.length) {
      return true;
    }
    return requestedCaipNetworks == null ? void 0 : requestedCaipNetworks.some((network) => network.id === (activeCaipNetwork == null ? void 0 : activeCaipNetwork.id));
  },
  checkIfSupportedChainId(chainId) {
    if (!state$b.activeChain) {
      return true;
    }
    const requestedCaipNetworks = this.getRequestedCaipNetworks(state$b.activeChain);
    return requestedCaipNetworks == null ? void 0 : requestedCaipNetworks.some((network) => network.id === chainId);
  },
  // Smart Account Network Handlers
  setSmartAccountEnabledNetworks(smartAccountEnabledNetworks, chain) {
    this.setAdapterNetworkState(chain, { smartAccountEnabledNetworks });
  },
  checkIfSmartAccountEnabled() {
    var _a3;
    const networkId = NetworkUtil.caipNetworkIdToNumber((_a3 = state$b.activeCaipNetwork) == null ? void 0 : _a3.caipNetworkId);
    const activeChain = state$b.activeChain;
    if (!activeChain || !networkId) {
      return false;
    }
    const smartAccountEnabledNetworks = this.getNetworkProp("smartAccountEnabledNetworks", activeChain);
    return Boolean(smartAccountEnabledNetworks == null ? void 0 : smartAccountEnabledNetworks.includes(Number(networkId)));
  },
  getActiveNetworkTokenAddress() {
    var _a3, _b2;
    const namespace = ((_a3 = state$b.activeCaipNetwork) == null ? void 0 : _a3.chainNamespace) || "eip155";
    const chainId = ((_b2 = state$b.activeCaipNetwork) == null ? void 0 : _b2.id) || 1;
    const address = ConstantsUtil$3.NATIVE_TOKEN_ADDRESS[namespace];
    return `${namespace}:${chainId}:${address}`;
  },
  showUnsupportedChainUI() {
    ModalController.open({ view: "UnsupportedChain" });
  },
  checkIfNamesSupported() {
    const activeCaipNetwork = state$b.activeCaipNetwork;
    return Boolean((activeCaipNetwork == null ? void 0 : activeCaipNetwork.chainNamespace) && ConstantsUtil$3.NAMES_SUPPORTED_CHAIN_NAMESPACES.includes(activeCaipNetwork.chainNamespace));
  },
  resetNetwork(namespace) {
    this.setAdapterNetworkState(namespace, {
      approvedCaipNetworkIds: void 0,
      supportsAllNetworks: true,
      smartAccountEnabledNetworks: []
    });
  },
  resetAccount(chain) {
    const chainToWrite = chain;
    if (!chainToWrite) {
      throw new Error("Chain is required to set account prop");
    }
    state$b.activeCaipAddress = void 0;
    this.setChainAccountData(chainToWrite, {
      smartAccountDeployed: false,
      currentTab: 0,
      caipAddress: void 0,
      address: void 0,
      balance: void 0,
      balanceSymbol: void 0,
      profileName: void 0,
      profileImage: void 0,
      addressExplorerUrl: void 0,
      tokenBalance: [],
      connectedWalletInfo: void 0,
      preferredAccountType: void 0,
      socialProvider: void 0,
      socialWindow: void 0,
      farcasterUrl: void 0,
      allAccounts: [],
      user: void 0,
      status: "disconnected"
    });
  },
  async disconnect() {
    try {
      SendController.resetSend();
      const disconnectResults = await Promise.allSettled(Array.from(state$b.chains.entries()).map(async ([namespace, adapter]) => {
        var _a3;
        try {
          if ((_a3 = adapter.connectionControllerClient) == null ? void 0 : _a3.disconnect) {
            await adapter.connectionControllerClient.disconnect();
          }
          this.resetAccount(namespace);
          this.resetNetwork(namespace);
          StorageUtil.deleteConnectedConnectorId(namespace);
        } catch (error) {
          throw new Error(`Failed to disconnect chain ${namespace}: ${error.message}`);
        }
      }));
      ConnectionController.resetWcConnection();
      const failures = disconnectResults.filter((result) => result.status === "rejected");
      if (failures.length > 0) {
        throw new Error(failures.map((f6) => f6.reason.message).join(", "));
      }
      StorageUtil.deleteConnectedSocialProvider();
      ConnectionController.resetWcConnection();
      EventsController.sendEvent({
        type: "track",
        event: "DISCONNECT_SUCCESS"
      });
    } catch (error) {
      console.error(error.message || "Failed to disconnect chains");
      EventsController.sendEvent({
        type: "track",
        event: "DISCONNECT_ERROR",
        properties: {
          message: error.message || "Failed to disconnect chains"
        }
      });
    }
  },
  setIsSwitchingNamespace(isSwitchingNamespace) {
    state$b.isSwitchingNamespace = isSwitchingNamespace;
  },
  getFirstCaipNetworkSupportsAuthConnector() {
    var _a3, _b2;
    const availableChains = [];
    let firstCaipNetwork = void 0;
    state$b.chains.forEach((chain) => {
      if (ConstantsUtil$4.AUTH_CONNECTOR_SUPPORTED_CHAINS.find((ns2) => ns2 === chain.namespace)) {
        if (chain.namespace) {
          availableChains.push(chain.namespace);
        }
      }
    });
    if (availableChains.length > 0) {
      const firstAvailableChain = availableChains[0];
      firstCaipNetwork = firstAvailableChain ? (_b2 = (_a3 = state$b.chains.get(firstAvailableChain)) == null ? void 0 : _a3.caipNetworks) == null ? void 0 : _b2[0] : void 0;
      return firstCaipNetwork;
    }
    return void 0;
  },
  getAccountDataByChainNamespace(chainNamespace) {
    var _a3, _b2;
    if (!chainNamespace) {
      if (!ChainController.state.activeChain) {
        return void 0;
      }
      return (_a3 = ChainController.state.chains.get(ChainController.state.activeChain)) == null ? void 0 : _a3.accountState;
    }
    return (_b2 = ChainController.state.chains.get(chainNamespace)) == null ? void 0 : _b2.accountState;
  }
};
const DEFAULT_OPTIONS = {
  purchaseCurrencies: [
    {
      id: "2b92315d-eab7-5bef-84fa-089a131333f5",
      name: "USD Coin",
      symbol: "USDC",
      networks: [
        {
          name: "ethereum-mainnet",
          display_name: "Ethereum",
          chain_id: "1",
          contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
        },
        {
          name: "polygon-mainnet",
          display_name: "Polygon",
          chain_id: "137",
          contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
        }
      ]
    },
    {
      id: "2b92315d-eab7-5bef-84fa-089a131333f5",
      name: "Ether",
      symbol: "ETH",
      networks: [
        {
          name: "ethereum-mainnet",
          display_name: "Ethereum",
          chain_id: "1",
          contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
        },
        {
          name: "polygon-mainnet",
          display_name: "Polygon",
          chain_id: "137",
          contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
        }
      ]
    }
  ],
  paymentCurrencies: [
    {
      id: "USD",
      payment_method_limits: [
        {
          id: "card",
          min: "10.00",
          max: "7500.00"
        },
        {
          id: "ach_bank_account",
          min: "10.00",
          max: "25000.00"
        }
      ]
    },
    {
      id: "EUR",
      payment_method_limits: [
        {
          id: "card",
          min: "10.00",
          max: "7500.00"
        },
        {
          id: "ach_bank_account",
          min: "10.00",
          max: "25000.00"
        }
      ]
    }
  ]
};
const baseUrl$2 = CoreHelperUtil.getBlockchainApiUrl();
const state$a = proxy({
  clientId: null,
  api: new FetchUtil({ baseUrl: baseUrl$2, clientId: null }),
  supportedChains: { http: [], ws: [] }
});
const BlockchainApiController = {
  state: state$a,
  async get(request) {
    const { st: st2, sv } = BlockchainApiController.getSdkProperties();
    const projectId = OptionsController.state.projectId;
    const params = {
      ...request.params || {},
      st: st2,
      sv,
      projectId
    };
    return state$a.api.get({
      ...request,
      params
    });
  },
  getSdkProperties() {
    const { sdkType, sdkVersion } = OptionsController.state;
    return {
      st: sdkType || "unknown",
      sv: sdkVersion || "unknown"
    };
  },
  async isNetworkSupported(networkId) {
    return true;
  },
  async getSupportedNetworks() {
    const supportedChains = await BlockchainApiController.get({
      path: "v1/supported-chains"
    });
    state$a.supportedChains = supportedChains;
    return supportedChains;
  },
  async fetchIdentity({ address, caipNetworkId }) {
    const isSupported = await BlockchainApiController.isNetworkSupported(caipNetworkId);
    if (!isSupported) {
      return { avatar: "", name: "" };
    }
    const identityCache = StorageUtil.getIdentityFromCacheForAddress(address);
    if (identityCache) {
      return identityCache;
    }
    const result = await BlockchainApiController.get({
      path: `/v1/identity/${address}`,
      params: {
        sender: ChainController.state.activeCaipAddress ? CoreHelperUtil.getPlainAddress(ChainController.state.activeCaipAddress) : void 0
      }
    });
    StorageUtil.updateIdentityCache({
      address,
      identity: result,
      timestamp: Date.now()
    });
    return result;
  },
  async fetchTransactions({ account, cursor, onramp, signal, cache, chainId }) {
    var _a3;
    const isSupported = await BlockchainApiController.isNetworkSupported((_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.caipNetworkId);
    if (!isSupported) {
      return { data: [], next: void 0 };
    }
    return BlockchainApiController.get({
      path: `/v1/account/${account}/history`,
      params: {
        cursor,
        onramp,
        chainId
      },
      signal,
      cache
    });
  },
  async fetchSwapQuote({ amount, userAddress, from: from2, to: to2, gasPrice }) {
    var _a3;
    const isSupported = await BlockchainApiController.isNetworkSupported((_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.caipNetworkId);
    if (!isSupported) {
      return { quotes: [] };
    }
    return BlockchainApiController.get({
      path: `/v1/convert/quotes`,
      headers: {
        "Content-Type": "application/json"
      },
      params: {
        amount,
        userAddress,
        from: from2,
        to: to2,
        gasPrice
      }
    });
  },
  async fetchSwapTokens({ chainId }) {
    var _a3;
    const isSupported = await BlockchainApiController.isNetworkSupported((_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.caipNetworkId);
    if (!isSupported) {
      return { tokens: [] };
    }
    return BlockchainApiController.get({
      path: `/v1/convert/tokens`,
      params: { chainId }
    });
  },
  async fetchTokenPrice({ addresses }) {
    return {
      fungibles: [
        {
          name: "CROSS",
          symbol: "CROSS",
          iconUrl: "",
          price: 0.1
        }
      ]
    };
  },
  async fetchSwapAllowance({ tokenAddress, userAddress }) {
    var _a3;
    const isSupported = await BlockchainApiController.isNetworkSupported((_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.caipNetworkId);
    if (!isSupported) {
      return { allowance: "0" };
    }
    return BlockchainApiController.get({
      path: `/v1/convert/allowance`,
      params: {
        tokenAddress,
        userAddress
      },
      headers: {
        "Content-Type": "application/json"
      }
    });
  },
  async generateSwapCalldata({ amount, from: from2, to: to2, userAddress }) {
    var _a3;
    const isSupported = await BlockchainApiController.isNetworkSupported((_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.caipNetworkId);
    if (!isSupported) {
      throw new Error("Network not supported for Swaps");
    }
    return state$a.api.post({
      path: "/v1/convert/build-transaction",
      headers: {
        "Content-Type": "application/json"
      },
      body: {
        amount,
        eip155: {
          slippage: ConstantsUtil$3.CONVERT_SLIPPAGE_TOLERANCE
        },
        projectId: OptionsController.state.projectId,
        from: from2,
        to: to2,
        userAddress
      }
    });
  },
  async generateApproveCalldata({ from: from2, to: to2, userAddress }) {
    var _a3;
    const { st: st2, sv } = BlockchainApiController.getSdkProperties();
    const isSupported = await BlockchainApiController.isNetworkSupported((_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.caipNetworkId);
    if (!isSupported) {
      throw new Error("Network not supported for Swaps");
    }
    return BlockchainApiController.get({
      path: `/v1/convert/build-approve`,
      headers: {
        "Content-Type": "application/json"
      },
      params: {
        userAddress,
        from: from2,
        to: to2,
        st: st2,
        sv
      }
    });
  },
  async lookupEnsName(name) {
    var _a3;
    const isSupported = await BlockchainApiController.isNetworkSupported((_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.caipNetworkId);
    if (!isSupported) {
      return { addresses: {}, attributes: [] };
    }
    return BlockchainApiController.get({
      path: `/v1/profile/account/${name}`,
      params: { apiVersion: "2" }
    });
  },
  async reverseLookupEnsName({ address }) {
    var _a3;
    const isSupported = await BlockchainApiController.isNetworkSupported((_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.caipNetworkId);
    if (!isSupported) {
      return [];
    }
    return BlockchainApiController.get({
      path: `/v1/profile/reverse/${address}`,
      params: {
        sender: AccountController.state.address,
        apiVersion: "2"
      }
    });
  },
  async getEnsNameSuggestions(name) {
    var _a3;
    const isSupported = await BlockchainApiController.isNetworkSupported((_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.caipNetworkId);
    if (!isSupported) {
      return { suggestions: [] };
    }
    return BlockchainApiController.get({
      path: `/v1/profile/suggestions/${name}`,
      params: { zone: "reown.id" }
    });
  },
  async registerEnsName({ coinType, address, message, signature: signature2 }) {
    var _a3;
    const isSupported = await BlockchainApiController.isNetworkSupported((_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.caipNetworkId);
    if (!isSupported) {
      return { success: false };
    }
    return state$a.api.post({
      path: `/v1/profile/account`,
      body: { coin_type: coinType, address, message, signature: signature2 },
      headers: {
        "Content-Type": "application/json"
      }
    });
  },
  async generateOnRampURL({ destinationWallets, partnerUserId, defaultNetwork, purchaseAmount, paymentAmount }) {
    var _a3;
    const isSupported = await BlockchainApiController.isNetworkSupported((_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.caipNetworkId);
    if (!isSupported) {
      return "";
    }
    const response = await state$a.api.post({
      path: `/v1/generators/onrampurl`,
      params: {
        projectId: OptionsController.state.projectId
      },
      body: {
        destinationWallets,
        defaultNetwork,
        partnerUserId,
        defaultExperience: "buy",
        presetCryptoAmount: purchaseAmount,
        presetFiatAmount: paymentAmount
      }
    });
    return response.url;
  },
  async getOnrampOptions() {
    var _a3;
    const isSupported = await BlockchainApiController.isNetworkSupported((_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.caipNetworkId);
    if (!isSupported) {
      return { paymentCurrencies: [], purchaseCurrencies: [] };
    }
    try {
      const response = await BlockchainApiController.get({
        path: `/v1/onramp/options`
      });
      return response;
    } catch (e3) {
      return DEFAULT_OPTIONS;
    }
  },
  async getOnrampQuote({ purchaseCurrency, paymentCurrency, amount, network }) {
    var _a3;
    try {
      const isSupported = await BlockchainApiController.isNetworkSupported((_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.caipNetworkId);
      if (!isSupported) {
        return null;
      }
      const response = await state$a.api.post({
        path: `/v1/onramp/quote`,
        params: {
          projectId: OptionsController.state.projectId
        },
        body: {
          purchaseCurrency,
          paymentCurrency,
          amount,
          network
        }
      });
      return response;
    } catch (e3) {
      return {
        coinbaseFee: { amount, currency: paymentCurrency.id },
        networkFee: { amount, currency: paymentCurrency.id },
        paymentSubtotal: { amount, currency: paymentCurrency.id },
        paymentTotal: { amount, currency: paymentCurrency.id },
        purchaseAmount: { amount, currency: paymentCurrency.id },
        quoteId: "mocked-quote-id"
      };
    }
  },
  async getSmartSessions(caipAddress) {
    var _a3;
    const isSupported = await BlockchainApiController.isNetworkSupported((_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.caipNetworkId);
    if (!isSupported) {
      return [];
    }
    return BlockchainApiController.get({
      path: `/v1/sessions/${caipAddress}`
    });
  },
  async revokeSmartSession(address, pci, signature2) {
    var _a3;
    const isSupported = await BlockchainApiController.isNetworkSupported((_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.caipNetworkId);
    if (!isSupported) {
      return { success: false };
    }
    return state$a.api.post({
      path: `/v1/sessions/${address}/revoke`,
      params: {
        projectId: OptionsController.state.projectId
      },
      body: {
        pci,
        signature: signature2
      }
    });
  },
  setClientId(clientId) {
    state$a.clientId = clientId;
    state$a.api = new FetchUtil({ baseUrl: baseUrl$2, clientId });
  }
};
const SwapApiUtil = {
  async getTokenList() {
    var _a3;
    const caipNetwork = ChainController.state.activeCaipNetwork;
    const response = await BlockchainApiController.fetchSwapTokens({
      chainId: caipNetwork == null ? void 0 : caipNetwork.caipNetworkId
    });
    const tokens = ((_a3 = response == null ? void 0 : response.tokens) == null ? void 0 : _a3.map((token) => ({
      ...token,
      eip2612: false,
      quantity: {
        decimals: "0",
        numeric: "0"
      },
      price: 0,
      value: 0
    }))) || [];
    return tokens;
  },
  async fetchGasPrice() {
    var _a3;
    const caipNetwork = ChainController.state.activeCaipNetwork;
    if (!caipNetwork) {
      return null;
    }
    try {
      switch (caipNetwork.chainNamespace) {
        case "solana":
          const lamportsPerSignature = (_a3 = await (ConnectionController == null ? void 0 : ConnectionController.estimateGas({ chainNamespace: "solana" }))) == null ? void 0 : _a3.toString();
          return {
            data: {
              standard: lamportsPerSignature,
              fast: lamportsPerSignature,
              instant: lamportsPerSignature
            }
          };
        case "eip155":
        default:
          return await ApiController$1.fetchGasPrice({
            chainId: caipNetwork.caipNetworkId
          });
      }
    } catch {
      return null;
    }
  },
  async fetchSwapAllowance({ tokenAddress, userAddress, sourceTokenAmount, sourceTokenDecimals }) {
    const response = await BlockchainApiController.fetchSwapAllowance({
      tokenAddress,
      userAddress
    });
    if ((response == null ? void 0 : response.allowance) && sourceTokenAmount && sourceTokenDecimals) {
      const parsedValue = ConnectionController.parseUnits(sourceTokenAmount, sourceTokenDecimals) || 0;
      const hasAllowance = BigInt(response.allowance) >= parsedValue;
      return hasAllowance;
    }
    return false;
  },
  async getMyTokensWithBalance(forceUpdate) {
    const address = AccountController.state.address;
    const caipNetwork = ChainController.state.activeCaipNetwork;
    if (!address || !caipNetwork) {
      return [];
    }
    const balances = await ApiController$1.getBalance(address, caipNetwork.caipNetworkId, forceUpdate);
    const filteredBalances = balances.filter((balance) => balance.quantity.numeric > "0");
    AccountController.setTokenBalance(filteredBalances, ChainController.state.activeChain);
    return this.mapBalancesToSwapTokens(filteredBalances);
  },
  mapBalancesToSwapTokens(balances) {
    return (balances == null ? void 0 : balances.map((token) => ({
      ...token,
      address: (token == null ? void 0 : token.address) ? token.address : ChainController.getActiveNetworkTokenAddress(),
      decimals: parseInt(token.quantity.decimals, 10),
      logoUri: token.iconUrl,
      eip2612: false
    }))) || [];
  }
};
const SwapCalculationUtil = {
  getGasPriceInEther(gas, gasPrice) {
    const totalGasCostInWei = gasPrice * gas;
    const totalGasCostInEther = Number(totalGasCostInWei) / 1e18;
    return totalGasCostInEther;
  },
  getGasPriceInUSD(networkPrice, gas, gasPrice) {
    const totalGasCostInEther = SwapCalculationUtil.getGasPriceInEther(gas, gasPrice);
    const networkPriceInUSD = NumberUtil.bigNumber(networkPrice);
    const gasCostInUSD = networkPriceInUSD.times(totalGasCostInEther);
    return gasCostInUSD.toNumber();
  },
  getPriceImpact({ sourceTokenAmount, sourceTokenPriceInUSD, toTokenPriceInUSD, toTokenAmount }) {
    const inputValue = NumberUtil.bigNumber(sourceTokenAmount).times(sourceTokenPriceInUSD);
    const outputValue = NumberUtil.bigNumber(toTokenAmount).times(toTokenPriceInUSD);
    const priceImpact = inputValue.minus(outputValue).div(inputValue).times(100);
    return priceImpact.toNumber();
  },
  getMaxSlippage(slippage, toTokenAmount) {
    const slippageToleranceDecimal = NumberUtil.bigNumber(slippage).div(100);
    const maxSlippageAmount = NumberUtil.multiply(toTokenAmount, slippageToleranceDecimal);
    return maxSlippageAmount.toNumber();
  },
  getProviderFee(sourceTokenAmount, feePercentage = 85e-4) {
    const providerFee = NumberUtil.bigNumber(sourceTokenAmount).times(feePercentage);
    return providerFee.toString();
  },
  isInsufficientNetworkTokenForGas(networkBalanceInUSD, gasPriceInUSD) {
    const gasPrice = gasPriceInUSD || "0";
    if (NumberUtil.bigNumber(networkBalanceInUSD).eq(0)) {
      return true;
    }
    return NumberUtil.bigNumber(NumberUtil.bigNumber(gasPrice)).gt(networkBalanceInUSD);
  },
  isInsufficientSourceTokenForSwap(sourceTokenAmount, sourceTokenAddress, balance) {
    var _a3, _b2;
    const sourceTokenBalance = (_b2 = (_a3 = balance == null ? void 0 : balance.find((token) => token.address === sourceTokenAddress)) == null ? void 0 : _a3.quantity) == null ? void 0 : _b2.numeric;
    const isInSufficientBalance = NumberUtil.bigNumber(sourceTokenBalance || "0").lt(sourceTokenAmount);
    return isInSufficientBalance;
  },
  getToTokenAmount({ sourceToken, toToken, sourceTokenPrice, toTokenPrice, sourceTokenAmount }) {
    if (sourceTokenAmount === "0") {
      return "0";
    }
    if (!sourceToken || !toToken) {
      return "0";
    }
    const sourceTokenDecimals = sourceToken.decimals;
    const sourceTokenPriceInUSD = sourceTokenPrice;
    const toTokenDecimals = toToken.decimals;
    const toTokenPriceInUSD = toTokenPrice;
    if (toTokenPriceInUSD <= 0) {
      return "0";
    }
    const providerFee = NumberUtil.bigNumber(sourceTokenAmount).times(85e-4);
    const adjustedSourceTokenAmount = NumberUtil.bigNumber(sourceTokenAmount).minus(providerFee);
    const sourceAmountInSmallestUnit = adjustedSourceTokenAmount.times(NumberUtil.bigNumber(10).pow(sourceTokenDecimals));
    const priceRatio = NumberUtil.bigNumber(sourceTokenPriceInUSD).div(toTokenPriceInUSD);
    const decimalDifference = sourceTokenDecimals - toTokenDecimals;
    const toTokenAmountInSmallestUnit = sourceAmountInSmallestUnit.times(priceRatio).div(NumberUtil.bigNumber(10).pow(decimalDifference));
    const toTokenAmount = toTokenAmountInSmallestUnit.div(NumberUtil.bigNumber(10).pow(toTokenDecimals));
    const amount = toTokenAmount.toFixed(toTokenDecimals).toString();
    return amount;
  }
};
const INITIAL_GAS_LIMIT = 15e4;
const TO_AMOUNT_DECIMALS = 6;
const initialState = {
  // Loading states
  initializing: false,
  initialized: false,
  loadingPrices: false,
  loadingQuote: false,
  loadingApprovalTransaction: false,
  loadingBuildTransaction: false,
  loadingTransaction: false,
  // Error states
  fetchError: false,
  // Approval & Swap transaction states
  approvalTransaction: void 0,
  swapTransaction: void 0,
  transactionError: void 0,
  // Input values
  sourceToken: void 0,
  sourceTokenAmount: "",
  sourceTokenPriceInUSD: 0,
  toToken: void 0,
  toTokenAmount: "",
  toTokenPriceInUSD: 0,
  networkPrice: "0",
  networkBalanceInUSD: "0",
  networkTokenSymbol: "",
  inputError: void 0,
  // Request values
  slippage: ConstantsUtil$3.CONVERT_SLIPPAGE_TOLERANCE,
  // Tokens
  tokens: void 0,
  popularTokens: void 0,
  suggestedTokens: void 0,
  foundTokens: void 0,
  myTokensWithBalance: void 0,
  tokensPriceMap: {},
  // Calculations
  gasFee: "0",
  gasPriceInUSD: 0,
  priceImpact: void 0,
  maxSlippage: void 0,
  providerFee: void 0
};
const state$9 = proxy(initialState);
const SwapController = {
  state: state$9,
  subscribe(callback) {
    return subscribe(state$9, () => callback(state$9));
  },
  subscribeKey(key2, callback) {
    return subscribeKey(state$9, key2, callback);
  },
  getParams() {
    var _a3, _b2, _c3, _d, _e4, _f, _g, _h;
    const caipAddress = ChainController.state.activeCaipAddress;
    const namespace = ChainController.state.activeChain;
    const address = CoreHelperUtil.getPlainAddress(caipAddress);
    const networkAddress = ChainController.getActiveNetworkTokenAddress();
    const connectorId = StorageUtil.getConnectedConnectorId(namespace);
    if (!address) {
      throw new Error("No address found to swap the tokens from.");
    }
    const invalidToToken = !((_a3 = state$9.toToken) == null ? void 0 : _a3.address) || !((_b2 = state$9.toToken) == null ? void 0 : _b2.decimals);
    const invalidSourceToken = !((_c3 = state$9.sourceToken) == null ? void 0 : _c3.address) || !((_d = state$9.sourceToken) == null ? void 0 : _d.decimals) || !NumberUtil.bigNumber(state$9.sourceTokenAmount).gt(0);
    const invalidSourceTokenAmount = !state$9.sourceTokenAmount;
    return {
      networkAddress,
      fromAddress: address,
      fromCaipAddress: caipAddress,
      sourceTokenAddress: (_e4 = state$9.sourceToken) == null ? void 0 : _e4.address,
      toTokenAddress: (_f = state$9.toToken) == null ? void 0 : _f.address,
      toTokenAmount: state$9.toTokenAmount,
      toTokenDecimals: (_g = state$9.toToken) == null ? void 0 : _g.decimals,
      sourceTokenAmount: state$9.sourceTokenAmount,
      sourceTokenDecimals: (_h = state$9.sourceToken) == null ? void 0 : _h.decimals,
      invalidToToken,
      invalidSourceToken,
      invalidSourceTokenAmount,
      availableToSwap: caipAddress && !invalidToToken && !invalidSourceToken && !invalidSourceTokenAmount,
      isAuthConnector: connectorId === ConstantsUtil$4.CONNECTOR_ID.AUTH
    };
  },
  setSourceToken(sourceToken) {
    if (!sourceToken) {
      state$9.sourceToken = sourceToken;
      state$9.sourceTokenAmount = "";
      state$9.sourceTokenPriceInUSD = 0;
      return;
    }
    state$9.sourceToken = sourceToken;
    this.setTokenPrice(sourceToken.address, "sourceToken");
  },
  setSourceTokenAmount(amount) {
    state$9.sourceTokenAmount = amount;
  },
  setToToken(toToken) {
    if (!toToken) {
      state$9.toToken = toToken;
      state$9.toTokenAmount = "";
      state$9.toTokenPriceInUSD = 0;
      return;
    }
    state$9.toToken = toToken;
    this.setTokenPrice(toToken.address, "toToken");
  },
  setToTokenAmount(amount) {
    state$9.toTokenAmount = amount ? NumberUtil.formatNumberToLocalString(amount, TO_AMOUNT_DECIMALS) : "";
  },
  async setTokenPrice(address, target) {
    let price = state$9.tokensPriceMap[address] || 0;
    if (!price) {
      state$9.loadingPrices = true;
      price = await this.getAddressPrice(address);
    }
    if (target === "sourceToken") {
      state$9.sourceTokenPriceInUSD = price;
    } else if (target === "toToken") {
      state$9.toTokenPriceInUSD = price;
    }
    if (state$9.loadingPrices) {
      state$9.loadingPrices = false;
    }
    if (this.getParams().availableToSwap) {
      this.swapTokens();
    }
  },
  switchTokens() {
    if (state$9.initializing || !state$9.initialized) {
      return;
    }
    const newSourceToken = state$9.toToken ? { ...state$9.toToken } : void 0;
    const newToToken = state$9.sourceToken ? { ...state$9.sourceToken } : void 0;
    const newSourceTokenAmount = newSourceToken && state$9.toTokenAmount === "" ? "1" : state$9.toTokenAmount;
    this.setSourceToken(newSourceToken);
    this.setToToken(newToToken);
    this.setSourceTokenAmount(newSourceTokenAmount);
    this.setToTokenAmount("");
    this.swapTokens();
  },
  resetState() {
    state$9.myTokensWithBalance = initialState.myTokensWithBalance;
    state$9.tokensPriceMap = initialState.tokensPriceMap;
    state$9.initialized = initialState.initialized;
    state$9.sourceToken = initialState.sourceToken;
    state$9.sourceTokenAmount = initialState.sourceTokenAmount;
    state$9.sourceTokenPriceInUSD = initialState.sourceTokenPriceInUSD;
    state$9.toToken = initialState.toToken;
    state$9.toTokenAmount = initialState.toTokenAmount;
    state$9.toTokenPriceInUSD = initialState.toTokenPriceInUSD;
    state$9.networkPrice = initialState.networkPrice;
    state$9.networkTokenSymbol = initialState.networkTokenSymbol;
    state$9.networkBalanceInUSD = initialState.networkBalanceInUSD;
    state$9.inputError = initialState.inputError;
  },
  resetValues() {
    var _a3;
    const { networkAddress } = this.getParams();
    const networkToken = (_a3 = state$9.tokens) == null ? void 0 : _a3.find((token) => token.address === networkAddress);
    this.setSourceToken(networkToken);
    this.setToToken(void 0);
  },
  getApprovalLoadingState() {
    return state$9.loadingApprovalTransaction;
  },
  clearError() {
    state$9.transactionError = void 0;
  },
  async initializeState() {
    if (state$9.initializing) {
      return;
    }
    state$9.initializing = true;
    if (!state$9.initialized) {
      try {
        await this.fetchTokens();
        state$9.initialized = true;
      } catch (error) {
        state$9.initialized = false;
        SnackController.showError("Failed to initialize swap");
        RouterController.goBack();
      }
    }
    state$9.initializing = false;
  },
  async fetchTokens() {
    var _a3;
    const { networkAddress } = this.getParams();
    await this.getTokenList();
    await this.getNetworkTokenPrice();
    await this.getMyTokensWithBalance();
    const networkToken = (_a3 = state$9.tokens) == null ? void 0 : _a3.find((token) => token.address === networkAddress);
    if (networkToken) {
      state$9.networkTokenSymbol = networkToken.symbol;
      this.setSourceToken(networkToken);
      this.setSourceTokenAmount("1");
    }
  },
  async getTokenList() {
    const tokens = await SwapApiUtil.getTokenList();
    state$9.tokens = tokens;
    state$9.popularTokens = tokens.sort((aTokenInfo, bTokenInfo) => {
      if (aTokenInfo.symbol < bTokenInfo.symbol) {
        return -1;
      }
      if (aTokenInfo.symbol > bTokenInfo.symbol) {
        return 1;
      }
      return 0;
    });
    state$9.suggestedTokens = tokens.filter((token) => {
      if (ConstantsUtil$3.SWAP_SUGGESTED_TOKENS.includes(token.symbol)) {
        return true;
      }
      return false;
    }, {});
  },
  async getAddressPrice(address) {
    var _a3, _b2;
    const existPrice = state$9.tokensPriceMap[address];
    if (existPrice) {
      return existPrice;
    }
    const response = await BlockchainApiController.fetchTokenPrice({
      addresses: [address]
    });
    const fungibles = (response == null ? void 0 : response.fungibles) || [];
    const allTokens = [...state$9.tokens || [], ...state$9.myTokensWithBalance || []];
    const symbol = (_a3 = allTokens == null ? void 0 : allTokens.find((token) => token.address === address)) == null ? void 0 : _a3.symbol;
    const price = ((_b2 = fungibles.find((p2) => p2.symbol.toLowerCase() === (symbol == null ? void 0 : symbol.toLowerCase()))) == null ? void 0 : _b2.price) || 0;
    const priceAsFloat = parseFloat(price.toString());
    state$9.tokensPriceMap[address] = priceAsFloat;
    return priceAsFloat;
  },
  async getNetworkTokenPrice() {
    var _a3;
    const { networkAddress } = this.getParams();
    const response = await BlockchainApiController.fetchTokenPrice({
      addresses: [networkAddress]
    }).catch(() => {
      SnackController.showError("Failed to fetch network token price");
      return { fungibles: [] };
    });
    const token = (_a3 = response.fungibles) == null ? void 0 : _a3[0];
    const price = (token == null ? void 0 : token.price.toString()) || "0";
    state$9.tokensPriceMap[networkAddress] = parseFloat(price);
    state$9.networkTokenSymbol = (token == null ? void 0 : token.symbol) || "";
    state$9.networkPrice = price;
  },
  async getMyTokensWithBalance(forceUpdate) {
    const balances = await SwapApiUtil.getMyTokensWithBalance(forceUpdate);
    if (!balances) {
      return;
    }
    await this.getInitialGasPrice();
    this.setBalances(balances);
  },
  setBalances(balances) {
    const { networkAddress } = this.getParams();
    const caipNetwork = ChainController.state.activeCaipNetwork;
    if (!caipNetwork) {
      return;
    }
    const networkToken = balances.find((token) => token.address === networkAddress);
    balances.forEach((token) => {
      state$9.tokensPriceMap[token.address] = token.price || 0;
    });
    state$9.myTokensWithBalance = balances.filter((token) => token.address.startsWith(caipNetwork.caipNetworkId));
    state$9.networkBalanceInUSD = networkToken ? NumberUtil.multiply(networkToken.quantity.numeric, networkToken.price).toString() : "0";
  },
  async getInitialGasPrice() {
    var _a3, _b2;
    const res = await SwapApiUtil.fetchGasPrice();
    if (!res) {
      return { gasPrice: null, gasPriceInUSD: null };
    }
    const { data: data2 } = res;
    switch ((_b2 = (_a3 = ChainController.state) == null ? void 0 : _a3.activeCaipNetwork) == null ? void 0 : _b2.chainNamespace) {
      case "solana":
        state$9.gasFee = res.data.standard ?? "0";
        state$9.gasPriceInUSD = NumberUtil.multiply(data2.standard, state$9.networkPrice).div(1e9).toNumber();
        return {
          gasPrice: BigInt(state$9.gasFee),
          gasPriceInUSD: Number(state$9.gasPriceInUSD)
        };
      case "eip155":
      default:
        const value = data2.standard ?? "0";
        const gasFee = BigInt(value);
        const gasLimit = BigInt(INITIAL_GAS_LIMIT);
        const gasPrice = SwapCalculationUtil.getGasPriceInUSD(state$9.networkPrice, gasLimit, gasFee);
        state$9.gasFee = value;
        state$9.gasPriceInUSD = gasPrice;
        return { gasPrice: gasFee, gasPriceInUSD: gasPrice };
    }
  },
  // -- Swap -------------------------------------- //
  async swapTokens() {
    var _a3, _b2;
    const address = AccountController.state.address;
    const sourceToken = state$9.sourceToken;
    const toToken = state$9.toToken;
    const haveSourceTokenAmount = NumberUtil.bigNumber(state$9.sourceTokenAmount).gt(0);
    if (!haveSourceTokenAmount) {
      this.setToTokenAmount("");
    }
    if (!toToken || !sourceToken || state$9.loadingPrices || !haveSourceTokenAmount) {
      return;
    }
    state$9.loadingQuote = true;
    const amountDecimal = NumberUtil.bigNumber(state$9.sourceTokenAmount).times(10 ** sourceToken.decimals).round(0);
    try {
      const quoteResponse = await BlockchainApiController.fetchSwapQuote({
        userAddress: address,
        from: sourceToken.address,
        to: toToken.address,
        gasPrice: state$9.gasFee,
        amount: amountDecimal.toString()
      });
      state$9.loadingQuote = false;
      const quoteToAmount = (_b2 = (_a3 = quoteResponse == null ? void 0 : quoteResponse.quotes) == null ? void 0 : _a3[0]) == null ? void 0 : _b2.toAmount;
      if (!quoteToAmount) {
        AlertController.open({
          shortMessage: "Incorrect amount",
          longMessage: "Please enter a valid amount"
        }, "error");
        return;
      }
      const toTokenAmount = NumberUtil.bigNumber(quoteToAmount).div(10 ** toToken.decimals).toString();
      this.setToTokenAmount(toTokenAmount);
      const isInsufficientToken = this.hasInsufficientToken(state$9.sourceTokenAmount, sourceToken.address);
      if (isInsufficientToken) {
        state$9.inputError = "Insufficient balance";
      } else {
        state$9.inputError = void 0;
        this.setTransactionDetails();
      }
    } catch (error) {
      state$9.loadingQuote = false;
      state$9.inputError = "Insufficient balance";
    }
  },
  // -- Create Transactions -------------------------------------- //
  async getTransaction() {
    const { fromCaipAddress, availableToSwap } = this.getParams();
    const sourceToken = state$9.sourceToken;
    const toToken = state$9.toToken;
    if (!fromCaipAddress || !availableToSwap || !sourceToken || !toToken || state$9.loadingQuote) {
      return void 0;
    }
    try {
      state$9.loadingBuildTransaction = true;
      const hasAllowance = await SwapApiUtil.fetchSwapAllowance({
        userAddress: fromCaipAddress,
        tokenAddress: sourceToken.address,
        sourceTokenAmount: state$9.sourceTokenAmount,
        sourceTokenDecimals: sourceToken.decimals
      });
      let transaction = void 0;
      if (hasAllowance) {
        transaction = await this.createSwapTransaction();
      } else {
        transaction = await this.createAllowanceTransaction();
      }
      state$9.loadingBuildTransaction = false;
      state$9.fetchError = false;
      return transaction;
    } catch (error) {
      RouterController.goBack();
      SnackController.showError("Failed to check allowance");
      state$9.loadingBuildTransaction = false;
      state$9.approvalTransaction = void 0;
      state$9.swapTransaction = void 0;
      state$9.fetchError = true;
      return void 0;
    }
  },
  async createAllowanceTransaction() {
    const { fromCaipAddress, fromAddress, sourceTokenAddress, toTokenAddress } = this.getParams();
    if (!fromCaipAddress || !toTokenAddress) {
      return void 0;
    }
    if (!sourceTokenAddress) {
      throw new Error("createAllowanceTransaction - No source token address found.");
    }
    try {
      const response = await BlockchainApiController.generateApproveCalldata({
        from: sourceTokenAddress,
        to: toTokenAddress,
        userAddress: fromCaipAddress
      });
      const gasLimit = await ConnectionController.estimateGas({
        address: fromAddress,
        to: CoreHelperUtil.getPlainAddress(response.tx.to),
        data: response.tx.data
      });
      const transaction = {
        data: response.tx.data,
        to: CoreHelperUtil.getPlainAddress(response.tx.from),
        gas: gasLimit,
        gasPrice: BigInt(response.tx.eip155.gasPrice),
        value: BigInt(response.tx.value),
        toAmount: state$9.toTokenAmount
      };
      state$9.swapTransaction = void 0;
      state$9.approvalTransaction = {
        data: transaction.data,
        to: transaction.to,
        gas: transaction.gas ?? BigInt(0),
        gasPrice: transaction.gasPrice,
        value: transaction.value,
        toAmount: transaction.toAmount
      };
      return {
        data: transaction.data,
        to: transaction.to,
        gas: transaction.gas ?? BigInt(0),
        gasPrice: transaction.gasPrice,
        value: transaction.value,
        toAmount: transaction.toAmount
      };
    } catch (error) {
      RouterController.goBack();
      SnackController.showError("Failed to create approval transaction");
      state$9.approvalTransaction = void 0;
      state$9.swapTransaction = void 0;
      state$9.fetchError = true;
      return void 0;
    }
  },
  async createSwapTransaction() {
    var _a3;
    const { networkAddress, fromCaipAddress, sourceTokenAmount } = this.getParams();
    const sourceToken = state$9.sourceToken;
    const toToken = state$9.toToken;
    if (!fromCaipAddress || !sourceTokenAmount || !sourceToken || !toToken) {
      return void 0;
    }
    const amount = (_a3 = ConnectionController.parseUnits(sourceTokenAmount, sourceToken.decimals)) == null ? void 0 : _a3.toString();
    try {
      const response = await BlockchainApiController.generateSwapCalldata({
        userAddress: fromCaipAddress,
        from: sourceToken.address,
        to: toToken.address,
        amount
      });
      const isSourceTokenIsNetworkToken = sourceToken.address === networkAddress;
      const gas = BigInt(response.tx.eip155.gas);
      const gasPrice = BigInt(response.tx.eip155.gasPrice);
      const transaction = {
        data: response.tx.data,
        to: CoreHelperUtil.getPlainAddress(response.tx.to),
        gas,
        gasPrice,
        value: isSourceTokenIsNetworkToken ? BigInt(amount ?? "0") : BigInt("0"),
        toAmount: state$9.toTokenAmount
      };
      state$9.gasPriceInUSD = SwapCalculationUtil.getGasPriceInUSD(state$9.networkPrice, gas, gasPrice);
      state$9.approvalTransaction = void 0;
      state$9.swapTransaction = transaction;
      return transaction;
    } catch (error) {
      RouterController.goBack();
      SnackController.showError("Failed to create transaction");
      state$9.approvalTransaction = void 0;
      state$9.swapTransaction = void 0;
      state$9.fetchError = true;
      return void 0;
    }
  },
  // -- Send Transactions --------------------------------- //
  async sendTransactionForApproval(data2) {
    var _a3, _b2, _c3;
    const { fromAddress, isAuthConnector } = this.getParams();
    state$9.loadingApprovalTransaction = true;
    const approveLimitMessage = `Approve limit increase in your wallet`;
    if (isAuthConnector) {
      RouterController.pushTransactionStack({
        view: null,
        goBack: true,
        onSuccess() {
          SnackController.showLoading(approveLimitMessage);
        }
      });
    } else {
      SnackController.showLoading(approveLimitMessage);
    }
    try {
      await ConnectionController.sendTransaction({
        address: fromAddress,
        to: data2.to,
        data: data2.data,
        gas: data2.gas,
        gasPrice: BigInt(data2.gasPrice),
        value: data2.value,
        chainNamespace: "eip155",
        type: ConstantsUtil$3.TRANSACTION_TYPE.LEGACY
      });
      await this.swapTokens();
      await this.getTransaction();
      state$9.approvalTransaction = void 0;
      state$9.loadingApprovalTransaction = false;
    } catch (err) {
      const error = err;
      state$9.transactionError = error == null ? void 0 : error.shortMessage;
      state$9.loadingApprovalTransaction = false;
      SnackController.showError((error == null ? void 0 : error.shortMessage) || "Transaction error");
      EventsController.sendEvent({
        type: "track",
        event: "SWAP_APPROVAL_ERROR",
        properties: {
          message: (error == null ? void 0 : error.shortMessage) || (error == null ? void 0 : error.message) || "Unknown",
          network: ((_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.caipNetworkId) || "",
          swapFromToken: ((_b2 = this.state.sourceToken) == null ? void 0 : _b2.symbol) || "",
          swapToToken: ((_c3 = this.state.toToken) == null ? void 0 : _c3.symbol) || "",
          swapFromAmount: this.state.sourceTokenAmount || "",
          swapToAmount: this.state.toTokenAmount || "",
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
        }
      });
    }
  },
  async sendTransactionForSwap(data2) {
    var _a3, _b2, _c3, _d, _e4, _f, _g, _h, _i2, _j, _k, _l;
    if (!data2) {
      return void 0;
    }
    const { fromAddress, toTokenAmount, isAuthConnector } = this.getParams();
    state$9.loadingTransaction = true;
    const snackbarPendingMessage = `Swapping ${(_a3 = state$9.sourceToken) == null ? void 0 : _a3.symbol} to ${NumberUtil.formatNumberToLocalString(toTokenAmount, 3)} ${(_b2 = state$9.toToken) == null ? void 0 : _b2.symbol}`;
    const snackbarSuccessMessage = `Swapped ${(_c3 = state$9.sourceToken) == null ? void 0 : _c3.symbol} to ${NumberUtil.formatNumberToLocalString(toTokenAmount, 3)} ${(_d = state$9.toToken) == null ? void 0 : _d.symbol}`;
    if (isAuthConnector) {
      RouterController.pushTransactionStack({
        view: "Account",
        goBack: false,
        onSuccess() {
          SnackController.showLoading(snackbarPendingMessage);
          SwapController.resetState();
        }
      });
    } else {
      SnackController.showLoading("Confirm transaction in your wallet");
    }
    try {
      const forceUpdateAddresses = [(_e4 = state$9.sourceToken) == null ? void 0 : _e4.address, (_f = state$9.toToken) == null ? void 0 : _f.address].join(",");
      const transactionHash = await ConnectionController.sendTransaction({
        address: fromAddress,
        to: data2.to,
        data: data2.data,
        gas: data2.gas,
        gasPrice: BigInt(data2.gasPrice),
        value: data2.value,
        chainNamespace: "eip155",
        type: ConstantsUtil$3.TRANSACTION_TYPE.LEGACY
      });
      state$9.loadingTransaction = false;
      SnackController.showSuccess(snackbarSuccessMessage);
      EventsController.sendEvent({
        type: "track",
        event: "SWAP_SUCCESS",
        properties: {
          network: ((_g = ChainController.state.activeCaipNetwork) == null ? void 0 : _g.caipNetworkId) || "",
          swapFromToken: ((_h = this.state.sourceToken) == null ? void 0 : _h.symbol) || "",
          swapToToken: ((_i2 = this.state.toToken) == null ? void 0 : _i2.symbol) || "",
          swapFromAmount: this.state.sourceTokenAmount || "",
          swapToAmount: this.state.toTokenAmount || "",
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
        }
      });
      SwapController.resetState();
      if (!isAuthConnector) {
        RouterController.replace("Account");
      }
      SwapController.getMyTokensWithBalance(forceUpdateAddresses);
      return transactionHash;
    } catch (err) {
      const error = err;
      state$9.transactionError = error == null ? void 0 : error.shortMessage;
      state$9.loadingTransaction = false;
      SnackController.showError((error == null ? void 0 : error.shortMessage) || "Transaction error");
      EventsController.sendEvent({
        type: "track",
        event: "SWAP_ERROR",
        properties: {
          message: (error == null ? void 0 : error.shortMessage) || (error == null ? void 0 : error.message) || "Unknown",
          network: ((_j = ChainController.state.activeCaipNetwork) == null ? void 0 : _j.caipNetworkId) || "",
          swapFromToken: ((_k = this.state.sourceToken) == null ? void 0 : _k.symbol) || "",
          swapToToken: ((_l = this.state.toToken) == null ? void 0 : _l.symbol) || "",
          swapFromAmount: this.state.sourceTokenAmount || "",
          swapToAmount: this.state.toTokenAmount || "",
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
        }
      });
      return void 0;
    }
  },
  // -- Checks -------------------------------------------- //
  hasInsufficientToken(sourceTokenAmount, sourceTokenAddress) {
    const isInsufficientSourceTokenForSwap = SwapCalculationUtil.isInsufficientSourceTokenForSwap(sourceTokenAmount, sourceTokenAddress, state$9.myTokensWithBalance);
    let insufficientNetworkTokenForGas = true;
    if (AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT) {
      insufficientNetworkTokenForGas = false;
    } else {
      insufficientNetworkTokenForGas = SwapCalculationUtil.isInsufficientNetworkTokenForGas(state$9.networkBalanceInUSD, state$9.gasPriceInUSD);
    }
    return insufficientNetworkTokenForGas || isInsufficientSourceTokenForSwap;
  },
  // -- Calculations -------------------------------------- //
  setTransactionDetails() {
    const { toTokenAddress, toTokenDecimals } = this.getParams();
    if (!toTokenAddress || !toTokenDecimals) {
      return;
    }
    state$9.gasPriceInUSD = SwapCalculationUtil.getGasPriceInUSD(state$9.networkPrice, BigInt(state$9.gasFee), BigInt(INITIAL_GAS_LIMIT));
    state$9.priceImpact = SwapCalculationUtil.getPriceImpact({
      sourceTokenAmount: state$9.sourceTokenAmount,
      sourceTokenPriceInUSD: state$9.sourceTokenPriceInUSD,
      toTokenPriceInUSD: state$9.toTokenPriceInUSD,
      toTokenAmount: state$9.toTokenAmount
    });
    state$9.maxSlippage = SwapCalculationUtil.getMaxSlippage(state$9.slippage, state$9.toTokenAmount);
    state$9.providerFee = SwapCalculationUtil.getProviderFee(state$9.sourceTokenAmount);
  }
};
const state$8 = proxy({
  currentTab: 0,
  tokenBalance: [],
  smartAccountDeployed: false,
  addressLabels: /* @__PURE__ */ new Map(),
  allAccounts: []
});
const AccountController = {
  state: state$8,
  replaceState(newState) {
    if (!newState) {
      return;
    }
    Object.assign(state$8, ref$1(newState));
  },
  subscribe(callback) {
    return ChainController.subscribeChainProp("accountState", (accountState2) => {
      if (accountState2) {
        return callback(accountState2);
      }
      return void 0;
    });
  },
  subscribeKey(property, callback, chain) {
    let prev = void 0;
    return ChainController.subscribeChainProp("accountState", (accountState2) => {
      if (accountState2) {
        const nextValue = accountState2[property];
        if (prev !== nextValue) {
          prev = nextValue;
          callback(nextValue);
        }
      }
    }, chain);
  },
  setStatus(status, chain) {
    ChainController.setAccountProp("status", status, chain);
  },
  getCaipAddress(chain) {
    return ChainController.getAccountProp("caipAddress", chain);
  },
  setCaipAddress(caipAddress, chain) {
    const newAddress = caipAddress ? CoreHelperUtil.getPlainAddress(caipAddress) : void 0;
    if (chain === ChainController.state.activeChain) {
      ChainController.state.activeCaipAddress = caipAddress;
    }
    ChainController.setAccountProp("caipAddress", caipAddress, chain);
    ChainController.setAccountProp("address", newAddress, chain);
  },
  setBalance(balance, balanceSymbol, chain) {
    ChainController.setAccountProp("balance", balance, chain);
    ChainController.setAccountProp("balanceSymbol", balanceSymbol, chain);
  },
  setProfileName(profileName, chain) {
    ChainController.setAccountProp("profileName", profileName, chain);
  },
  setProfileImage(profileImage, chain) {
    ChainController.setAccountProp("profileImage", profileImage, chain);
  },
  setUser(user, chain) {
    ChainController.setAccountProp("user", user, chain);
  },
  setAddressExplorerUrl(explorerUrl, chain) {
    ChainController.setAccountProp("addressExplorerUrl", explorerUrl, chain);
  },
  setSmartAccountDeployed(isDeployed, chain) {
    ChainController.setAccountProp("smartAccountDeployed", isDeployed, chain);
  },
  setCurrentTab(currentTab) {
    ChainController.setAccountProp("currentTab", currentTab, ChainController.state.activeChain);
  },
  setTokenBalance(tokenBalance, chain) {
    if (tokenBalance) {
      ChainController.setAccountProp("tokenBalance", tokenBalance, chain);
    }
  },
  setShouldUpdateToAddress(address, chain) {
    ChainController.setAccountProp("shouldUpdateToAddress", address, chain);
  },
  setAllAccounts(accounts, namespace) {
    ChainController.setAccountProp("allAccounts", accounts, namespace);
  },
  addAddressLabel(address, label, chain) {
    const map = ChainController.getAccountProp("addressLabels", chain) || /* @__PURE__ */ new Map();
    map.set(address, label);
    ChainController.setAccountProp("addressLabels", map, chain);
  },
  removeAddressLabel(address, chain) {
    const map = ChainController.getAccountProp("addressLabels", chain) || /* @__PURE__ */ new Map();
    map.delete(address);
    ChainController.setAccountProp("addressLabels", map, chain);
  },
  setConnectedWalletInfo(connectedWalletInfo, chain) {
    ChainController.setAccountProp("connectedWalletInfo", connectedWalletInfo, chain, false);
  },
  setPreferredAccountType(preferredAccountType, chain) {
    ChainController.setAccountProp("preferredAccountType", preferredAccountType, chain);
  },
  setSocialProvider(socialProvider, chain) {
    if (socialProvider) {
      ChainController.setAccountProp("socialProvider", socialProvider, chain);
    }
  },
  setSocialWindow(socialWindow, chain) {
    ChainController.setAccountProp("socialWindow", socialWindow ? ref$1(socialWindow) : void 0, chain);
  },
  setFarcasterUrl(farcasterUrl, chain) {
    ChainController.setAccountProp("farcasterUrl", farcasterUrl, chain);
  },
  // update a single token balance from contract. Use this after transaction(WriteContract).
  async updateTokenBalance(balance) {
    this.setTokenBalance(balance, ChainController.state.activeChain);
    SwapController.setBalances(SwapApiUtil.mapBalancesToSwapTokens(balance));
  },
  // read all token balances from API. Blocknumber is not synced with the chain.
  async fetchTokenBalance(onError) {
    var _a3, _b2;
    state$8.balanceLoading = true;
    const networkId = (_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.caipNetworkId;
    const chain = (_b2 = ChainController.state.activeCaipNetwork) == null ? void 0 : _b2.chainNamespace;
    const caipAddress = ChainController.state.activeCaipAddress;
    const address = caipAddress ? CoreHelperUtil.getPlainAddress(caipAddress) : void 0;
    if (state$8.lastRetry && !CoreHelperUtil.isAllowedRetry(state$8.lastRetry, 30 * ConstantsUtil$3.ONE_SEC_MS)) {
      state$8.balanceLoading = false;
      return [];
    }
    try {
      if (address && networkId && chain) {
        const balance = await ApiController$1.getBalance(address, networkId);
        const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
        const filteredBalance = balance.filter((balance2) => {
          var _a4;
          return balance2.quantity.numeric > "0" && ((_a4 = balance2.address) == null ? void 0 : _a4.toLowerCase()) !== ZERO_ADDRESS;
        });
        this.setTokenBalance(filteredBalance, chain);
        SwapController.setBalances(SwapApiUtil.mapBalancesToSwapTokens(filteredBalance));
        state$8.lastRetry = void 0;
        state$8.balanceLoading = false;
        return filteredBalance;
      }
    } catch (error) {
      state$8.lastRetry = Date.now();
      onError == null ? void 0 : onError(error);
      SnackController.showError("Token Balance Unavailable");
    } finally {
      state$8.balanceLoading = false;
    }
    return [];
  },
  resetAccount(chain) {
    ChainController.resetAccount(chain);
  }
};
const baseUrl$1 = CoreHelperUtil.getApiUrl();
const api$1 = new FetchUtil({ baseUrl: baseUrl$1, clientId: null });
const state$7 = proxy({
  page: 1,
  count: 0,
  featured: [],
  recommended: [],
  wallets: [],
  search: [],
  isAnalyticsEnabled: false,
  excludedRDNS: []
});
const ApiController$1 = {
  state: state$7,
  subscribeKey(key2, callback) {
    return subscribeKey(state$7, key2, callback);
  },
  _getSdkProperties() {
    const { projectId, sdkType, sdkVersion } = OptionsController.state;
    return {
      projectId,
      st: sdkType || "appkit",
      sv: sdkVersion || "html-wagmi-4.2.2"
    };
  },
  _filterOutExtensions(wallets) {
    if (OptionsController.state.isUniversalProvider) {
      return wallets.filter((w2) => Boolean(w2.mobile_link || w2.desktop_link || w2.webapp_link));
    }
    return wallets;
  },
  async _fetchWalletImage(imageId) {
    AssetController.setWalletImage(imageId, "");
  },
  async _fetchNetworkImage(imageId) {
    AssetController.setNetworkImage(imageId, "");
  },
  async _fetchConnectorImage(imageId) {
    const imageUrl = `${api$1.baseUrl}/public/getAssetImage/${imageId}`;
    const blob = await api$1.getBlob({ path: imageUrl, params: ApiController$1._getSdkProperties() });
    AssetController.setConnectorImage(imageId, URL.createObjectURL(blob));
  },
  async _fetchCurrencyImage(countryCode) {
    const imageUrl = `${api$1.baseUrl}/public/getCurrencyImage/${countryCode}`;
    const blob = await api$1.getBlob({ path: imageUrl, params: ApiController$1._getSdkProperties() });
    AssetController.setCurrencyImage(countryCode, URL.createObjectURL(blob));
  },
  async _fetchTokenImage(symbol) {
    const imageUrl = `${api$1.baseUrl}/public/getTokenImage/${symbol}`;
    const blob = await api$1.getBlob({ path: imageUrl, params: ApiController$1._getSdkProperties() });
    AssetController.setTokenImage(symbol, URL.createObjectURL(blob));
  },
  async prefetchNetworkImages() {
  },
  async getBalance(account, networkId, forceUpdate) {
    const caipAddress = `${networkId}:${account}`;
    const cachedBalance = StorageUtil.getBalanceCacheForCaipAddress(caipAddress);
    if (cachedBalance) {
      return cachedBalance;
    }
    const response = await api$1.get({
      path: `/api/v1/public/token/balance`,
      params: {
        account,
        networkId,
        projectId: "0123456789"
      }
    });
    const balance = response.data;
    StorageUtil.updateBalanceCache({
      caipAddress,
      balance,
      timestamp: Date.now()
    });
    return balance;
  },
  async fetchGasPrice({ chainId: chainIdWithNetwork }) {
    const chain_id = chainIdWithNetwork.split(":")[1];
    return api$1.get({
      path: `/api/v1/public/transaction/gas-suggestion/legacy`,
      headers: {
        "Content-Type": "application/json"
      },
      params: {
        chain_id
      }
    });
  },
  async fetchConnectorImages() {
  },
  async fetchCurrencyImages(currencies = []) {
  },
  async fetchTokenImages(tokens = []) {
  },
  async fetchFeaturedWallets() {
  },
  async fetchRecommendedWallets() {
  },
  async fetchWallets({ page }) {
  },
  async initializeExcludedWalletRdns({ ids }) {
  },
  async searchWallet({ search, badge }) {
  },
  prefetch() {
    if (AccountController.state.status === "connected") {
      return Promise.resolve();
    }
    if (state$7.prefetchPromise) {
      return state$7.prefetchPromise;
    }
    const promises = [
      ApiController$1.fetchFeaturedWallets(),
      ApiController$1.fetchRecommendedWallets(),
      ApiController$1.fetchConnectorImages(),
      ApiController$1.prefetchNetworkImages()
    ];
    state$7.prefetchPromise = Promise.allSettled(promises);
    return state$7.prefetchPromise;
  },
  prefetchAnalyticsConfig() {
    var _a3;
    if ((_a3 = OptionsController.state.features) == null ? void 0 : _a3.analytics) {
      ApiController$1.fetchAnalyticsConfig();
    }
  },
  async fetchAnalyticsConfig() {
    const { isAnalyticsEnabled } = await api$1.get({
      path: "/getAnalyticsConfig",
      params: ApiController$1._getSdkProperties()
    });
    OptionsController.setFeatures({ analytics: isAnalyticsEnabled });
  }
};
const state$6 = proxy({
  loading: false,
  open: false,
  shake: false
});
const ModalController = {
  state: state$6,
  subscribe(callback) {
    return subscribe(state$6, () => callback(state$6));
  },
  subscribeKey(key2, callback) {
    return subscribeKey(state$6, key2, callback);
  },
  async open(options) {
    await ApiController$1.prefetch();
    const caipAddress = ChainController.state.activeCaipAddress;
    const noAdapters = ChainController.state.noAdapters;
    if (options == null ? void 0 : options.view) {
      RouterController.reset(options.view);
    } else if (caipAddress) {
      RouterController.reset("Account");
    } else if (noAdapters && !CoreHelperUtil.isMobile()) {
      RouterController.reset("ConnectingWalletConnectBasic");
    } else {
      RouterController.reset("Connect");
    }
    state$6.open = true;
    PublicStateController.set({ open: true });
    EventsController.sendEvent({
      type: "track",
      event: "MODAL_OPEN",
      properties: { connected: Boolean(caipAddress) }
    });
  },
  close() {
    const isEmbeddedEnabled = OptionsController.state.enableEmbedded;
    const connected = Boolean(ChainController.state.activeCaipAddress);
    state$6.open = false;
    if (isEmbeddedEnabled) {
      if (connected) {
        RouterController.replace("Account");
      } else {
        RouterController.push("Connect");
      }
    } else {
      PublicStateController.set({ open: false });
    }
    EventsController.sendEvent({
      type: "track",
      event: "MODAL_CLOSE",
      properties: { connected }
    });
    ConnectorController.clearNamespaceFilter();
  },
  setLoading(loading) {
    state$6.loading = loading;
    PublicStateController.set({ loading });
  },
  shake() {
    if (state$6.shake) {
      return;
    }
    state$6.shake = true;
    setTimeout(() => {
      state$6.shake = false;
    }, 500);
  }
};
const USDC_CURRENCY_DEFAULT = {
  id: "2b92315d-eab7-5bef-84fa-089a131333f5",
  name: "USD Coin",
  symbol: "USDC",
  networks: [
    {
      name: "ethereum-mainnet",
      display_name: "Ethereum",
      chain_id: "1",
      contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
    },
    {
      name: "polygon-mainnet",
      display_name: "Polygon",
      chain_id: "137",
      contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
    }
  ]
};
const USD_CURRENCY_DEFAULT = {
  id: "USD",
  payment_method_limits: [
    {
      id: "card",
      min: "10.00",
      max: "7500.00"
    },
    {
      id: "ach_bank_account",
      min: "10.00",
      max: "25000.00"
    }
  ]
};
const defaultState = {
  providers: ONRAMP_PROVIDERS,
  selectedProvider: null,
  error: null,
  purchaseCurrency: USDC_CURRENCY_DEFAULT,
  paymentCurrency: USD_CURRENCY_DEFAULT,
  purchaseCurrencies: [USDC_CURRENCY_DEFAULT],
  paymentCurrencies: [],
  quotesLoading: false
};
const state$5 = proxy(defaultState);
const OnRampController = {
  state: state$5,
  subscribe(callback) {
    return subscribe(state$5, () => callback(state$5));
  },
  subscribeKey(key2, callback) {
    return subscribeKey(state$5, key2, callback);
  },
  setSelectedProvider(provider) {
    if (provider && provider.name === "meld") {
      const currency = ChainController.state.activeChain === ConstantsUtil$4.CHAIN.SOLANA ? "SOL" : "USDC";
      const address = AccountController.state.address ?? "";
      const url = new URL(provider.url);
      url.searchParams.append("publicKey", MELD_PUBLIC_KEY);
      url.searchParams.append("destinationCurrencyCode", currency);
      url.searchParams.append("walletAddress", address);
      provider.url = url.toString();
    }
    state$5.selectedProvider = provider;
  },
  setPurchaseCurrency(currency) {
    state$5.purchaseCurrency = currency;
  },
  setPaymentCurrency(currency) {
    state$5.paymentCurrency = currency;
  },
  setPurchaseAmount(amount) {
    this.state.purchaseAmount = amount;
  },
  setPaymentAmount(amount) {
    this.state.paymentAmount = amount;
  },
  async getAvailableCurrencies() {
    const options = await BlockchainApiController.getOnrampOptions();
    state$5.purchaseCurrencies = options.purchaseCurrencies;
    state$5.paymentCurrencies = options.paymentCurrencies;
    state$5.paymentCurrency = options.paymentCurrencies[0] || USD_CURRENCY_DEFAULT;
    state$5.purchaseCurrency = options.purchaseCurrencies[0] || USDC_CURRENCY_DEFAULT;
    await ApiController$1.fetchCurrencyImages(options.paymentCurrencies.map((currency) => currency.id));
    await ApiController$1.fetchTokenImages(options.purchaseCurrencies.map((currency) => currency.symbol));
  },
  async getQuote() {
    var _a3, _b2;
    state$5.quotesLoading = true;
    try {
      const quote = await BlockchainApiController.getOnrampQuote({
        purchaseCurrency: state$5.purchaseCurrency,
        paymentCurrency: state$5.paymentCurrency,
        amount: ((_a3 = state$5.paymentAmount) == null ? void 0 : _a3.toString()) || "0",
        network: (_b2 = state$5.purchaseCurrency) == null ? void 0 : _b2.symbol
      });
      state$5.quotesLoading = false;
      state$5.purchaseAmount = Number(quote == null ? void 0 : quote.purchaseAmount.amount);
      return quote;
    } catch (error) {
      state$5.error = error.message;
      state$5.quotesLoading = false;
      return null;
    } finally {
      state$5.quotesLoading = false;
    }
  },
  resetState() {
    state$5.providers = ONRAMP_PROVIDERS;
    state$5.selectedProvider = null;
    state$5.error = null;
    state$5.purchaseCurrency = USDC_CURRENCY_DEFAULT;
    state$5.paymentCurrency = USD_CURRENCY_DEFAULT;
    state$5.purchaseCurrencies = [USDC_CURRENCY_DEFAULT];
    state$5.paymentCurrencies = [];
    state$5.paymentAmount = void 0;
    state$5.purchaseAmount = void 0;
    state$5.quotesLoading = false;
  }
};
const state$4 = proxy({
  message: "",
  open: false,
  triggerRect: {
    width: 0,
    height: 0,
    top: 0,
    left: 0
  },
  variant: "shade"
});
const TooltipController = {
  state: state$4,
  subscribe(callback) {
    return subscribe(state$4, () => callback(state$4));
  },
  subscribeKey(key2, callback) {
    return subscribeKey(state$4, key2, callback);
  },
  showTooltip({ message, triggerRect, variant }) {
    state$4.open = true;
    state$4.message = message;
    state$4.triggerRect = triggerRect;
    state$4.variant = variant;
  },
  hide() {
    state$4.open = false;
    state$4.message = "";
    state$4.triggerRect = {
      width: 0,
      height: 0,
      top: 0,
      left: 0
    };
  }
};
const SLIP44_MSB = 2147483648;
const EnsUtil = {
  convertEVMChainIdToCoinType(chainId) {
    if (chainId >= SLIP44_MSB) {
      throw new Error("Invalid chainId");
    }
    return (SLIP44_MSB | chainId) >>> 0;
  }
};
const state$3 = proxy({
  suggestions: [],
  loading: false
});
const EnsController = {
  state: state$3,
  subscribe(callback) {
    return subscribe(state$3, () => callback(state$3));
  },
  subscribeKey(key2, callback) {
    return subscribeKey(state$3, key2, callback);
  },
  async resolveName(name) {
    var _a3, _b2;
    try {
      return await BlockchainApiController.lookupEnsName(name);
    } catch (e3) {
      const error = e3;
      throw new Error(((_b2 = (_a3 = error == null ? void 0 : error.reasons) == null ? void 0 : _a3[0]) == null ? void 0 : _b2.description) || "Error resolving name");
    }
  },
  async isNameRegistered(name) {
    try {
      await BlockchainApiController.lookupEnsName(name);
      return true;
    } catch {
      return false;
    }
  },
  async getSuggestions(value) {
    try {
      state$3.loading = true;
      state$3.suggestions = [];
      const response = await BlockchainApiController.getEnsNameSuggestions(value);
      state$3.suggestions = response.suggestions.map((suggestion) => ({
        ...suggestion,
        name: suggestion.name
      })) || [];
      return state$3.suggestions;
    } catch (e3) {
      const errorMessage = this.parseEnsApiError(e3, "Error fetching name suggestions");
      throw new Error(errorMessage);
    } finally {
      state$3.loading = false;
    }
  },
  async getNamesForAddress(address) {
    try {
      const network = ChainController.state.activeCaipNetwork;
      if (!network) {
        return [];
      }
      const cachedEns = StorageUtil.getEnsFromCacheForAddress(address);
      if (cachedEns) {
        return cachedEns;
      }
      const response = await BlockchainApiController.reverseLookupEnsName({ address });
      StorageUtil.updateEnsCache({
        address,
        ens: response,
        timestamp: Date.now()
      });
      return response;
    } catch (e3) {
      const errorMessage = this.parseEnsApiError(e3, "Error fetching names for address");
      throw new Error(errorMessage);
    }
  },
  async registerName(name) {
    const network = ChainController.state.activeCaipNetwork;
    if (!network) {
      throw new Error("Network not found");
    }
    const address = AccountController.state.address;
    const emailConnector = ConnectorController.getAuthConnector();
    if (!address || !emailConnector) {
      throw new Error("Address or auth connector not found");
    }
    state$3.loading = true;
    try {
      const message = JSON.stringify({
        name,
        attributes: {},
        // Unix timestamp
        timestamp: Math.floor(Date.now() / 1e3)
      });
      RouterController.pushTransactionStack({
        view: "RegisterAccountNameSuccess",
        goBack: false,
        replace: true,
        onCancel() {
          state$3.loading = false;
        }
      });
      const signature2 = await ConnectionController.signMessage({
        message
      });
      const networkId = network.id;
      if (!networkId) {
        throw new Error("Network not found");
      }
      const coinType = EnsUtil.convertEVMChainIdToCoinType(Number(networkId));
      await BlockchainApiController.registerEnsName({
        coinType,
        address,
        signature: signature2,
        message
      });
      AccountController.setProfileName(name, network.chainNamespace);
      RouterController.replace("RegisterAccountNameSuccess");
    } catch (e3) {
      const errorMessage = this.parseEnsApiError(e3, `Error registering name ${name}`);
      RouterController.replace("RegisterAccountName");
      throw new Error(errorMessage);
    } finally {
      state$3.loading = false;
    }
  },
  validateName(name) {
    return /^[a-zA-Z0-9-]{4,}$/u.test(name);
  },
  parseEnsApiError(error, defaultError) {
    var _a3, _b2;
    const ensError = error;
    return ((_b2 = (_a3 = ensError == null ? void 0 : ensError.reasons) == null ? void 0 : _a3[0]) == null ? void 0 : _b2.description) || defaultError;
  }
};
const ConstantsUtil$2 = {
  ACCOUNT_TABS: [{ label: "Tokens" }, { label: "NFTs" }, { label: "Activity" }],
  SECURE_SITE_ORIGIN: "https://secure.walletconnect.org",
  VIEW_DIRECTION: {
    Next: "next",
    Prev: "prev"
  },
  DEFAULT_CONNECT_METHOD_ORDER: ["email", "social", "wallet"],
  ANIMATION_DURATIONS: {
    HeaderText: 120,
    ModalHeight: 150,
    ViewTransition: 150
  }
};
const WalletUtil$1 = {
  filterOutDuplicatesByRDNS(wallets) {
    const connectors = OptionsController.state.enableEIP6963 ? ConnectorController.state.connectors : [];
    const recent = StorageUtil.getRecentWallets();
    const connectorRDNSs = connectors.map((connector) => {
      var _a3;
      return (_a3 = connector.info) == null ? void 0 : _a3.rdns;
    }).filter(Boolean);
    const recentRDNSs = recent.map((wallet) => wallet.rdns).filter(Boolean);
    const allRDNSs = connectorRDNSs.concat(recentRDNSs);
    if (allRDNSs.includes("io.metamask.mobile") && CoreHelperUtil.isMobile()) {
      const index2 = allRDNSs.indexOf("io.metamask.mobile");
      allRDNSs[index2] = "io.metamask";
    }
    const filtered = wallets.filter((wallet) => !allRDNSs.includes(String(wallet == null ? void 0 : wallet.rdns)));
    return filtered;
  },
  filterOutDuplicatesByIds(wallets) {
    const connectors = ConnectorController.state.connectors.filter((connector) => connector.type === "ANNOUNCED" || connector.type === "INJECTED");
    const recent = StorageUtil.getRecentWallets();
    const connectorIds = connectors.map((connector) => connector.explorerId);
    const recentIds = recent.map((wallet) => wallet.id);
    const allIds = connectorIds.concat(recentIds);
    const filtered = wallets.filter((wallet) => !allIds.includes(wallet == null ? void 0 : wallet.id));
    return filtered;
  },
  filterOutDuplicateWallets(wallets) {
    const uniqueByRDNS = this.filterOutDuplicatesByRDNS(wallets);
    const uniqueWallets = this.filterOutDuplicatesByIds(uniqueByRDNS);
    return uniqueWallets;
  },
  markWalletsAsInstalled(wallets) {
    const { connectors } = ConnectorController.state;
    const installedConnectors = connectors.filter((c2) => c2.type === "ANNOUNCED").reduce((acum, val) => {
      var _a3;
      if (!((_a3 = val.info) == null ? void 0 : _a3.rdns)) {
        return acum;
      }
      acum[val.info.rdns] = true;
      return acum;
    }, {});
    const walletsWithInstalled = wallets.map((wallet) => ({
      ...wallet,
      installed: Boolean(wallet.rdns) && Boolean(installedConnectors[wallet.rdns ?? ""])
    }));
    const sortedWallets = walletsWithInstalled.sort((a2, b2) => Number(b2.installed) - Number(a2.installed));
    return sortedWallets;
  },
  getConnectOrderMethod(_features, _connectors) {
    var _a3;
    const connectMethodOrder = (_features == null ? void 0 : _features.connectMethodsOrder) || ((_a3 = OptionsController.state.features) == null ? void 0 : _a3.connectMethodsOrder);
    const connectors = _connectors || ConnectorController.state.connectors;
    if (connectMethodOrder) {
      return connectMethodOrder;
    }
    const { injected: injected2, announced } = ConnectorUtil$1.getConnectorsByType(connectors);
    const shownInjected = injected2.filter(ConnectorUtil$1.showConnector);
    const shownAnnounced = announced.filter(ConnectorUtil$1.showConnector);
    if (shownInjected.length || shownAnnounced.length) {
      return ["wallet", "email", "social"];
    }
    return ConstantsUtil$2.DEFAULT_CONNECT_METHOD_ORDER;
  }
};
const ConnectorUtil$1 = {
  getConnectorsByType(connectors) {
    const { featured, recommended } = ApiController$1.state;
    const { customWallets: custom2 } = OptionsController.state;
    const recent = StorageUtil.getRecentWallets();
    const filteredRecommended = WalletUtil$1.filterOutDuplicateWallets(recommended);
    const filteredFeatured = WalletUtil$1.filterOutDuplicateWallets(featured);
    const multiChain = connectors.filter((connector) => connector.type === "MULTI_CHAIN");
    const announced = connectors.filter((connector) => connector.type === "ANNOUNCED");
    const injected2 = connectors.filter((connector) => connector.type === "INJECTED");
    const external = connectors.filter((connector) => connector.type === "EXTERNAL");
    return {
      custom: custom2,
      recent,
      external,
      multiChain,
      announced,
      injected: injected2,
      recommended: filteredRecommended,
      featured: filteredFeatured
    };
  },
  showConnector(connector) {
    var _a3, _b2;
    if (connector.type === "INJECTED") {
      if (!CoreHelperUtil.isMobile() && connector.name === "Browser Wallet") {
        return false;
      }
      const walletRDNS = (_a3 = connector.info) == null ? void 0 : _a3.rdns;
      if (!walletRDNS && !ConnectionController.checkInstalled()) {
        return false;
      }
      if (walletRDNS && ApiController$1.state.excludedRDNS) {
        if (ApiController$1.state.excludedRDNS.includes(walletRDNS)) {
          return false;
        }
      }
    }
    if (connector.type === "ANNOUNCED") {
      const rdns = (_b2 = connector.info) == null ? void 0 : _b2.rdns;
      if (rdns && ApiController$1.state.excludedRDNS.includes(rdns)) {
        return false;
      }
    }
    return true;
  }
};
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$2 = globalThis, e$5 = t$2.ShadowRoot && (void 0 === t$2.ShadyCSS || t$2.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, s$3 = Symbol(), o$7 = /* @__PURE__ */ new WeakMap();
let n$6 = class n4 {
  constructor(t2, e3, o3) {
    if (this._$cssResult$ = true, o3 !== s$3) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t2, this.t = e3;
  }
  get styleSheet() {
    let t2 = this.o;
    const s2 = this.t;
    if (e$5 && void 0 === t2) {
      const e3 = void 0 !== s2 && 1 === s2.length;
      e3 && (t2 = o$7.get(s2)), void 0 === t2 && ((this.o = t2 = new CSSStyleSheet()).replaceSync(this.cssText), e3 && o$7.set(s2, t2));
    }
    return t2;
  }
  toString() {
    return this.cssText;
  }
};
const r$5 = (t2) => new n$6("string" == typeof t2 ? t2 : t2 + "", void 0, s$3), i$4 = (t2, ...e3) => {
  const o3 = 1 === t2.length ? t2[0] : e3.reduce((e4, s2, o4) => e4 + ((t3) => {
    if (true === t3._$cssResult$) return t3.cssText;
    if ("number" == typeof t3) return t3;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t3 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s2) + t2[o4 + 1], t2[0]);
  return new n$6(o3, t2, s$3);
}, S$3 = (s2, o3) => {
  if (e$5) s2.adoptedStyleSheets = o3.map((t2) => t2 instanceof CSSStyleSheet ? t2 : t2.styleSheet);
  else for (const e3 of o3) {
    const o4 = document.createElement("style"), n5 = t$2.litNonce;
    void 0 !== n5 && o4.setAttribute("nonce", n5), o4.textContent = e3.cssText, s2.appendChild(o4);
  }
}, c$4 = e$5 ? (t2) => t2 : (t2) => t2 instanceof CSSStyleSheet ? ((t3) => {
  let e3 = "";
  for (const s2 of t3.cssRules) e3 += s2.cssText;
  return r$5(e3);
})(t2) : t2;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: i$3, defineProperty: e$4, getOwnPropertyDescriptor: h$4, getOwnPropertyNames: r$4, getOwnPropertySymbols: o$6, getPrototypeOf: n$5 } = Object, a$1 = globalThis, c$3 = a$1.trustedTypes, l$1 = c$3 ? c$3.emptyScript : "", p$4 = a$1.reactiveElementPolyfillSupport, d$2 = (t2, s2) => t2, u$1 = { toAttribute(t2, s2) {
  switch (s2) {
    case Boolean:
      t2 = t2 ? l$1 : null;
      break;
    case Object:
    case Array:
      t2 = null == t2 ? t2 : JSON.stringify(t2);
  }
  return t2;
}, fromAttribute(t2, s2) {
  let i4 = t2;
  switch (s2) {
    case Boolean:
      i4 = null !== t2;
      break;
    case Number:
      i4 = null === t2 ? null : Number(t2);
      break;
    case Object:
    case Array:
      try {
        i4 = JSON.parse(t2);
      } catch (t3) {
        i4 = null;
      }
  }
  return i4;
} }, f$4 = (t2, s2) => !i$3(t2, s2), b$3 = { attribute: true, type: String, converter: u$1, reflect: false, useDefault: false, hasChanged: f$4 };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), a$1.litPropertyMetadata ?? (a$1.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
let y$2 = class y3 extends HTMLElement {
  static addInitializer(t2) {
    this._$Ei(), (this.l ?? (this.l = [])).push(t2);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t2, s2 = b$3) {
    if (s2.state && (s2.attribute = false), this._$Ei(), this.prototype.hasOwnProperty(t2) && ((s2 = Object.create(s2)).wrapped = true), this.elementProperties.set(t2, s2), !s2.noAccessor) {
      const i4 = Symbol(), h5 = this.getPropertyDescriptor(t2, i4, s2);
      void 0 !== h5 && e$4(this.prototype, t2, h5);
    }
  }
  static getPropertyDescriptor(t2, s2, i4) {
    const { get: e3, set: r3 } = h$4(this.prototype, t2) ?? { get() {
      return this[s2];
    }, set(t3) {
      this[s2] = t3;
    } };
    return { get: e3, set(s3) {
      const h5 = e3 == null ? void 0 : e3.call(this);
      r3 == null ? void 0 : r3.call(this, s3), this.requestUpdate(t2, h5, i4);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t2) {
    return this.elementProperties.get(t2) ?? b$3;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d$2("elementProperties"))) return;
    const t2 = n$5(this);
    t2.finalize(), void 0 !== t2.l && (this.l = [...t2.l]), this.elementProperties = new Map(t2.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d$2("finalized"))) return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d$2("properties"))) {
      const t3 = this.properties, s2 = [...r$4(t3), ...o$6(t3)];
      for (const i4 of s2) this.createProperty(i4, t3[i4]);
    }
    const t2 = this[Symbol.metadata];
    if (null !== t2) {
      const s2 = litPropertyMetadata.get(t2);
      if (void 0 !== s2) for (const [t3, i4] of s2) this.elementProperties.set(t3, i4);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t3, s2] of this.elementProperties) {
      const i4 = this._$Eu(t3, s2);
      void 0 !== i4 && this._$Eh.set(i4, t3);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s2) {
    const i4 = [];
    if (Array.isArray(s2)) {
      const e3 = new Set(s2.flat(1 / 0).reverse());
      for (const s3 of e3) i4.unshift(c$4(s3));
    } else void 0 !== s2 && i4.push(c$4(s2));
    return i4;
  }
  static _$Eu(t2, s2) {
    const i4 = s2.attribute;
    return false === i4 ? void 0 : "string" == typeof i4 ? i4 : "string" == typeof t2 ? t2.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var _a3;
    this._$ES = new Promise((t2) => this.enableUpdating = t2), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (_a3 = this.constructor.l) == null ? void 0 : _a3.forEach((t2) => t2(this));
  }
  addController(t2) {
    var _a3;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t2), void 0 !== this.renderRoot && this.isConnected && ((_a3 = t2.hostConnected) == null ? void 0 : _a3.call(t2));
  }
  removeController(t2) {
    var _a3;
    (_a3 = this._$EO) == null ? void 0 : _a3.delete(t2);
  }
  _$E_() {
    const t2 = /* @__PURE__ */ new Map(), s2 = this.constructor.elementProperties;
    for (const i4 of s2.keys()) this.hasOwnProperty(i4) && (t2.set(i4, this[i4]), delete this[i4]);
    t2.size > 0 && (this._$Ep = t2);
  }
  createRenderRoot() {
    const t2 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S$3(t2, this.constructor.elementStyles), t2;
  }
  connectedCallback() {
    var _a3;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), (_a3 = this._$EO) == null ? void 0 : _a3.forEach((t2) => {
      var _a4;
      return (_a4 = t2.hostConnected) == null ? void 0 : _a4.call(t2);
    });
  }
  enableUpdating(t2) {
  }
  disconnectedCallback() {
    var _a3;
    (_a3 = this._$EO) == null ? void 0 : _a3.forEach((t2) => {
      var _a4;
      return (_a4 = t2.hostDisconnected) == null ? void 0 : _a4.call(t2);
    });
  }
  attributeChangedCallback(t2, s2, i4) {
    this._$AK(t2, i4);
  }
  _$ET(t2, s2) {
    var _a3;
    const i4 = this.constructor.elementProperties.get(t2), e3 = this.constructor._$Eu(t2, i4);
    if (void 0 !== e3 && true === i4.reflect) {
      const h5 = (void 0 !== ((_a3 = i4.converter) == null ? void 0 : _a3.toAttribute) ? i4.converter : u$1).toAttribute(s2, i4.type);
      this._$Em = t2, null == h5 ? this.removeAttribute(e3) : this.setAttribute(e3, h5), this._$Em = null;
    }
  }
  _$AK(t2, s2) {
    var _a3, _b2;
    const i4 = this.constructor, e3 = i4._$Eh.get(t2);
    if (void 0 !== e3 && this._$Em !== e3) {
      const t3 = i4.getPropertyOptions(e3), h5 = "function" == typeof t3.converter ? { fromAttribute: t3.converter } : void 0 !== ((_a3 = t3.converter) == null ? void 0 : _a3.fromAttribute) ? t3.converter : u$1;
      this._$Em = e3;
      const r3 = h5.fromAttribute(s2, t3.type);
      this[e3] = r3 ?? ((_b2 = this._$Ej) == null ? void 0 : _b2.get(e3)) ?? r3, this._$Em = null;
    }
  }
  requestUpdate(t2, s2, i4) {
    var _a3;
    if (void 0 !== t2) {
      const e3 = this.constructor, h5 = this[t2];
      if (i4 ?? (i4 = e3.getPropertyOptions(t2)), !((i4.hasChanged ?? f$4)(h5, s2) || i4.useDefault && i4.reflect && h5 === ((_a3 = this._$Ej) == null ? void 0 : _a3.get(t2)) && !this.hasAttribute(e3._$Eu(t2, i4)))) return;
      this.C(t2, s2, i4);
    }
    false === this.isUpdatePending && (this._$ES = this._$EP());
  }
  C(t2, s2, { useDefault: i4, reflect: e3, wrapped: h5 }, r3) {
    i4 && !(this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Map())).has(t2) && (this._$Ej.set(t2, r3 ?? s2 ?? this[t2]), true !== h5 || void 0 !== r3) || (this._$AL.has(t2) || (this.hasUpdated || i4 || (s2 = void 0), this._$AL.set(t2, s2)), true === e3 && this._$Em !== t2 && (this._$Eq ?? (this._$Eq = /* @__PURE__ */ new Set())).add(t2));
  }
  async _$EP() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t3) {
      Promise.reject(t3);
    }
    const t2 = this.scheduleUpdate();
    return null != t2 && await t2, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var _a3;
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [t4, s3] of this._$Ep) this[t4] = s3;
        this._$Ep = void 0;
      }
      const t3 = this.constructor.elementProperties;
      if (t3.size > 0) for (const [s3, i4] of t3) {
        const { wrapped: t4 } = i4, e3 = this[s3];
        true !== t4 || this._$AL.has(s3) || void 0 === e3 || this.C(s3, void 0, i4, e3);
      }
    }
    let t2 = false;
    const s2 = this._$AL;
    try {
      t2 = this.shouldUpdate(s2), t2 ? (this.willUpdate(s2), (_a3 = this._$EO) == null ? void 0 : _a3.forEach((t3) => {
        var _a4;
        return (_a4 = t3.hostUpdate) == null ? void 0 : _a4.call(t3);
      }), this.update(s2)) : this._$EM();
    } catch (s3) {
      throw t2 = false, this._$EM(), s3;
    }
    t2 && this._$AE(s2);
  }
  willUpdate(t2) {
  }
  _$AE(t2) {
    var _a3;
    (_a3 = this._$EO) == null ? void 0 : _a3.forEach((t3) => {
      var _a4;
      return (_a4 = t3.hostUpdated) == null ? void 0 : _a4.call(t3);
    }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t2)), this.updated(t2);
  }
  _$EM() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t2) {
    return true;
  }
  update(t2) {
    this._$Eq && (this._$Eq = this._$Eq.forEach((t3) => this._$ET(t3, this[t3]))), this._$EM();
  }
  updated(t2) {
  }
  firstUpdated(t2) {
  }
};
y$2.elementStyles = [], y$2.shadowRootOptions = { mode: "open" }, y$2[d$2("elementProperties")] = /* @__PURE__ */ new Map(), y$2[d$2("finalized")] = /* @__PURE__ */ new Map(), p$4 == null ? void 0 : p$4({ ReactiveElement: y$2 }), (a$1.reactiveElementVersions ?? (a$1.reactiveElementVersions = [])).push("2.1.1");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$1 = globalThis, i$2 = t$1.trustedTypes, s$2 = i$2 ? i$2.createPolicy("lit-html", { createHTML: (t2) => t2 }) : void 0, e$3 = "$lit$", h$3 = `lit$${Math.random().toFixed(9).slice(2)}$`, o$5 = "?" + h$3, n$4 = `<${o$5}>`, r$3 = document, l = () => r$3.createComment(""), c$2 = (t2) => null === t2 || "object" != typeof t2 && "function" != typeof t2, a = Array.isArray, u = (t2) => a(t2) || "function" == typeof (t2 == null ? void 0 : t2[Symbol.iterator]), d$1 = "[ 	\n\f\r]", f$3 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, v$2 = /-->/g, _$4 = />/g, m = RegExp(`>|${d$1}(?:([^\\s"'>=/]+)(${d$1}*=${d$1}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), p$3 = /'/g, g$1 = /"/g, $$4 = /^(?:script|style|textarea|title)$/i, y$1 = (t2) => (i4, ...s2) => ({ _$litType$: t2, strings: i4, values: s2 }), x$3 = y$1(1), b$2 = y$1(2), T$2 = Symbol.for("lit-noChange"), E$2 = Symbol.for("lit-nothing"), A$2 = /* @__PURE__ */ new WeakMap(), C$3 = r$3.createTreeWalker(r$3, 129);
function P$1(t2, i4) {
  if (!a(t2) || !t2.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== s$2 ? s$2.createHTML(i4) : i4;
}
const V$5 = (t2, i4) => {
  const s2 = t2.length - 1, o3 = [];
  let r3, l2 = 2 === i4 ? "<svg>" : 3 === i4 ? "<math>" : "", c2 = f$3;
  for (let i5 = 0; i5 < s2; i5++) {
    const s3 = t2[i5];
    let a2, u2, d4 = -1, y4 = 0;
    for (; y4 < s3.length && (c2.lastIndex = y4, u2 = c2.exec(s3), null !== u2); ) y4 = c2.lastIndex, c2 === f$3 ? "!--" === u2[1] ? c2 = v$2 : void 0 !== u2[1] ? c2 = _$4 : void 0 !== u2[2] ? ($$4.test(u2[2]) && (r3 = RegExp("</" + u2[2], "g")), c2 = m) : void 0 !== u2[3] && (c2 = m) : c2 === m ? ">" === u2[0] ? (c2 = r3 ?? f$3, d4 = -1) : void 0 === u2[1] ? d4 = -2 : (d4 = c2.lastIndex - u2[2].length, a2 = u2[1], c2 = void 0 === u2[3] ? m : '"' === u2[3] ? g$1 : p$3) : c2 === g$1 || c2 === p$3 ? c2 = m : c2 === v$2 || c2 === _$4 ? c2 = f$3 : (c2 = m, r3 = void 0);
    const x2 = c2 === m && t2[i5 + 1].startsWith("/>") ? " " : "";
    l2 += c2 === f$3 ? s3 + n$4 : d4 >= 0 ? (o3.push(a2), s3.slice(0, d4) + e$3 + s3.slice(d4) + h$3 + x2) : s3 + h$3 + (-2 === d4 ? i5 : x2);
  }
  return [P$1(t2, l2 + (t2[s2] || "<?>") + (2 === i4 ? "</svg>" : 3 === i4 ? "</math>" : "")), o3];
};
let N$2 = class N2 {
  constructor({ strings: t2, _$litType$: s2 }, n5) {
    let r3;
    this.parts = [];
    let c2 = 0, a2 = 0;
    const u2 = t2.length - 1, d4 = this.parts, [f6, v2] = V$5(t2, s2);
    if (this.el = N2.createElement(f6, n5), C$3.currentNode = this.el.content, 2 === s2 || 3 === s2) {
      const t3 = this.el.content.firstChild;
      t3.replaceWith(...t3.childNodes);
    }
    for (; null !== (r3 = C$3.nextNode()) && d4.length < u2; ) {
      if (1 === r3.nodeType) {
        if (r3.hasAttributes()) for (const t3 of r3.getAttributeNames()) if (t3.endsWith(e$3)) {
          const i4 = v2[a2++], s3 = r3.getAttribute(t3).split(h$3), e3 = /([.?@])?(.*)/.exec(i4);
          d4.push({ type: 1, index: c2, name: e3[2], strings: s3, ctor: "." === e3[1] ? H$3 : "?" === e3[1] ? I$2 : "@" === e3[1] ? L$2 : k$2 }), r3.removeAttribute(t3);
        } else t3.startsWith(h$3) && (d4.push({ type: 6, index: c2 }), r3.removeAttribute(t3));
        if ($$4.test(r3.tagName)) {
          const t3 = r3.textContent.split(h$3), s3 = t3.length - 1;
          if (s3 > 0) {
            r3.textContent = i$2 ? i$2.emptyScript : "";
            for (let i4 = 0; i4 < s3; i4++) r3.append(t3[i4], l()), C$3.nextNode(), d4.push({ type: 2, index: ++c2 });
            r3.append(t3[s3], l());
          }
        }
      } else if (8 === r3.nodeType) if (r3.data === o$5) d4.push({ type: 2, index: c2 });
      else {
        let t3 = -1;
        for (; -1 !== (t3 = r3.data.indexOf(h$3, t3 + 1)); ) d4.push({ type: 7, index: c2 }), t3 += h$3.length - 1;
      }
      c2++;
    }
  }
  static createElement(t2, i4) {
    const s2 = r$3.createElement("template");
    return s2.innerHTML = t2, s2;
  }
};
function S$2(t2, i4, s2 = t2, e3) {
  var _a3, _b2;
  if (i4 === T$2) return i4;
  let h5 = void 0 !== e3 ? (_a3 = s2._$Co) == null ? void 0 : _a3[e3] : s2._$Cl;
  const o3 = c$2(i4) ? void 0 : i4._$litDirective$;
  return (h5 == null ? void 0 : h5.constructor) !== o3 && ((_b2 = h5 == null ? void 0 : h5._$AO) == null ? void 0 : _b2.call(h5, false), void 0 === o3 ? h5 = void 0 : (h5 = new o3(t2), h5._$AT(t2, s2, e3)), void 0 !== e3 ? (s2._$Co ?? (s2._$Co = []))[e3] = h5 : s2._$Cl = h5), void 0 !== h5 && (i4 = S$2(t2, h5._$AS(t2, i4.values), h5, e3)), i4;
}
let M$4 = class M3 {
  constructor(t2, i4) {
    this._$AV = [], this._$AN = void 0, this._$AD = t2, this._$AM = i4;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t2) {
    const { el: { content: i4 }, parts: s2 } = this._$AD, e3 = ((t2 == null ? void 0 : t2.creationScope) ?? r$3).importNode(i4, true);
    C$3.currentNode = e3;
    let h5 = C$3.nextNode(), o3 = 0, n5 = 0, l2 = s2[0];
    for (; void 0 !== l2; ) {
      if (o3 === l2.index) {
        let i5;
        2 === l2.type ? i5 = new R$2(h5, h5.nextSibling, this, t2) : 1 === l2.type ? i5 = new l2.ctor(h5, l2.name, l2.strings, this, t2) : 6 === l2.type && (i5 = new z$5(h5, this, t2)), this._$AV.push(i5), l2 = s2[++n5];
      }
      o3 !== (l2 == null ? void 0 : l2.index) && (h5 = C$3.nextNode(), o3++);
    }
    return C$3.currentNode = r$3, e3;
  }
  p(t2) {
    let i4 = 0;
    for (const s2 of this._$AV) void 0 !== s2 && (void 0 !== s2.strings ? (s2._$AI(t2, s2, i4), i4 += s2.strings.length - 2) : s2._$AI(t2[i4])), i4++;
  }
};
let R$2 = class R4 {
  get _$AU() {
    var _a3;
    return ((_a3 = this._$AM) == null ? void 0 : _a3._$AU) ?? this._$Cv;
  }
  constructor(t2, i4, s2, e3) {
    this.type = 2, this._$AH = E$2, this._$AN = void 0, this._$AA = t2, this._$AB = i4, this._$AM = s2, this.options = e3, this._$Cv = (e3 == null ? void 0 : e3.isConnected) ?? true;
  }
  get parentNode() {
    let t2 = this._$AA.parentNode;
    const i4 = this._$AM;
    return void 0 !== i4 && 11 === (t2 == null ? void 0 : t2.nodeType) && (t2 = i4.parentNode), t2;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t2, i4 = this) {
    t2 = S$2(this, t2, i4), c$2(t2) ? t2 === E$2 || null == t2 || "" === t2 ? (this._$AH !== E$2 && this._$AR(), this._$AH = E$2) : t2 !== this._$AH && t2 !== T$2 && this._(t2) : void 0 !== t2._$litType$ ? this.$(t2) : void 0 !== t2.nodeType ? this.T(t2) : u(t2) ? this.k(t2) : this._(t2);
  }
  O(t2) {
    return this._$AA.parentNode.insertBefore(t2, this._$AB);
  }
  T(t2) {
    this._$AH !== t2 && (this._$AR(), this._$AH = this.O(t2));
  }
  _(t2) {
    this._$AH !== E$2 && c$2(this._$AH) ? this._$AA.nextSibling.data = t2 : this.T(r$3.createTextNode(t2)), this._$AH = t2;
  }
  $(t2) {
    var _a3;
    const { values: i4, _$litType$: s2 } = t2, e3 = "number" == typeof s2 ? this._$AC(t2) : (void 0 === s2.el && (s2.el = N$2.createElement(P$1(s2.h, s2.h[0]), this.options)), s2);
    if (((_a3 = this._$AH) == null ? void 0 : _a3._$AD) === e3) this._$AH.p(i4);
    else {
      const t3 = new M$4(e3, this), s3 = t3.u(this.options);
      t3.p(i4), this.T(s3), this._$AH = t3;
    }
  }
  _$AC(t2) {
    let i4 = A$2.get(t2.strings);
    return void 0 === i4 && A$2.set(t2.strings, i4 = new N$2(t2)), i4;
  }
  k(t2) {
    a(this._$AH) || (this._$AH = [], this._$AR());
    const i4 = this._$AH;
    let s2, e3 = 0;
    for (const h5 of t2) e3 === i4.length ? i4.push(s2 = new R4(this.O(l()), this.O(l()), this, this.options)) : s2 = i4[e3], s2._$AI(h5), e3++;
    e3 < i4.length && (this._$AR(s2 && s2._$AB.nextSibling, e3), i4.length = e3);
  }
  _$AR(t2 = this._$AA.nextSibling, i4) {
    var _a3;
    for ((_a3 = this._$AP) == null ? void 0 : _a3.call(this, false, true, i4); t2 !== this._$AB; ) {
      const i5 = t2.nextSibling;
      t2.remove(), t2 = i5;
    }
  }
  setConnected(t2) {
    var _a3;
    void 0 === this._$AM && (this._$Cv = t2, (_a3 = this._$AP) == null ? void 0 : _a3.call(this, t2));
  }
};
let k$2 = class k2 {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t2, i4, s2, e3, h5) {
    this.type = 1, this._$AH = E$2, this._$AN = void 0, this.element = t2, this.name = i4, this._$AM = e3, this.options = h5, s2.length > 2 || "" !== s2[0] || "" !== s2[1] ? (this._$AH = Array(s2.length - 1).fill(new String()), this.strings = s2) : this._$AH = E$2;
  }
  _$AI(t2, i4 = this, s2, e3) {
    const h5 = this.strings;
    let o3 = false;
    if (void 0 === h5) t2 = S$2(this, t2, i4, 0), o3 = !c$2(t2) || t2 !== this._$AH && t2 !== T$2, o3 && (this._$AH = t2);
    else {
      const e4 = t2;
      let n5, r3;
      for (t2 = h5[0], n5 = 0; n5 < h5.length - 1; n5++) r3 = S$2(this, e4[s2 + n5], i4, n5), r3 === T$2 && (r3 = this._$AH[n5]), o3 || (o3 = !c$2(r3) || r3 !== this._$AH[n5]), r3 === E$2 ? t2 = E$2 : t2 !== E$2 && (t2 += (r3 ?? "") + h5[n5 + 1]), this._$AH[n5] = r3;
    }
    o3 && !e3 && this.j(t2);
  }
  j(t2) {
    t2 === E$2 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t2 ?? "");
  }
};
let H$3 = class H2 extends k$2 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t2) {
    this.element[this.name] = t2 === E$2 ? void 0 : t2;
  }
};
let I$2 = class I3 extends k$2 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t2) {
    this.element.toggleAttribute(this.name, !!t2 && t2 !== E$2);
  }
};
let L$2 = class L3 extends k$2 {
  constructor(t2, i4, s2, e3, h5) {
    super(t2, i4, s2, e3, h5), this.type = 5;
  }
  _$AI(t2, i4 = this) {
    if ((t2 = S$2(this, t2, i4, 0) ?? E$2) === T$2) return;
    const s2 = this._$AH, e3 = t2 === E$2 && s2 !== E$2 || t2.capture !== s2.capture || t2.once !== s2.once || t2.passive !== s2.passive, h5 = t2 !== E$2 && (s2 === E$2 || e3);
    e3 && this.element.removeEventListener(this.name, this, s2), h5 && this.element.addEventListener(this.name, this, t2), this._$AH = t2;
  }
  handleEvent(t2) {
    var _a3;
    "function" == typeof this._$AH ? this._$AH.call(((_a3 = this.options) == null ? void 0 : _a3.host) ?? this.element, t2) : this._$AH.handleEvent(t2);
  }
};
let z$5 = class z2 {
  constructor(t2, i4, s2) {
    this.element = t2, this.type = 6, this._$AN = void 0, this._$AM = i4, this.options = s2;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t2) {
    S$2(this, t2);
  }
};
const j$1 = t$1.litHtmlPolyfillSupport;
j$1 == null ? void 0 : j$1(N$2, R$2), (t$1.litHtmlVersions ?? (t$1.litHtmlVersions = [])).push("3.3.1");
const B$3 = (t2, i4, s2) => {
  const e3 = (s2 == null ? void 0 : s2.renderBefore) ?? i4;
  let h5 = e3._$litPart$;
  if (void 0 === h5) {
    const t3 = (s2 == null ? void 0 : s2.renderBefore) ?? null;
    e3._$litPart$ = h5 = new R$2(i4.insertBefore(l(), t3), t3, void 0, s2 ?? {});
  }
  return h5._$AI(t2), h5;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const s$1 = globalThis;
let i$1 = class i3 extends y$2 {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var _a3;
    const t2 = super.createRenderRoot();
    return (_a3 = this.renderOptions).renderBefore ?? (_a3.renderBefore = t2.firstChild), t2;
  }
  update(t2) {
    const r3 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t2), this._$Do = B$3(r3, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var _a3;
    super.connectedCallback(), (_a3 = this._$Do) == null ? void 0 : _a3.setConnected(true);
  }
  disconnectedCallback() {
    var _a3;
    super.disconnectedCallback(), (_a3 = this._$Do) == null ? void 0 : _a3.setConnected(false);
  }
  render() {
    return T$2;
  }
};
i$1._$litElement$ = true, i$1["finalized"] = true, (_b = s$1.litElementHydrateSupport) == null ? void 0 : _b.call(s$1, { LitElement: i$1 });
const o$4 = s$1.litElementPolyfillSupport;
o$4 == null ? void 0 : o$4({ LitElement: i$1 });
(s$1.litElementVersions ?? (s$1.litElementVersions = [])).push("4.2.1");
const swapInputMaskBottomSvg = b$2`<svg class="input_mask" width="328" height="100" viewBox="0 0 328 100" fill="none">
  <mask id="path-1-inside-1_18299_4189">
    <path
      class="input_mask__border"
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M138.008 0H40C21.1438 0 11.7157 0 5.85786 5.85786C0 11.7157 0 21.1438 0 40V60C0 78.8562 0 88.2843 5.85786 94.1421C11.7157 100 21.1438 100 40 100H288C306.856 100 316.284 100 322.142 94.1421C328 88.2843 328 78.8562 328 60V40C328 21.1438 328 11.7157 322.142 5.85786C316.284 0 306.856 0 288 0H189.992C189.958 4.89122 189.786 7.76279 188.914 10.1564C187.095 15.1562 183.156 19.0947 178.156 20.9145C175.174 22 171.449 22 164 22C156.551 22 152.826 22 149.844 20.9145C144.844 19.0947 140.905 15.1562 139.086 10.1564C138.214 7.76279 138.042 4.89122 138.008 0Z"
    />
  </mask>
  <path
    class="input_mask__background"
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M138.008 0H40C21.1438 0 11.7157 0 5.85786 5.85786C0 11.7157 0 21.1438 0 40V60C0 78.8562 0 88.2843 5.85786 94.1421C11.7157 100 21.1438 100 40 100H288C306.856 100 316.284 100 322.142 94.1421C328 88.2843 328 78.8562 328 60V40C328 21.1438 328 11.7157 322.142 5.85786C316.284 0 306.856 0 288 0H189.992C189.958 4.89122 189.786 7.76279 188.914 10.1564C187.095 15.1562 183.156 19.0947 178.156 20.9145C175.174 22 171.449 22 164 22C156.551 22 152.826 22 149.844 20.9145C144.844 19.0947 140.905 15.1562 139.086 10.1564C138.214 7.76279 138.042 4.89122 138.008 0Z"
  />
  <path
    class="input_mask__border"
    d="M138.008 0L139.008 -0.00694413L139.001 -1H138.008V0ZM322.142 94.1421L322.849 94.8492H322.849L322.142 94.1421ZM322.142 5.85786L322.849 5.15076L322.849 5.15076L322.142 5.85786ZM189.992 0V-1H188.999L188.992 -0.00694413L189.992 0ZM188.914 10.1564L189.854 10.4984V10.4984L188.914 10.1564ZM178.156 20.9145L177.814 19.9748V19.9748L178.156 20.9145ZM149.844 20.9145L150.186 19.9748V19.9748L149.844 20.9145ZM139.086 10.1564L138.146 10.4984V10.4984L139.086 10.1564ZM40 1H138.008V-1H40V1ZM6.56497 6.56497C9.27713 3.85281 12.8524 2.44064 18.1878 1.72332C23.552 1.00212 30.5436 1 40 1V-1C30.6002 -1 23.4497 -1.00212 17.9213 -0.25885C12.3641 0.488292 8.29646 2.00506 5.15076 5.15076L6.56497 6.56497ZM1 40C1 30.5436 1.00212 23.552 1.72332 18.1878C2.44064 12.8524 3.85281 9.27713 6.56497 6.56497L5.15076 5.15076C2.00506 8.29646 0.488292 12.3641 -0.25885 17.9213C-1.00212 23.4497 -1 30.6002 -1 40H1ZM1 60V40H-1V60H1ZM6.56497 93.435C3.85281 90.7229 2.44064 87.1476 1.72332 81.8122C1.00212 76.448 1 69.4564 1 60H-1C-1 69.3998 -1.00212 76.5503 -0.25885 82.0787C0.488292 87.6358 2.00506 91.7035 5.15076 94.8492L6.56497 93.435ZM40 99C30.5436 99 23.552 98.9979 18.1878 98.2767C12.8524 97.5594 9.27713 96.1472 6.56497 93.435L5.15076 94.8492C8.29646 97.9949 12.3641 99.5117 17.9213 100.259C23.4497 101.002 30.6002 101 40 101V99ZM288 99H40V101H288V99ZM321.435 93.435C318.723 96.1472 315.148 97.5594 309.812 98.2767C304.448 98.9979 297.456 99 288 99V101C297.4 101 304.55 101.002 310.079 100.259C315.636 99.5117 319.704 97.9949 322.849 94.8492L321.435 93.435ZM327 60C327 69.4564 326.998 76.448 326.277 81.8122C325.559 87.1476 324.147 90.7229 321.435 93.435L322.849 94.8492C325.995 91.7035 327.512 87.6358 328.259 82.0787C329.002 76.5503 329 69.3998 329 60H327ZM327 40V60H329V40H327ZM321.435 6.56497C324.147 9.27713 325.559 12.8524 326.277 18.1878C326.998 23.552 327 30.5436 327 40H329C329 30.6002 329.002 23.4497 328.259 17.9213C327.512 12.3642 325.995 8.29646 322.849 5.15076L321.435 6.56497ZM288 1C297.456 1 304.448 1.00212 309.812 1.72332C315.148 2.44064 318.723 3.85281 321.435 6.56497L322.849 5.15076C319.704 2.00506 315.636 0.488292 310.079 -0.25885C304.55 -1.00212 297.4 -1 288 -1V1ZM189.992 1H288V-1H189.992V1ZM188.992 -0.00694413C188.958 4.90792 188.778 7.60788 187.975 9.81434L189.854 10.4984C190.793 7.9177 190.958 4.87452 190.992 0.00694413L188.992 -0.00694413ZM187.975 9.81434C186.256 14.5364 182.536 18.2561 177.814 19.9748L178.498 21.8542C183.776 19.9333 187.933 15.7759 189.854 10.4984L187.975 9.81434ZM177.814 19.9748C175.039 20.9848 171.536 21 164 21V23C171.362 23 175.308 23.0152 178.498 21.8542L177.814 19.9748ZM164 21C156.464 21 152.961 20.9848 150.186 19.9748L149.502 21.8542C152.692 23.0152 156.638 23 164 23V21ZM150.186 19.9748C145.464 18.2561 141.744 14.5364 140.025 9.81434L138.146 10.4984C140.067 15.7759 144.224 19.9333 149.502 21.8542L150.186 19.9748ZM140.025 9.81434C139.222 7.60788 139.042 4.90792 139.008 -0.00694413L137.008 0.00694413C137.042 4.87452 137.207 7.9177 138.146 10.4984L140.025 9.81434Z"
    mask="url(#path-1-inside-1_18299_4189)"
  />
</svg>`;
const swapInputMaskTopSvg = b$2`<svg class="input_mask" width="328" height="100" viewBox="0 0 328 100" fill="none">
  <mask id="path-1-inside-1_18299_4168">
    <path
      class="input_mask__border"
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M5.85786 5.85786C0 11.7157 0 21.1438 0 40V60C0 78.8562 0 88.2843 5.85786 94.1421C11.7157 100 21.1438 100 40 100H138.008C138.042 95.1088 138.214 92.2372 139.086 89.8436C140.905 84.8438 144.844 80.9053 149.844 79.0855C152.826 78 156.551 78 164 78C171.449 78 175.174 78 178.156 79.0855C183.156 80.9053 187.095 84.8438 188.914 89.8436C189.786 92.2372 189.958 95.1088 189.992 100H288C306.856 100 316.284 100 322.142 94.1421C328 88.2843 328 78.8562 328 60V40C328 21.1438 328 11.7157 322.142 5.85786C316.284 0 306.856 0 288 0H40C21.1438 0 11.7157 0 5.85786 5.85786Z"
    />
  </mask>
  <path
    class="input_mask__background"
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M5.85786 5.85786C0 11.7157 0 21.1438 0 40V60C0 78.8562 0 88.2843 5.85786 94.1421C11.7157 100 21.1438 100 40 100H138.008C138.042 95.1088 138.214 92.2372 139.086 89.8436C140.905 84.8438 144.844 80.9053 149.844 79.0855C152.826 78 156.551 78 164 78C171.449 78 175.174 78 178.156 79.0855C183.156 80.9053 187.095 84.8438 188.914 89.8436C189.786 92.2372 189.958 95.1088 189.992 100H288C306.856 100 316.284 100 322.142 94.1421C328 88.2843 328 78.8562 328 60V40C328 21.1438 328 11.7157 322.142 5.85786C316.284 0 306.856 0 288 0H40C21.1438 0 11.7157 0 5.85786 5.85786Z"
  />
  <path
    class="input_mask__border"
    d="M138.008 100V101H139.001L139.008 100.007L138.008 100ZM139.086 89.8436L138.146 89.5016L139.086 89.8436ZM149.844 79.0855L150.186 80.0252L149.844 79.0855ZM178.156 79.0855L177.814 80.0252L178.156 79.0855ZM188.914 89.8436L189.854 89.5016L188.914 89.8436ZM189.992 100L188.992 100.007L188.999 101H189.992V100ZM322.142 94.1421L322.849 94.8492H322.849L322.142 94.1421ZM322.142 5.85786L322.849 5.15076L322.849 5.15076L322.142 5.85786ZM1 40C1 30.5436 1.00212 23.552 1.72332 18.1878C2.44064 12.8524 3.85281 9.27713 6.56497 6.56497L5.15076 5.15076C2.00506 8.29646 0.488292 12.3641 -0.25885 17.9213C-1.00212 23.4497 -1 30.6002 -1 40H1ZM1 60V40H-1V60H1ZM6.56497 93.435C3.85281 90.7229 2.44064 87.1476 1.72332 81.8122C1.00212 76.448 1 69.4564 1 60H-1C-1 69.3998 -1.00212 76.5503 -0.25885 82.0787C0.488292 87.6358 2.00506 91.7035 5.15076 94.8492L6.56497 93.435ZM40 99C30.5436 99 23.552 98.9979 18.1878 98.2767C12.8524 97.5594 9.27713 96.1472 6.56497 93.435L5.15076 94.8492C8.29646 97.9949 12.3641 99.5117 17.9213 100.259C23.4497 101.002 30.6002 101 40 101V99ZM138.008 99H40V101H138.008V99ZM139.008 100.007C139.042 95.0921 139.222 92.3921 140.025 90.1857L138.146 89.5016C137.207 92.0823 137.042 95.1255 137.008 99.9931L139.008 100.007ZM140.025 90.1857C141.744 85.4636 145.464 81.7439 150.186 80.0252L149.502 78.1458C144.224 80.0667 140.067 84.2241 138.146 89.5016L140.025 90.1857ZM150.186 80.0252C152.961 79.0152 156.464 79 164 79V77C156.638 77 152.692 76.9848 149.502 78.1458L150.186 80.0252ZM164 79C171.536 79 175.039 79.0152 177.814 80.0252L178.498 78.1458C175.308 76.9848 171.362 77 164 77V79ZM177.814 80.0252C182.536 81.7439 186.256 85.4636 187.975 90.1857L189.854 89.5016C187.933 84.2241 183.776 80.0667 178.498 78.1458L177.814 80.0252ZM187.975 90.1857C188.778 92.3921 188.958 95.0921 188.992 100.007L190.992 99.9931C190.958 95.1255 190.793 92.0823 189.854 89.5016L187.975 90.1857ZM288 99H189.992V101H288V99ZM321.435 93.435C318.723 96.1472 315.148 97.5594 309.812 98.2767C304.448 98.9979 297.456 99 288 99V101C297.4 101 304.55 101.002 310.079 100.259C315.636 99.5117 319.704 97.9949 322.849 94.8492L321.435 93.435ZM327 60C327 69.4564 326.998 76.448 326.277 81.8122C325.559 87.1476 324.147 90.7229 321.435 93.435L322.849 94.8492C325.995 91.7035 327.512 87.6358 328.259 82.0787C329.002 76.5503 329 69.3998 329 60H327ZM327 40V60H329V40H327ZM321.435 6.56497C324.147 9.27713 325.559 12.8524 326.277 18.1878C326.998 23.552 327 30.5436 327 40H329C329 30.6002 329.002 23.4497 328.259 17.9213C327.512 12.3642 325.995 8.29646 322.849 5.15076L321.435 6.56497ZM288 1C297.456 1 304.448 1.00212 309.812 1.72332C315.148 2.44064 318.723 3.85281 321.435 6.56497L322.849 5.15076C319.704 2.00506 315.636 0.488292 310.079 -0.25885C304.55 -1.00212 297.4 -1 288 -1V1ZM40 1H288V-1H40V1ZM6.56497 6.56497C9.27713 3.85281 12.8524 2.44064 18.1878 1.72332C23.552 1.00212 30.5436 1 40 1V-1C30.6002 -1 23.4497 -1.00212 17.9213 -0.25885C12.3641 0.488292 8.29646 2.00506 5.15076 5.15076L6.56497 6.56497Z"
    mask="url(#path-1-inside-1_18299_4168)"
  />
</svg>`;
let themeTag = void 0;
let darkModeTag = void 0;
let lightModeTag = void 0;
function initializeTheming(themeVariables, themeMode) {
  themeTag = document.createElement("style");
  darkModeTag = document.createElement("style");
  lightModeTag = document.createElement("style");
  themeTag.textContent = createRootStyles(themeVariables).core.cssText;
  darkModeTag.textContent = createRootStyles(themeVariables).dark.cssText;
  lightModeTag.textContent = createRootStyles(themeVariables).light.cssText;
  document.head.appendChild(themeTag);
  document.head.appendChild(darkModeTag);
  document.head.appendChild(lightModeTag);
  setColorTheme(themeMode);
}
function setColorTheme(themeMode) {
  if (darkModeTag && lightModeTag) {
    if (themeMode === "light") {
      darkModeTag.removeAttribute("media");
      lightModeTag.media = "enabled";
    } else {
      lightModeTag.removeAttribute("media");
      darkModeTag.media = "enabled";
    }
  }
}
function setThemeVariables(themeVariables) {
  if (themeTag && darkModeTag && lightModeTag) {
    themeTag.textContent = createRootStyles(themeVariables).core.cssText;
    darkModeTag.textContent = createRootStyles(themeVariables).dark.cssText;
    lightModeTag.textContent = createRootStyles(themeVariables).light.cssText;
  }
}
function createRootStyles(themeVariables) {
  return {
    core: i$4`
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
      @keyframes w3m-shake {
        0% {
          transform: scale(1) rotate(0deg);
        }
        20% {
          transform: scale(1) rotate(-1deg);
        }
        40% {
          transform: scale(1) rotate(1.5deg);
        }
        60% {
          transform: scale(1) rotate(-1.5deg);
        }
        80% {
          transform: scale(1) rotate(1deg);
        }
        100% {
          transform: scale(1) rotate(0deg);
        }
      }
      @keyframes w3m-iframe-fade-out {
        0% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }
      @keyframes w3m-iframe-zoom-in {
        0% {
          transform: translateY(50px);
          opacity: 0;
        }
        100% {
          transform: translateY(0px);
          opacity: 1;
        }
      }
      @keyframes w3m-iframe-zoom-in-mobile {
        0% {
          transform: scale(0.95);
          opacity: 0;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      :root {
        --w3m-modal-width: 360px;
        --w3m-color-mix-strength: ${r$5((themeVariables == null ? void 0 : themeVariables["--w3m-color-mix-strength"]) ? `${themeVariables["--w3m-color-mix-strength"]}%` : "0%")};
        --w3m-font-family: ${r$5((themeVariables == null ? void 0 : themeVariables["--w3m-font-family"]) || "Inter, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;")};
        --w3m-font-size-master: ${r$5((themeVariables == null ? void 0 : themeVariables["--w3m-font-size-master"]) || "10px")};
        --w3m-border-radius-master: ${r$5((themeVariables == null ? void 0 : themeVariables["--w3m-border-radius-master"]) || "4px")};
        --w3m-z-index: ${r$5((themeVariables == null ? void 0 : themeVariables["--w3m-z-index"]) || 999)};

        --wui-font-family: var(--w3m-font-family);

        --wui-font-size-mini: calc(var(--w3m-font-size-master) * 0.8);
        --wui-font-size-micro: var(--w3m-font-size-master);
        --wui-font-size-tiny: calc(var(--w3m-font-size-master) * 1.2);
        --wui-font-size-small: calc(var(--w3m-font-size-master) * 1.4);
        --wui-font-size-paragraph: calc(var(--w3m-font-size-master) * 1.6);
        --wui-font-size-medium: calc(var(--w3m-font-size-master) * 1.8);
        --wui-font-size-large: calc(var(--w3m-font-size-master) * 2);
        --wui-font-size-title-6: calc(var(--w3m-font-size-master) * 2.2);
        --wui-font-size-medium-title: calc(var(--w3m-font-size-master) * 2.4);
        --wui-font-size-2xl: calc(var(--w3m-font-size-master) * 4);

        --wui-border-radius-5xs: var(--w3m-border-radius-master);
        --wui-border-radius-4xs: calc(var(--w3m-border-radius-master) * 1.5);
        --wui-border-radius-3xs: calc(var(--w3m-border-radius-master) * 2);
        --wui-border-radius-xxs: calc(var(--w3m-border-radius-master) * 3);
        --wui-border-radius-xs: calc(var(--w3m-border-radius-master) * 4);
        --wui-border-radius-s: calc(var(--w3m-border-radius-master) * 5);
        --wui-border-radius-m: calc(var(--w3m-border-radius-master) * 7);
        --wui-border-radius-l: calc(var(--w3m-border-radius-master) * 9);
        --wui-border-radius-3xl: calc(var(--w3m-border-radius-master) * 20);

        --wui-font-weight-light: 400;
        --wui-font-weight-regular: 500;
        --wui-font-weight-medium: 600;
        --wui-font-weight-bold: 700;

        --wui-letter-spacing-2xl: -1.6px;
        --wui-letter-spacing-medium-title: -0.96px;
        --wui-letter-spacing-title-6: -0.88px;
        --wui-letter-spacing-large: -0.8px;
        --wui-letter-spacing-medium: -0.72px;
        --wui-letter-spacing-paragraph: -0.64px;
        --wui-letter-spacing-small: -0.56px;
        --wui-letter-spacing-tiny: -0.48px;
        --wui-letter-spacing-micro: -0.2px;
        --wui-letter-spacing-mini: -0.16px;

        --wui-spacing-0: 0px;
        --wui-spacing-4xs: 2px;
        --wui-spacing-3xs: 4px;
        --wui-spacing-xxs: 6px;
        --wui-spacing-2xs: 7px;
        --wui-spacing-xs: 8px;
        --wui-spacing-1xs: 10px;
        --wui-spacing-s: 12px;
        --wui-spacing-m: 14px;
        --wui-spacing-l: 16px;
        --wui-spacing-2l: 18px;
        --wui-spacing-xl: 20px;
        --wui-spacing-xxl: 24px;
        --wui-spacing-2xl: 32px;
        --wui-spacing-3xl: 40px;
        --wui-spacing-4xl: 90px;
        --wui-spacing-5xl: 95px;

        --wui-icon-box-size-xxs: 14px;
        --wui-icon-box-size-xs: 20px;
        --wui-icon-box-size-sm: 24px;
        --wui-icon-box-size-md: 32px;
        --wui-icon-box-size-mdl: 36px;
        --wui-icon-box-size-lg: 40px;
        --wui-icon-box-size-2lg: 48px;
        --wui-icon-box-size-xl: 64px;

        --wui-icon-size-inherit: inherit;
        --wui-icon-size-xxs: 10px;
        --wui-icon-size-xs: 12px;
        --wui-icon-size-sm: 14px;
        --wui-icon-size-md: 16px;
        --wui-icon-size-mdl: 18px;
        --wui-icon-size-lg: 20px;
        --wui-icon-size-xl: 24px;
        --wui-icon-size-xxl: 28px;

        --wui-wallet-image-size-inherit: inherit;
        --wui-wallet-image-size-sm: 40px;
        --wui-wallet-image-size-md: 56px;
        --wui-wallet-image-size-lg: 80px;

        --wui-visual-size-size-inherit: inherit;
        --wui-visual-size-sm: 40px;
        --wui-visual-size-md: 55px;
        --wui-visual-size-lg: 80px;

        --wui-box-size-md: 100px;
        --wui-box-size-lg: 120px;

        --wui-ease-out-power-2: cubic-bezier(0, 0, 0.22, 1);
        --wui-ease-out-power-1: cubic-bezier(0, 0, 0.55, 1);

        --wui-ease-in-power-3: cubic-bezier(0.66, 0, 1, 1);
        --wui-ease-in-power-2: cubic-bezier(0.45, 0, 1, 1);
        --wui-ease-in-power-1: cubic-bezier(0.3, 0, 1, 1);

        --wui-ease-inout-power-1: cubic-bezier(0.45, 0, 0.55, 1);

        --wui-duration-lg: 200ms;
        --wui-duration-md: 125ms;
        --wui-duration-sm: 75ms;

        --wui-path-network-sm: path(
          'M15.4 2.1a5.21 5.21 0 0 1 5.2 0l11.61 6.7a5.21 5.21 0 0 1 2.61 4.52v13.4c0 1.87-1 3.59-2.6 4.52l-11.61 6.7c-1.62.93-3.6.93-5.22 0l-11.6-6.7a5.21 5.21 0 0 1-2.61-4.51v-13.4c0-1.87 1-3.6 2.6-4.52L15.4 2.1Z'
        );

        --wui-path-network-md: path(
          'M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z'
        );

        --wui-path-network-lg: path(
          'M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z'
        );

        --wui-width-network-sm: 36px;
        --wui-width-network-md: 48px;
        --wui-width-network-lg: 86px;

        --wui-height-network-sm: 40px;
        --wui-height-network-md: 54px;
        --wui-height-network-lg: 96px;

        --wui-icon-size-network-xs: 12px;
        --wui-icon-size-network-sm: 16px;
        --wui-icon-size-network-md: 24px;
        --wui-icon-size-network-lg: 42px;

        --wui-color-inherit: inherit;

        --wui-color-inverse-100: #fff;
        --wui-color-inverse-000: #000;

        --wui-cover: rgba(20, 20, 20, 0.8);

        --wui-color-modal-bg: var(--wui-color-modal-bg-base);

        --wui-color-accent-100: var(--wui-color-accent-base-100);
        --wui-color-accent-090: var(--wui-color-accent-base-090);
        --wui-color-accent-080: var(--wui-color-accent-base-080);

        --wui-color-success-100: var(--wui-color-success-base-100);
        --wui-color-success-125: var(--wui-color-success-base-125);

        --wui-color-warning-100: var(--wui-color-warning-base-100);

        --wui-color-error-100: var(--wui-color-error-base-100);
        --wui-color-error-125: var(--wui-color-error-base-125);

        --wui-color-blue-100: var(--wui-color-blue-base-100);
        --wui-color-blue-90: var(--wui-color-blue-base-90);

        --wui-icon-box-bg-error-100: var(--wui-icon-box-bg-error-base-100);
        --wui-icon-box-bg-blue-100: var(--wui-icon-box-bg-blue-base-100);
        --wui-icon-box-bg-success-100: var(--wui-icon-box-bg-success-base-100);
        --wui-icon-box-bg-inverse-100: var(--wui-icon-box-bg-inverse-base-100);

        --wui-all-wallets-bg-100: var(--wui-all-wallets-bg-100);

        --wui-avatar-border: var(--wui-avatar-border-base);

        --wui-thumbnail-border: var(--wui-thumbnail-border-base);

        --wui-wallet-button-bg: var(--wui-wallet-button-bg-base);

        --wui-box-shadow-blue: var(--wui-color-accent-glass-020);
      }

      @supports (background: color-mix(in srgb, white 50%, black)) {
        :root {
          --wui-color-modal-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-modal-bg-base)
          );

          --wui-box-shadow-blue: color-mix(in srgb, var(--wui-color-accent-100) 20%, transparent);

          --wui-color-accent-100: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 100%,
            transparent
          );
          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-glass-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-020: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 20%,
            transparent
          );
          --wui-color-accent-glass-015: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 15%,
            transparent
          );
          --wui-color-accent-glass-010: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 10%,
            transparent
          );
          --wui-color-accent-glass-005: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 5%,
            transparent
          );
          --wui-color-accent-002: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 2%,
            transparent
          );

          --wui-color-fg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-100)
          );
          --wui-color-fg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-125)
          );
          --wui-color-fg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-150)
          );
          --wui-color-fg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-175)
          );
          --wui-color-fg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-200)
          );
          --wui-color-fg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-225)
          );
          --wui-color-fg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-250)
          );
          --wui-color-fg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-275)
          );
          --wui-color-fg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-300)
          );
          --wui-color-fg-325: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-325)
          );
          --wui-color-fg-350: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-350)
          );

          --wui-color-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-100)
          );
          --wui-color-bg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-125)
          );
          --wui-color-bg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-150)
          );
          --wui-color-bg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-175)
          );
          --wui-color-bg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-200)
          );
          --wui-color-bg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-225)
          );
          --wui-color-bg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-250)
          );
          --wui-color-bg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-275)
          );
          --wui-color-bg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-300)
          );
          --wui-color-bg-325: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-325)
          );
          --wui-color-bg-350: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-350)
          );

          --wui-color-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-100)
          );
          --wui-color-success-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-125)
          );

          --wui-color-warning-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-warning-base-100)
          );

          --wui-color-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-100)
          );
          --wui-color-blue-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-blue-base-100)
          );
          --wui-color-blue-90: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-blue-base-90)
          );
          --wui-color-error-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-125)
          );

          --wui-icon-box-bg-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-error-base-100)
          );
          --wui-icon-box-bg-accent-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-blue-base-100)
          );
          --wui-icon-box-bg-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-success-base-100)
          );
          --wui-icon-box-bg-inverse-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-inverse-base-100)
          );

          --wui-all-wallets-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-all-wallets-bg-100)
          );

          --wui-avatar-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-avatar-border-base)
          );

          --wui-thumbnail-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-thumbnail-border-base)
          );

          --wui-wallet-button-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-wallet-button-bg-base)
          );
        }
      }
    `,
    light: i$4`
      :root {
        --w3m-color-mix: ${r$5((themeVariables == null ? void 0 : themeVariables["--w3m-color-mix"]) || "#fff")};
        --w3m-accent: ${r$5(getW3mThemeVariables(themeVariables, "dark")["--w3m-accent"])};
        --w3m-default: #fff;

        --wui-color-modal-bg-base: ${r$5(getW3mThemeVariables(themeVariables, "dark")["--w3m-background"])};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(230, 100%, 67%, 1);
        --wui-color-blueberry-090: hsla(231, 76%, 61%, 1);
        --wui-color-blueberry-080: hsla(230, 59%, 55%, 1);
        --wui-color-blueberry-050: hsla(231, 100%, 70%, 0.1);

        --wui-color-fg-100: #e4e7e7;
        --wui-color-fg-125: #d0d5d5;
        --wui-color-fg-150: #a8b1b1;
        --wui-color-fg-175: #a8b0b0;
        --wui-color-fg-200: #949e9e;
        --wui-color-fg-225: #868f8f;
        --wui-color-fg-250: #788080;
        --wui-color-fg-275: #788181;
        --wui-color-fg-300: #6e7777;
        --wui-color-fg-325: #9a9a9a;
        --wui-color-fg-350: #363636;

        --wui-color-bg-100: #141414;
        --wui-color-bg-125: #191a1a;
        --wui-color-bg-150: #1e1f1f;
        --wui-color-bg-175: #222525;
        --wui-color-bg-200: #272a2a;
        --wui-color-bg-225: #2c3030;
        --wui-color-bg-250: #313535;
        --wui-color-bg-275: #363b3b;
        --wui-color-bg-300: #3b4040;
        --wui-color-bg-325: #252525;
        --wui-color-bg-350: #ffffff;

        --wui-color-success-base-100: #26d962;
        --wui-color-success-base-125: #30a46b;

        --wui-color-warning-base-100: #f3a13f;

        --wui-color-error-base-100: #f25a67;
        --wui-color-error-base-125: #df4a34;

        --wui-color-blue-base-100: rgba(102, 125, 255, 1);
        --wui-color-blue-base-90: rgba(102, 125, 255, 0.9);

        --wui-color-success-glass-001: rgba(38, 217, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 217, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 217, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 217, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 217, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 217, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 217, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 217, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 217, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 217, 98, 0.8);

        --wui-color-success-glass-reown-020: rgba(48, 164, 107, 0.2);

        --wui-color-warning-glass-reown-020: rgba(243, 161, 63, 0.2);

        --wui-color-error-glass-001: rgba(242, 90, 103, 0.01);
        --wui-color-error-glass-002: rgba(242, 90, 103, 0.02);
        --wui-color-error-glass-005: rgba(242, 90, 103, 0.05);
        --wui-color-error-glass-010: rgba(242, 90, 103, 0.1);
        --wui-color-error-glass-015: rgba(242, 90, 103, 0.15);
        --wui-color-error-glass-020: rgba(242, 90, 103, 0.2);
        --wui-color-error-glass-025: rgba(242, 90, 103, 0.25);
        --wui-color-error-glass-030: rgba(242, 90, 103, 0.3);
        --wui-color-error-glass-060: rgba(242, 90, 103, 0.6);
        --wui-color-error-glass-080: rgba(242, 90, 103, 0.8);

        --wui-color-error-glass-reown-020: rgba(223, 74, 52, 0.2);

        --wui-color-gray-glass-001: rgba(255, 255, 255, 0.01);
        --wui-color-gray-glass-002: rgba(255, 255, 255, 0.02);
        --wui-color-gray-glass-005: rgba(255, 255, 255, 0.05);
        --wui-color-gray-glass-010: rgba(255, 255, 255, 0.1);
        --wui-color-gray-glass-015: rgba(255, 255, 255, 0.15);
        --wui-color-gray-glass-020: rgba(255, 255, 255, 0.2);
        --wui-color-gray-glass-025: rgba(255, 255, 255, 0.25);
        --wui-color-gray-glass-030: rgba(255, 255, 255, 0.3);
        --wui-color-gray-glass-060: rgba(255, 255, 255, 0.6);
        --wui-color-gray-glass-080: rgba(255, 255, 255, 0.8);
        --wui-color-gray-glass-090: rgba(255, 255, 255, 0.9);

        --wui-color-dark-glass-100: rgba(42, 42, 42, 1);

        --wui-icon-box-bg-error-base-100: #3c2426;
        --wui-icon-box-bg-blue-base-100: #20303f;
        --wui-icon-box-bg-success-base-100: #1f3a28;
        --wui-icon-box-bg-inverse-base-100: #243240;

        --wui-all-wallets-bg-100: #222b35;

        --wui-avatar-border-base: #252525;

        --wui-thumbnail-border-base: #252525;

        --wui-wallet-button-bg-base: var(--wui-color-bg-125);

        --w3m-card-embedded-shadow-color: rgb(17 17 18 / 25%);
      }
    `,
    dark: i$4`
      :root {
        --w3m-color-mix: ${r$5((themeVariables == null ? void 0 : themeVariables["--w3m-color-mix"]) || "#000")};
        --w3m-accent: ${r$5(getW3mThemeVariables(themeVariables, "light")["--w3m-accent"])};
        --w3m-default: #000;

        --wui-color-modal-bg-base: ${r$5(getW3mThemeVariables(themeVariables, "light")["--w3m-background"])};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(231, 100%, 70%, 1);
        --wui-color-blueberry-090: hsla(231, 97%, 72%, 1);
        --wui-color-blueberry-080: hsla(231, 92%, 74%, 1);

        --wui-color-fg-100: #141414;
        --wui-color-fg-125: #2d3131;
        --wui-color-fg-150: #474d4d;
        --wui-color-fg-175: #636d6d;
        --wui-color-fg-200: #798686;
        --wui-color-fg-225: #828f8f;
        --wui-color-fg-250: #8b9797;
        --wui-color-fg-275: #95a0a0;
        --wui-color-fg-300: #9ea9a9;
        --wui-color-fg-325: #9a9a9a;
        --wui-color-fg-350: #d0d0d0;

        --wui-color-bg-100: #ffffff;
        --wui-color-bg-125: #f5fafa;
        --wui-color-bg-150: #f3f8f8;
        --wui-color-bg-175: #eef4f4;
        --wui-color-bg-200: #eaf1f1;
        --wui-color-bg-225: #e5eded;
        --wui-color-bg-250: #e1e9e9;
        --wui-color-bg-275: #dce7e7;
        --wui-color-bg-300: #d8e3e3;
        --wui-color-bg-325: #f3f3f3;
        --wui-color-bg-350: #202020;

        --wui-color-success-base-100: #26b562;
        --wui-color-success-base-125: #30a46b;

        --wui-color-warning-base-100: #f3a13f;

        --wui-color-error-base-100: #f05142;
        --wui-color-error-base-125: #df4a34;

        --wui-color-blue-base-100: rgba(102, 125, 255, 1);
        --wui-color-blue-base-90: rgba(102, 125, 255, 0.9);

        --wui-color-success-glass-001: rgba(38, 181, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 181, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 181, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 181, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 181, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 181, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 181, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 181, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 181, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 181, 98, 0.8);

        --wui-color-success-glass-reown-020: rgba(48, 164, 107, 0.2);

        --wui-color-warning-glass-reown-020: rgba(243, 161, 63, 0.2);

        --wui-color-error-glass-001: rgba(240, 81, 66, 0.01);
        --wui-color-error-glass-002: rgba(240, 81, 66, 0.02);
        --wui-color-error-glass-005: rgba(240, 81, 66, 0.05);
        --wui-color-error-glass-010: rgba(240, 81, 66, 0.1);
        --wui-color-error-glass-015: rgba(240, 81, 66, 0.15);
        --wui-color-error-glass-020: rgba(240, 81, 66, 0.2);
        --wui-color-error-glass-025: rgba(240, 81, 66, 0.25);
        --wui-color-error-glass-030: rgba(240, 81, 66, 0.3);
        --wui-color-error-glass-060: rgba(240, 81, 66, 0.6);
        --wui-color-error-glass-080: rgba(240, 81, 66, 0.8);

        --wui-color-error-glass-reown-020: rgba(223, 74, 52, 0.2);

        --wui-icon-box-bg-error-base-100: #f4dfdd;
        --wui-icon-box-bg-blue-base-100: #d9ecfb;
        --wui-icon-box-bg-success-base-100: #daf0e4;
        --wui-icon-box-bg-inverse-base-100: #dcecfc;

        --wui-all-wallets-bg-100: #e8f1fa;

        --wui-avatar-border-base: #f3f4f4;

        --wui-thumbnail-border-base: #eaefef;

        --wui-wallet-button-bg-base: var(--wui-color-bg-125);

        --wui-color-gray-glass-001: rgba(0, 0, 0, 0.01);
        --wui-color-gray-glass-002: rgba(0, 0, 0, 0.02);
        --wui-color-gray-glass-005: rgba(0, 0, 0, 0.05);
        --wui-color-gray-glass-010: rgba(0, 0, 0, 0.1);
        --wui-color-gray-glass-015: rgba(0, 0, 0, 0.15);
        --wui-color-gray-glass-020: rgba(0, 0, 0, 0.2);
        --wui-color-gray-glass-025: rgba(0, 0, 0, 0.25);
        --wui-color-gray-glass-030: rgba(0, 0, 0, 0.3);
        --wui-color-gray-glass-060: rgba(0, 0, 0, 0.6);
        --wui-color-gray-glass-080: rgba(0, 0, 0, 0.8);
        --wui-color-gray-glass-090: rgba(0, 0, 0, 0.9);

        --wui-color-dark-glass-100: rgba(233, 233, 233, 1);

        --w3m-card-embedded-shadow-color: rgb(224 225 233 / 25%);
      }
    `
  };
}
const resetStyles = i$4`
  *,
  *::after,
  *::before,
  :host {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-style: normal;
    text-rendering: optimizeSpeed;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    font-family: var(--wui-font-family);
    backface-visibility: hidden;
  }
`;
const elementStyles = i$4`
  button,
  a {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    transition:
      color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      background-color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1),
      box-shadow var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: background-color, color, border, box-shadow, border-radius;
    outline: none;
    border: none;
    column-gap: var(--wui-spacing-3xs);
    background-color: transparent;
    text-decoration: none;
  }

  cross-wui-flex {
    transition: border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: border-radius;
  }

  button:disabled > cross-wui-wallet-image,
  button:disabled > cross-wui-all-wallets-image,
  button:disabled > cross-wui-network-image,
  button:disabled > cross-wui-image,
  button:disabled > cross-wui-transaction-visual,
  button:disabled > cross-wui-logo {
    filter: grayscale(1);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-gray-glass-005);
    }

    button:active:enabled {
      background-color: var(--wui-color-gray-glass-010);
    }
  }

  button:disabled > cross-wui-icon-box {
    opacity: 0.5;
  }

  input {
    border: none;
    outline: none;
    appearance: none;
  }
`;
const colorStyles = i$4`
  .cross-wui-color-inherit {
    color: var(--wui-color-inherit);
  }

  .wui-color-accent-100 {
    color: var(--wui-color-accent-100);
  }

  .wui-color-error-100 {
    color: var(--wui-color-error-100);
  }

  .wui-color-blue-100 {
    color: var(--wui-color-blue-100);
  }

  .wui-color-blue-90 {
    color: var(--wui-color-blue-90);
  }

  .wui-color-error-125 {
    color: var(--wui-color-error-125);
  }

  .wui-color-success-100 {
    color: var(--wui-color-success-100);
  }

  .wui-color-success-125 {
    color: var(--wui-color-success-125);
  }

  .wui-color-inverse-100 {
    color: var(--wui-color-inverse-100);
  }

  .wui-color-inverse-000 {
    color: var(--wui-color-inverse-000);
  }

  .wui-color-fg-100 {
    color: var(--wui-color-fg-100);
  }

  .wui-color-fg-200 {
    color: var(--wui-color-fg-200);
  }

  .wui-color-fg-300 {
    color: var(--wui-color-fg-300);
  }

  .wui-color-fg-325 {
    color: var(--wui-color-fg-325);
  }

  .wui-color-fg-350 {
    color: var(--wui-color-fg-350);
  }

  .cross-wui-bg-color-inherit {
    background-color: var(--wui-color-inherit);
  }

  .wui-bg-color-blue-100 {
    background-color: var(--wui-color-accent-100);
  }

  .wui-bg-color-error-100 {
    background-color: var(--wui-color-error-100);
  }

  .wui-bg-color-error-125 {
    background-color: var(--wui-color-error-125);
  }

  .wui-bg-color-success-100 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-success-125 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-inverse-100 {
    background-color: var(--wui-color-inverse-100);
  }

  .wui-bg-color-inverse-000 {
    background-color: var(--wui-color-inverse-000);
  }

  .wui-bg-color-fg-100 {
    background-color: var(--wui-color-fg-100);
  }

  .wui-bg-color-fg-200 {
    background-color: var(--wui-color-fg-200);
  }

  .wui-bg-color-fg-300 {
    background-color: var(--wui-color-fg-300);
  }

  .wui-color-fg-325 {
    background-color: var(--wui-color-fg-325);
  }

  .wui-color-fg-350 {
    background-color: var(--wui-color-fg-350);
  }
`;
function standardCustomElement(tagName, descriptor) {
  const { kind, elements } = descriptor;
  return {
    kind,
    elements,
    finisher(clazz) {
      if (!customElements.get(tagName)) {
        customElements.define(tagName, clazz);
      }
    }
  };
}
function legacyCustomElement(tagName, clazz) {
  if (!customElements.get(tagName)) {
    customElements.define(tagName, clazz);
  }
  return clazz;
}
function customElement(tagName) {
  return function create2(classOrDescriptor) {
    return typeof classOrDescriptor === "function" ? legacyCustomElement(tagName, classOrDescriptor) : standardCustomElement(tagName, classOrDescriptor);
  };
}
const styles$2n = i$4`
  :host {
    display: block;
    border-radius: clamp(0px, var(--wui-border-radius-l), 44px);
    box-shadow: 0 0 0 1px var(--wui-color-gray-glass-005);
    background-color: var(--wui-color-modal-bg);
    overflow: hidden;
  }

  :host([data-embedded='true']) {
    box-shadow:
      0 0 0 1px var(--wui-color-gray-glass-005),
      0px 4px 12px 4px var(--w3m-card-embedded-shadow-color);
  }
`;
var __decorate$2$ = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiCard = class WuiCard2 extends i$1 {
  render() {
    return x$3`<slot></slot>`;
  }
};
WuiCard.styles = [resetStyles, styles$2n];
WuiCard = __decorate$2$([
  customElement("cross-wui-card")
], WuiCard);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o$3 = { attribute: true, type: String, converter: u$1, reflect: false, hasChanged: f$4 }, r$2 = (t2 = o$3, e3, r3) => {
  const { kind: n5, metadata: i4 } = r3;
  let s2 = globalThis.litPropertyMetadata.get(i4);
  if (void 0 === s2 && globalThis.litPropertyMetadata.set(i4, s2 = /* @__PURE__ */ new Map()), "setter" === n5 && ((t2 = Object.create(t2)).wrapped = true), s2.set(r3.name, t2), "accessor" === n5) {
    const { name: o3 } = r3;
    return { set(r4) {
      const n6 = e3.get.call(this);
      e3.set.call(this, r4), this.requestUpdate(o3, n6, t2);
    }, init(e4) {
      return void 0 !== e4 && this.C(o3, void 0, t2, e4), e4;
    } };
  }
  if ("setter" === n5) {
    const { name: o3 } = r3;
    return function(r4) {
      const n6 = this[o3];
      e3.call(this, r4), this.requestUpdate(o3, n6, t2);
    };
  }
  throw Error("Unsupported decorator location: " + n5);
};
function n$3(t2) {
  return (e3, o3) => "object" == typeof o3 ? r$2(t2, e3, o3) : ((t3, e4, o4) => {
    const r3 = e4.hasOwnProperty(o4);
    return e4.constructor.createProperty(o4, t3), r3 ? Object.getOwnPropertyDescriptor(e4, o4) : void 0;
  })(t2, e3, o3);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function r$1(r3) {
  return n$3({ ...r3, state: true, attribute: false });
}
const addSvg = b$2`<svg
  width="14"
  height="14"
  viewBox="0 0 14 14"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill="currentColor"
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M7.0023 0.875C7.48571 0.875 7.8776 1.26675 7.8776 1.75V6.125H12.2541C12.7375 6.125 13.1294 6.51675 13.1294 7C13.1294 7.48325 12.7375 7.875 12.2541 7.875H7.8776V12.25C7.8776 12.7332 7.48571 13.125 7.0023 13.125C6.51889 13.125 6.12701 12.7332 6.12701 12.25V7.875H1.75054C1.26713 7.875 0.875244 7.48325 0.875244 7C0.875244 6.51675 1.26713 6.125 1.75054 6.125H6.12701V1.75C6.12701 1.26675 6.51889 0.875 7.0023 0.875Z"
    fill="#667dff"
  /></svg
>`;
const allWalletsSvg = b$2`<svg fill="none" viewBox="0 0 24 24">
  <path
    style="fill: var(--wui-color-accent-100);"
    d="M10.2 6.6a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM21 6.6a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM10.2 17.4a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM21 17.4a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0Z"
  />
</svg>`;
const appStoreSvg = b$2`
<svg width="36" height="36">
  <path
    d="M28.724 0H7.271A7.269 7.269 0 0 0 0 7.272v21.46A7.268 7.268 0 0 0 7.271 36H28.73A7.272 7.272 0 0 0 36 28.728V7.272A7.275 7.275 0 0 0 28.724 0Z"
    fill="url(#a)"
  />
  <path
    d="m17.845 8.271.729-1.26a1.64 1.64 0 1 1 2.843 1.638l-7.023 12.159h5.08c1.646 0 2.569 1.935 1.853 3.276H6.434a1.632 1.632 0 0 1-1.638-1.638c0-.909.73-1.638 1.638-1.638h4.176l5.345-9.265-1.67-2.898a1.642 1.642 0 0 1 2.844-1.638l.716 1.264Zm-6.317 17.5-1.575 2.732a1.64 1.64 0 1 1-2.844-1.638l1.17-2.025c1.323-.41 2.398-.095 3.249.931Zm13.56-4.954h4.262c.909 0 1.638.729 1.638 1.638 0 .909-.73 1.638-1.638 1.638h-2.367l1.597 2.772c.45.788.185 1.782-.602 2.241a1.642 1.642 0 0 1-2.241-.603c-2.69-4.666-4.711-8.159-6.052-10.485-1.372-2.367-.391-4.743.576-5.549 1.075 1.846 2.682 4.631 4.828 8.348Z"
    fill="#fff"
  />
  <defs>
    <linearGradient id="a" x1="18" y1="0" x2="18" y2="36" gradientUnits="userSpaceOnUse">
      <stop stop-color="#18BFFB" />
      <stop offset="1" stop-color="#2072F3" />
    </linearGradient>
  </defs>
</svg>`;
const appleSvg = b$2`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#000" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M28.77 23.3c-.69 1.99-2.75 5.52-4.87 5.56-1.4.03-1.86-.84-3.46-.84-1.61 0-2.12.81-3.45.86-2.25.1-5.72-5.1-5.72-9.62 0-4.15 2.9-6.2 5.42-6.25 1.36-.02 2.64.92 3.47.92.83 0 2.38-1.13 4.02-.97.68.03 2.6.28 3.84 2.08-3.27 2.14-2.76 6.61.75 8.25ZM24.2 7.88c-2.47.1-4.49 2.69-4.2 4.84 2.28.17 4.47-2.39 4.2-4.84Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
const arrowBottomCircleSvg = b$2`<svg
  fill="none"
  viewBox="0 0 21 20"
>
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10.5 2.42908C6.31875 2.42908 2.92859 5.81989 2.92859 10.0034C2.92859 14.1869 6.31875 17.5777 10.5 17.5777C14.6813 17.5777 18.0714 14.1869 18.0714 10.0034C18.0714 5.81989 14.6813 2.42908 10.5 2.42908ZM0.928589 10.0034C0.928589 4.71596 5.21355 0.429077 10.5 0.429077C15.7865 0.429077 20.0714 4.71596 20.0714 10.0034C20.0714 15.2908 15.7865 19.5777 10.5 19.5777C5.21355 19.5777 0.928589 15.2908 0.928589 10.0034ZM10.5 5.75003C11.0523 5.75003 11.5 6.19774 11.5 6.75003L11.5 10.8343L12.7929 9.54137C13.1834 9.15085 13.8166 9.15085 14.2071 9.54137C14.5976 9.9319 14.5976 10.5651 14.2071 10.9556L11.2071 13.9556C10.8166 14.3461 10.1834 14.3461 9.79291 13.9556L6.79291 10.9556C6.40239 10.5651 6.40239 9.9319 6.79291 9.54137C7.18343 9.15085 7.8166 9.15085 8.20712 9.54137L9.50002 10.8343L9.50002 6.75003C9.50002 6.19774 9.94773 5.75003 10.5 5.75003Z"
    clip-rule="evenodd"
  /></svg
>`;
const arrowBottomSvg = b$2`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 1.99a1 1 0 0 1 1 1v7.58l2.46-2.46a1 1 0 0 1 1.41 1.42L7.7 13.69a1 1 0 0 1-1.41 0L2.12 9.53A1 1 0 0 1 3.54 8.1L6 10.57V3a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
const arrowLeftSvg = b$2`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M13 7.99a1 1 0 0 1-1 1H4.4l2.46 2.46a1 1 0 1 1-1.41 1.41L1.29 8.7a1 1 0 0 1 0-1.41L5.46 3.1a1 1 0 0 1 1.41 1.42L4.41 6.99H12a1 1 0 0 1 1 1Z"
    clip-rule="evenodd"
  />
</svg>`;
const arrowRightSvg = b$2`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M1 7.99a1 1 0 0 1 1-1h7.58L7.12 4.53A1 1 0 1 1 8.54 3.1l4.16 4.17a1 1 0 0 1 0 1.41l-4.16 4.17a1 1 0 1 1-1.42-1.41l2.46-2.46H2a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
const arrowTopSvg = b$2`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 13.99a1 1 0 0 1-1-1V5.4L3.54 7.86a1 1 0 0 1-1.42-1.41L6.3 2.28a1 1 0 0 1 1.41 0l4.17 4.17a1 1 0 1 1-1.41 1.41L8 5.4v7.59a1 1 0 0 1-1 1Z"
    clip-rule="evenodd"
  />
</svg>`;
const bankSvg = b$2`<svg
  xmlns="http://www.w3.org/2000/svg"
  width="12"
  height="13"
  viewBox="0 0 12 13"
  fill="none"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M5.61391 1.57124C5.85142 1.42873 6.14813 1.42873 6.38564 1.57124L11.0793 4.38749C11.9179 4.89067 11.5612 6.17864 10.5832 6.17864H9.96398V10.0358H10.2854C10.6996 10.0358 11.0354 10.3716 11.0354 10.7858C11.0354 11.2 10.6996 11.5358 10.2854 11.5358H1.71416C1.29995 11.5358 0.964172 11.2 0.964172 10.7858C0.964172 10.3716 1.29995 10.0358 1.71416 10.0358H2.03558L2.03558 6.17864H1.41637C0.438389 6.17864 0.0816547 4.89066 0.920263 4.38749L5.61391 1.57124ZM3.53554 6.17864V10.0358H5.24979V6.17864H3.53554ZM6.74976 6.17864V10.0358H8.46401V6.17864H6.74976ZM8.64913 4.67864H3.35043L5.99978 3.089L8.64913 4.67864Z"
    fill="currentColor"
  /></svg
>`;
const browserSvg$1 = b$2`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4 6.4a1 1 0 0 1-.46.89 6.98 6.98 0 0 0 .38 6.18A7 7 0 0 0 16.46 7.3a1 1 0 0 1-.47-.92 7 7 0 0 0-12 .03Zm-2.02-.5a9 9 0 1 1 16.03 8.2A9 9 0 0 1 1.98 5.9Z"
    clip-rule="evenodd"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.03 8.63c-1.46-.3-2.72-.75-3.6-1.35l-.02-.01-.14-.11a1 1 0 0 1 1.2-1.6l.1.08c.6.4 1.52.74 2.69 1 .16-.99.39-1.88.67-2.65.3-.79.68-1.5 1.15-2.02A2.58 2.58 0 0 1 9.99 1c.8 0 1.45.44 1.92.97.47.52.84 1.23 1.14 2.02.29.77.52 1.66.68 2.64a8 8 0 0 0 2.7-1l.26-.18h.48a1 1 0 0 1 .12 2c-.86.51-2.01.91-3.34 1.18a22.24 22.24 0 0 1-.03 3.19c1.45.29 2.7.73 3.58 1.31a1 1 0 0 1-1.1 1.68c-.6-.4-1.56-.76-2.75-1-.15.8-.36 1.55-.6 2.2-.3.79-.67 1.5-1.14 2.02-.47.53-1.12.97-1.92.97-.8 0-1.45-.44-1.91-.97a6.51 6.51 0 0 1-1.15-2.02c-.24-.65-.44-1.4-.6-2.2-1.18.24-2.13.6-2.73.99a1 1 0 1 1-1.1-1.67c.88-.58 2.12-1.03 3.57-1.31a22.03 22.03 0 0 1-.04-3.2Zm2.2-1.7c.15-.86.34-1.61.58-2.24.24-.65.51-1.12.76-1.4.25-.28.4-.29.42-.29.03 0 .17.01.42.3.25.27.52.74.77 1.4.23.62.43 1.37.57 2.22a19.96 19.96 0 0 1-3.52 0Zm-.18 4.6a20.1 20.1 0 0 1-.03-2.62 21.95 21.95 0 0 0 3.94 0 20.4 20.4 0 0 1-.03 2.63 21.97 21.97 0 0 0-3.88 0Zm.27 2c.13.66.3 1.26.49 1.78.24.65.51 1.12.76 1.4.25.28.4.29.42.29.03 0 .17-.01.42-.3.25-.27.52-.74.77-1.4.19-.5.36-1.1.49-1.78a20.03 20.03 0 0 0-3.35 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const cardSvg = b$2`<svg
  xmlns="http://www.w3.org/2000/svg"
  width="12"
  height="13"
  viewBox="0 0 12 13"
  fill="none"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M4.16072 2C4.17367 2 4.18665 2 4.19968 2L7.83857 2C8.36772 1.99998 8.82398 1.99996 9.19518 2.04018C9.5895 2.0829 9.97577 2.17811 10.3221 2.42971C10.5131 2.56849 10.6811 2.73647 10.8198 2.92749C11.0714 3.27379 11.1666 3.66007 11.2094 4.0544C11.2496 4.42561 11.2496 4.88188 11.2495 5.41105V7.58896C11.2496 8.11812 11.2496 8.57439 11.2094 8.94561C11.1666 9.33994 11.0714 9.72621 10.8198 10.0725C10.6811 10.2635 10.5131 10.4315 10.3221 10.5703C9.97577 10.8219 9.5895 10.9171 9.19518 10.9598C8.82398 11 8.36772 11 7.83856 11H4.16073C3.63157 11 3.17531 11 2.80411 10.9598C2.40979 10.9171 2.02352 10.8219 1.67722 10.5703C1.48621 10.4315 1.31824 10.2635 1.17946 10.0725C0.927858 9.72621 0.832652 9.33994 0.78993 8.94561C0.749713 8.5744 0.749733 8.11813 0.749757 7.58896L0.749758 5.45C0.749758 5.43697 0.749758 5.42399 0.749757 5.41104C0.749733 4.88188 0.749713 4.42561 0.78993 4.0544C0.832652 3.66007 0.927858 3.27379 1.17946 2.92749C1.31824 2.73647 1.48621 2.56849 1.67722 2.42971C2.02352 2.17811 2.40979 2.0829 2.80411 2.04018C3.17531 1.99996 3.63157 1.99998 4.16072 2ZM2.96567 3.53145C2.69897 3.56034 2.60687 3.60837 2.55888 3.64324C2.49521 3.6895 2.43922 3.74549 2.39296 3.80916C2.35809 3.85715 2.31007 3.94926 2.28117 4.21597C2.26629 4.35335 2.25844 4.51311 2.25431 4.70832H9.74498C9.74085 4.51311 9.733 4.35335 9.71812 4.21597C9.68922 3.94926 9.6412 3.85715 9.60633 3.80916C9.56007 3.74549 9.50408 3.6895 9.44041 3.64324C9.39242 3.60837 9.30031 3.56034 9.03362 3.53145C8.75288 3.50103 8.37876 3.5 7.79961 3.5H4.19968C3.62053 3.5 3.24641 3.50103 2.96567 3.53145ZM9.74956 6.20832H2.24973V7.55C2.24973 8.12917 2.25076 8.5033 2.28117 8.78404C2.31007 9.05074 2.35809 9.14285 2.39296 9.19084C2.43922 9.25451 2.49521 9.31051 2.55888 9.35677C2.60687 9.39163 2.69897 9.43966 2.96567 9.46856C3.24641 9.49897 3.62053 9.5 4.19968 9.5H7.79961C8.37876 9.5 8.75288 9.49897 9.03362 9.46856C9.30032 9.43966 9.39242 9.39163 9.44041 9.35677C9.50408 9.31051 9.56007 9.25451 9.60633 9.19084C9.6412 9.14285 9.68922 9.05075 9.71812 8.78404C9.74854 8.5033 9.74956 8.12917 9.74956 7.55V6.20832ZM6.74963 8C6.74963 7.58579 7.08541 7.25 7.49961 7.25H8.2496C8.6638 7.25 8.99958 7.58579 8.99958 8C8.99958 8.41422 8.6638 8.75 8.2496 8.75H7.49961C7.08541 8.75 6.74963 8.41422 6.74963 8Z"
    fill="currentColor"
  /></svg
>`;
const checkmarkBoldSvg = b$2`<svg fill="none" viewBox="0 0 14 14">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M12.9576 2.23383C13.3807 2.58873 13.4361 3.21947 13.0812 3.64263L6.37159 11.6426C6.19161 11.8572 5.92989 11.9865 5.65009 11.999C5.3703 12.0115 5.09808 11.9062 4.89965 11.7085L0.979321 7.80331C0.588042 7.41354 0.586817 6.78038 0.976585 6.3891C1.36635 5.99782 1.99952 5.99659 2.3908 6.38636L5.53928 9.52268L11.5488 2.35742C11.9037 1.93426 12.5344 1.87893 12.9576 2.23383Z"
    clip-rule="evenodd"
  />
</svg>`;
const checkmarkSvg = b$2`<svg
  width="28"
  height="28"
  viewBox="0 0 28 28" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M25.5297 4.92733C26.1221 5.4242 26.1996 6.30724 25.7027 6.89966L12.2836 22.8997C12.0316 23.2001 11.6652 23.3811 11.2735 23.3986C10.8817 23.4161 10.5006 23.2686 10.2228 22.9919L2.38218 15.1815C1.83439 14.6358 1.83268 13.7494 2.37835 13.2016C2.92403 12.6538 3.81046 12.6521 4.35825 13.1978L11.1183 19.9317L23.5573 5.10036C24.0542 4.50794 24.9372 4.43047 25.5297 4.92733Z"
    fill="currentColor"/>
</svg>
`;
const chevronBottomSvg = b$2`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M1.46 4.96a1 1 0 0 1 1.41 0L8 10.09l5.13-5.13a1 1 0 1 1 1.41 1.41l-5.83 5.84a1 1 0 0 1-1.42 0L1.46 6.37a1 1 0 0 1 0-1.41Z"
    clip-rule="evenodd"
  />
</svg>`;
const chevronLeftSvg = b$2`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M11.04 1.46a1 1 0 0 1 0 1.41L5.91 8l5.13 5.13a1 1 0 1 1-1.41 1.41L3.79 8.71a1 1 0 0 1 0-1.42l5.84-5.83a1 1 0 0 1 1.41 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const chevronRightSvg = b$2`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.96 14.54a1 1 0 0 1 0-1.41L10.09 8 4.96 2.87a1 1 0 0 1 1.41-1.41l5.84 5.83a1 1 0 0 1 0 1.42l-5.84 5.83a1 1 0 0 1-1.41 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const chevronTopSvg = b$2`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M14.54 11.04a1 1 0 0 1-1.41 0L8 5.92l-5.13 5.12a1 1 0 1 1-1.41-1.41l5.83-5.84a1 1 0 0 1 1.42 0l5.83 5.84a1 1 0 0 1 0 1.41Z"
    clip-rule="evenodd"
  />
</svg>`;
const chromeStoreSvg = b$2`<svg width="36" height="36" fill="none">
  <path
    fill="#fff"
    fill-opacity=".05"
    d="M0 14.94c0-5.55 0-8.326 1.182-10.4a9 9 0 0 1 3.359-3.358C6.614 0 9.389 0 14.94 0h6.12c5.55 0 8.326 0 10.4 1.182a9 9 0 0 1 3.358 3.359C36 6.614 36 9.389 36 14.94v6.12c0 5.55 0 8.326-1.182 10.4a9 9 0 0 1-3.359 3.358C29.386 36 26.611 36 21.06 36h-6.12c-5.55 0-8.326 0-10.4-1.182a9 9 0 0 1-3.358-3.359C0 29.386 0 26.611 0 21.06v-6.12Z"
  />
  <path
    stroke="#fff"
    stroke-opacity=".05"
    d="M14.94.5h6.12c2.785 0 4.84 0 6.46.146 1.612.144 2.743.43 3.691.97a8.5 8.5 0 0 1 3.172 3.173c.541.948.826 2.08.971 3.692.145 1.62.146 3.675.146 6.459v6.12c0 2.785 0 4.84-.146 6.46-.145 1.612-.43 2.743-.97 3.691a8.5 8.5 0 0 1-3.173 3.172c-.948.541-2.08.826-3.692.971-1.62.145-3.674.146-6.459.146h-6.12c-2.784 0-4.84 0-6.46-.146-1.612-.145-2.743-.43-3.691-.97a8.5 8.5 0 0 1-3.172-3.173c-.541-.948-.827-2.08-.971-3.692C.5 25.9.5 23.845.5 21.06v-6.12c0-2.784 0-4.84.146-6.46.144-1.612.43-2.743.97-3.691A8.5 8.5 0 0 1 4.79 1.617C5.737 1.076 6.869.79 8.48.646 10.1.5 12.156.5 14.94.5Z"
  />
  <path
    fill="url(#a)"
    d="M17.998 10.8h12.469a14.397 14.397 0 0 0-24.938.001l6.234 10.798.006-.001a7.19 7.19 0 0 1 6.23-10.799Z"
  />
  <path
    fill="url(#b)"
    d="m24.237 21.598-6.234 10.798A14.397 14.397 0 0 0 30.47 10.798H18.002l-.002.006a7.191 7.191 0 0 1 6.237 10.794Z"
  />
  <path
    fill="url(#c)"
    d="M11.765 21.601 5.531 10.803A14.396 14.396 0 0 0 18.001 32.4l6.235-10.798-.004-.004a7.19 7.19 0 0 1-12.466.004Z"
  />
  <path fill="#fff" d="M18 25.2a7.2 7.2 0 1 0 0-14.4 7.2 7.2 0 0 0 0 14.4Z" />
  <path fill="#1A73E8" d="M18 23.7a5.7 5.7 0 1 0 0-11.4 5.7 5.7 0 0 0 0 11.4Z" />
  <defs>
    <linearGradient
      id="a"
      x1="6.294"
      x2="41.1"
      y1="5.995"
      y2="5.995"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#D93025" />
      <stop offset="1" stop-color="#EA4335" />
    </linearGradient>
    <linearGradient
      id="b"
      x1="20.953"
      x2="37.194"
      y1="32.143"
      y2="2.701"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#FCC934" />
      <stop offset="1" stop-color="#FBBC04" />
    </linearGradient>
    <linearGradient
      id="c"
      x1="25.873"
      x2="9.632"
      y1="31.2"
      y2="1.759"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#1E8E3E" />
      <stop offset="1" stop-color="#34A853" />
    </linearGradient>
  </defs>
</svg>`;
const clockSvg = b$2`<svg width="14" height="14" viewBox="0 0 14 14" fill="none">
  <path 
    fill-rule="evenodd" 
    clip-rule="evenodd" 
    d="M7.00235 2C4.24 2 2.00067 4.23858 2.00067 7C2.00067 9.76142 4.24 12 7.00235 12C9.7647 12 12.004 9.76142 12.004 7C12.004 4.23858 9.7647 2 7.00235 2ZM0 7C0 3.13401 3.13506 0 7.00235 0C10.8696 0 14.0047 3.13401 14.0047 7C14.0047 10.866 10.8696 14 7.00235 14C3.13506 14 0 10.866 0 7ZM7.00235 3C7.55482 3 8.00269 3.44771 8.00269 4V6.58579L9.85327 8.43575C10.2439 8.82627 10.2439 9.45944 9.85327 9.84996C9.46262 10.2405 8.82924 10.2405 8.43858 9.84996L6.29501 7.70711C6.10741 7.51957 6.00201 7.26522 6.00201 7V4C6.00201 3.44771 6.44988 3 7.00235 3Z" 
    fill="currentColor"
  />
</svg>`;
const closeSvg = b$2`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M2.54 2.54a1 1 0 0 1 1.42 0L8 6.6l4.04-4.05a1 1 0 1 1 1.42 1.42L9.4 8l4.05 4.04a1 1 0 0 1-1.42 1.42L8 9.4l-4.04 4.05a1 1 0 0 1-1.42-1.42L6.6 8 2.54 3.96a1 1 0 0 1 0-1.42Z"
    clip-rule="evenodd"
  />
</svg>`;
const coinPlaceholderSvg = b$2`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10 3a7 7 0 0 0-6.85 8.44l8.29-8.3C10.97 3.06 10.49 3 10 3Zm3.49.93-9.56 9.56c.32.55.71 1.06 1.16 1.5L15 5.1a7.03 7.03 0 0 0-1.5-1.16Zm2.7 2.8-9.46 9.46a7 7 0 0 0 9.46-9.46ZM1.99 5.9A9 9 0 1 1 18 14.09 9 9 0 0 1 1.98 5.91Z"
    clip-rule="evenodd"
  />
</svg>`;
const compassSvg = b$2`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M8 2a6 6 0 1 0 0 12A6 6 0 0 0 8 2ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm10.66-2.65a1 1 0 0 1 .23 1.06L9.83 9.24a1 1 0 0 1-.59.58l-2.83 1.06A1 1 0 0 1 5.13 9.6l1.06-2.82a1 1 0 0 1 .58-.59L9.6 5.12a1 1 0 0 1 1.06.23ZM7.9 7.89l-.13.35.35-.13.12-.35-.34.13Z"
    clip-rule="evenodd"
  />
</svg>`;
const copySvg = b$2`<svg
  xmlns="http://www.w3.org/2000/svg"
  width="16"
  height="16"
  viewBox="0 0 16 16"
  fill="none"
>
  <path
    fill="currentColor"
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M9.21498 1.28565H10.5944C11.1458 1.28562 11.6246 1.2856 12.0182 1.32093C12.4353 1.35836 12.853 1.44155 13.2486 1.66724C13.7005 1.92498 14.0749 2.29935 14.3326 2.75122C14.5583 3.14689 14.6415 3.56456 14.6789 3.9817C14.7143 4.37531 14.7142 4.85403 14.7142 5.40545V6.78489C14.7142 7.33631 14.7143 7.81503 14.6789 8.20865C14.6415 8.62578 14.5583 9.04345 14.3326 9.43912C14.0749 9.89099 13.7005 10.2654 13.2486 10.5231C12.853 10.7488 12.4353 10.832 12.0182 10.8694C11.7003 10.8979 11.3269 10.9034 10.9045 10.9045C10.9034 11.3269 10.8979 11.7003 10.8694 12.0182C10.832 12.4353 10.7488 12.853 10.5231 13.2486C10.2654 13.7005 9.89099 14.0749 9.43912 14.3326C9.04345 14.5583 8.62578 14.6415 8.20865 14.6789C7.81503 14.7143 7.33631 14.7142 6.78489 14.7142H5.40545C4.85403 14.7142 4.37531 14.7143 3.9817 14.6789C3.56456 14.6415 3.14689 14.5583 2.75122 14.3326C2.29935 14.0749 1.92498 13.7005 1.66724 13.2486C1.44155 12.853 1.35836 12.4353 1.32093 12.0182C1.2856 11.6246 1.28562 11.1458 1.28565 10.5944V9.21498C1.28562 8.66356 1.2856 8.18484 1.32093 7.79122C1.35836 7.37409 1.44155 6.95642 1.66724 6.56074C1.92498 6.10887 2.29935 5.73451 2.75122 5.47677C3.14689 5.25108 3.56456 5.16789 3.9817 5.13045C4.2996 5.10192 4.67301 5.09645 5.09541 5.09541C5.09645 4.67302 5.10192 4.2996 5.13045 3.9817C5.16789 3.56456 5.25108 3.14689 5.47676 2.75122C5.73451 2.29935 6.10887 1.92498 6.56074 1.66724C6.95642 1.44155 7.37409 1.35836 7.79122 1.32093C8.18484 1.2856 8.66356 1.28562 9.21498 1.28565ZM5.09541 7.09552C4.68397 7.09667 4.39263 7.10161 4.16046 7.12245C3.88053 7.14757 3.78516 7.18949 3.74214 7.21403C3.60139 7.29431 3.48478 7.41091 3.4045 7.55166C3.37997 7.59468 3.33804 7.69005 3.31292 7.96999C3.28659 8.26345 3.28565 8.65147 3.28565 9.25708V10.5523C3.28565 11.1579 3.28659 11.5459 3.31292 11.8394C3.33804 12.1193 3.37997 12.2147 3.4045 12.2577C3.48478 12.3985 3.60139 12.5151 3.74214 12.5954C3.78516 12.6199 3.88053 12.6618 4.16046 12.6869C4.45393 12.7133 4.84195 12.7142 5.44755 12.7142H6.74279C7.3484 12.7142 7.73641 12.7133 8.02988 12.6869C8.30981 12.6618 8.40518 12.6199 8.44821 12.5954C8.58895 12.5151 8.70556 12.3985 8.78584 12.2577C8.81038 12.2147 8.8523 12.1193 8.87742 11.8394C8.89825 11.6072 8.90319 11.3159 8.90435 10.9045C8.48219 10.9034 8.10898 10.8979 7.79122 10.8694C7.37409 10.832 6.95641 10.7488 6.56074 10.5231C6.10887 10.2654 5.73451 9.89099 5.47676 9.43912C5.25108 9.04345 5.16789 8.62578 5.13045 8.20865C5.10194 7.89089 5.09645 7.51767 5.09541 7.09552ZM7.96999 3.31292C7.69005 3.33804 7.59468 3.37997 7.55166 3.4045C7.41091 3.48478 7.29431 3.60139 7.21403 3.74214C7.18949 3.78516 7.14757 3.88053 7.12245 4.16046C7.09611 4.45393 7.09517 4.84195 7.09517 5.44755V6.74279C7.09517 7.3484 7.09611 7.73641 7.12245 8.02988C7.14757 8.30981 7.18949 8.40518 7.21403 8.4482C7.29431 8.58895 7.41091 8.70556 7.55166 8.78584C7.59468 8.81038 7.69005 8.8523 7.96999 8.87742C8.26345 8.90376 8.65147 8.9047 9.25708 8.9047H10.5523C11.1579 8.9047 11.5459 8.90376 11.8394 8.87742C12.1193 8.8523 12.2147 8.81038 12.2577 8.78584C12.3985 8.70556 12.5151 8.58895 12.5954 8.4482C12.6199 8.40518 12.6618 8.30981 12.6869 8.02988C12.7133 7.73641 12.7142 7.3484 12.7142 6.74279V5.44755C12.7142 4.84195 12.7133 4.45393 12.6869 4.16046C12.6618 3.88053 12.6199 3.78516 12.5954 3.74214C12.5151 3.60139 12.3985 3.48478 12.2577 3.4045C12.2147 3.37997 12.1193 3.33804 11.8394 3.31292C11.5459 3.28659 11.1579 3.28565 10.5523 3.28565H9.25708C8.65147 3.28565 8.26345 3.28659 7.96999 3.31292Z"
    fill="#788181"
  /></svg
>`;
const cursorTransparentSvg = b$2`<svg fill="none" viewBox="0 0 14 6">
  <path style="fill: var(--wui-color-bg-150);" d="M0 1h14L9.21 5.12a3.31 3.31 0 0 1-4.49 0L0 1Z" />
  <path
    style="stroke: var(--wui-color-inverse-100);"
    stroke-opacity=".05"
    d="M1.33 1.5h11.32L8.88 4.75l-.01.01a2.81 2.81 0 0 1-3.8 0l-.02-.01L1.33 1.5Z"
  />
  <path
    style="fill: var(--wui-color-bg-150);"
    d="M1.25.71h11.5L9.21 3.88a3.31 3.31 0 0 1-4.49 0L1.25.71Z"
  />
</svg> `;
const cursorSvg = b$2` <svg fill="none" viewBox="0 0 13 4">
  <path fill="currentColor" d="M.5 0h12L8.9 3.13a3.76 3.76 0 0 1-4.8 0L.5 0Z" />
</svg>`;
const desktopSvg = b$2`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M13.66 2H6.34c-1.07 0-1.96 0-2.68.08-.74.08-1.42.25-2.01.68a4 4 0 0 0-.89.89c-.43.6-.6 1.27-.68 2.01C0 6.38 0 7.26 0 8.34v.89c0 1.07 0 1.96.08 2.68.08.74.25 1.42.68 2.01a4 4 0 0 0 .89.89c.6.43 1.27.6 2.01.68a27 27 0 0 0 2.68.08h7.32a27 27 0 0 0 2.68-.08 4.03 4.03 0 0 0 2.01-.68 4 4 0 0 0 .89-.89c.43-.6.6-1.27.68-2.01.08-.72.08-1.8.18-2.68v-.89c0-1.07 0-1.96-.08-2.68a4.04 4.04 0 0 0-.68-2.01 4 4 0 0 0-.89-.89c-.6-.43-1.27-.6-2.01-.68C15.62 2 14.74 2 13.66 2ZM2.82 4.38c.2-.14.48-.25 1.06-.31C4.48 4 5.25 4 6.4 4h7.2c1.15 0 1.93 0 2.52.07.58.06.86.17 1.06.31a2 2 0 0 1 .44.44c.14.2.25.48.31 1.06.07.6.07 1.37.07 2.52v.77c0 1.15 0 1.93-.07 2.52-.06.58-.17.86-.31 1.06a2 2 0 0 1-.44.44c-.2.14-.48.25-1.06.32-.6.06-1.37.06-2.52.06H6.4c-1.15 0-1.93 0-2.52-.06-.58-.07-.86-.18-1.06-.32a2 2 0 0 1-.44-.44c-.14-.2-.25-.48-.31-1.06C2 11.1 2 10.32 2 9.17V8.4c0-1.15 0-1.93.07-2.52.06-.58.17-.86.31-1.06a2 2 0 0 1 .44-.44Z"
    clip-rule="evenodd"
  />
  <path fill="currentColor" d="M6.14 17.57a1 1 0 1 0 0 2h7.72a1 1 0 1 0 0-2H6.14Z" />
</svg>`;
const disconnectSvg = b$2`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.07 1h.57a1 1 0 0 1 0 2h-.52c-.98 0-1.64 0-2.14.06-.48.05-.7.14-.84.24-.13.1-.25.22-.34.35-.1.14-.2.35-.25.83-.05.5-.05 1.16-.05 2.15v2.74c0 .99 0 1.65.05 2.15.05.48.14.7.25.83.1.14.2.25.34.35.14.1.36.2.84.25.5.05 1.16.05 2.14.05h.52a1 1 0 0 1 0 2h-.57c-.92 0-1.69 0-2.3-.07a3.6 3.6 0 0 1-1.8-.61c-.3-.22-.57-.49-.8-.8a3.6 3.6 0 0 1-.6-1.79C.5 11.11.5 10.35.5 9.43V6.58c0-.92 0-1.8.16-2.31a3.6 3.6 0 0 1 .62-1.8c.22-.3.48-.57.79-.79a3.6 3.6 0 0 1 1.8-.61C4.37 1 5.14 1 6.06 1ZM9.5 3a1 1 0 0 1 1.42 0l4.28 4.3a1 1 0 0 1 0 1.4L10.93 13a1 1 0 0 1-1.42-1.42L12.1 9H6.8a1 1 0 1 1 0-2h5.3L9.51 4.42a1 1 0 0 1 0-1.41Z"
    clip-rule="evenodd"
  />
</svg>`;
const discordSvg = b$2`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5865F2" />
      <path
        fill="#fff"
        fill-rule="evenodd"
        d="M25.71 28.15C30.25 28 32 25.02 32 25.02c0-6.61-2.96-11.98-2.96-11.98-2.96-2.22-5.77-2.15-5.77-2.15l-.29.32c3.5 1.07 5.12 2.61 5.12 2.61a16.75 16.75 0 0 0-10.34-1.93l-.35.04a15.43 15.43 0 0 0-5.88 1.9s1.71-1.63 5.4-2.7l-.2-.24s-2.81-.07-5.77 2.15c0 0-2.96 5.37-2.96 11.98 0 0 1.73 2.98 6.27 3.13l1.37-1.7c-2.6-.79-3.6-2.43-3.6-2.43l.58.35.09.06.08.04.02.01.08.05a17.25 17.25 0 0 0 4.52 1.58 14.4 14.4 0 0 0 8.3-.86c.72-.27 1.52-.66 2.37-1.21 0 0-1.03 1.68-3.72 2.44.61.78 1.35 1.67 1.35 1.67Zm-9.55-9.6c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28.01-1.25-.93-2.28-2.1-2.28Zm7.5 0c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28 0-1.25-.93-2.28-2.1-2.28Z"
        clip-rule="evenodd"
      />
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  </defs>
</svg>`;
const etherscanSvg = b$2`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="M4.25 7a.63.63 0 0 0-.63.63v3.97c0 .28-.2.51-.47.54l-.75.07a.93.93 0 0 1-.9-.47A7.51 7.51 0 0 1 5.54.92a7.5 7.5 0 0 1 9.54 4.62c.12.35.06.72-.16 1-.74.97-1.68 1.78-2.6 2.44V4.44a.64.64 0 0 0-.63-.64h-1.06c-.35 0-.63.3-.63.64v5.5c0 .23-.12.42-.32.5l-.52.23V6.05c0-.36-.3-.64-.64-.64H7.45c-.35 0-.64.3-.64.64v4.97c0 .25-.17.46-.4.52a5.8 5.8 0 0 0-.45.11v-4c0-.36-.3-.65-.64-.65H4.25ZM14.07 12.4A7.49 7.49 0 0 1 3.6 14.08c4.09-.58 9.14-2.5 11.87-6.6v.03a7.56 7.56 0 0 1-1.41 4.91Z"
  />
</svg>`;
const exclamationTriangleSvg = b$2`<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M15.0162 11.6312L9.55059 2.13937C9.39228 1.86862 9.16584 1.64405 8.8938 1.48798C8.62176 1.33192 8.3136 1.2498 7.99997 1.2498C7.68634 1.2498 7.37817 1.33192 7.10613 1.48798C6.83409 1.64405 6.60765 1.86862 6.44934 2.13937L0.983716 11.6312C0.830104 11.894 0.749146 12.1928 0.749146 12.4972C0.749146 12.8015 0.830104 13.1004 0.983716 13.3631C1.14027 13.6352 1.3664 13.8608 1.63889 14.0166C1.91139 14.1725 2.22044 14.253 2.53434 14.25H13.4656C13.7793 14.2528 14.0881 14.1721 14.3603 14.0163C14.6326 13.8604 14.8585 13.635 15.015 13.3631C15.1688 13.1005 15.2499 12.8017 15.2502 12.4973C15.2504 12.193 15.1696 11.8941 15.0162 11.6312ZM13.7162 12.6125C13.6908 12.6558 13.6541 12.6914 13.6101 12.7157C13.5661 12.7399 13.5164 12.7517 13.4662 12.75H2.53434C2.48415 12.7517 2.43442 12.7399 2.39042 12.7157C2.34641 12.6914 2.30976 12.6558 2.28434 12.6125C2.26278 12.5774 2.25137 12.5371 2.25137 12.4959C2.25137 12.4548 2.26278 12.4144 2.28434 12.3794L7.74997 2.88749C7.77703 2.84583 7.81408 2.8116 7.85774 2.7879C7.9014 2.7642 7.95029 2.75178 7.99997 2.75178C8.04964 2.75178 8.09854 2.7642 8.1422 2.7879C8.18586 2.8116 8.2229 2.84583 8.24997 2.88749L13.715 12.3794C13.7367 12.4143 13.7483 12.4546 13.7486 12.4958C13.7488 12.5369 13.7376 12.5773 13.7162 12.6125ZM7.24997 8.49999V6.49999C7.24997 6.30108 7.32898 6.11031 7.46964 5.96966C7.61029 5.82901 7.80105 5.74999 7.99997 5.74999C8.19888 5.74999 8.38964 5.82901 8.5303 5.96966C8.67095 6.11031 8.74997 6.30108 8.74997 6.49999V8.49999C8.74997 8.6989 8.67095 8.88967 8.5303 9.03032C8.38964 9.17097 8.19888 9.24999 7.99997 9.24999C7.80105 9.24999 7.61029 9.17097 7.46964 9.03032C7.32898 8.88967 7.24997 8.6989 7.24997 8.49999ZM8.99997 11C8.99997 11.1978 8.94132 11.3911 8.83144 11.5556C8.72155 11.72 8.56538 11.8482 8.38265 11.9239C8.19992 11.9996 7.99886 12.0194 7.80488 11.9808C7.6109 11.9422 7.43271 11.847 7.29286 11.7071C7.15301 11.5672 7.05777 11.3891 7.01918 11.1951C6.9806 11.0011 7.0004 10.8 7.07609 10.6173C7.15177 10.4346 7.27995 10.2784 7.4444 10.1685C7.60885 10.0586 7.80219 9.99999 7.99997 9.99999C8.26518 9.99999 8.51954 10.1053 8.70707 10.2929C8.89461 10.4804 8.99997 10.7348 8.99997 11Z" fill="currentColor"/>
</svg>
`;
const extensionSvg = b$2`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.71 2.99a.57.57 0 0 0-.57.57 1 1 0 0 1-1 1c-.58 0-.96 0-1.24.03-.27.03-.37.07-.42.1a.97.97 0 0 0-.36.35c-.04.08-.09.21-.11.67a2.57 2.57 0 0 1 0 5.13c.02.45.07.6.11.66.09.15.21.28.36.36.07.04.21.1.67.12a2.57 2.57 0 0 1 5.12 0c.46-.03.6-.08.67-.12a.97.97 0 0 0 .36-.36c.03-.04.07-.14.1-.41.02-.29.03-.66.03-1.24a1 1 0 0 1 1-1 .57.57 0 0 0 0-1.15 1 1 0 0 1-1-1c0-.58 0-.95-.03-1.24a1.04 1.04 0 0 0-.1-.42.97.97 0 0 0-.36-.36 1.04 1.04 0 0 0-.42-.1c-.28-.02-.65-.02-1.24-.02a1 1 0 0 1-1-1 .57.57 0 0 0-.57-.57ZM5.15 13.98a1 1 0 0 0 .99-1v-.78a.57.57 0 0 1 1.14 0v.78a1 1 0 0 0 .99 1H8.36a66.26 66.26 0 0 0 .73 0 3.78 3.78 0 0 0 1.84-.38c.46-.26.85-.64 1.1-1.1.23-.4.32-.8.36-1.22.02-.2.03-.4.03-.63a2.57 2.57 0 0 0 0-4.75c0-.23-.01-.44-.03-.63a2.96 2.96 0 0 0-.35-1.22 2.97 2.97 0 0 0-1.1-1.1c-.4-.22-.8-.31-1.22-.35a8.7 8.7 0 0 0-.64-.04 2.57 2.57 0 0 0-4.74 0c-.23 0-.44.02-.63.04-.42.04-.83.13-1.22.35-.46.26-.84.64-1.1 1.1-.33.57-.37 1.2-.39 1.84a21.39 21.39 0 0 0 0 .72v.1a1 1 0 0 0 1 .99h.78a.57.57 0 0 1 0 1.15h-.77a1 1 0 0 0-1 .98v.1a63.87 63.87 0 0 0 0 .73c0 .64.05 1.27.38 1.83.26.47.64.85 1.1 1.11.56.32 1.2.37 1.84.38a20.93 20.93 0 0 0 .72 0h.1Z"
    clip-rule="evenodd"
  />
</svg>`;
const externalLinkSvg = b$2`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.74 3.99a1 1 0 0 1 1-1H11a1 1 0 0 1 1 1v6.26a1 1 0 0 1-2 0V6.4l-6.3 6.3a1 1 0 0 1-1.4-1.42l6.29-6.3H4.74a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
const facebookSvg = b$2`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1877F2" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M26 12.38h-2.89c-.92 0-1.61.38-1.61 1.34v1.66H26l-.36 4.5H21.5v12H17v-12h-3v-4.5h3V12.5c0-3.03 1.6-4.62 5.2-4.62H26v4.5Z"
        />
      </g>
    </g>
    <path
      fill="#1877F2"
      d="M40 20a20 20 0 1 0-23.13 19.76V25.78H11.8V20h5.07v-4.4c0-5.02 3-7.79 7.56-7.79 2.19 0 4.48.4 4.48.4v4.91h-2.53c-2.48 0-3.25 1.55-3.25 3.13V20h5.54l-.88 5.78h-4.66v13.98A20 20 0 0 0 40 20Z"
    />
    <path
      fill="#fff"
      d="m27.79 25.78.88-5.78h-5.55v-3.75c0-1.58.78-3.13 3.26-3.13h2.53V8.2s-2.3-.39-4.48-.39c-4.57 0-7.55 2.77-7.55 7.78V20H11.8v5.78h5.07v13.98a20.15 20.15 0 0 0 6.25 0V25.78h4.67Z"
    />
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
const farcasterSvg = b$2`<svg style="border-radius: 9999px; overflow: hidden;"  fill="none" viewBox="0 0 1000 1000">
  <rect width="1000" height="1000" rx="9999" ry="9999" fill="#855DCD"/>
  <path fill="#855DCD" d="M0 0h1000v1000H0V0Z" />
  <path
    fill="#fff"
    d="M320 248h354v504h-51.96V521.13h-.5c-5.76-63.8-59.31-113.81-124.54-113.81s-118.78 50-124.53 113.81h-.5V752H320V248Z"
  />
  <path
    fill="#fff"
    d="m225 320 21.16 71.46h17.9v289.09a16.29 16.29 0 0 0-16.28 16.24v19.49h-3.25a16.3 16.3 0 0 0-16.28 16.24V752h182.26v-19.48a16.22 16.22 0 0 0-16.28-16.24h-3.25v-19.5a16.22 16.22 0 0 0-16.28-16.23h-19.52V320H225Zm400.3 360.55a16.3 16.3 0 0 0-15.04 10.02 16.2 16.2 0 0 0-1.24 6.22v19.49h-3.25a16.29 16.29 0 0 0-16.27 16.24V752h182.24v-19.48a16.23 16.23 0 0 0-16.27-16.24h-3.25v-19.5a16.2 16.2 0 0 0-10.04-15 16.3 16.3 0 0 0-6.23-1.23v-289.1h17.9L775 320H644.82v360.55H625.3Z"
  />
</svg>`;
const filtersSvg = b$2`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 3a1 1 0 0 1 1-1h14a1 1 0 1 1 0 2H1a1 1 0 0 1-1-1Zm2.63 5.25a1 1 0 0 1 1-1h8.75a1 1 0 1 1 0 2H3.63a1 1 0 0 1-1-1Zm2.62 5.25a1 1 0 0 1 1-1h3.5a1 1 0 0 1 0 2h-3.5a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
const githubSvg = b$2`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1B1F23" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M8 19.89a12 12 0 1 1 15.8 11.38c-.6.12-.8-.26-.8-.57v-3.3c0-1.12-.4-1.85-.82-2.22 2.67-.3 5.48-1.31 5.48-5.92 0-1.31-.47-2.38-1.24-3.22.13-.3.54-1.52-.12-3.18 0 0-1-.32-3.3 1.23a11.54 11.54 0 0 0-6 0c-2.3-1.55-3.3-1.23-3.3-1.23a4.32 4.32 0 0 0-.12 3.18 4.64 4.64 0 0 0-1.24 3.22c0 4.6 2.8 5.63 5.47 5.93-.34.3-.65.83-.76 1.6-.69.31-2.42.84-3.5-1 0 0-.63-1.15-1.83-1.23 0 0-1.18-.02-.09.73 0 0 .8.37 1.34 1.76 0 0 .7 2.14 4.03 1.41v2.24c0 .31-.2.68-.8.57A12 12 0 0 1 8 19.9Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
const googleSvg$1 = b$2`<svg fill="none" viewBox="0 0 40 40">
  <path
    fill="#4285F4"
    d="M32.74 20.3c0-.93-.08-1.81-.24-2.66H20.26v5.03h7a6 6 0 0 1-2.62 3.91v3.28h4.22c2.46-2.27 3.88-5.6 3.88-9.56Z"
  />
  <path
    fill="#34A853"
    d="M20.26 33a12.4 12.4 0 0 0 8.6-3.14l-4.22-3.28a7.74 7.74 0 0 1-4.38 1.26 7.76 7.76 0 0 1-7.28-5.36H8.65v3.36A12.99 12.99 0 0 0 20.26 33Z"
  />
  <path
    fill="#FBBC05"
    d="M12.98 22.47a7.79 7.79 0 0 1 0-4.94v-3.36H8.65a12.84 12.84 0 0 0 0 11.66l3.37-2.63.96-.73Z"
  />
  <path
    fill="#EA4335"
    d="M20.26 12.18a7.1 7.1 0 0 1 4.98 1.93l3.72-3.72A12.47 12.47 0 0 0 20.26 7c-5.08 0-9.47 2.92-11.6 7.17l4.32 3.36a7.76 7.76 0 0 1 7.28-5.35Z"
  />
</svg>`;
const helpCircleSvg = b$2`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="M8.51 5.66a.83.83 0 0 0-.57-.2.83.83 0 0 0-.52.28.8.8 0 0 0-.25.52 1 1 0 0 1-2 0c0-.75.34-1.43.81-1.91a2.75 2.75 0 0 1 4.78 1.92c0 1.24-.8 1.86-1.25 2.2l-.04.03c-.47.36-.5.43-.5.65a1 1 0 1 1-2 0c0-1.25.8-1.86 1.24-2.2l.04-.04c.47-.36.5-.43.5-.65 0-.3-.1-.49-.24-.6ZM9.12 11.87a1.13 1.13 0 1 1-2.25 0 1.13 1.13 0 0 1 2.25 0Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6a6 6 0 1 0 0 12A6 6 0 0 0 8 2Z"
    clip-rule="evenodd"
  />
</svg>`;
const idSvg = b$2`<svg
 xmlns="http://www.w3.org/2000/svg"
 width="28"
 height="28"
 viewBox="0 0 28 28"
 fill="none">
  <path
    fill="#949E9E"
    fill-rule="evenodd"
    d="M7.974 2.975h12.052c1.248 0 2.296 0 3.143.092.89.096 1.723.307 2.461.844a4.9 4.9 0 0 1 1.084 1.084c.537.738.748 1.57.844 2.461.092.847.092 1.895.092 3.143v6.802c0 1.248 0 2.296-.092 3.143-.096.89-.307 1.723-.844 2.461a4.9 4.9 0 0 1-1.084 1.084c-.738.537-1.57.748-2.461.844-.847.092-1.895.092-3.143.092H7.974c-1.247 0-2.296 0-3.143-.092-.89-.096-1.723-.307-2.461-.844a4.901 4.901 0 0 1-1.084-1.084c-.537-.738-.748-1.571-.844-2.461C.35 19.697.35 18.649.35 17.4v-6.802c0-1.248 0-2.296.092-3.143.096-.89.307-1.723.844-2.461A4.9 4.9 0 0 1 2.37 3.91c.738-.537 1.571-.748 2.461-.844.847-.092 1.895-.092 3.143-.092ZM5.133 5.85c-.652.071-.936.194-1.117.326a2.1 2.1 0 0 0-.465.465c-.132.181-.255.465-.325 1.117-.074.678-.076 1.573-.076 2.917v6.65c0 1.344.002 2.239.076 2.917.07.652.193.936.325 1.117a2.1 2.1 0 0 0 .465.465c.181.132.465.255 1.117.326.678.073 1.574.075 2.917.075h11.9c1.344 0 2.239-.002 2.917-.075.652-.071.936-.194 1.117-.326.179-.13.335-.286.465-.465.132-.181.255-.465.326-1.117.073-.678.075-1.573.075-2.917v-6.65c0-1.344-.002-2.239-.075-2.917-.071-.652-.194-.936-.326-1.117a2.1 2.1 0 0 0-.465-.465c-.181-.132-.465-.255-1.117-.326-.678-.073-1.573-.075-2.917-.075H8.05c-1.343 0-2.239.002-2.917.075Zm.467 7.275a3.15 3.15 0 1 1 6.3 0 3.15 3.15 0 0 1-6.3 0Zm8.75-1.75a1.4 1.4 0 0 1 1.4-1.4h3.5a1.4 1.4 0 0 1 0 2.8h-3.5a1.4 1.4 0 0 1-1.4-1.4Zm0 5.25a1.4 1.4 0 0 1 1.4-1.4H21a1.4 1.4 0 1 1 0 2.8h-5.25a1.4 1.4 0 0 1-1.4-1.4Z"
    clip-rule="evenodd"/>
</svg>`;
const imageSvg = b$2`<svg width="14" height="14" viewBox="0 0 14 14" fill="none">
  <path d="M4.98926 3.73932C4.2989 3.73932 3.73926 4.29896 3.73926 4.98932C3.73926 5.67968 4.2989 6.23932 4.98926 6.23932C5.67962 6.23932 6.23926 5.67968 6.23926 4.98932C6.23926 4.29896 5.67962 3.73932 4.98926 3.73932Z" fill="currentColor"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M7.60497 0.500001H6.39504C5.41068 0.499977 4.59185 0.499958 3.93178 0.571471C3.24075 0.64634 2.60613 0.809093 2.04581 1.21619C1.72745 1.44749 1.44749 1.72745 1.21619 2.04581C0.809093 2.60613 0.64634 3.24075 0.571471 3.93178C0.499958 4.59185 0.499977 5.41065 0.500001 6.39501V7.57815C0.499998 8.37476 0.499995 9.05726 0.534869 9.62725C0.570123 10.2034 0.644114 10.7419 0.828442 11.2302C0.925651 11.4877 1.05235 11.7287 1.21619 11.9542C1.44749 12.2726 1.72745 12.5525 2.04581 12.7838C2.60613 13.1909 3.24075 13.3537 3.93178 13.4285C4.59185 13.5001 5.41066 13.5 6.39503 13.5H7.60496C8.58933 13.5 9.40815 13.5001 10.0682 13.4285C10.7593 13.3537 11.3939 13.1909 11.9542 12.7838C12.2726 12.5525 12.5525 12.2726 12.7838 11.9542C13.1909 11.3939 13.3537 10.7593 13.4285 10.0682C13.5 9.40816 13.5 8.58935 13.5 7.60497V6.39505C13.5 5.41068 13.5 4.59185 13.4285 3.93178C13.3537 3.24075 13.1909 2.60613 12.7838 2.04581C12.5525 1.72745 12.2726 1.44749 11.9542 1.21619C11.3939 0.809093 10.7593 0.64634 10.0682 0.571471C9.40816 0.499958 8.58933 0.499977 7.60497 0.500001ZM3.22138 2.83422C3.38394 2.71612 3.62634 2.61627 4.14721 2.55984C4.68679 2.50138 5.39655 2.5 6.45 2.5H7.55C8.60345 2.5 9.31322 2.50138 9.8528 2.55984C10.3737 2.61627 10.6161 2.71612 10.7786 2.83422C10.9272 2.94216 11.0578 3.07281 11.1658 3.22138C11.2839 3.38394 11.3837 3.62634 11.4402 4.14721C11.4986 4.68679 11.5 5.39655 11.5 6.45V6.49703C10.9674 6.11617 10.386 5.84936 9.74213 5.81948C8.40536 5.75745 7.3556 6.73051 6.40509 7.84229C6.33236 7.92737 6.27406 7.98735 6.22971 8.02911L6.1919 8.00514L6.17483 7.99427C6.09523 7.94353 5.98115 7.87083 5.85596 7.80302C5.56887 7.64752 5.18012 7.4921 4.68105 7.4921C4.66697 7.4921 4.6529 7.49239 4.63884 7.49299C3.79163 7.52878 3.09922 8.1106 2.62901 8.55472C2.58751 8.59392 2.54594 8.6339 2.50435 8.6745C2.50011 8.34653 2.5 7.97569 2.5 7.55V6.45C2.5 5.39655 2.50138 4.68679 2.55984 4.14721C2.61627 3.62634 2.71612 3.38394 2.83422 3.22138C2.94216 3.07281 3.07281 2.94216 3.22138 2.83422ZM10.3703 8.14825C10.6798 8.37526 11.043 8.71839 11.4832 9.20889C11.4744 9.44992 11.4608 9.662 11.4402 9.8528C11.3837 10.3737 11.2839 10.6161 11.1658 10.7786C11.0578 10.9272 10.9272 11.0578 10.7786 11.1658C10.6161 11.2839 10.3737 11.3837 9.8528 11.4402C9.31322 11.4986 8.60345 11.5 7.55 11.5H6.45C5.39655 11.5 4.68679 11.4986 4.14721 11.4402C3.62634 11.3837 3.38394 11.2839 3.22138 11.1658C3.15484 11.1174 3.0919 11.0645 3.03298 11.0075C3.10126 10.9356 3.16806 10.8649 3.23317 10.7959L3.29772 10.7276C3.55763 10.4525 3.78639 10.2126 4.00232 10.0087C4.22016 9.80294 4.39412 9.66364 4.53524 9.57742C4.63352 9.51738 4.69022 9.49897 4.71275 9.49345C4.76387 9.49804 4.81803 9.51537 4.90343 9.56162C4.96409 9.59447 5.02355 9.63225 5.11802 9.69238L5.12363 9.69595C5.20522 9.74789 5.32771 9.82587 5.46078 9.89278C5.76529 10.0459 6.21427 10.186 6.74977 10.0158C7.21485 9.86796 7.59367 9.52979 7.92525 9.14195C8.91377 7.98571 9.38267 7.80495 9.64941 7.81733C9.7858 7.82366 10.0101 7.884 10.3703 8.14825Z" fill="currentColor"/>
</svg>`;
const infoCircleSvg = b$2`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    d="M6 10.49a1 1 0 1 0 2 0v-2a1 1 0 0 0-2 0v2ZM7 4.49a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 14.99a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm5-7a5 5 0 1 1-10 0 5 5 0 0 1 10 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const infoSvg = b$2`<svg width="22" height="22" viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9.125 6.875C9.125 6.57833 9.21298 6.28832 9.3778 6.04165C9.54262 5.79497 9.77689 5.60271 10.051 5.48918C10.3251 5.37565 10.6267 5.34594 10.9176 5.40382C11.2086 5.4617 11.4759 5.60456 11.6857 5.81434C11.8954 6.02412 12.0383 6.29139 12.0962 6.58236C12.1541 6.87334 12.1244 7.17494 12.0108 7.44903C11.8973 7.72311 11.705 7.95738 11.4584 8.1222C11.2117 8.28703 10.9217 8.375 10.625 8.375C10.2272 8.375 9.84565 8.21696 9.56434 7.93566C9.28304 7.65436 9.125 7.27282 9.125 6.875ZM21.125 11C21.125 13.0025 20.5312 14.9601 19.4186 16.6251C18.3061 18.2902 16.7248 19.5879 14.8747 20.3543C13.0246 21.1206 10.9888 21.3211 9.02471 20.9305C7.06066 20.5398 5.25656 19.5755 3.84055 18.1595C2.42454 16.7435 1.46023 14.9393 1.06955 12.9753C0.678878 11.0112 0.879387 8.97543 1.64572 7.12533C2.41206 5.27523 3.70981 3.69392 5.37486 2.58137C7.0399 1.46882 8.99747 0.875 11 0.875C13.6844 0.877978 16.258 1.94567 18.1562 3.84383C20.0543 5.74199 21.122 8.3156 21.125 11ZM18.875 11C18.875 9.44247 18.4131 7.91992 17.5478 6.62488C16.6825 5.32985 15.4526 4.32049 14.0136 3.72445C12.5747 3.12841 10.9913 2.97246 9.46367 3.27632C7.93607 3.58017 6.53288 4.3302 5.43154 5.43153C4.3302 6.53287 3.58018 7.93606 3.27632 9.46366C2.97246 10.9913 3.12841 12.5747 3.72445 14.0136C4.32049 15.4526 5.32985 16.6825 6.62489 17.5478C7.91993 18.4131 9.44248 18.875 11 18.875C13.0879 18.8728 15.0896 18.0424 16.566 16.566C18.0424 15.0896 18.8728 13.0879 18.875 11ZM12.125 14.4387V11.375C12.125 10.8777 11.9275 10.4008 11.5758 10.0492C11.2242 9.69754 10.7473 9.5 10.25 9.5C9.98433 9.4996 9.72708 9.59325 9.52383 9.76435C9.32058 9.93544 9.18444 10.173 9.13952 10.4348C9.09461 10.6967 9.14381 10.966 9.27843 11.195C9.41304 11.4241 9.62438 11.5981 9.875 11.6863V14.75C9.875 15.2473 10.0725 15.7242 10.4242 16.0758C10.7758 16.4275 11.2527 16.625 11.75 16.625C12.0157 16.6254 12.2729 16.5318 12.4762 16.3607C12.6794 16.1896 12.8156 15.952 12.8605 15.6902C12.9054 15.4283 12.8562 15.159 12.7216 14.93C12.587 14.7009 12.3756 14.5269 12.125 14.4387Z" fill="currentColor"/>
</svg>`;
const lightbulbSvg$1 = b$2`<svg width="10" height="10" viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.00177 1.78569C3.8179 1.78569 2.85819 2.74508 2.85819 3.92855C2.85819 4.52287 3.09928 5.05956 3.49077 5.4485L3.5005 5.45817C3.64381 5.60054 3.76515 5.72108 3.85631 5.81845C3.93747 5.90512 4.05255 6.03218 4.12889 6.1805C4.16999 6.26034 4.19 6.30843 4.21768 6.39385C4.22145 6.40546 4.22499 6.41703 4.22833 6.42855H5.77521C5.77854 6.41703 5.78208 6.40547 5.78585 6.39385C5.81353 6.30843 5.83354 6.26034 5.87464 6.1805C5.95098 6.03218 6.06606 5.90512 6.14722 5.81845C6.23839 5.72108 6.35973 5.60053 6.50304 5.45816L6.51276 5.4485C6.90425 5.05956 7.14534 4.52287 7.14534 3.92855C7.14534 2.74508 6.18563 1.78569 5.00177 1.78569ZM5.71629 7.85712H4.28724C4.28724 8.21403 4.28876 8.40985 4.30703 8.54571C4.30727 8.54748 4.30751 8.54921 4.30774 8.55091C4.30944 8.55115 4.31118 8.55138 4.31295 8.55162C4.44884 8.56989 4.64474 8.5714 5.00177 8.5714C5.3588 8.5714 5.55469 8.56989 5.69059 8.55162C5.69236 8.55138 5.69409 8.55115 5.69579 8.55091C5.69603 8.54921 5.69627 8.54748 5.6965 8.54571C5.71477 8.40985 5.71629 8.21403 5.71629 7.85712ZM2.85819 7.14283C2.85819 6.9948 2.85796 6.91114 2.8548 6.85032C2.85461 6.84656 2.85441 6.84309 2.85421 6.83988C2.84393 6.8282 2.83047 6.81334 2.81301 6.79469C2.74172 6.71856 2.63908 6.61643 2.48342 6.46178C1.83307 5.81566 1.42914 4.91859 1.42914 3.92855C1.42914 1.9561 3.02866 0.357117 5.00177 0.357117C6.97487 0.357117 8.57439 1.9561 8.57439 3.92855C8.57439 4.91859 8.17047 5.81566 7.52012 6.46178C7.36445 6.61643 7.26182 6.71856 7.19053 6.79469C7.17306 6.81334 7.1596 6.8282 7.14932 6.83988C7.14912 6.84309 7.14892 6.84656 7.14873 6.85032C7.14557 6.91114 7.14534 6.9948 7.14534 7.14283V7.85712C7.14534 7.87009 7.14535 7.88304 7.14535 7.89598C7.14541 8.19889 7.14547 8.49326 7.11281 8.73606C7.076 9.00978 6.98631 9.32212 6.72678 9.58156C6.46726 9.841 6.15481 9.93065 5.881 9.96745C5.63813 10.0001 5.34365 10 5.04064 9.99998C5.0277 9.99998 5.01474 9.99998 5.00177 9.99998C4.98879 9.99998 4.97583 9.99998 4.96289 9.99998C4.65988 10 4.36541 10.0001 4.12253 9.96745C3.84872 9.93065 3.53628 9.841 3.27675 9.58156C3.01722 9.32212 2.92753 9.00978 2.89072 8.73606C2.85807 8.49326 2.85812 8.19889 2.85818 7.89598C2.85819 7.88304 2.85819 7.87008 2.85819 7.85712V7.14283ZM7.1243 6.86977C7.12366 6.87069 7.1233 6.87116 7.12327 6.87119C7.12323 6.87123 7.12356 6.87076 7.1243 6.86977ZM2.88027 6.8712C2.88025 6.87119 2.87988 6.8707 2.87921 6.86975C2.87995 6.87072 2.88028 6.8712 2.88027 6.8712Z" fill="#949E9E"/>
</svg>`;
const mailSvg = b$2`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.83 1.34h6.34c.68 0 1.26 0 1.73.04.5.05.97.15 1.42.4.52.3.95.72 1.24 1.24.26.45.35.92.4 1.42.04.47.04 1.05.04 1.73v3.71c0 .69 0 1.26-.04 1.74-.05.5-.14.97-.4 1.41-.3.52-.72.95-1.24 1.25-.45.25-.92.35-1.42.4-.47.03-1.05.03-1.73.03H4.83c-.68 0-1.26 0-1.73-.04-.5-.04-.97-.14-1.42-.4-.52-.29-.95-.72-1.24-1.24a3.39 3.39 0 0 1-.4-1.41A20.9 20.9 0 0 1 0 9.88v-3.7c0-.7 0-1.27.04-1.74.05-.5.14-.97.4-1.42.3-.52.72-.95 1.24-1.24.45-.25.92-.35 1.42-.4.47-.04 1.05-.04 1.73-.04ZM3.28 3.38c-.36.03-.51.08-.6.14-.21.11-.39.29-.5.5a.8.8 0 0 0-.08.19l5.16 3.44c.45.3 1.03.3 1.48 0L13.9 4.2a.79.79 0 0 0-.08-.2c-.11-.2-.29-.38-.5-.5-.09-.05-.24-.1-.6-.13-.37-.04-.86-.04-1.6-.04H4.88c-.73 0-1.22 0-1.8.14ZM14 6.54 9.85 9.31a3.33 3.33 0 0 1-3.7 0L2 6.54v3.3c0 .74 0 1.22.03 1.8.14.36.1.5.15.6.11.2.29.38.5.5.09.05.24.1.6.14.37.03.86.03 1.8.13h6.25c.73 0 1.22 0 1.6-.03.35-.03.5-.09.6-.14.2-.12.38-.3.5-.5.05-.1.1-.24.14-.6.03-.38.03-.86.03-1.6v-3.3Z"
    clip-rule="evenodd"
  />
</svg>`;
const mobileSvg = b$2`<svg fill="none" viewBox="0 0 20 20">
  <path fill="currentColor" d="M10.81 5.81a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z" />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3 4.75A4.75 4.75 0 0 1 7.75 0h4.5A4.75 4.75 0 0 1 17 4.75v10.5A4.75 4.75 0 0 1 12.25 20h-4.5A4.75 4.75 0 0 1 3 15.25V4.75ZM7.75 2A2.75 2.75 0 0 0 5 4.75v10.5A2.75 2.75 0 0 0 7.75 18h4.5A2.75 2.75 0 0 0 15 15.25V4.75A2.75 2.75 0 0 0 12.25 2h-4.5Z"
    clip-rule="evenodd"
  />
</svg>`;
const moreSvg = b$2`<svg fill="none" viewBox="0 0 41 40">
  <path
    style="fill: var(--wui-color-fg-100);"
    fill-opacity=".05"
    d="M.6 20a20 20 0 1 1 40 0 20 20 0 0 1-40 0Z"
  />
  <path
    fill="#949E9E"
    d="M15.6 20.31a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0ZM23.1 20.31a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0ZM28.1 22.81a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5Z"
  />
</svg>`;
const networkPlaceholderSvg = b$2`<svg fill="none" viewBox="0 0 22 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M16.32 13.62a3.14 3.14 0 1 1-.99 1.72l-1.6-.93a3.83 3.83 0 0 1-3.71 1 3.66 3.66 0 0 1-1.74-1l-1.6.94a3.14 3.14 0 1 1-1-1.73l1.6-.94a3.7 3.7 0 0 1 0-2 3.81 3.81 0 0 1 1.8-2.33c.29-.17.6-.3.92-.38V6.1a3.14 3.14 0 1 1 2 0l-.01.02v1.85H12a3.82 3.82 0 0 1 2.33 1.8 3.7 3.7 0 0 1 .39 2.91l1.6.93ZM2.6 16.54a1.14 1.14 0 0 0 1.98-1.14 1.14 1.14 0 0 0-1.98 1.14ZM11 2.01a1.14 1.14 0 1 0 0 2.28 1.14 1.14 0 0 0 0-2.28Zm1.68 10.45c.08-.19.14-.38.16-.58v-.05l.02-.13v-.13a1.92 1.92 0 0 0-.24-.8l-.11-.15a1.89 1.89 0 0 0-.74-.6 1.86 1.86 0 0 0-.77-.17h-.19a1.97 1.97 0 0 0-.89.34 1.98 1.98 0 0 0-.61.74 1.99 1.99 0 0 0-.16.9v.05a1.87 1.87 0 0 0 .24.74l.1.15c.12.16.26.3.42.42l.16.1.13.07.04.02a1.84 1.84 0 0 0 .76.17h.17a2 2 0 0 0 .91-.35 1.78 1.78 0 0 0 .52-.58l.03-.05a.84.84 0 0 0 .05-.11Zm5.15 4.5a1.14 1.14 0 0 0 1.14-1.97 1.13 1.13 0 0 0-1.55.41c-.32.55-.13 1.25.41 1.56Z"
    clip-rule="evenodd"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.63 9.43a1.5 1.5 0 1 0 1.5-2.6 1.5 1.5 0 0 0-1.5 2.6Zm.32-1.55a.5.5 0 0 1 .68-.19.5.5 0 0 1 .18.68.5.5 0 0 1-.68.19.5.5 0 0 1-.18-.68ZM17.94 8.88a1.5 1.5 0 1 1-2.6-1.5 1.5 1.5 0 1 1 2.6 1.5ZM16.9 7.69a.5.5 0 0 0-.68.19.5.5 0 0 0 .18.68.5.5 0 0 0 .68-.19.5.5 0 0 0-.18-.68ZM9.75 17.75a1.5 1.5 0 1 1 2.6 1.5 1.5 1.5 0 1 1-2.6-1.5Zm1.05 1.18a.5.5 0 0 0 .68-.18.5.5 0 0 0-.18-.68.5.5 0 0 0-.68.18.5.5 0 0 0 .18.68Z"
    clip-rule="evenodd"
  />
</svg>`;
const nftPlaceholderSvg = b$2`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.13 1h1.71c1.46 0 2.63 0 3.56.1.97.1 1.8.33 2.53.85a5 5 0 0 1 1.1 1.11c.53.73.75 1.56.86 2.53.1.93.1 2.1.1 3.55v1.72c0 1.45 0 2.62-.1 3.55-.1.97-.33 1.8-.86 2.53a5 5 0 0 1-1.1 1.1c-.73.53-1.56.75-2.53.86-.93.1-2.1.1-3.55.1H9.13c-1.45 0-2.62 0-3.56-.1-.96-.1-1.8-.33-2.52-.85a5 5 0 0 1-1.1-1.11 5.05 5.05 0 0 1-.86-2.53c-.1-.93-.1-2.1-.1-3.55V9.14c0-1.45 0-2.62.1-3.55.1-.97.33-1.8.85-2.53a5 5 0 0 1 1.1-1.1 5.05 5.05 0 0 1 2.53-.86C6.51 1 7.67 1 9.13 1ZM5.79 3.09a3.1 3.1 0 0 0-1.57.48 3 3 0 0 0-.66.67c-.24.32-.4.77-.48 1.56-.1.82-.1 1.88-.1 3.4v1.6c0 1.15 0 2.04.05 2.76l.41-.42c.5-.5.93-.92 1.32-1.24.41-.33.86-.6 1.43-.7a3 3 0 0 1 .94 0c.35.06.66.2.95.37a17.11 17.11 0 0 0 .8.45c.1-.08.2-.2.41-.4l.04-.03a27 27 0 0 1 1.95-1.84 4.03 4.03 0 0 1 1.91-.94 4 4 0 0 1 1.25 0c.73.11 1.33.46 1.91.94l.64.55V9.2c0-1.52 0-2.58-.1-3.4a3.1 3.1 0 0 0-.48-1.56 3 3 0 0 0-.66-.67 3.1 3.1 0 0 0-1.56-.48C13.37 3 12.3 3 10.79 3h-1.6c-1.52 0-2.59 0-3.4.09Zm11.18 10-.04-.05a26.24 26.24 0 0 0-1.83-1.74c-.45-.36-.73-.48-.97-.52a2 2 0 0 0-.63 0c-.24.04-.51.16-.97.52-.46.38-1.01.93-1.83 1.74l-.02.02c-.17.18-.34.34-.49.47a2.04 2.04 0 0 1-1.08.5 1.97 1.97 0 0 1-1.25-.27l-.79-.46-.02-.02a.65.65 0 0 0-.24-.1 1 1 0 0 0-.31 0c-.08.02-.21.06-.49.28-.3.24-.65.59-1.2 1.14l-.56.56-.65.66a3 3 0 0 0 .62.6c.33.24.77.4 1.57.49.81.09 1.88.09 3.4.09h1.6c1.52 0 2.58 0 3.4-.09a3.1 3.1 0 0 0 1.56-.48 3 3 0 0 0 .66-.67c.24-.32.4-.77.49-1.56l.07-1.12Zm-8.02-1.03ZM4.99 7a2 2 0 1 1 4 0 2 2 0 0 1-4 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const offSvg = b$2`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M8 0a1 1 0 0 1 1 1v5.38a1 1 0 0 1-2 0V1a1 1 0 0 1 1-1ZM5.26 2.6a1 1 0 0 1-.28 1.39 5.46 5.46 0 1 0 6.04 0 1 1 0 1 1 1.1-1.67 7.46 7.46 0 1 1-8.25 0 1 1 0 0 1 1.4.28Z"
    clip-rule="evenodd"
  />
</svg>`;
const playStoreSvg = b$2` <svg
  width="36"
  height="36"
  fill="none"
>
  <path
    d="M0 8a8 8 0 0 1 8-8h20a8 8 0 0 1 8 8v20a8 8 0 0 1-8 8H8a8 8 0 0 1-8-8V8Z"
    fill="#fff"
    fill-opacity=".05"
  />
  <path
    d="m18.262 17.513-8.944 9.49v.01a2.417 2.417 0 0 0 3.56 1.452l.026-.017 10.061-5.803-4.703-5.132Z"
    fill="#EA4335"
  />
  <path
    d="m27.307 15.9-.008-.008-4.342-2.52-4.896 4.36 4.913 4.912 4.325-2.494a2.42 2.42 0 0 0 .008-4.25Z"
    fill="#FBBC04"
  />
  <path
    d="M9.318 8.997c-.05.202-.084.403-.084.622V26.39c0 .218.025.42.084.621l9.246-9.247-9.246-8.768Z"
    fill="#4285F4"
  />
  <path
    d="m18.33 18 4.627-4.628-10.053-5.828a2.427 2.427 0 0 0-3.586 1.444L18.329 18Z"
    fill="#34A853"
  />
  <path
    d="M8 .5h20A7.5 7.5 0 0 1 35.5 8v20a7.5 7.5 0 0 1-7.5 7.5H8A7.5 7.5 0 0 1 .5 28V8A7.5 7.5 0 0 1 8 .5Z"
    stroke="#fff"
    stroke-opacity=".05"
  />
</svg>`;
const plusSvg = b$2`<svg
  width="13"
  height="12"
  viewBox="0 0 13 12"
  fill="none"
>
  <path
    fill="currentColor"
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M0.794373 5.99982C0.794373 5.52643 1.17812 5.14268 1.6515 5.14268H5.643V1.15109C5.643 0.677701 6.02675 0.293946 6.50012 0.293945C6.9735 0.293946 7.35725 0.677701 7.35725 1.15109V5.14268H11.3488C11.8221 5.14268 12.2059 5.52643 12.2059 5.99982C12.2059 6.47321 11.8221 6.85696 11.3488 6.85696H7.35725V10.8486C7.35725 11.3219 6.9735 11.7057 6.50012 11.7057C6.02675 11.7057 5.643 11.3219 5.643 10.8486V6.85696H1.6515C1.17812 6.85696 0.794373 6.47321 0.794373 5.99982Z"
  /></svg
>`;
const qrCodeIcon = b$2`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    d="M3 6a3 3 0 0 1 3-3h1a1 1 0 1 0 0-2H6a5 5 0 0 0-5 5v1a1 1 0 0 0 2 0V6ZM13 1a1 1 0 1 0 0 2h1a3 3 0 0 1 3 3v1a1 1 0 1 0 2 0V6a5 5 0 0 0-5-5h-1ZM3 13a1 1 0 1 0-2 0v1a5 5 0 0 0 5 5h1a1 1 0 1 0 0-2H6a3 3 0 0 1-3-3v-1ZM19 13a1 1 0 1 0-2 0v1a3 3 0 0 1-3 3h-1a1 1 0 1 0 0 2h1.01a5 5 0 0 0 5-5v-1ZM5.3 6.36c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05A1.5 1.5 0 0 0 9.2 8.14c.06-.2.06-.43.06-.89s0-.7-.06-.89A1.5 1.5 0 0 0 8.14 5.3c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06ZM10.8 6.36c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05a1.5 1.5 0 0 0 1.06-1.06c.06-.2.06-.43.06-.89s0-.7-.06-.89a1.5 1.5 0 0 0-1.06-1.06c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06ZM5.26 12.75c0-.46 0-.7.05-.89a1.5 1.5 0 0 1 1.06-1.06c.19-.05.42-.05.89-.05.46 0 .7 0 .88.05.52.14.93.54 1.06 1.06.06.2.06.43.06.89s0 .7-.06.89a1.5 1.5 0 0 1-1.06 1.06c-.19.05-.42.05-.88.05-.47 0-.7 0-.9-.05a1.5 1.5 0 0 1-1.05-1.06c-.05-.2-.05-.43-.05-.89ZM10.8 11.86c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05a1.5 1.5 0 0 0 1.06-1.06c.06-.2.06-.43.06-.89s0-.7-.06-.89a1.5 1.5 0 0 0-1.06-1.06c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06Z"
  />
</svg>`;
const recycleHorizontalSvg = b$2`<svg
  fill="none"
  viewBox="0 0 21 20"
>
  <path
    fill="currentColor"
    d="M8.8071 0.292893C9.19763 0.683417 9.19763 1.31658 8.8071 1.70711L6.91421 3.6H11.8404C14.3368 3.6 16.5533 5.1975 17.3427 7.56588L17.4487 7.88377C17.6233 8.40772 17.3402 8.97404 16.8162 9.14868C16.2923 9.32333 15.726 9.04017 15.5513 8.51623L15.4453 8.19834C14.9281 6.64664 13.476 5.6 11.8404 5.6H6.91421L8.8071 7.49289C9.19763 7.88342 9.19763 8.51658 8.8071 8.90711C8.41658 9.29763 7.78341 9.29763 7.39289 8.90711L3.79289 5.30711C3.40236 4.91658 3.40236 4.28342 3.79289 3.89289L7.39289 0.292893C7.78341 -0.0976311 8.41658 -0.0976311 8.8071 0.292893ZM4.18377 10.8513C4.70771 10.6767 5.27403 10.9598 5.44868 11.4838L5.55464 11.8017C6.07188 13.3534 7.52401 14.4 9.15964 14.4L14.0858 14.4L12.1929 12.5071C11.8024 12.1166 11.8024 11.4834 12.1929 11.0929C12.5834 10.7024 13.2166 10.7024 13.6071 11.0929L17.2071 14.6929C17.5976 15.0834 17.5976 15.7166 17.2071 16.1071L13.6071 19.7071C13.2166 20.0976 12.5834 20.0976 12.1929 19.7071C11.8024 19.3166 11.8024 18.6834 12.1929 18.2929L14.0858 16.4L9.15964 16.4C6.66314 16.4 4.44674 14.8025 3.65728 12.4341L3.55131 12.1162C3.37667 11.5923 3.65983 11.026 4.18377 10.8513Z"
  /></svg
>`;
const refreshSvg = b$2`<svg fill="none" viewBox="0 0 14 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.94 1.04a1 1 0 0 1 .7 1.23l-.48 1.68a5.85 5.85 0 0 1 8.53 4.32 5.86 5.86 0 0 1-11.4 2.56 1 1 0 0 1 1.9-.57 3.86 3.86 0 1 0 1.83-4.5l1.87.53a1 1 0 0 1-.55 1.92l-4.1-1.15a1 1 0 0 1-.69-1.23l1.16-4.1a1 1 0 0 1 1.23-.7Z"
    clip-rule="evenodd"
  />
</svg>`;
const searchSvg = b$2`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.36 4.21a5.14 5.14 0 1 0 0 10.29 5.14 5.14 0 0 0 0-10.29ZM1.64 9.36a7.71 7.71 0 1 1 14 4.47l2.52 2.5a1.29 1.29 0 1 1-1.82 1.83l-2.51-2.51A7.71 7.71 0 0 1 1.65 9.36Z"
    clip-rule="evenodd"
  />
</svg>`;
const sendSvg = b$2`<svg fill="none" viewBox="0 0 21 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M14.3808 4.34812C13.72 4.47798 12.8501 4.7587 11.5748 5.17296L9.00869 6.00646C6.90631 6.68935 5.40679 7.17779 4.38121 7.63178C3.87166 7.85734 3.5351 8.05091 3.32022 8.22035C3.11183 8.38466 3.07011 8.48486 3.05969 8.51817C2.98058 8.77103 2.98009 9.04195 3.05831 9.29509C3.06861 9.32844 3.10998 9.42878 3.31777 9.59384C3.53205 9.76404 3.86792 9.95881 4.37667 10.1862C5.29287 10.5957 6.58844 11.0341 8.35529 11.6164L10.8876 8.59854C11.2426 8.17547 11.8733 8.12028 12.2964 8.47528C12.7195 8.83029 12.7746 9.46104 12.4196 9.88412L9.88738 12.9019C10.7676 14.5408 11.4244 15.7406 11.9867 16.5718C12.299 17.0333 12.5491 17.3303 12.7539 17.5117C12.9526 17.6877 13.0586 17.711 13.0932 17.7154C13.3561 17.7484 13.6228 17.7009 13.8581 17.5791C13.8891 17.563 13.9805 17.5046 14.1061 17.2708C14.2357 17.0298 14.3679 16.6647 14.5015 16.1237C14.7705 15.0349 14.9912 13.4733 15.2986 11.2843L15.6738 8.61249C15.8603 7.28456 15.9857 6.37917 15.9989 5.7059C16.012 5.03702 15.9047 4.8056 15.8145 4.69183C15.7044 4.55297 15.5673 4.43792 15.4114 4.35365C15.2837 4.28459 15.0372 4.2191 14.3808 4.34812ZM7.99373 13.603C6.11919 12.9864 4.6304 12.4902 3.5606 12.0121C2.98683 11.7557 2.4778 11.4808 2.07383 11.1599C1.66337 10.8339 1.31312 10.4217 1.14744 9.88551C0.949667 9.24541 0.950886 8.56035 1.15094 7.92096C1.31852 7.38534 1.67024 6.97442 2.08185 6.64985C2.48697 6.33041 2.99697 6.05734 3.57166 5.80295C4.70309 5.3021 6.30179 4.78283 8.32903 4.12437L11.0196 3.25042C12.2166 2.86159 13.2017 2.54158 13.9951 2.38566C14.8065 2.22618 15.6202 2.19289 16.3627 2.59437C16.7568 2.80747 17.1035 3.09839 17.3818 3.4495C17.9062 4.111 18.0147 4.91815 17.9985 5.74496C17.9827 6.55332 17.8386 7.57903 17.6636 8.82534L17.2701 11.6268C16.9737 13.7376 16.7399 15.4022 16.4432 16.6034C16.2924 17.2135 16.1121 17.7632 15.8678 18.2176C15.6197 18.6794 15.2761 19.0971 14.7777 19.3551C14.1827 19.6632 13.5083 19.7833 12.8436 19.6997C12.2867 19.6297 11.82 19.3563 11.4277 19.0087C11.0415 18.6666 10.6824 18.213 10.3302 17.6925C9.67361 16.722 8.92648 15.342 7.99373 13.603Z"
    clip-rule="evenodd"
  />
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="21"
    height="20"
    viewBox="0 0 21 20"
    fill="none"
  ></svg></svg
>`;
const swapHorizontalSvg = b$2`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.76.3a1 1 0 0 1 0 1.4L4.07 4.4h9a1 1 0 1 1 0 2h-9l2.69 2.68a1 1 0 1 1-1.42 1.42L.95 6.09a1 1 0 0 1 0-1.4l4.4-4.4a1 1 0 0 1 1.4 0Zm6.49 9.21a1 1 0 0 1 1.41 0l4.39 4.4a1 1 0 0 1 0 1.4l-4.39 4.4a1 1 0 0 1-1.41-1.42l2.68-2.68h-9a1 1 0 0 1 0-2h9l-2.68-2.68a1 1 0 0 1 0-1.42Z"
    clip-rule="evenodd"
  />
</svg>`;
const swapHorizontalBoldSvg = b$2`<svg width="10" height="10" viewBox="0 0 10 10">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.77986 0.566631C4.0589 0.845577 4.0589 1.29784 3.77986 1.57678L3.08261 2.2738H6.34184C6.73647 2.2738 7.05637 2.5936 7.05637 2.98808C7.05637 3.38257 6.73647 3.70237 6.34184 3.70237H3.08261L3.77986 4.39938C4.0589 4.67833 4.0589 5.13059 3.77986 5.40954C3.50082 5.68848 3.04841 5.68848 2.76937 5.40954L0.852346 3.49316C0.573306 3.21421 0.573306 2.76195 0.852346 2.48301L2.76937 0.566631C3.04841 0.287685 3.50082 0.287685 3.77986 0.566631ZM6.22 4.59102C6.49904 4.31208 6.95145 4.31208 7.23049 4.59102L9.14751 6.5074C9.42655 6.78634 9.42655 7.23861 9.14751 7.51755L7.23049 9.43393C6.95145 9.71287 6.49904 9.71287 6.22 9.43393C5.94096 9.15498 5.94096 8.70272 6.22 8.42377L6.91725 7.72676L3.65802 7.72676C3.26339 7.72676 2.94349 7.40696 2.94349 7.01247C2.94349 6.61798 3.26339 6.29819 3.65802 6.29819L6.91725 6.29819L6.22 5.60117C5.94096 5.32223 5.94096 4.86997 6.22 4.59102Z"
    clip-rule="evenodd"
  />
</svg>`;
const swapHorizontalMediumSvg = b$2`<svg
  width="14"
  height="14"
  viewBox="0 0 14 14"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M13.7306 3.24213C14.0725 3.58384 14.0725 4.13786 13.7306 4.47957L10.7418 7.46737C10.4 7.80908 9.84581 7.80908 9.50399 7.46737C9.16216 7.12567 9.16216 6.57165 9.50399 6.22994L10.9986 4.73585H5.34082C4.85741 4.73585 4.46553 4.3441 4.46553 3.86085C4.46553 3.3776 4.85741 2.98585 5.34082 2.98585L10.9986 2.98585L9.50399 1.49177C9.16216 1.15006 9.16216 0.596037 9.50399 0.254328C9.84581 -0.0873803 10.4 -0.0873803 10.7418 0.254328L13.7306 3.24213ZM9.52515 10.1352C9.52515 10.6185 9.13327 11.0102 8.64986 11.0102L2.9921 11.0102L4.48669 12.5043C4.82852 12.846 4.82852 13.4001 4.48669 13.7418C4.14487 14.0835 3.59066 14.0835 3.24884 13.7418L0.26003 10.754C0.0958806 10.5899 0.0036621 10.3673 0.00366211 10.1352C0.00366212 9.90318 0.0958806 9.68062 0.26003 9.51652L3.24884 6.52872C3.59066 6.18701 4.14487 6.18701 4.48669 6.52872C4.82851 6.87043 4.82851 7.42445 4.48669 7.76616L2.9921 9.26024L8.64986 9.26024C9.13327 9.26024 9.52515 9.65199 9.52515 10.1352Z"
    fill="currentColor"
  />
</svg>

`;
const swapHorizontalRoundedBoldSvg = b$2`<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20" fill="none">
  <path 
    fill="currentColor"
    fill-rule="evenodd" 
    clip-rule="evenodd" 
    d="M8.3071 0.292893C8.69763 0.683417 8.69763 1.31658 8.3071 1.70711L6.41421 3.6H11.3404C13.8368 3.6 16.0533 5.1975 16.8427 7.56588L16.9487 7.88377C17.1233 8.40772 16.8402 8.97404 16.3162 9.14868C15.7923 9.32333 15.226 9.04017 15.0513 8.51623L14.9453 8.19834C14.4281 6.64664 12.976 5.6 11.3404 5.6H6.41421L8.3071 7.49289C8.69763 7.88342 8.69763 8.51658 8.3071 8.90711C7.91658 9.29763 7.28341 9.29763 6.89289 8.90711L3.29289 5.30711C2.90236 4.91658 2.90236 4.28342 3.29289 3.89289L6.89289 0.292893C7.28341 -0.0976311 7.91658 -0.0976311 8.3071 0.292893ZM3.68377 10.8513C4.20771 10.6767 4.77403 10.9598 4.94868 11.4838L5.05464 11.8017C5.57188 13.3534 7.024 14.4 8.65964 14.4L13.5858 14.4L11.6929 12.5071C11.3024 12.1166 11.3024 11.4834 11.6929 11.0929C12.0834 10.7024 12.7166 10.7024 13.1071 11.0929L16.7071 14.6929C17.0976 15.0834 17.0976 15.7166 16.7071 16.1071L13.1071 19.7071C12.7166 20.0976 12.0834 20.0976 11.6929 19.7071C11.3024 19.3166 11.3024 18.6834 11.6929 18.2929L13.5858 16.4L8.65964 16.4C6.16314 16.4 3.94674 14.8025 3.15728 12.4341L3.05131 12.1162C2.87667 11.5923 3.15983 11.026 3.68377 10.8513Z" 
  />
</svg>`;
const swapVerticalSvg = b$2`<svg fill="none" viewBox="0 0 14 14">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.48 2.18a1 1 0 0 1 1.41 0l2.68 2.68a1 1 0 1 1-1.41 1.42l-.98-.98v4.56a1 1 0 0 1-2 0V5.3l-.97.98A1 1 0 0 1 .79 4.86l2.69-2.68Zm6.34 2.93a1 1 0 0 1 1 1v4.56l.97-.98a1 1 0 1 1 1.42 1.42l-2.69 2.68a1 1 0 0 1-1.41 0l-2.68-2.68a1 1 0 0 1 1.41-1.42l.98.98V6.1a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
const telegramSvg = b$2`<svg width="32" height="32" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
  <g clip-path="url(#a)">
    <path fill="url(#b)" d="M0 0h32v32H0z"/>
    <path fill-rule="evenodd" clip-rule="evenodd" d="M7.034 15.252c4.975-2.167 8.293-3.596 9.953-4.287 4.74-1.971 5.725-2.314 6.366-2.325.142-.002.457.033.662.198.172.14.22.33.243.463.022.132.05.435.028.671-.257 2.7-1.368 9.248-1.933 12.27-.24 1.28-.71 1.708-1.167 1.75-.99.091-1.743-.655-2.703-1.284-1.502-.985-2.351-1.598-3.81-2.558-1.684-1.11-.592-1.721.368-2.718.252-.261 4.619-4.233 4.703-4.594.01-.045.02-.213-.08-.301-.1-.09-.246-.059-.353-.035-.15.034-2.55 1.62-7.198 4.758-.682.468-1.298.696-1.851.684-.61-.013-1.782-.344-2.653-.628-1.069-.347-1.918-.53-1.845-1.12.039-.308.462-.623 1.27-.944Z" fill="#fff"/>
  </g>
  <path d="M.5 16C.5 7.44 7.44.5 16 .5 24.56.5 31.5 7.44 31.5 16c0 8.56-6.94 15.5-15.5 15.5C7.44 31.5.5 24.56.5 16Z" stroke="#141414" stroke-opacity=".05"/>
  <defs>
    <linearGradient id="b" x1="1600" y1="0" x2="1600" y2="3176.27" gradientUnits="userSpaceOnUse">
      <stop stop-color="#2AABEE"/>
      <stop offset="1" stop-color="#229ED9"/>
    </linearGradient>
    <clipPath id="a">
      <path d="M0 16C0 7.163 7.163 0 16 0s16 7.163 16 16-7.163 16-16 16S0 24.837 0 16Z" fill="#fff"/>
    </clipPath>
  </defs>
</svg>`;
const threeDotsSvg = b$2`<svg width="14" height="15" viewBox="0 0 14 15" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M7 3.71875C6.0335 3.71875 5.25 2.93525 5.25 1.96875C5.25 1.00225 6.0335 0.21875 7 0.21875C7.9665 0.21875 8.75 1.00225 8.75 1.96875C8.75 2.93525 7.9665 3.71875 7 3.71875Z" fill="#949E9E"/>
  <path d="M7 8.96875C6.0335 8.96875 5.25 8.18525 5.25 7.21875C5.25 6.25225 6.0335 5.46875 7 5.46875C7.9665 5.46875 8.75 6.25225 8.75 7.21875C8.75 8.18525 7.9665 8.96875 7 8.96875Z" fill="#949E9E"/>
  <path d="M5.25 12.4688C5.25 13.4352 6.0335 14.2187 7 14.2187C7.9665 14.2187 8.75 13.4352 8.75 12.4688C8.75 11.5023 7.9665 10.7188 7 10.7188C6.0335 10.7188 5.25 11.5023 5.25 12.4688Z" fill="#949E9E"/>
</svg>`;
const twitchSvg = b$2`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5A3E85" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M18.22 25.7 20 23.91h3.34l2.1-2.1v-6.68H15.4v8.78h2.82v1.77Zm3.87-8.16h1.25v3.66H22.1v-3.66Zm-3.34 0H20v3.66h-1.25v-3.66ZM20 7.9a12 12 0 1 0 0 24 12 12 0 0 0 0-24Zm6.69 14.56-3.66 3.66h-2.72l-1.77 1.78h-1.88V26.1H13.3v-9.82l.94-2.4H26.7v8.56Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
const twitterIconSvg = b$2`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="m14.36 4.74.01.42c0 4.34-3.3 9.34-9.34 9.34A9.3 9.3 0 0 1 0 13.03a6.6 6.6 0 0 0 4.86-1.36 3.29 3.29 0 0 1-3.07-2.28c.5.1 1 .07 1.48-.06A3.28 3.28 0 0 1 .64 6.11v-.04c.46.26.97.4 1.49.41A3.29 3.29 0 0 1 1.11 2.1a9.32 9.32 0 0 0 6.77 3.43 3.28 3.28 0 0 1 5.6-3 6.59 6.59 0 0 0 2.08-.8 3.3 3.3 0 0 1-1.45 1.82A6.53 6.53 0 0 0 16 3.04c-.44.66-1 1.23-1.64 1.7Z"
  />
</svg>`;
const verifyFilledSvg = b$2`<svg fill="none" viewBox="0 0 14 14">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="m4.1 12.43-.45-.78-.93-.2a1.65 1.65 0 0 1-1.31-1.8l.1-.86-.61-.71a1.65 1.65 0 0 1 0-2.16l.6-.7-.09-.85c-.1-.86.47-1.64 1.3-1.81l.94-.2.45-.78A1.65 1.65 0 0 1 6.23.9l.77.36.78-.36c.77-.36 1.69-.07 2.12.66l.47.8.91.2c.84.17 1.4.95 1.31 1.8l-.1.86.6.7c.54.62.54 1.54.01 2.16l-.6.71.09.86c.1.85-.47 1.63-1.3 1.8l-.92.2-.47.79a1.65 1.65 0 0 1-2.12.66L7 12.74l-.77.36c-.78.35-1.8.17-2.13-.67Zm5.74-6.9a1 1 0 1 0-1.68-1.07L6.32 7.3l-.55-.66a1 1 0 0 0-1.54 1.28l1.43 1.71a1 1 0 0 0 1.61-.1l2.57-4Z"
    clip-rule="evenodd"
  />
</svg>`;
const verifySvg = b$2`<svg fill="none" viewBox="0 0 28 28">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M18.1 4.76c-.42-.73-1.33-1.01-2.09-.66l-1.42.66c-.37.18-.8.18-1.18 0l-1.4-.65a1.63 1.63 0 0 0-2.1.66l-.84 1.45c-.2.34-.53.59-.92.67l-1.7.35c-.83.17-1.39.94-1.3 1.78l.19 1.56c.04.39-.08.78-.33 1.07l-1.12 1.3c-.52.6-.52 1.5 0 2.11L5 16.38c.25.3.37.68.33 1.06l-.18 1.57c-.1.83.46 1.6 1.28 1.78l1.7.35c.4.08.73.32.93.66l.84 1.43a1.63 1.63 0 0 0 2.09.66l1.41-.66c.37-.17.8-.17 1.18 0l1.43.67c.76.35 1.66.07 2.08-.65l.86-1.45c.2-.34.54-.58.92-.66l1.68-.35A1.63 1.63 0 0 0 22.84 19l-.18-1.57a1.4 1.4 0 0 1 .33-1.06l1.12-1.32c.52-.6.52-1.5 0-2.11l-1.12-1.3a1.4 1.4 0 0 1-.33-1.07l.18-1.57c.1-.83-.46-1.6-1.28-1.77l-1.68-.35a1.4 1.4 0 0 1-.92-.66l-.86-1.47Zm-3.27-3.2a4.43 4.43 0 0 1 5.69 1.78l.54.93 1.07.22a4.43 4.43 0 0 1 3.5 4.84l-.11.96.7.83a4.43 4.43 0 0 1 .02 5.76l-.72.85.1.96a4.43 4.43 0 0 1-3.5 4.84l-1.06.22-.54.92a4.43 4.43 0 0 1-5.68 1.77l-.84-.4-.82.39a4.43 4.43 0 0 1-5.7-1.79l-.51-.89-1.09-.22a4.43 4.43 0 0 1-3.5-4.84l.1-.96-.72-.85a4.43 4.43 0 0 1 .01-5.76l.71-.83-.1-.95a4.43 4.43 0 0 1 3.5-4.84l1.08-.23.53-.9a4.43 4.43 0 0 1 5.7-1.8l.81.38.83-.39ZM18.2 9.4c.65.42.84 1.28.42 1.93l-4.4 6.87a1.4 1.4 0 0 1-2.26.14L9.5 15.39a1.4 1.4 0 0 1 2.15-1.8l1.23 1.48 3.38-5.26a1.4 1.4 0 0 1 1.93-.42Z"
    clip-rule="evenodd"
  />
</svg>`;
const walletPlaceholderSvg = b$2`
  <svg fill="none" viewBox="0 0 48 44">
    <path
      style="fill: var(--wui-color-bg-300);"
      d="M4.56 8.64c-1.23 1.68-1.23 4.08-1.23 8.88v8.96c0 4.8 0 7.2 1.23 8.88.39.55.87 1.02 1.41 1.42C7.65 38 10.05 38 14.85 38h14.3c4.8 0 7.2 0 8.88-1.22a6.4 6.4 0 0 0 1.41-1.42c.83-1.14 1.1-2.6 1.19-4.92a6.4 6.4 0 0 0 5.16-4.65c.21-.81.21-1.8.21-3.79 0-1.98 0-2.98-.22-3.79a6.4 6.4 0 0 0-5.15-4.65c-.1-2.32-.36-3.78-1.19-4.92a6.4 6.4 0 0 0-1.41-1.42C36.35 6 33.95 6 29.15 6h-14.3c-4.8 0-7.2 0-8.88 1.22a6.4 6.4 0 0 0-1.41 1.42Z"
    />
    <path
      style="fill: var(--wui-color-fg-200);"
      fill-rule="evenodd"
      d="M2.27 11.33a6.4 6.4 0 0 1 6.4-6.4h26.66a6.4 6.4 0 0 1 6.4 6.4v1.7a6.4 6.4 0 0 1 5.34 6.3v5.34a6.4 6.4 0 0 1-5.34 6.3v1.7a6.4 6.4 0 0 1-6.4 6.4H8.67a6.4 6.4 0 0 1-6.4-6.4V11.33ZM39.6 31.07h-6.93a9.07 9.07 0 1 1 0-18.14h6.93v-1.6a4.27 4.27 0 0 0-4.27-4.26H8.67a4.27 4.27 0 0 0-4.27 4.26v21.34a4.27 4.27 0 0 0 4.27 4.26h26.66a4.27 4.27 0 0 0 4.27-4.26v-1.6Zm-6.93-16a6.93 6.93 0 0 0 0 13.86h8a4.27 4.27 0 0 0 4.26-4.26v-5.34a4.27 4.27 0 0 0-4.26-4.26h-8Z"
      clip-rule="evenodd"
    />
  </svg>
`;
const walletSvg = b$2`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 5.5c0-1.8 1.46-3.25 3.25-3.25H14.5c1.8 0 3.25 1.46 3.25 3.25v.28A3.25 3.25 0 0 1 20 8.88v2.24c0 1.45-.94 2.68-2.25 3.1v.28c0 1.8-1.46 3.25-3.25 3.25H3.25A3.25 3.25 0 0 1 0 14.5v-9Zm15.75 8.88h-2.38a4.38 4.38 0 0 1 0-8.76h2.38V5.5c0-.69-.56-1.25-1.25-1.25H3.25C2.56 4.25 2 4.81 2 5.5v9c0 .69.56 1.25 1.25 1.25H14.5c.69 0 1.25-.56 1.25-1.25v-.13Zm-2.38-6.76a2.37 2.37 0 1 0 0 4.75h3.38c.69 0 1.25-.55 1.25-1.24V8.87c0-.69-.56-1.24-1.25-1.24h-3.38Z"
    clip-rule="evenodd"
  />
</svg>`;
const walletConnectSvg = b$2`<svg fill="none" viewBox="0 0 96 67">
  <path
    fill="currentColor"
    d="M25.32 18.8a32.56 32.56 0 0 1 45.36 0l1.5 1.47c.63.62.63 1.61 0 2.22l-5.15 5.05c-.31.3-.82.3-1.14 0l-2.07-2.03a22.71 22.71 0 0 0-31.64 0l-2.22 2.18c-.31.3-.82.3-1.14 0l-5.15-5.05a1.55 1.55 0 0 1 0-2.22l1.65-1.62Zm56.02 10.44 4.59 4.5c.63.6.63 1.6 0 2.21l-20.7 20.26c-.62.61-1.63.61-2.26 0L48.28 41.83a.4.4 0 0 0-.56 0L33.03 56.21c-.63.61-1.64.61-2.27 0L10.07 35.95a1.55 1.55 0 0 1 0-2.22l4.59-4.5a1.63 1.63 0 0 1 2.27 0L31.6 43.63a.4.4 0 0 0 .57 0l14.69-14.38a1.63 1.63 0 0 1 2.26 0l14.69 14.38a.4.4 0 0 0 .57 0l14.68-14.38a1.63 1.63 0 0 1 2.27 0Z"
  />
  <path
    stroke="#000"
    stroke-opacity=".1"
    d="M25.67 19.15a32.06 32.06 0 0 1 44.66 0l1.5 1.48c.43.42.43 1.09 0 1.5l-5.15 5.05a.31.31 0 0 1-.44 0l-2.07-2.03a23.21 23.21 0 0 0-32.34 0l-2.22 2.18a.31.31 0 0 1-.44 0l-5.15-5.05a1.05 1.05 0 0 1 0-1.5l1.65-1.63ZM81 29.6l4.6 4.5c.42.41.42 1.09 0 1.5l-20.7 20.26c-.43.43-1.14.43-1.57 0L48.63 41.47a.9.9 0 0 0-1.26 0L32.68 55.85c-.43.43-1.14.43-1.57 0L10.42 35.6a1.05 1.05 0 0 1 0-1.5l4.59-4.5a1.13 1.13 0 0 1 1.57 0l14.68 14.38a.9.9 0 0 0 1.27 0l-.35-.35.35.35L47.22 29.6a1.13 1.13 0 0 1 1.56 0l14.7 14.38a.9.9 0 0 0 1.26 0L79.42 29.6a1.13 1.13 0 0 1 1.57 0Z"
  />
</svg>`;
const walletConnectLightBrownSvg = b$2`
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_22274_4692)">
<path d="M0 6.64C0 4.17295 0 2.93942 0.525474 2.01817C0.880399 1.39592 1.39592 0.880399 2.01817 0.525474C2.93942 0 4.17295 0 6.64 0H9.36C11.8271 0 13.0606 0 13.9818 0.525474C14.6041 0.880399 15.1196 1.39592 15.4745 2.01817C16 2.93942 16 4.17295 16 6.64V9.36C16 11.8271 16 13.0606 15.4745 13.9818C15.1196 14.6041 14.6041 15.1196 13.9818 15.4745C13.0606 16 11.8271 16 9.36 16H6.64C4.17295 16 2.93942 16 2.01817 15.4745C1.39592 15.1196 0.880399 14.6041 0.525474 13.9818C0 13.0606 0 11.8271 0 9.36V6.64Z" fill="#C7B994"/>
<path d="M4.49038 5.76609C6.42869 3.86833 9.5713 3.86833 11.5096 5.76609L11.7429 5.99449C11.8398 6.08938 11.8398 6.24323 11.7429 6.33811L10.9449 7.11942C10.8964 7.16686 10.8179 7.16686 10.7694 7.11942L10.4484 6.80512C9.09617 5.48119 6.90381 5.48119 5.5516 6.80512L5.20782 7.14171C5.15936 7.18915 5.08079 7.18915 5.03234 7.14171L4.23434 6.3604C4.13742 6.26552 4.13742 6.11167 4.23434 6.01678L4.49038 5.76609ZM13.1599 7.38192L13.8702 8.07729C13.9671 8.17217 13.9671 8.32602 13.8702 8.4209L10.6677 11.5564C10.5708 11.6513 10.4137 11.6513 10.3168 11.5564L8.04388 9.33105C8.01965 9.30733 7.98037 9.30733 7.95614 9.33105L5.6833 11.5564C5.58638 11.6513 5.42925 11.6513 5.33234 11.5564L2.12982 8.42087C2.0329 8.32598 2.0329 8.17213 2.12982 8.07724L2.84004 7.38188C2.93695 7.28699 3.09408 7.28699 3.191 7.38188L5.46392 9.60726C5.48815 9.63098 5.52743 9.63098 5.55166 9.60726L7.82447 7.38188C7.92138 7.28699 8.07851 7.28699 8.17543 7.38187L10.4484 9.60726C10.4726 9.63098 10.5119 9.63098 10.5361 9.60726L12.809 7.38192C12.9059 7.28703 13.063 7.28703 13.1599 7.38192Z" fill="#202020"/>
</g>
<defs>
<clipPath id="clip0_22274_4692">
<path d="M0 8C0 3.58172 3.58172 0 8 0C12.4183 0 16 3.58172 16 8C16 12.4183 12.4183 16 8 16C3.58172 16 0 12.4183 0 8Z" fill="white"/>
</clipPath>
</defs>
</svg>
`;
const walletConnectBrownSvg = b$2`
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle cx="11" cy="11" r="11" transform="matrix(-1 0 0 1 23 1)" fill="#202020"/>
<circle cx="11" cy="11" r="11.5" transform="matrix(-1 0 0 1 23 1)" stroke="#C7B994" stroke-opacity="0.7"/>
<path d="M15.4523 11.0686L16.7472 9.78167C13.8205 6.87297 10.1838 6.87297 7.25708 9.78167L8.55201 11.0686C10.7779 8.85645 13.2279 8.85645 15.4538 11.0686H15.4523Z" fill="#C7B994"/>
<path d="M15.0199 14.067L12 11.0656L8.98 14.067L5.96004 11.0656L4.66663 12.3511L8.98 16.6393L12 13.638L15.0199 16.6393L19.3333 12.3511L18.0399 11.0656L15.0199 14.067Z" fill="#C7B994"/>
</svg>
`;
const warningCircleSvg = b$2`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    d="M11 6.67a1 1 0 1 0-2 0v2.66a1 1 0 0 0 2 0V6.67ZM10 14.5a1.25 1.25 0 1 0 0-2.5 1.25 1.25 0 0 0 0 2.5Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10 1a9 9 0 1 0 0 18 9 9 0 0 0 0-18Zm-7 9a7 7 0 1 1 14 0 7 7 0 0 1-14 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const xSvg = b$2`<svg fill="none" viewBox="0 0 41 40">
  <g clip-path="url(#a)">
    <path fill="#000" d="M.8 0h40v40H.8z" />
    <path
      fill="#fff"
      d="m22.63 18.46 7.14-8.3h-1.69l-6.2 7.2-4.96-7.2H11.2l7.5 10.9-7.5 8.71h1.7l6.55-7.61 5.23 7.61h5.72l-7.77-11.31Zm-9.13-7.03h2.6l11.98 17.13h-2.6L13.5 11.43Z"
    />
  </g>
  <defs>
    <clipPath id="a"><path fill="#fff" d="M.8 20a20 20 0 1 1 40 0 20 20 0 0 1-40 0Z" /></clipPath>
  </defs>
</svg>`;
const styles$2m = i$4`
  :host {
    display: flex;
    aspect-ratio: 1 / 1;
    color: var(--local-color);
    width: var(--local-width);
  }

  svg {
    width: inherit;
    height: inherit;
    object-fit: contain;
    object-position: center;
  }
`;
var __decorate$2_ = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
const svgOptions$1 = {
  add: addSvg,
  allWallets: allWalletsSvg,
  arrowBottomCircle: arrowBottomCircleSvg,
  appStore: appStoreSvg,
  apple: appleSvg,
  arrowBottom: arrowBottomSvg,
  arrowLeft: arrowLeftSvg,
  arrowRight: arrowRightSvg,
  arrowTop: arrowTopSvg,
  bank: bankSvg,
  browser: browserSvg$1,
  card: cardSvg,
  checkmark: checkmarkSvg,
  checkmarkBold: checkmarkBoldSvg,
  chevronBottom: chevronBottomSvg,
  chevronLeft: chevronLeftSvg,
  chevronRight: chevronRightSvg,
  chevronTop: chevronTopSvg,
  chromeStore: chromeStoreSvg,
  clock: clockSvg,
  close: closeSvg,
  compass: compassSvg,
  coinPlaceholder: coinPlaceholderSvg,
  copy: copySvg,
  cursor: cursorSvg,
  cursorTransparent: cursorTransparentSvg,
  desktop: desktopSvg,
  disconnect: disconnectSvg,
  discord: discordSvg,
  etherscan: etherscanSvg,
  extension: extensionSvg,
  externalLink: externalLinkSvg,
  facebook: facebookSvg,
  farcaster: farcasterSvg,
  filters: filtersSvg,
  github: githubSvg,
  google: googleSvg$1,
  helpCircle: helpCircleSvg,
  image: imageSvg,
  id: idSvg,
  infoCircle: infoCircleSvg,
  lightbulb: lightbulbSvg$1,
  mail: mailSvg,
  mobile: mobileSvg,
  more: moreSvg,
  networkPlaceholder: networkPlaceholderSvg,
  nftPlaceholder: nftPlaceholderSvg,
  off: offSvg,
  playStore: playStoreSvg,
  plus: plusSvg,
  qrCode: qrCodeIcon,
  recycleHorizontal: recycleHorizontalSvg,
  refresh: refreshSvg,
  search: searchSvg,
  send: sendSvg,
  swapHorizontal: swapHorizontalSvg,
  swapHorizontalMedium: swapHorizontalMediumSvg,
  swapHorizontalBold: swapHorizontalBoldSvg,
  swapHorizontalRoundedBold: swapHorizontalRoundedBoldSvg,
  swapVertical: swapVerticalSvg,
  telegram: telegramSvg,
  threeDots: threeDotsSvg,
  twitch: twitchSvg,
  twitter: xSvg,
  twitterIcon: twitterIconSvg,
  verify: verifySvg,
  verifyFilled: verifyFilledSvg,
  wallet: walletSvg,
  walletConnect: walletConnectSvg,
  walletConnectLightBrown: walletConnectLightBrownSvg,
  walletConnectBrown: walletConnectBrownSvg,
  walletPlaceholder: walletPlaceholderSvg,
  warningCircle: warningCircleSvg,
  x: xSvg,
  info: infoSvg,
  exclamationTriangle: exclamationTriangleSvg
};
let WuiIcon = class WuiIcon2 extends i$1 {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.name = "copy";
    this.color = "fg-300";
  }
  render() {
    this.style.cssText = `
      --local-color: ${`var(--wui-color-${this.color});`}
      --local-width: ${`var(--wui-icon-size-${this.size});`}
    `;
    return x$3`${svgOptions$1[this.name]}`;
  }
};
WuiIcon.styles = [resetStyles, colorStyles, styles$2m];
__decorate$2_([
  n$3()
], WuiIcon.prototype, "size", void 0);
__decorate$2_([
  n$3()
], WuiIcon.prototype, "name", void 0);
__decorate$2_([
  n$3()
], WuiIcon.prototype, "color", void 0);
WuiIcon = __decorate$2_([
  customElement("cross-wui-icon")
], WuiIcon);
const styles$2l = i$4`
  :host {
    display: block;
    width: var(--local-width);
    height: var(--local-height);
  }

  img {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center center;
    border-radius: inherit;
  }
`;
var __decorate$2Z = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiImage = class WuiImage2 extends i$1 {
  constructor() {
    super(...arguments);
    this.src = "./path/to/image.jpg";
    this.alt = "Image";
    this.size = void 0;
  }
  render() {
    this.style.cssText = `
      --local-width: ${this.size ? `var(--wui-icon-size-${this.size});` : "100%"};
      --local-height: ${this.size ? `var(--wui-icon-size-${this.size});` : "100%"};
      `;
    return x$3`<img src=${this.src} alt=${this.alt} @error=${this.handleImageError} />`;
  }
  handleImageError() {
    this.dispatchEvent(new CustomEvent("onLoadError", { bubbles: true, composed: true }));
  }
};
WuiImage.styles = [resetStyles, colorStyles, styles$2l];
__decorate$2Z([
  n$3()
], WuiImage.prototype, "src", void 0);
__decorate$2Z([
  n$3()
], WuiImage.prototype, "alt", void 0);
__decorate$2Z([
  n$3()
], WuiImage.prototype, "size", void 0);
WuiImage = __decorate$2Z([
  customElement("cross-wui-image")
], WuiImage);
const styles$2k = i$4`
  :host {
    display: block;
    width: var(--wui-box-size-lg);
    height: var(--wui-box-size-lg);
  }

  svg {
    width: var(--wui-box-size-lg);
    height: var(--wui-box-size-lg);
    fill: none;
    stroke: transparent;
    stroke-linecap: round;
  }

  use {
    stroke: var(--wui-color-accent-100);
    stroke-width: 2px;
    stroke-dasharray: 54, 118;
    stroke-dashoffset: 172;
    animation: dash 1s linear infinite;
  }

  @keyframes dash {
    to {
      stroke-dashoffset: 0px;
    }
  }
`;
var __decorate$2Y = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiLoadingHexagon = class WuiLoadingHexagon2 extends i$1 {
  render() {
    return x$3`
      <svg viewBox="0 0 54 59">
        <path
          id="wui-loader-path"
          d="M17.22 5.295c3.877-2.277 5.737-3.363 7.72-3.726a11.44 11.44 0 0 1 4.12 0c1.983.363 3.844 1.45 7.72 3.726l6.065 3.562c3.876 2.276 5.731 3.372 7.032 4.938a11.896 11.896 0 0 1 2.06 3.63c.683 1.928.688 4.11.688 8.663v7.124c0 4.553-.005 6.735-.688 8.664a11.896 11.896 0 0 1-2.06 3.63c-1.3 1.565-3.156 2.66-7.032 4.937l-6.065 3.563c-3.877 2.276-5.737 3.362-7.72 3.725a11.46 11.46 0 0 1-4.12 0c-1.983-.363-3.844-1.449-7.72-3.726l-6.065-3.562c-3.876-2.276-5.731-3.372-7.032-4.938a11.885 11.885 0 0 1-2.06-3.63c-.682-1.928-.688-4.11-.688-8.663v-7.124c0-4.553.006-6.735.688-8.664a11.885 11.885 0 0 1 2.06-3.63c1.3-1.565 3.156-2.66 7.032-4.937l6.065-3.562Z"
        />
        <use xlink:href="#wui-loader-path"></use>
      </svg>
    `;
  }
};
WuiLoadingHexagon.styles = [resetStyles, styles$2k];
WuiLoadingHexagon = __decorate$2Y([
  customElement("cross-wui-loading-hexagon")
], WuiLoadingHexagon);
const styles$2j = i$4`
  :host {
    display: flex;
  }

  :host([data-size='sm']) > svg {
    width: 12px;
    height: 12px;
  }

  :host([data-size='md']) > svg {
    width: 16px;
    height: 16px;
  }

  :host([data-size='lg']) > svg {
    width: 24px;
    height: 24px;
  }

  :host([data-size='xl']) > svg {
    width: 32px;
    height: 32px;
  }

  svg {
    animation: rotate 2s linear infinite;
  }

  circle {
    fill: none;
    stroke: var(--local-color);
    stroke-width: 4px;
    stroke-dasharray: 1, 124;
    stroke-dashoffset: 0;
    stroke-linecap: round;
    animation: dash 1.5s ease-in-out infinite;
  }

  :host([data-size='md']) > svg > circle {
    stroke-width: 6px;
  }

  :host([data-size='sm']) > svg > circle {
    stroke-width: 8px;
  }

  @keyframes rotate {
    100% {
      transform: rotate(360deg);
    }
  }

  @keyframes dash {
    0% {
      stroke-dasharray: 1, 124;
      stroke-dashoffset: 0;
    }

    50% {
      stroke-dasharray: 90, 124;
      stroke-dashoffset: -35;
    }

    100% {
      stroke-dashoffset: -125;
    }
  }
`;
var __decorate$2X = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiLoadingSpinner = class WuiLoadingSpinner2 extends i$1 {
  constructor() {
    super(...arguments);
    this.color = "accent-100";
    this.size = "lg";
  }
  render() {
    this.style.cssText = `--local-color: ${this.color === "inherit" ? "inherit" : `var(--wui-color-${this.color})`}`;
    this.dataset["size"] = this.size;
    return x$3`<svg viewBox="25 25 50 50">
      <circle r="20" cy="50" cx="50"></circle>
    </svg>`;
  }
};
WuiLoadingSpinner.styles = [resetStyles, styles$2j];
__decorate$2X([
  n$3()
], WuiLoadingSpinner.prototype, "color", void 0);
__decorate$2X([
  n$3()
], WuiLoadingSpinner.prototype, "size", void 0);
WuiLoadingSpinner = __decorate$2X([
  customElement("cross-wui-loading-spinner")
], WuiLoadingSpinner);
const styles$2i = i$4`
  :host {
    display: block;
    width: var(--wui-box-size-md);
    height: var(--wui-box-size-md);
  }

  svg {
    width: var(--wui-box-size-md);
    height: var(--wui-box-size-md);
  }

  rect {
    fill: none;
    stroke: var(--wui-color-accent-100);
    stroke-width: 4px;
    stroke-linecap: round;
    animation: dash 1s linear infinite;
  }

  @keyframes dash {
    to {
      stroke-dashoffset: 0px;
    }
  }
`;
var __decorate$2W = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiLoadingThumbnail = class WuiLoadingThumbnail2 extends i$1 {
  constructor() {
    super(...arguments);
    this.radius = 36;
  }
  render() {
    return this.svgLoaderTemplate();
  }
  svgLoaderTemplate() {
    const radius = this.radius > 50 ? 50 : this.radius;
    const standardValue = 36;
    const radiusFactor = standardValue - radius;
    const dashArrayStart = 116 + radiusFactor;
    const dashArrayEnd = 245 + radiusFactor;
    const dashOffset = 360 + radiusFactor * 1.75;
    return x$3`
      <svg viewBox="0 0 110 110" width="110" height="110">
        <rect
          x="2"
          y="2"
          width="106"
          height="106"
          rx=${radius}
          stroke-dasharray="${dashArrayStart} ${dashArrayEnd}"
          stroke-dashoffset=${dashOffset}
        />
      </svg>
    `;
  }
};
WuiLoadingThumbnail.styles = [resetStyles, styles$2i];
__decorate$2W([
  n$3({ type: Number })
], WuiLoadingThumbnail.prototype, "radius", void 0);
WuiLoadingThumbnail = __decorate$2W([
  customElement("cross-wui-loading-thumbnail")
], WuiLoadingThumbnail);
const styles$2h = i$4`
  :host {
    display: block;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
    background: linear-gradient(
      120deg,
      var(--wui-color-bg-200) 5%,
      var(--wui-color-bg-200) 48%,
      var(--wui-color-bg-300) 55%,
      var(--wui-color-bg-300) 60%,
      var(--wui-color-bg-300) calc(60% + 10px),
      var(--wui-color-bg-200) calc(60% + 12px),
      var(--wui-color-bg-200) 100%
    );
    background-size: 250%;
    animation: shimmer 3s linear infinite reverse;
  }

  :host([variant='light']) {
    background: linear-gradient(
      120deg,
      var(--wui-color-bg-150) 5%,
      var(--wui-color-bg-150) 48%,
      var(--wui-color-bg-200) 55%,
      var(--wui-color-bg-200) 60%,
      var(--wui-color-bg-200) calc(60% + 10px),
      var(--wui-color-bg-150) calc(60% + 12px),
      var(--wui-color-bg-150) 100%
    );
    background-size: 250%;
  }

  @keyframes shimmer {
    from {
      background-position: -250% 0;
    }
    to {
      background-position: 250% 0;
    }
  }
`;
var __decorate$2V = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiShimmer = class WuiShimmer2 extends i$1 {
  constructor() {
    super(...arguments);
    this.width = "";
    this.height = "";
    this.borderRadius = "m";
    this.variant = "default";
  }
  render() {
    this.style.cssText = `
      width: ${this.width};
      height: ${this.height};
      border-radius: ${`clamp(0px,var(--wui-border-radius-${this.borderRadius}), 40px)`};
    `;
    return x$3`<slot></slot>`;
  }
};
WuiShimmer.styles = [styles$2h];
__decorate$2V([
  n$3()
], WuiShimmer.prototype, "width", void 0);
__decorate$2V([
  n$3()
], WuiShimmer.prototype, "height", void 0);
__decorate$2V([
  n$3()
], WuiShimmer.prototype, "borderRadius", void 0);
__decorate$2V([
  n$3()
], WuiShimmer.prototype, "variant", void 0);
WuiShimmer = __decorate$2V([
  customElement("cross-wui-shimmer")
], WuiShimmer);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t = { ATTRIBUTE: 1, CHILD: 2 }, e$2 = (t2) => (...e3) => ({ _$litDirective$: t2, values: e3 });
class i {
  constructor(t2) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t2, e3, i4) {
    this._$Ct = t2, this._$AM = e3, this._$Ci = i4;
  }
  _$AS(t2, e3) {
    return this.update(t2, e3);
  }
  update(t2, e3) {
    return this.render(...e3);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e$1 = e$2(class extends i {
  constructor(t$12) {
    var _a3;
    if (super(t$12), t$12.type !== t.ATTRIBUTE || "class" !== t$12.name || ((_a3 = t$12.strings) == null ? void 0 : _a3.length) > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(t2) {
    return " " + Object.keys(t2).filter((s2) => t2[s2]).join(" ") + " ";
  }
  update(s2, [i4]) {
    var _a3, _b2;
    if (void 0 === this.st) {
      this.st = /* @__PURE__ */ new Set(), void 0 !== s2.strings && (this.nt = new Set(s2.strings.join(" ").split(/\s/).filter((t2) => "" !== t2)));
      for (const t2 in i4) i4[t2] && !((_a3 = this.nt) == null ? void 0 : _a3.has(t2)) && this.st.add(t2);
      return this.render(i4);
    }
    const r3 = s2.element.classList;
    for (const t2 of this.st) t2 in i4 || (r3.remove(t2), this.st.delete(t2));
    for (const t2 in i4) {
      const s3 = !!i4[t2];
      s3 === this.st.has(t2) || ((_b2 = this.nt) == null ? void 0 : _b2.has(t2)) || (s3 ? (r3.add(t2), this.st.add(t2)) : (r3.remove(t2), this.st.delete(t2)));
    }
    return T$2;
  }
});
const styles$2g = i$4`
  :host {
    display: inline-flex !important;
  }

  slot {
    width: 100%;
    display: inline-block;
    font-style: normal;
    font-family: var(--wui-font-family);
    font-feature-settings:
      'tnum' on,
      'lnum' on,
      'case' on;
    line-height: 130%;
    font-weight: var(--wui-font-weight-regular);
    overflow: inherit;
    text-overflow: inherit;
    text-align: var(--local-align);
    color: var(--local-color);
  }

  .wui-line-clamp-1 {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 1;
  }

  .wui-line-clamp-2 {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 2;
  }

  .wui-font-medium-400 {
    font-size: var(--wui-font-size-medium);
    font-weight: var(--wui-font-weight-light);
    letter-spacing: var(--wui-letter-spacing-medium);
  }

  .wui-font-medium-600 {
    font-size: var(--wui-font-size-medium);
    letter-spacing: var(--wui-letter-spacing-medium);
  }

  .wui-font-title-600 {
    font-size: var(--wui-font-size-title);
    letter-spacing: var(--wui-letter-spacing-title);
  }

  .wui-font-title-6-600 {
    font-size: var(--wui-font-size-title-6);
    letter-spacing: var(--wui-letter-spacing-title-6);
  }

  .wui-font-mini-700 {
    font-size: var(--wui-font-size-mini);
    letter-spacing: var(--wui-letter-spacing-mini);
    text-transform: uppercase;
  }

  .wui-font-large-500,
  .wui-font-large-600,
  .wui-font-large-700 {
    font-size: var(--wui-font-size-large);
    letter-spacing: var(--wui-letter-spacing-large);
  }

  .wui-font-2xl-500,
  .wui-font-2xl-600,
  .wui-font-2xl-700 {
    font-size: var(--wui-font-size-2xl);
    letter-spacing: var(--wui-letter-spacing-2xl);
  }

  .wui-font-paragraph-400,
  .wui-font-paragraph-500,
  .wui-font-paragraph-600,
  .wui-font-paragraph-700 {
    font-size: var(--wui-font-size-paragraph);
    letter-spacing: var(--wui-letter-spacing-paragraph);
  }

  .wui-font-small-400,
  .wui-font-small-500,
  .wui-font-small-600 {
    font-size: var(--wui-font-size-small);
    letter-spacing: var(--wui-letter-spacing-small);
  }

  .wui-font-tiny-400,
  .wui-font-tiny-500,
  .wui-font-tiny-600 {
    font-size: var(--wui-font-size-tiny);
    letter-spacing: var(--wui-letter-spacing-tiny);
  }

  .wui-font-micro-700,
  .wui-font-micro-600 {
    font-size: var(--wui-font-size-micro);
    letter-spacing: var(--wui-letter-spacing-micro);
    text-transform: uppercase;
  }

  .wui-font-tiny-400,
  .wui-font-small-400,
  .wui-font-medium-400,
  .wui-font-paragraph-400 {
    font-weight: var(--wui-font-weight-light);
  }

  .wui-font-large-700,
  .wui-font-paragraph-700,
  .wui-font-micro-700,
  .wui-font-mini-700 {
    font-weight: var(--wui-font-weight-bold);
  }

  .wui-font-medium-600,
  .wui-font-medium-title-600,
  .wui-font-title-6-600,
  .wui-font-large-600,
  .wui-font-paragraph-600,
  .wui-font-small-600,
  .wui-font-tiny-600,
  .wui-font-micro-600 {
    font-weight: var(--wui-font-weight-medium);
  }

  :host([disabled]) {
    opacity: 0.4;
  }
`;
var __decorate$2U = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiText = class WuiText2 extends i$1 {
  constructor() {
    super(...arguments);
    this.variant = "paragraph-500";
    this.color = "fg-300";
    this.align = "left";
    this.lineClamp = void 0;
  }
  render() {
    const classes = {
      [`wui-font-${this.variant}`]: true,
      [`wui-color-${this.color}`]: true,
      [`wui-line-clamp-${this.lineClamp}`]: this.lineClamp ? true : false
    };
    this.style.cssText = `
      --local-align: ${this.align};
      --local-color: var(--wui-color-${this.color});
    `;
    return x$3`<slot class=${e$1(classes)}></slot>`;
  }
};
WuiText.styles = [resetStyles, styles$2g];
__decorate$2U([
  n$3()
], WuiText.prototype, "variant", void 0);
__decorate$2U([
  n$3()
], WuiText.prototype, "color", void 0);
__decorate$2U([
  n$3()
], WuiText.prototype, "align", void 0);
__decorate$2U([
  n$3()
], WuiText.prototype, "lineClamp", void 0);
WuiText = __decorate$2U([
  customElement("cross-wui-text")
], WuiText);
const browserSvg = b$2`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#1DC956" rx="30" />
  <circle cx="30" cy="30" r="3" fill="#fff" />
  <path
    fill="#2BEE6C"
    stroke="#fff"
    stroke-width="2"
    d="m45.32 17.9-.88-.42.88.42.02-.05c.1-.2.21-.44.26-.7l-.82-.15.82.16a2 2 0 0 0-.24-1.4c-.13-.23-.32-.42-.47-.57a8.42 8.42 0 0 1-.04-.04l-.04-.04a2.9 2.9 0 0 0-.56-.47l-.51.86.5-.86a2 2 0 0 0-1.4-.24c-.26.05-.5.16-.69.26l-.05.02-15.05 7.25-.1.05c-1.14.55-1.85.89-2.46 1.37a7 7 0 0 0-1.13 1.14c-.5.6-.83 1.32-1.38 2.45l-.05.11-7.25 15.05-.02.05c-.1.2-.21.43-.26.69a2 2 0 0 0 .24 1.4l.85-.5-.85.5c.13.23.32.42.47.57l.04.04.04.04c.15.15.34.34.56.47a2 2 0 0 0 1.41.24l-.2-.98.2.98c.25-.05.5-.17.69-.26l.05-.02-.42-.87.42.87 15.05-7.25.1-.05c1.14-.55 1.85-.89 2.46-1.38a7 7 0 0 0 1.13-1.13 12.87 12.87 0 0 0 1.43-2.56l7.25-15.05Z"
  />
  <path
    fill="#1DC956"
    d="M33.38 32.72 30.7 29.3 15.86 44.14l.2.2a1 1 0 0 0 1.14.2l15.1-7.27a3 3 0 0 0 1.08-4.55Z"
  />
  <path
    fill="#86F999"
    d="m26.62 27.28 2.67 3.43 14.85-14.85-.2-.2a1 1 0 0 0-1.14-.2l-15.1 7.27a3 3 0 0 0-1.08 4.55Z"
  />
  <circle cx="30" cy="30" r="3" fill="#fff" transform="rotate(45 30 30)" />
  <rect width="59" height="59" x=".5" y=".5" stroke="#062B2B" stroke-opacity=".1" rx="29.5" />
</svg> `;
const coinbaseSvg = b$2`<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40" fill="none">
  <g clip-path="url(#clip0_187_29)">
    <path d="M1.18187e-05 15.8055C1.18187e-05 9.8015 -5.19442e-07 6.91338 1.69991e-08 0C4.5 3.72236e-05 9.62249 0 16.5 0L23.5 4.31399e-05C29.9349 4.31399e-05 35.5 0.000206332 40 3.73468e-05C40 2.77754 40 9.36708 40 15.8055V22.8364C40 29.2647 40 33.7962 40 40C31.5 40 29.8337 40 23.4 40H16.6C10.5092 40 6.50004 40 4.04289e-05 40C3.05176e-05 32.2453 1.18187e-05 29.6382 1.18187e-05 22.8364V15.8055Z" fill="#0052FF"/>
    <path d="M20.0236 26.5C16.4342 26.5 13.5236 23.5931 13.5236 20C13.5236 16.4069 16.4342 13.5 20.0236 13.5C23.2411 13.5 25.9134 15.8472 26.4261 18.9167H32.9731C32.4206 12.2433 26.8342 7 20.02 7C12.8411 7 7.02002 12.8211 7.02002 20C7.02002 27.1789 12.8411 33 20.02 33C26.8342 33 32.4206 27.7567 32.9731 21.0833H26.4225C25.9061 24.1528 23.2411 26.5 20.0236 26.5Z" fill="white"/>
  </g>
  <defs>
    <clipPath id="clip0_187_29">
      <rect width="40" height="40" fill="white"/>
    </clipPath>
  </defs>
</svg>`;
const daoSvg = b$2`<svg viewBox="0 0 60 60" fill="none">
  <g clip-path="url(#clip0_7734_50402)">
    <path
      d="M0 24.9C0 15.6485 0 11.0228 1.97053 7.56812C3.3015 5.23468 5.23468 3.3015 7.56812 1.97053C11.0228 0 15.6485 0 24.9 0H35.1C44.3514 0 48.9772 0 52.4319 1.97053C54.7653 3.3015 56.6985 5.23468 58.0295 7.56812C60 11.0228 60 15.6485 60 24.9V35.1C60 44.3514 60 48.9772 58.0295 52.4319C56.6985 54.7653 54.7653 56.6985 52.4319 58.0295C48.9772 60 44.3514 60 35.1 60H24.9C15.6485 60 11.0228 60 7.56812 58.0295C5.23468 56.6985 3.3015 54.7653 1.97053 52.4319C0 48.9772 0 44.3514 0 35.1V24.9Z"
      fill="#EB8B47"
    />
    <path
      d="M0.5 24.9C0.5 20.2652 0.50047 16.8221 0.744315 14.105C0.987552 11.3946 1.46987 9.45504 2.40484 7.81585C3.69145 5.56019 5.56019 3.69145 7.81585 2.40484C9.45504 1.46987 11.3946 0.987552 14.105 0.744315C16.8221 0.50047 20.2652 0.5 24.9 0.5H35.1C39.7348 0.5 43.1779 0.50047 45.895 0.744315C48.6054 0.987552 50.545 1.46987 52.1841 2.40484C54.4398 3.69145 56.3086 5.56019 57.5952 7.81585C58.5301 9.45504 59.0124 11.3946 59.2557 14.105C59.4995 16.8221 59.5 20.2652 59.5 24.9V35.1C59.5 39.7348 59.4995 43.1779 59.2557 45.895C59.0124 48.6054 58.5301 50.545 57.5952 52.1841C56.3086 54.4398 54.4398 56.3086 52.1841 57.5952C50.545 58.5301 48.6054 59.0124 45.895 59.2557C43.1779 59.4995 39.7348 59.5 35.1 59.5H24.9C20.2652 59.5 16.8221 59.4995 14.105 59.2557C11.3946 59.0124 9.45504 58.5301 7.81585 57.5952C5.56019 56.3086 3.69145 54.4398 2.40484 52.1841C1.46987 50.545 0.987552 48.6054 0.744315 45.895C0.50047 43.1779 0.5 39.7348 0.5 35.1V24.9Z"
      stroke="#062B2B"
      stroke-opacity="0.1"
    />
    <path
      d="M19 52C24.5228 52 29 47.5228 29 42C29 36.4772 24.5228 32 19 32C13.4772 32 9 36.4772 9 42C9 47.5228 13.4772 52 19 52Z"
      fill="#FF974C"
      stroke="white"
      stroke-width="2"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M42.8437 8.3264C42.4507 7.70891 41.5493 7.70891 41.1564 8.32641L28.978 27.4638C28.5544 28.1295 29.0326 29.0007 29.8217 29.0007H54.1783C54.9674 29.0007 55.4456 28.1295 55.022 27.4638L42.8437 8.3264Z"
      fill="white"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M42.3348 11.6456C42.659 11.7608 42.9061 12.1492 43.4005 12.926L50.7332 24.4488C51.2952 25.332 51.5763 25.7737 51.5254 26.1382C51.4915 26.3808 51.3698 26.6026 51.1833 26.7614C50.9031 27 50.3796 27 49.3327 27H34.6673C33.6204 27 33.0969 27 32.8167 26.7614C32.6302 26.6026 32.5085 26.3808 32.4746 26.1382C32.4237 25.7737 32.7048 25.332 33.2669 24.4488L40.5995 12.926C41.0939 12.1492 41.341 11.7608 41.6652 11.6456C41.8818 11.5687 42.1182 11.5687 42.3348 11.6456ZM35.0001 26.999C38.8661 26.999 42.0001 23.865 42.0001 19.999C42.0001 23.865 45.1341 26.999 49.0001 26.999H35.0001Z"
      fill="#FF974C"
    />
    <path
      d="M10.1061 9.35712C9.9973 9.67775 9.99867 10.0388 9.99978 10.3323C9.99989 10.3611 10 10.3893 10 10.4167V25.5833C10 25.6107 9.99989 25.6389 9.99978 25.6677C9.99867 25.9612 9.9973 26.3222 10.1061 26.6429C10.306 27.2317 10.7683 27.694 11.3571 27.8939C11.6777 28.0027 12.0388 28.0013 12.3323 28.0002C12.3611 28.0001 12.3893 28 12.4167 28H19C24.5228 28 29 23.5228 29 18C29 12.4772 24.5228 8 19 8H12.4167C12.3893 8 12.3611 7.99989 12.3323 7.99978C12.0388 7.99867 11.6778 7.9973 11.3571 8.10614C10.7683 8.306 10.306 8.76834 10.1061 9.35712Z"
      fill="#FF974C"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="19" cy="18" r="4" fill="#EB8B47" stroke="white" stroke-width="2" />
    <circle cx="19" cy="42" r="4" fill="#EB8B47" stroke="white" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="clip0_7734_50402">
      <rect width="60" height="60" fill="white" />
    </clipPath>
  </defs>
</svg> `;
const defiSvg = b$2`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <path
      fill="#1DC956"
      d="M0 25.01c0-9.25 0-13.88 1.97-17.33a15 15 0 0 1 5.6-5.6C11.02.11 15.65.11 24.9.11h10.2c9.25 0 13.88 0 17.33 1.97a15 15 0 0 1 5.6 5.6C60 11.13 60 15.76 60 25v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6c-3.45 1.97-8.08 1.97-17.33 1.97H24.9c-9.25 0-13.88 0-17.33-1.97a15 15 0 0 1-5.6-5.6C0 49.1 0 44.46 0 35.21v-10.2Z"
    />
    <path
      fill="#2BEE6C"
      d="M16.1 60c-3.82-.18-6.4-.64-8.53-1.86a15 15 0 0 1-5.6-5.6C.55 50.06.16 46.97.04 41.98L4.2 40.6a4 4 0 0 0 2.48-2.39l4.65-12.4a2 2 0 0 1 2.5-1.2l2.53.84a2 2 0 0 0 2.43-1l2.96-5.94a2 2 0 0 1 3.7.32l3.78 12.58a2 2 0 0 0 3.03 1.09l3.34-2.23a2 2 0 0 0 .65-.7l5.3-9.72a2 2 0 0 1 1.42-1.01l4.14-.69a2 2 0 0 1 1.6.44l3.9 3.24a2 2 0 0 0 2.7-.12l4.62-4.63c.08 2.2.08 4.8.08 7.93v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6c-2.13 1.22-4.7 1.68-8.54 1.86H16.11Z"
    />
    <path
      fill="#fff"
      d="m.07 43.03-.05-2.1 3.85-1.28a3 3 0 0 0 1.86-1.79l4.66-12.4a3 3 0 0 1 3.75-1.8l2.53.84a1 1 0 0 0 1.21-.5l2.97-5.94a3 3 0 0 1 5.56.48l3.77 12.58a1 1 0 0 0 1.51.55l3.34-2.23a1 1 0 0 0 .33-.35l5.3-9.71a3 3 0 0 1 2.14-1.53l4.13-.69a3 3 0 0 1 2.41.66l3.9 3.24a1 1 0 0 0 1.34-.06l5.28-5.28c.05.85.08 1.75.1 2.73L56 22.41a3 3 0 0 1-4.04.19l-3.9-3.25a1 1 0 0 0-.8-.21l-4.13.69a1 1 0 0 0-.72.5l-5.3 9.72a3 3 0 0 1-.97 1.05l-3.34 2.23a3 3 0 0 1-4.53-1.63l-3.78-12.58a1 1 0 0 0-1.85-.16l-2.97 5.94a3 3 0 0 1-3.63 1.5l-2.53-.84a1 1 0 0 0-1.25.6l-4.65 12.4a5 5 0 0 1-3.1 3L.07 43.02Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M49.5 19a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z"
      clip-rule="evenodd"
    />
    <path fill="#fff" d="M45 .28v59.66l-2 .1V.19c.7.02 1.37.05 2 .1Z" />
    <path fill="#2BEE6C" d="M47.5 19a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0Z" />
    <path
      stroke="#fff"
      stroke-opacity=".1"
      d="M.5 25.01c0-4.63 0-8.08.24-10.8.25-2.7.73-4.64 1.66-6.28a14.5 14.5 0 0 1 5.42-5.41C9.46 1.58 11.39 1.1 14.1.85A133 133 0 0 1 24.9.61h10.2c4.63 0 8.08 0 10.8.24 2.7.25 4.65.73 6.28 1.67a14.5 14.5 0 0 1 5.42 5.4c.93 1.65 1.41 3.58 1.66 6.3.24 2.71.24 6.16.24 10.79v10.2c0 4.64 0 8.08-.24 10.8-.25 2.7-.73 4.65-1.66 6.28a14.5 14.5 0 0 1-5.42 5.42c-1.63.93-3.57 1.41-6.28 1.66-2.72.24-6.17.24-10.8.24H24.9c-4.63 0-8.08 0-10.8-.24-2.7-.25-4.64-.73-6.28-1.66a14.5 14.5 0 0 1-5.42-5.42C1.47 50.66 1 48.72.74 46.01A133 133 0 0 1 .5 35.2v-10.2Z"
    />
  </g>
  <defs>
    <clipPath id="a"><path fill="#fff" d="M0 0h60v60H0z" /></clipPath>
  </defs>
</svg>`;
const defiAltSvg = b$2`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#C653C6" rx="30" />
    <path
      fill="#E87DE8"
      d="M57.98.01v19.5a4.09 4.09 0 0 0-2.63 2.29L50.7 34.2a2 2 0 0 1-2.5 1.2l-2.53-.84a2 2 0 0 0-2.42 1l-2.97 5.94a2 2 0 0 1-3.7-.32L32.8 28.6a2 2 0 0 0-3.02-1.09l-3.35 2.23a2 2 0 0 0-.64.7l-5.3 9.72a2 2 0 0 1-1.43 1.01l-4.13.69a2 2 0 0 1-1.61-.44l-3.9-3.24a2 2 0 0 0-2.69.12L2.1 42.93.02 43V.01h57.96Z"
    />
    <path
      fill="#fff"
      d="m61.95 16.94.05 2.1-3.85 1.28a3 3 0 0 0-1.86 1.79l-4.65 12.4a3 3 0 0 1-3.76 1.8l-2.53-.84a1 1 0 0 0-1.2.5l-2.98 5.94a3 3 0 0 1-5.55-.48l-3.78-12.58a1 1 0 0 0-1.5-.55l-3.35 2.23a1 1 0 0 0-.32.35l-5.3 9.72a3 3 0 0 1-2.14 1.52l-4.14.69a3 3 0 0 1-2.41-.66l-3.9-3.24a1 1 0 0 0-1.34.06l-5.28 5.28c-.05-.84-.08-1.75-.1-2.73l3.97-3.96a3 3 0 0 1 4.04-.19l3.89 3.25a1 1 0 0 0 .8.21l4.14-.68a1 1 0 0 0 .71-.51l5.3-9.71a3 3 0 0 1 .97-1.06l3.34-2.23a3 3 0 0 1 4.54 1.63l3.77 12.58a1 1 0 0 0 1.86.16l2.96-5.93a3 3 0 0 1 3.64-1.5l2.52.83a1 1 0 0 0 1.25-.6l4.66-12.4a5 5 0 0 1 3.1-2.99l4.43-1.48Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M35.5 27a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z"
      clip-rule="evenodd"
    />
    <path fill="#fff" d="M31 0v60h-2V0h2Z" />
    <path fill="#E87DE8" d="M33.5 27a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0Z" />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg> `;
const ethSvg = b$2`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#987DE8" rx="30" />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="m15.48 28.37 11.97-19.3a3 3 0 0 1 5.1 0l11.97 19.3a6 6 0 0 1 .9 3.14v.03a6 6 0 0 1-1.16 3.56L33.23 50.2a4 4 0 0 1-6.46 0L15.73 35.1a6 6 0 0 1-1.15-3.54v-.03a6 6 0 0 1 .9-3.16Z"
      clip-rule="evenodd"
    />
    <path
      fill="#643CDD"
      d="M30.84 10.11a1 1 0 0 0-.84-.46V24.5l12.6 5.53a2 2 0 0 0-.28-1.4L30.84 10.11Z"
    />
    <path
      fill="#BDADEB"
      d="M30 9.65a1 1 0 0 0-.85.46L17.66 28.64a2 2 0 0 0-.26 1.39L30 24.5V9.65Z"
    />
    <path
      fill="#643CDD"
      d="M30 50.54a1 1 0 0 0 .8-.4l11.24-15.38c.3-.44-.2-1-.66-.73l-9.89 5.68a3 3 0 0 1-1.5.4v10.43Z"
    />
    <path
      fill="#BDADEB"
      d="m17.97 34.76 11.22 15.37c.2.28.5.41.8.41V40.11a3 3 0 0 1-1.49-.4l-9.88-5.68c-.47-.27-.97.3-.65.73Z"
    />
    <path
      fill="#401AB3"
      d="M42.6 30.03 30 24.5v13.14a3 3 0 0 0 1.5-.4l10.14-5.83a2 2 0 0 0 .95-1.38Z"
    />
    <path
      fill="#7C5AE2"
      d="M30 37.64V24.46l-12.6 5.57a2 2 0 0 0 .97 1.39l10.13 5.82a3 3 0 0 0 1.5.4Z"
    />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg> `;
const googleSvg = b$2`<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
  <rect width="64" height="64" rx="30" fill="#1DC956"/>
  <rect x="0.5" y="0.5" width="63" height="63" rx="29.5" stroke="#141414" stroke-opacity="0.1"/>
  <path d="M32.4053 19.8031C35.3901 19.8031 38.0431 20.8349 40.1619 22.8247L45.9656 17.0211C42.4465 13.7416 37.8773 11.7333 32.4053 11.7333C24.4829 11.7333 17.6475 16.2841 14.3127 22.9168L21.056 28.1493C22.6589 23.359 27.136 19.8031 32.4053 19.8031Z" fill="#1DC956" stroke="white" stroke-width="2" stroke-linejoin="round"/>
  <path d="M32.4053 52.2667C37.8773 52.2667 42.465 50.4611 45.8182 47.3658L39.2407 42.2623C37.4351 43.4783 35.1321 44.2153 32.4053 44.2153C27.136 44.2153 22.6589 40.6594 21.056 35.8691L14.3127 41.1016C17.6475 47.7159 24.4829 52.2667 32.4053 52.2667Z" fill="#2BEE6C"/>
  <path d="M21.056 35.8507L19.5636 36.993L14.3127 41.0832M39.2407 42.2623L45.8182 47.3658C42.465 50.4611 37.8773 52.2667 32.4053 52.2667C24.4829 52.2667 17.6475 47.7159 14.3127 41.1016L21.056 35.8691C22.6589 40.6594 27.136 44.2153 32.4053 44.2153C35.1321 44.2153 37.4351 43.4783 39.2407 42.2623Z" stroke="white" stroke-width="2" stroke-linejoin="round"/>
  <path d="M51.8613 32.4606C51.8613 31.0235 51.7323 29.6417 51.4928 28.3151H32.4053V36.1638H43.3124C42.8334 38.688 41.3963 40.8252 39.2407 42.2623L45.8181 47.3658C49.6503 43.8283 51.8613 38.6327 51.8613 32.4606Z" fill="#1FAD7E" stroke="white" stroke-width="2" stroke-linejoin="round"/>
  <path d="M21.056 35.8507C20.6507 34.6347 20.4111 33.345 20.4111 32C20.4111 30.655 20.6507 29.3653 21.056 28.1493L14.3127 22.9169C12.9309 25.6437 12.1387 28.7205 12.1387 32C12.1387 35.2795 12.9309 38.3564 14.3127 41.0831L19.5636 36.993L21.056 35.8507Z" fill="#86F999"/>
  <path d="M21.056 35.8691L14.3127 41.1016M21.056 35.8507C20.6507 34.6347 20.4111 33.345 20.4111 32C20.4111 30.655 20.6507 29.3653 21.056 28.1493L14.3127 22.9169C12.9309 25.6437 12.1387 28.7205 12.1387 32C12.1387 35.2795 12.9309 38.3564 14.3127 41.0831L19.5636 36.993L21.056 35.8507Z" stroke="white" stroke-width="2" stroke-linejoin="round"/>
</svg>
`;
const layersSvg = b$2`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#1DC956" rx="3" />
  <path
    fill="#1FAD7E"
    stroke="#fff"
    stroke-width="2"
    d="m30.49 29.13-.49-.27-.49.27-12.77 7.1-.05.02c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45l-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-12.77-7.1Z"
  />
  <path
    fill="#2BEE6C"
    stroke="#fff"
    stroke-width="2"
    d="m30.49 19.13-.49-.27-.49.27-12.77 7.1-.05.02c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45l-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-12.77-7.1Z"
  />
  <path
    fill="#86F999"
    stroke="#fff"
    stroke-width="2"
    d="m46.69 21.06-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-6.32-3.51-.18-.1c-2.33-1.3-3.72-2.06-5.22-2.33a9 9 0 0 0-3.08 0c-1.5.27-2.9 1.04-5.22 2.33l-.17.1-6.33 3.51-.05.03c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45Z"
  />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`;
const lightbulbSvg = b$2`<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
  <g clip-path="url(#clip0_241_31636)">
    <path d="M0 26.5595C0 16.6913 0 11.7572 2.1019 8.07217C3.5216 5.58318 5.58366 3.52111 8.07266 2.10141C11.7577 -0.000488281 16.6918 -0.000488281 26.56 -0.000488281H37.44C47.3082 -0.000488281 52.2423 -0.000488281 55.9273 2.10141C58.4163 3.52111 60.4784 5.58318 61.8981 8.07217C64 11.7572 64 16.6913 64 26.5595V37.4395C64 47.3077 64 52.2418 61.8981 55.9269C60.4784 58.4159 58.4163 60.4779 55.9273 61.8976C52.2423 63.9995 47.3082 63.9995 37.44 63.9995H26.56C16.6918 63.9995 11.7577 63.9995 8.07266 61.8976C5.58366 60.4779 3.5216 58.4159 2.1019 55.9269C0 52.2418 0 47.3077 0 37.4395V26.5595Z" fill="#794CFF"/>
    <path d="M0.5 26.5595C0.5 21.6163 0.50047 17.942 0.760736 15.0418C1.02039 12.1485 1.53555 10.0742 2.53621 8.3199C3.91155 5.90869 5.90917 3.91106 8.32039 2.53572C10.0747 1.53506 12.1489 1.01991 15.0423 0.760247C17.9425 0.499981 21.6168 0.499512 26.56 0.499512H37.44C42.3832 0.499512 46.0575 0.499981 48.9577 0.760247C51.8511 1.01991 53.9253 1.53506 55.6796 2.53572C58.0908 3.91106 60.0885 5.90869 61.4638 8.3199C62.4645 10.0742 62.9796 12.1485 63.2393 15.0418C63.4995 17.942 63.5 21.6163 63.5 26.5595V37.4395C63.5 42.3827 63.4995 46.057 63.2393 48.9572C62.9796 51.8506 62.4645 53.9248 61.4638 55.6791C60.0885 58.0903 58.0908 60.088 55.6796 61.4633C53.9253 62.464 51.8511 62.9791 48.9577 63.2388C46.0575 63.499 42.3832 63.4995 37.44 63.4995H26.56C21.6168 63.4995 17.9425 63.499 15.0423 63.2388C12.1489 62.9791 10.0747 62.464 8.32039 61.4633C5.90917 60.088 3.91155 58.0903 2.53621 55.6791C1.53555 53.9248 1.02039 51.8506 0.760736 48.9572C0.50047 46.057 0.5 42.3827 0.5 37.4395V26.5595Z" stroke="#141414" stroke-opacity="0.1"/>
    <path d="M40 39.4595C44.7824 36.693 48 31.5222 48 25.6C48 16.7634 40.8366 9.59998 32 9.59998C23.1634 9.59998 16 16.7634 16 25.6C16 31.5222 19.2176 36.693 24 39.4595V45.8144H40V39.4595Z" fill="#906EF7"/>
    <path d="M24 49.9689C24 51.8192 24 52.7444 24.3941 53.4353C24.6603 53.902 25.0469 54.2886 25.5136 54.5548C26.2046 54.9489 27.1297 54.9489 28.98 54.9489H35.02C36.8703 54.9489 37.7954 54.9489 38.4864 54.5548C38.9531 54.2886 39.3397 53.902 39.6059 53.4353C40 52.7444 40 51.8192 40 49.9689V45.8144H24V49.9689Z" fill="#906EF7"/>
    <path d="M24 45.8144V39.4595C19.2176 36.693 16 31.5222 16 25.6C16 16.7634 23.1634 9.59998 32 9.59998C40.8366 9.59998 48 16.7634 48 25.6C48 31.5222 44.7824 36.693 40 39.4595V45.8144M24 45.8144H40M24 45.8144V49.9689C24 51.8192 24 52.7444 24.3941 53.4353C24.6603 53.902 25.0469 54.2886 25.5136 54.5548C26.2046 54.9489 27.1297 54.9489 28.98 54.9489H35.02C36.8703 54.9489 37.7954 54.9489 38.4864 54.5548C38.9531 54.2886 39.3397 53.902 39.6059 53.4353C40 52.7444 40 51.8192 40 49.9689V45.8144" stroke="white" stroke-width="2" stroke-linejoin="round"/>
    <path d="M24 49.9689C24 51.8192 24 52.7444 24.3941 53.4353C24.6603 53.902 25.0469 54.2886 25.5136 54.5548C26.2046 54.9489 27.1297 54.9489 28.98 54.9489H35.02C36.8703 54.9489 37.7954 54.9489 38.4864 54.5548C38.9531 54.2886 39.3397 53.902 39.6059 53.4353C40 52.7444 40 51.8192 40 49.9689V45.8144H24V49.9689Z" fill="#643CDD" stroke="white" stroke-width="2" stroke-linejoin="round"/>
    <path d="M29.6735 26.9101V29.1109H34.0753V26.9101C34.0753 25.6945 35.0607 24.7092 36.2762 24.7092C37.4917 24.7092 38.4771 25.6945 38.4771 26.9101C38.4771 28.1256 37.4917 29.1109 36.2762 29.1109H34.0753H29.6735H27.4726C26.2571 29.1109 25.2717 28.1256 25.2717 26.9101C25.2717 25.6945 26.2571 24.7092 27.4726 24.7092C28.6881 24.7092 29.6735 25.6945 29.6735 26.9101Z" fill="#906EF7"/>
    <path d="M29.6735 45.3183V26.9101C29.6735 25.6945 28.6881 24.7092 27.4726 24.7092V24.7092C26.2571 24.7092 25.2717 25.6945 25.2717 26.9101V26.9101C25.2717 28.1256 26.2571 29.1109 27.4726 29.1109H36.2762C37.4917 29.1109 38.4771 28.1256 38.4771 26.9101V26.9101C38.4771 25.6945 37.4917 24.7092 36.2762 24.7092V24.7092C35.0607 24.7092 34.0753 25.6945 34.0753 26.9101V45.3183" stroke="white" stroke-width="2" stroke-linejoin="round"/>
  </g>
  <defs>
    <clipPath id="clip0_241_31636">
      <rect width="64" height="64" fill="white"/>
    </clipPath>
  </defs>
</svg>
`;
const lockSvg = b$2`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#C653C6" rx="3" />
  <path
    fill="#fff"
    d="M20.03 15.22C20 15.6 20 16.07 20 17v2.8c0 1.14 0 1.7-.2 2.12-.15.31-.3.5-.58.71-.37.28-1.06.42-2.43.7-.59.12-1.11.29-1.6.51a9 9 0 0 0-4.35 4.36C10 30 10 32.34 10 37c0 4.66 0 7 .84 8.8a9 9 0 0 0 4.36 4.36C17 51 19.34 51 24 51h12c4.66 0 7 0 8.8-.84a9 9 0 0 0 4.36-4.36C50 44 50 41.66 50 37c0-4.66 0-7-.84-8.8a9 9 0 0 0-4.36-4.36c-.48-.22-1-.39-1.6-.5-1.36-.29-2.05-.43-2.42-.7-.27-.22-.43-.4-.58-.72-.2-.42-.2-.98-.2-2.11V17c0-.93 0-1.4-.03-1.78a9 9 0 0 0-8.19-8.19C31.4 7 30.93 7 30 7s-1.4 0-1.78.03a9 9 0 0 0-8.19 8.19Z"
  />
  <path
    fill="#E87DE8"
    d="M22 17c0-.93 0-1.4.04-1.78a7 7 0 0 1 6.18-6.18C28.6 9 29.07 9 30 9s1.4 0 1.78.04a7 7 0 0 1 6.18 6.18c.04.39.04.85.04 1.78v4.5a1.5 1.5 0 0 1-3 0V17c0-.93 0-1.4-.08-1.78a4 4 0 0 0-3.14-3.14C31.39 12 30.93 12 30 12s-1.4 0-1.78.08a4 4 0 0 0-3.14 3.14c-.08.39-.08.85-.08 1.78v4.5a1.5 1.5 0 0 1-3 0V17Z"
  />
  <path
    fill="#E87DE8"
    fill-rule="evenodd"
    d="M12 36.62c0-4.32 0-6.48.92-8.09a7 7 0 0 1 2.61-2.61C17.14 25 19.3 25 23.62 25h6.86c.46 0 .7 0 .9.02 2.73.22 4.37 2.43 4.62 4.98.27-2.7 2.11-5 5.02-5A6.98 6.98 0 0 1 48 31.98v5.4c0 4.32 0 6.48-.92 8.09a7 7 0 0 1-2.61 2.61c-1.61.92-3.77.92-8.09.92h-5.86c-.46 0-.7 0-.9-.02-2.73-.22-4.37-2.43-4.62-4.98-.26 2.58-1.94 4.82-4.71 4.99l-.7.01c-.55 0-.82 0-1.05-.02a7 7 0 0 1-6.52-6.52c-.02-.23-.02-.5-.02-1.05v-4.79Zm21.24-.27a4 4 0 1 0-6.48 0 31.28 31.28 0 0 1 1.57 2.23c.17.4.17.81.17 1.24V42.5a1.5 1.5 0 0 0 3 0V39.82c0-.43 0-.85.17-1.24.09-.2.58-.87 1.57-2.23Z"
    clip-rule="evenodd"
  />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`;
const loginSvg = b$2`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <path
      fill="#EB8B47"
      d="M0 24.9c0-9.25 0-13.88 1.97-17.33a15 15 0 0 1 5.6-5.6C11.02 0 15.65 0 24.9 0h10.2c9.25 0 13.88 0 17.33 1.97a15 15 0 0 1 5.6 5.6C60 11.02 60 15.65 60 24.9v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6C48.98 60 44.35 60 35.1 60H24.9c-9.25 0-13.88 0-17.33-1.97a15 15 0 0 1-5.6-5.6C0 48.98 0 44.35 0 35.1V24.9Z"
    />
    <path
      stroke="#062B2B"
      stroke-opacity=".1"
      d="M.5 24.9c0-4.64 0-8.08.24-10.8.25-2.7.73-4.65 1.66-6.28A14.5 14.5 0 0 1 7.82 2.4C9.46 1.47 11.39 1 14.1.74A133 133 0 0 1 24.9.5h10.2c4.63 0 8.08 0 10.8.24 2.7.25 4.65.73 6.28 1.66a14.5 14.5 0 0 1 5.42 5.42c.93 1.63 1.41 3.57 1.66 6.28.24 2.72.24 6.16.24 10.8v10.2c0 4.63 0 8.08-.24 10.8-.25 2.7-.73 4.64-1.66 6.28a14.5 14.5 0 0 1-5.42 5.41c-1.63.94-3.57 1.42-6.28 1.67-2.72.24-6.17.24-10.8.24H24.9c-4.63 0-8.08 0-10.8-.24-2.7-.25-4.64-.73-6.28-1.67a14.5 14.5 0 0 1-5.42-5.4C1.47 50.53 1 48.6.74 45.88A133 133 0 0 1 .5 35.1V24.9Z"
    />
    <path
      fill="#FF974C"
      stroke="#fff"
      stroke-width="2"
      d="M39.2 29.2a13 13 0 1 0-18.4 0l1.3 1.28a12.82 12.82 0 0 1 2.1 2.39 6 6 0 0 1 .6 1.47c.2.76.2 1.56.2 3.17v11.24c0 1.08 0 1.61.13 2.12a4 4 0 0 0 .41.98c.26.45.64.83 1.4 1.6l.3.29c.65.65.98.98 1.36 1.09.26.07.54.07.8 0 .38-.11.7-.44 1.36-1.1l3.48-3.47c.65-.65.98-.98 1.09-1.36a1.5 1.5 0 0 0 0-.8c-.1-.38-.44-.7-1.1-1.36l-.47-.48c-.65-.65-.98-.98-1.09-1.36a1.5 1.5 0 0 1 0-.8c.1-.38.44-.7 1.1-1.36l.47-.48c.65-.65.98-.98 1.09-1.36a1.5 1.5 0 0 0 0-.8c-.1-.38-.44-.7-1.1-1.36l-.48-.5c-.65-.64-.98-.97-1.08-1.35a1.5 1.5 0 0 1 0-.79c.1-.38.42-.7 1.06-1.36l5.46-5.55Z"
    />
    <circle cx="30" cy="17" r="4" fill="#EB8B47" stroke="#fff" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="a"><path fill="#fff" d="M0 0h60v60H0z" /></clipPath>
  </defs>
</svg> `;
const meldSvg = b$2`<svg width="40" height="42" viewBox="0 0 40 42" fill="none">
<path opacity="0.7" d="M19.9526 41.9076L7.3877 34.655V26.1226L19.9526 33.3751V41.9076Z" fill="url(#paint0_linear_2113_32117)"/>
<path opacity="0.7" d="M19.9521 41.9076L32.5171 34.655V26.1226L19.9521 33.3751V41.9076Z" fill="url(#paint1_linear_2113_32117)"/>
<path opacity="0.7" d="M39.9095 7.34521V21.8562L32.5166 26.1225V11.6114L39.9095 7.34521Z" fill="url(#paint2_linear_2113_32117)"/>
<path d="M39.9099 7.34536L27.345 0.0927734L19.9521 4.359L32.5171 11.6116L39.9099 7.34536Z" fill="url(#paint3_linear_2113_32117)"/>
<path d="M0 7.34536L12.5649 0.0927734L19.9519 4.359L7.387 11.6116L0 7.34536Z" fill="#F969D3"/>
<path opacity="0.7" d="M0 7.34521V21.8562L7.387 26.1225V11.6114L0 7.34521Z" fill="url(#paint4_linear_2113_32117)"/>
<defs>
<linearGradient id="paint0_linear_2113_32117" x1="18.6099" y1="41.8335" x2="7.73529" y2="8.31842" gradientUnits="userSpaceOnUse">
<stop stop-color="#E98ADA"/>
<stop offset="1" stop-color="#7E4DBD"/>
</linearGradient>
<linearGradient id="paint1_linear_2113_32117" x1="26.2346" y1="26.1226" x2="26.2346" y2="41.9076" gradientUnits="userSpaceOnUse">
<stop stop-color="#719DED"/>
<stop offset="1" stop-color="#2545BE"/>
</linearGradient>
<linearGradient id="paint2_linear_2113_32117" x1="36.213" y1="7.34521" x2="36.213" y2="26.1225" gradientUnits="userSpaceOnUse">
<stop stop-color="#93EBFF"/>
<stop offset="1" stop-color="#197DDB"/>
</linearGradient>
<linearGradient id="paint3_linear_2113_32117" x1="29.931" y1="0.0927734" x2="38.2156" y2="14.8448" gradientUnits="userSpaceOnUse">
<stop stop-color="#F969D3"/>
<stop offset="1" stop-color="#4F51C0"/>
</linearGradient>
<linearGradient id="paint4_linear_2113_32117" x1="18.1251" y1="44.2539" x2="-7.06792" y2="15.2763" gradientUnits="userSpaceOnUse">
<stop stop-color="#E98ADA"/>
<stop offset="1" stop-color="#7E4DBD"/>
</linearGradient>
</defs>
</svg>`;
const moonpaySvg = b$2`
  <svg width="40" height="40" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g clip-path="url(#a)">
      <path
        d="M0 16.6c0-6.168 0-9.251 1.314-11.555a10 10 0 0 1 3.731-3.731C7.35 0 10.432 0 16.6 0h6.8c6.168 0 9.252 0 11.555 1.314a10 10 0 0 1 3.731 3.731C40 7.35 40 10.432 40 16.6v6.8c0 6.168 0 9.252-1.314 11.555a10 10 0 0 1-3.731 3.731C32.652 40 29.568 40 23.4 40h-6.8c-6.168 0-9.251 0-11.555-1.314a10 10 0 0 1-3.731-3.731C0 32.652 0 29.568 0 23.4v-6.8Z"
        fill="#7D00FF"
      />
      <path
        d="M.5 16.6c0-3.093 0-5.38.162-7.182.161-1.795.48-3.061 1.086-4.125a9.5 9.5 0 0 1 3.545-3.545C6.357 1.141 7.623.823 9.418.662 11.221.5 13.508.5 16.6.5h6.8c3.093 0 5.38 0 7.182.162 1.795.161 3.062.48 4.125 1.086a9.5 9.5 0 0 1 3.545 3.545c.607 1.064.925 2.33 1.086 4.125.161 1.803.162 4.09.162 7.182v6.8c0 3.093 0 5.38-.162 7.182-.161 1.795-.48 3.062-1.086 4.125a9.5 9.5 0 0 1-3.545 3.545c-1.063.607-2.33.925-4.125 1.086-1.803.161-4.09.162-7.182.162h-6.8c-3.093 0-5.38 0-7.182-.162-1.795-.161-3.061-.48-4.125-1.086a9.5 9.5 0 0 1-3.545-3.545c-.607-1.063-.925-2.33-1.086-4.125C.5 28.779.5 26.492.5 23.4v-6.8Z"
        stroke="#fff"
        stroke-opacity=".05"
      />
      <path
        d="M28.306 15.381a3.69 3.69 0 1 0 0-7.381 3.69 3.69 0 0 0 0 7.381ZM16.987 32a8.991 8.991 0 1 1 .016-17.983A8.991 8.991 0 0 1 16.988 32Z"
        fill="#fff"
      />
    </g>
    <defs>
      <clipPath id="a"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    </defs>
  </svg>
`;
const networkSvg = b$2`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#00ACE6" rx="30" />
    <circle cx="64" cy="39" r="50" fill="#1AC6FF" stroke="#fff" stroke-width="2" />
    <circle cx="78" cy="30" r="50" fill="#4DD2FF" stroke="#fff" stroke-width="2" />
    <circle cx="72" cy="15" r="35" fill="#80DFFF" stroke="#fff" stroke-width="2" />
    <circle cx="34" cy="-17" r="45" stroke="#fff" stroke-width="2" />
    <circle cx="34" cy="-5" r="50" stroke="#fff" stroke-width="2" />
    <circle cx="30" cy="45" r="4" fill="#4DD2FF" stroke="#fff" stroke-width="2" />
    <circle cx="39.5" cy="27.5" r="4" fill="#80DFFF" stroke="#fff" stroke-width="2" />
    <circle cx="16" cy="24" r="4" fill="#19C6FF" stroke="#fff" stroke-width="2" />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#062B2B" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg>`;
const nftSvg = b$2`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#C653C6" rx="3" />
    <path
      fill="#E87DE8"
      stroke="#fff"
      stroke-width="2"
      d="M52.1 47.34c0-4.24-1.44-9.55-5.9-12.4a2.86 2.86 0 0 0-1.6-3.89v-.82c0-1.19-.52-2.26-1.35-3a4.74 4.74 0 0 0-2.4-6.26v-5.5a11.31 11.31 0 1 0-22.63 0v2.15a3.34 3.34 0 0 0-1.18 5.05 4.74 4.74 0 0 0-.68 6.44A5.22 5.22 0 0 0 14 35.92c-3.06 4.13-6.1 8.3-6.1 15.64 0 2.67.37 4.86.74 6.39a20.3 20.3 0 0 0 .73 2.39l.02.04v.01l.92-.39-.92.4.26.6h38.26l.3-.49-.87-.51.86.5.02-.01.03-.07a16.32 16.32 0 0 0 .57-1.05c.36-.72.85-1.74 1.33-2.96a25.51 25.51 0 0 0 1.94-9.07Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M26.5 29.5c-3-.5-5.5-3-5.5-7v-7c0-.47 0-.7.03-.9a3 3 0 0 1 2.58-2.57c.2-.03.42-.03.89-.03 2 0 2.5-2.5 2.5-2.5s0 2.5 2.5 2.5c1.4 0 2.1 0 2.65.23a3 3 0 0 1 1.62 1.62c.23.55.23 1.25.23 2.65v6c0 4-3 7-6.5 7 1.35.23 4 0 6.5-2v9.53C34 38.5 31.5 40 28 40s-6-1.5-6-2.97L24 34l2.5 1.5v-6ZM26 47h4.5c2.5 0 3 4 3 5.5h-3l-1-1.5H26v-4Zm-6.25 5.5H24V57h-8c0-1 1-4.5 3.75-4.5Z"
      clip-rule="evenodd"
    />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="3" /></clipPath>
  </defs>
</svg> `;
const nounSvg = b$2`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#794CFF" rx="3" />
  <path
    fill="#987DE8"
    stroke="#fff"
    stroke-width="2"
    d="M33 22.5v-1H16v5H8.5V36H13v-5h3v7.5h17V31h1v7.5h17v-17H34v5h-1v-4Z"
  />
  <path fill="#fff" d="M37.5 25h10v10h-10z" />
  <path fill="#4019B2" d="M42.5 25h5v10h-5z" />
  <path fill="#fff" d="M19.5 25h10v10h-10z" />
  <path fill="#4019B2" d="M24.5 25h5v10h-5z" />
  <path fill="#fff" d="M12 30.5h4V37h-4v-6.5Z" />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`;
const onrampCardSvg = b$2`<svg width="60" height="60" viewBox="0 0 60 60" fill="none">
<g clip-path="url(#clip0_13859_31161)">
  <path d="M0 24.8995C0 15.6481 0 11.0223 1.97053 7.56763C3.3015 5.2342 5.23468 3.30101 7.56812 1.97004C11.0228 -0.000488281 15.6485 -0.000488281 24.9 -0.000488281H35.1C44.3514 -0.000488281 48.9772 -0.000488281 52.4319 1.97004C54.7653 3.30101 56.6985 5.2342 58.0295 7.56763C60 11.0223 60 15.6481 60 24.8995V35.0995C60 44.351 60 48.9767 58.0295 52.4314C56.6985 54.7648 54.7653 56.698 52.4319 58.029C48.9772 59.9995 44.3514 59.9995 35.1 59.9995H24.9C15.6485 59.9995 11.0228 59.9995 7.56812 58.029C5.23468 56.698 3.3015 54.7648 1.97053 52.4314C0 48.9767 0 44.351 0 35.0995V24.8995Z" fill="#EB8B47"/>
  <path d="M0.5 24.8995C0.5 20.2647 0.50047 16.8216 0.744315 14.1045C0.987552 11.3941 1.46987 9.45455 2.40484 7.81536C3.69145 5.55971 5.56019 3.69096 7.81585 2.40435C9.45504 1.46938 11.3946 0.987064 14.105 0.743826C16.8221 0.499981 20.2652 0.499512 24.9 0.499512H35.1C39.7348 0.499512 43.1779 0.499981 45.895 0.743826C48.6054 0.987064 50.545 1.46938 52.1841 2.40435C54.4398 3.69096 56.3086 5.55971 57.5952 7.81536C58.5301 9.45455 59.0124 11.3941 59.2557 14.1045C59.4995 16.8216 59.5 20.2647 59.5 24.8995V35.0995C59.5 39.7343 59.4995 43.1774 59.2557 45.8945C59.0124 48.6049 58.5301 50.5445 57.5952 52.1837C56.3086 54.4393 54.4398 56.3081 52.1841 57.5947C50.545 58.5296 48.6054 59.012 45.895 59.2552C43.1779 59.499 39.7348 59.4995 35.1 59.4995H24.9C20.2652 59.4995 16.8221 59.499 14.105 59.2552C11.3946 59.012 9.45504 58.5296 7.81585 57.5947C5.56019 56.3081 3.69145 54.4393 2.40484 52.1837C1.46987 50.5445 0.987552 48.6049 0.744315 45.8945C0.50047 43.1774 0.5 39.7343 0.5 35.0995V24.8995Z" stroke="#141414" stroke-opacity="0.1"/>
  <path d="M13 26.0335C13 21.7838 13 19.659 14.0822 18.1694C14.4318 17.6883 14.8548 17.2653 15.3359 16.9157C16.8255 15.8335 18.9503 15.8335 23.2 15.8335H36.8C41.0497 15.8335 43.1745 15.8335 44.6641 16.9157C45.1452 17.2653 45.5682 17.6883 45.9178 18.1694C47 19.659 47 21.7838 47 26.0335V33.9668C47 38.2165 47 40.3414 45.9178 41.831C45.5682 42.312 45.1452 42.7351 44.6641 43.0846C43.1745 44.1668 41.0497 44.1668 36.8 44.1668H23.2C18.9503 44.1668 16.8255 44.1668 15.3359 43.0846C14.8548 42.7351 14.4318 42.312 14.0822 41.831C13 40.3414 13 38.2165 13 33.9668V26.0335Z" fill="#FF974C" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M39.5 36.667H36.6666" stroke="white" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M45.2 23.0645H14.8C14.0501 23.0645 13.6751 23.0645 13.4122 23.2554C13.3273 23.3171 13.2527 23.3918 13.191 23.4767C13 23.7395 13 24.1145 13 24.8645V27.2645C13 28.0144 13 28.3894 13.191 28.6522C13.2527 28.7371 13.3273 28.8118 13.4122 28.8735C13.6751 29.0645 14.0501 29.0645 14.8 29.0645H45.2C45.9499 29.0645 46.3249 29.0645 46.5878 28.8735C46.6727 28.8118 46.7473 28.7371 46.809 28.6522C47 28.3894 47 28.0144 47 27.2645V24.8645C47 24.1145 47 23.7395 46.809 23.4767C46.7473 23.3918 46.6727 23.3171 46.5878 23.2554C46.3249 23.0645 45.9499 23.0645 45.2 23.0645Z" fill="white" fill-opacity="0.4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</g>
<defs>
  <clipPath id="clip0_13859_31161">
    <rect width="60" height="60" fill="white"/>
  </clipPath>
</defs>
</svg>`;
const paypalSvg = b$2`
  <svg width="40" height="40" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g clip-path="url(#a)">
      <path
        d="M0 16.6c0-6.168 0-9.251 1.314-11.555a10 10 0 0 1 3.731-3.731C7.35 0 10.432 0 16.6 0h6.8c6.168 0 9.252 0 11.555 1.314a10 10 0 0 1 3.731 3.731C40 7.35 40 10.432 40 16.6v6.8c0 6.168 0 9.252-1.314 11.555a10 10 0 0 1-3.731 3.731C32.652 40 29.568 40 23.4 40h-6.8c-6.168 0-9.251 0-11.555-1.314a10 10 0 0 1-3.731-3.731C0 32.652 0 29.568 0 23.4v-6.8Z"
        fill="#fff"
      />
      <path
        d="M.5 16.6c0-3.093 0-5.38.162-7.182.161-1.795.48-3.061 1.086-4.125a9.5 9.5 0 0 1 3.545-3.545C6.357 1.141 7.623.823 9.418.662 11.221.5 13.508.5 16.6.5h6.8c3.093 0 5.38 0 7.182.162 1.795.161 3.062.48 4.125 1.086a9.5 9.5 0 0 1 3.545 3.545c.607 1.064.925 2.33 1.086 4.125.161 1.803.162 4.09.162 7.182v6.8c0 3.093 0 5.38-.162 7.182-.161 1.795-.48 3.062-1.086 4.125a9.5 9.5 0 0 1-3.545 3.545c-1.063.607-2.33.925-4.125 1.086-1.803.161-4.09.162-7.182.162h-6.8c-3.093 0-5.38 0-7.182-.162-1.795-.161-3.061-.48-4.125-1.086a9.5 9.5 0 0 1-3.545-3.545c-.607-1.063-.925-2.33-1.086-4.125C.5 28.779.5 26.492.5 23.4v-6.8Z"
        stroke="#fff"
        stroke-opacity=".05"
      />
      <path
        d="M18.606 12.642a.781.781 0 0 0-.771.66l-1.281 8.125a.78.78 0 0 1 .77-.66h3.755a7.668 7.668 0 0 0 7.57-6.49 6.26 6.26 0 0 0 .075-.843c-.96-.504-2.089-.792-3.325-.792h-6.793Z"
        fill="#001C64"
      />
      <path
        d="M28.724 13.434c-.006.282-.03.564-.075.843a7.668 7.668 0 0 1-7.57 6.491h-3.754a.78.78 0 0 0-.771.66l-1.916 12.15a.634.634 0 0 0 .626.734h4.075a.781.781 0 0 0 .77-.66l1.074-6.807a.781.781 0 0 1 .772-.66h2.4a7.668 7.668 0 0 0 7.57-6.491c.415-2.651-.92-5.064-3.201-6.26Z"
        fill="#0070E0"
      />
      <path
        d="M13.977 7.226a.78.78 0 0 0-.771.658l-3.198 20.277a.634.634 0 0 0 .626.733h4.742l1.178-7.467 1.281-8.125a.782.782 0 0 1 .771-.66H25.4c1.237 0 2.364.289 3.325.792.065-3.4-2.74-6.208-6.599-6.208h-8.148Z"
        fill="#003087"
      />
    </g>
    <defs>
      <clipPath id="a"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    </defs>
  </svg>
`;
const pencilSvg = b$2`<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
  <g clip-path="url(#clip0_241_31635)">
    <path d="M0 26.5595C0 16.6913 0 11.7572 2.1019 8.07217C3.5216 5.58317 5.58366 3.52111 8.07266 2.10141C11.7577 -0.000488281 16.6918 -0.000488281 26.56 -0.000488281H37.44C47.3082 -0.000488281 52.2423 -0.000488281 55.9273 2.10141C58.4163 3.52111 60.4784 5.58317 61.8981 8.07217C64 11.7572 64 16.6913 64 26.5595V37.4395C64 47.3077 64 52.2418 61.8981 55.9268C60.4784 58.4158 58.4163 60.4779 55.9273 61.8976C52.2423 63.9995 47.3082 63.9995 37.44 63.9995H26.56C16.6918 63.9995 11.7577 63.9995 8.07266 61.8976C5.58366 60.4779 3.5216 58.4158 2.1019 55.9268C0 52.2418 0 47.3077 0 37.4395V26.5595Z" fill="#EB8B47"/>
    <path d="M0.5 26.5595C0.5 21.6163 0.50047 17.942 0.760736 15.0418C1.02039 12.1485 1.53555 10.0742 2.53621 8.3199C3.91155 5.90869 5.90917 3.91106 8.32039 2.53572C10.0747 1.53506 12.1489 1.01991 15.0423 0.760247C17.9425 0.499981 21.6168 0.499512 26.56 0.499512H37.44C42.3832 0.499512 46.0575 0.499981 48.9577 0.760247C51.8511 1.01991 53.9253 1.53506 55.6796 2.53572C58.0908 3.91106 60.0885 5.90869 61.4638 8.3199C62.4645 10.0742 62.9796 12.1485 63.2393 15.0418C63.4995 17.942 63.5 21.6163 63.5 26.5595V37.4395C63.5 42.3827 63.4995 46.057 63.2393 48.9572C62.9796 51.8506 62.4645 53.9248 61.4638 55.6791C60.0885 58.0903 58.0908 60.088 55.6796 61.4633C53.9253 62.464 51.8511 62.9791 48.9577 63.2388C46.0575 63.499 42.3832 63.4995 37.44 63.4995H26.56C21.6168 63.4995 17.9425 63.499 15.0423 63.2388C12.1489 62.9791 10.0747 62.464 8.32039 61.4633C5.90917 60.088 3.91155 58.0903 2.53621 55.6791C1.53555 53.9248 1.02039 51.8506 0.760736 48.9572C0.50047 46.057 0.5 42.3827 0.5 37.4395V26.5595Z" stroke="#141414" stroke-opacity="0.1"/>
    <path d="M28.1042 49.2329L13.1024 51.2077L15.0772 36.2059L37.1015 14.1815C39.2441 12.039 40.3154 10.9677 41.5718 10.624C42.4205 10.3918 43.3159 10.3918 44.1645 10.624C45.421 10.9677 46.4922 12.039 48.6348 14.1815L50.1286 15.6753C52.2711 17.8179 53.3424 18.8891 53.6861 20.1456C53.9183 20.9942 53.9183 21.8896 53.6861 22.7383C53.3424 23.9947 52.2711 25.066 50.1286 27.2086L28.1042 49.2329Z" fill="#FF974C" stroke="#E4E7E7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M38.5962 20.5376L22.4199 36.7139" stroke="#E4E7E7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M43.7727 25.714L27.5964 41.8903" stroke="#E4E7E7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M22.3703 36.7635C19.3258 39.808 16.0198 36.6395 16.2616 35.0324" stroke="#E4E7E7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M27.5466 41.9399C24.5034 44.9831 28.155 48.7098 29.2738 48.0475" stroke="#E4E7E7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M27.5468 41.9398C23.428 46.0586 18.2516 40.8822 22.3704 36.7634" stroke="#E4E7E7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M15.8191 50.5214C15.4711 49.5823 14.728 48.8392 13.7889 48.4912" stroke="#E4E7E7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M49.2862 29.5805L34.7275 15.0219" stroke="#E4E7E7" stroke-width="2" stroke-linejoin="round"/>
  </g>
  <defs>
    <clipPath id="clip0_241_31635">
      <rect width="64" height="64" fill="white"/>
    </clipPath>
  </defs>
</svg>
`;
const profileSvg = b$2`<svg
  viewBox="0 0 60 60"
  fill="none"
>
  <g clip-path="url(#1)">
    <rect width="60" height="60" rx="30" fill="#00ACE6" />
    <path
      d="M59 73C59 89.0163 46.0163 102 30 102C13.9837 102 1 89.0163 1 73C1 56.9837 12 44 30 44C48 44 59 56.9837 59 73Z"
      fill="#1AC6FF"
      stroke="white"
      stroke-width="2"
    />
    <path
      d="M18.6904 19.9015C19.6264 15.3286 23.3466 11.8445 27.9708 11.2096C29.3231 11.024 30.6751 11.0238 32.0289 11.2096C36.6532 11.8445 40.3733 15.3286 41.3094 19.9015C41.4868 20.7681 41.6309 21.6509 41.7492 22.5271C41.8811 23.5041 41.8811 24.4944 41.7492 25.4715C41.6309 26.3476 41.4868 27.2304 41.3094 28.097C40.3733 32.6699 36.6532 36.154 32.0289 36.7889C30.6772 36.9744 29.3216 36.9743 27.9708 36.7889C23.3466 36.154 19.6264 32.6699 18.6904 28.097C18.513 27.2304 18.3689 26.3476 18.2506 25.4715C18.1186 24.4944 18.1186 23.5041 18.2506 22.5271C18.3689 21.6509 18.513 20.7681 18.6904 19.9015Z"
      fill="#1AC6FF"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="24.5" cy="23.5" r="1.5" fill="white" />
    <circle cx="35.5" cy="23.5" r="1.5" fill="white" />
    <path
      d="M31 20L28 28H32"
      stroke="white"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
    />
  </g>
  <rect x="0.5" y="0.5" width="59" height="59" rx="29.5" stroke="white" stroke-opacity="0.1" />
  <defs>
    <clipPath id="1">
      <rect width="60" height="60" rx="30" fill="white" />
    </clipPath>
  </defs>
</svg> `;
const solanaSvg = b$2`<svg fill="none" viewBox="0 0 80 80">
  <g clip-path="url(#a)">
    <path fill="url(#b)" d="M40 80a40 40 0 1 0 0-80 40 40 0 0 0 0 80Z" />
    <path
      stroke="#fff"
      stroke-opacity=".1"
      d="M79.5 40a39.5 39.5 0 1 1-79 0 39.5 39.5 0 0 1 79 0Z"
    />
    <path
      fill="#fff"
      d="m62.62 51.54-7.54 7.91a1.75 1.75 0 0 1-1.29.55H18.02a.9.9 0 0 1-.8-.52.84.84 0 0 1 .16-.92l7.55-7.92a1.75 1.75 0 0 1 1.28-.55h35.77a.87.87 0 0 1 .8.52.84.84 0 0 1-.16.93Zm-7.54-15.95a1.75 1.75 0 0 0-1.29-.54H18.02a.89.89 0 0 0-.8.51.84.84 0 0 0 .16.93l7.55 7.92a1.75 1.75 0 0 0 1.28.54h35.77a.89.89 0 0 0 .8-.51.84.84 0 0 0-.16-.93l-7.54-7.92ZM18.02 29.9h35.77a1.79 1.79 0 0 0 1.29-.54l7.54-7.92a.85.85 0 0 0 .16-.93.87.87 0 0 0-.8-.51H26.21a1.79 1.79 0 0 0-1.28.54l-7.55 7.92a.85.85 0 0 0-.16.93.89.89 0 0 0 .8.52Z"
    />
  </g>
  <defs>
    <linearGradient id="b" x1="6.75" x2="80.68" y1="81.91" y2="7.37" gradientUnits="userSpaceOnUse">
      <stop offset=".08" stop-color="#9945FF" />
      <stop offset=".3" stop-color="#8752F3" />
      <stop offset=".5" stop-color="#5497D5" />
      <stop offset=".6" stop-color="#43B4CA" />
      <stop offset=".72" stop-color="#28E0B9" />
      <stop offset=".97" stop-color="#19FB9B" />
    </linearGradient>
    <clipPath id="a"><path fill="#fff" d="M0 0h80v80H0z" /></clipPath>
  </defs>
</svg> `;
const stripeSvg = b$2`
  <svg width="40" height="40" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g clip-path="url(#a)">
      <path
        d="M0 16.6c0-6.168 0-9.251 1.314-11.555a10 10 0 0 1 3.731-3.731C7.35 0 10.432 0 16.6 0h6.8c6.168 0 9.252 0 11.555 1.314a10 10 0 0 1 3.731 3.731C40 7.35 40 10.432 40 16.6v6.8c0 6.168 0 9.252-1.314 11.555a10 10 0 0 1-3.731 3.731C32.652 40 29.568 40 23.4 40h-6.8c-6.168 0-9.251 0-11.555-1.314a10 10 0 0 1-3.731-3.731C0 32.652 0 29.568 0 23.4v-6.8Z"
        fill="#635BFF"
      />
      <path
        d="M.5 16.6c0-3.093 0-5.38.162-7.182.161-1.795.48-3.061 1.086-4.125a9.5 9.5 0 0 1 3.545-3.545C6.357 1.141 7.623.823 9.418.662 11.221.5 13.508.5 16.6.5h6.8c3.093 0 5.38 0 7.182.162 1.795.161 3.062.48 4.125 1.086a9.5 9.5 0 0 1 3.545 3.545c.607 1.064.925 2.33 1.086 4.125.161 1.803.162 4.09.162 7.182v6.8c0 3.093 0 5.38-.162 7.182-.161 1.795-.48 3.062-1.086 4.125a9.5 9.5 0 0 1-3.545 3.545c-1.063.607-2.33.925-4.125 1.086-1.803.161-4.09.162-7.182.162h-6.8c-3.093 0-5.38 0-7.182-.162-1.795-.161-3.061-.48-4.125-1.086a9.5 9.5 0 0 1-3.545-3.545c-.607-1.063-.925-2.33-1.086-4.125C.5 28.779.5 26.492.5 23.4v-6.8Z"
        stroke="#fff"
        stroke-opacity=".05"
      />
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M18.299 15.147c0-1.028.844-1.424 2.242-1.424 2.004 0 4.536.607 6.54 1.688V9.213C24.892 8.343 22.73 8 20.541 8c-5.354 0-8.915 2.796-8.915 7.464 0 7.279 10.022 6.118 10.022 9.257 0 1.213-1.055 1.609-2.531 1.609-2.19 0-4.985-.897-7.2-2.11v6.277a18.283 18.283 0 0 0 7.2 1.503c5.485 0 9.257-2.716 9.257-7.437-.027-7.86-10.075-6.462-10.075-9.416Z"
        fill="#fff"
      />
    </g>
    <defs>
      <clipPath id="a"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    </defs>
  </svg>
`;
const systemSvg = b$2`<svg viewBox="0 0 60 60" fill="none">
  <g clip-path="url(#1)">
    <path
      d="M0 24.9C0 15.6485 0 11.0228 1.97053 7.56812C3.3015 5.23468 5.23468 3.3015 7.56812 1.97053C11.0228 0 15.6485 0 24.9 0H35.1C44.3514 0 48.9772 0 52.4319 1.97053C54.7653 3.3015 56.6985 5.23468 58.0295 7.56812C60 11.0228 60 15.6485 60 24.9V35.1C60 44.3514 60 48.9772 58.0295 52.4319C56.6985 54.7653 54.7653 56.6985 52.4319 58.0295C48.9772 60 44.3514 60 35.1 60H24.9C15.6485 60 11.0228 60 7.56812 58.0295C5.23468 56.6985 3.3015 54.7653 1.97053 52.4319C0 48.9772 0 44.3514 0 35.1V24.9Z"
      fill="#794CFF"
    />
    <path
      d="M0.5 24.9C0.5 20.2652 0.50047 16.8221 0.744315 14.105C0.987552 11.3946 1.46987 9.45504 2.40484 7.81585C3.69145 5.56019 5.56019 3.69145 7.81585 2.40484C9.45504 1.46987 11.3946 0.987552 14.105 0.744315C16.8221 0.50047 20.2652 0.5 24.9 0.5H35.1C39.7348 0.5 43.1779 0.50047 45.895 0.744315C48.6054 0.987552 50.545 1.46987 52.1841 2.40484C54.4398 3.69145 56.3086 5.56019 57.5952 7.81585C58.5301 9.45504 59.0124 11.3946 59.2557 14.105C59.4995 16.8221 59.5 20.2652 59.5 24.9V35.1C59.5 39.7348 59.4995 43.1779 59.2557 45.895C59.0124 48.6054 58.5301 50.545 57.5952 52.1841C56.3086 54.4398 54.4398 56.3086 52.1841 57.5952C50.545 58.5301 48.6054 59.0124 45.895 59.2557C43.1779 59.4995 39.7348 59.5 35.1 59.5H24.9C20.2652 59.5 16.8221 59.4995 14.105 59.2557C11.3946 59.0124 9.45504 58.5301 7.81585 57.5952C5.56019 56.3086 3.69145 54.4398 2.40484 52.1841C1.46987 50.545 0.987552 48.6054 0.744315 45.895C0.50047 43.1779 0.5 39.7348 0.5 35.1V24.9Z"
      stroke="#062B2B"
      stroke-opacity="0.1"
    />
    <path
      d="M35.1403 31.5016C35.1193 30.9637 35.388 30.4558 35.8446 30.1707C36.1207 29.9982 36.4761 29.8473 36.7921 29.7685C37.3143 29.6382 37.8664 29.7977 38.2386 30.1864C38.8507 30.8257 39.3004 31.6836 39.8033 32.408C40.2796 33.0942 41.4695 33.2512 41.9687 32.5047C42.4839 31.7341 42.9405 30.8229 43.572 30.1399C43.9375 29.7447 44.4866 29.5756 45.0111 29.6967C45.3283 29.7701 45.6863 29.9147 45.9655 30.0823C46.4269 30.3595 46.7045 30.8626 46.6928 31.4008C46.6731 32.3083 46.3764 33.2571 46.2158 34.1473C46.061 35.0048 46.9045 35.8337 47.7592 35.664C48.6464 35.4878 49.5899 35.1747 50.497 35.1391C51.0348 35.1181 51.5427 35.3868 51.8279 35.8433C52.0004 36.1195 52.1513 36.4749 52.2301 36.7908C52.3604 37.3131 52.2009 37.8651 51.8121 38.2374C51.1729 38.8495 50.3151 39.2991 49.5908 39.8019C48.9046 40.2782 48.7473 41.4683 49.4939 41.9675C50.2644 42.4827 51.1757 42.9393 51.8587 43.5708C52.2539 43.9362 52.423 44.4854 52.3018 45.0099C52.2285 45.3271 52.0839 45.6851 51.9162 45.9642C51.6391 46.4257 51.1359 46.7032 50.5978 46.6916C49.6903 46.6719 48.7417 46.3753 47.8516 46.2146C46.9939 46.0598 46.1648 46.9035 46.3346 47.7583C46.5108 48.6454 46.8239 49.5888 46.8594 50.4958C46.8805 51.0336 46.6117 51.5415 46.1552 51.8267C45.879 51.9992 45.5236 52.15 45.2077 52.2289C44.6854 52.3592 44.1334 52.1997 43.7611 51.8109C43.1491 51.1718 42.6996 50.314 42.1968 49.5897C41.7203 48.9034 40.5301 48.7463 40.0309 49.493C39.5157 50.2634 39.0592 51.1746 38.4278 51.8574C38.0623 52.2527 37.5132 52.4218 36.9887 52.3006C36.6715 52.2273 36.3135 52.0826 36.0343 51.915C35.5729 51.6379 35.2953 51.1347 35.307 50.5966C35.3267 49.6891 35.6233 48.7405 35.7839 47.8505C35.9388 46.9928 35.0951 46.1636 34.2402 46.3334C33.3531 46.5096 32.4098 46.8227 31.5028 46.8582C30.9649 46.8793 30.457 46.6105 30.1719 46.154C29.9994 45.8778 29.8485 45.5224 29.7697 45.2065C29.6394 44.6842 29.7989 44.1322 30.1877 43.7599C30.8269 43.1479 31.6847 42.6982 32.4091 42.1954C33.0954 41.7189 33.2522 40.5289 32.5056 40.0297C31.7351 39.5145 30.824 39.058 30.1411 38.4265C29.7459 38.0611 29.5768 37.5119 29.698 36.9875C29.7713 36.6702 29.9159 36.3122 30.0836 36.0331C30.3607 35.5717 30.8638 35.2941 31.402 35.3058C32.3095 35.3255 33.2583 35.6221 34.1485 35.7828C35.006 35.9376 35.8349 35.094 35.6652 34.2393C35.489 33.3521 35.1759 32.4087 35.1403 31.5016Z"
      fill="#906EF7"
      stroke="white"
      stroke-width="2"
    />
    <path
      d="M20.7706 8.22357C20.9036 7.51411 21.5231 7 22.2449 7H23.7551C24.4769 7 25.0964 7.51411 25.2294 8.22357C25.5051 9.69403 25.4829 11.6321 27.1202 12.2606C27.3092 12.3331 27.4958 12.4105 27.6798 12.4926C29.2818 13.2072 30.6374 11.8199 31.8721 10.9752C32.4678 10.5676 33.2694 10.6421 33.7798 11.1525L34.8477 12.2204C35.3581 12.7308 35.4326 13.5323 35.025 14.128C34.1802 15.3627 32.7931 16.7183 33.5077 18.3202C33.5898 18.5043 33.6672 18.6909 33.7398 18.88C34.3683 20.5171 36.3061 20.4949 37.7764 20.7706C38.4859 20.9036 39 21.5231 39 22.2449V23.7551C39 24.4769 38.4859 25.0964 37.7764 25.2294C36.3061 25.5051 34.3685 25.483 33.7401 27.1201C33.6675 27.3093 33.59 27.4961 33.5079 27.6803C32.7934 29.282 34.1803 30.6374 35.025 31.8719C35.4326 32.4677 35.3581 33.2692 34.8477 33.7796L33.7798 34.8475C33.2694 35.3579 32.4678 35.4324 31.8721 35.0248C30.6376 34.1801 29.2823 32.7934 27.6806 33.508C27.4962 33.5903 27.3093 33.6678 27.12 33.7405C25.483 34.3688 25.5051 36.3062 25.2294 37.7764C25.0964 38.4859 24.4769 39 23.7551 39H22.2449C21.5231 39 20.9036 38.4859 20.7706 37.7764C20.4949 36.3062 20.517 34.3688 18.88 33.7405C18.6908 33.6678 18.5039 33.5903 18.3196 33.5081C16.7179 32.7936 15.3625 34.1804 14.1279 35.0251C13.5322 35.4327 12.7307 35.3582 12.2203 34.8478L11.1524 33.7799C10.642 33.2695 10.5675 32.4679 10.9751 31.8722C11.8198 30.6376 13.2067 29.2822 12.4922 27.6804C12.41 27.4962 12.3325 27.3093 12.2599 27.1201C11.6315 25.483 9.69392 25.5051 8.22357 25.2294C7.51411 25.0964 7 24.4769 7 23.7551V22.2449C7 21.5231 7.51411 20.9036 8.22357 20.7706C9.69394 20.4949 11.6317 20.5171 12.2602 18.88C12.3328 18.6909 12.4103 18.5042 12.4924 18.3201C13.207 16.7181 11.8198 15.3625 10.975 14.1278C10.5674 13.5321 10.6419 12.7305 11.1523 12.2201L12.2202 11.1522C12.7306 10.6418 13.5322 10.5673 14.1279 10.9749C15.3626 11.8197 16.7184 13.2071 18.3204 12.4925C18.5044 12.4105 18.6909 12.3331 18.8799 12.2606C20.5171 11.6321 20.4949 9.69403 20.7706 8.22357Z"
      fill="#906EF7"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="23" cy="23" r="6" fill="#794CFF" stroke="white" stroke-width="2" />
    <circle cx="41" cy="41" r="4" fill="#794CFF" stroke="white" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="1">
      <rect width="60" height="60" fill="white" />
    </clipPath>
  </defs>
</svg> `;
const styles$2f = i$4`
  :host {
    display: block;
    width: var(--local-size);
    height: var(--local-size);
  }

  :host svg {
    width: 100%;
    height: 100%;
  }
`;
var __decorate$2T = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
const svgOptions = {
  browser: browserSvg,
  dao: daoSvg,
  defi: defiSvg,
  defiAlt: defiAltSvg,
  eth: ethSvg,
  layers: layersSvg,
  lock: lockSvg,
  login: loginSvg,
  network: networkSvg,
  nft: nftSvg,
  noun: nounSvg,
  profile: profileSvg,
  system: systemSvg,
  coinbase: coinbaseSvg,
  meld: meldSvg,
  onrampCard: onrampCardSvg,
  moonpay: moonpaySvg,
  stripe: stripeSvg,
  paypal: paypalSvg,
  google: googleSvg,
  pencil: pencilSvg,
  lightbulb: lightbulbSvg,
  solana: solanaSvg
};
let WuiVisual = class WuiVisual2 extends i$1 {
  constructor() {
    super(...arguments);
    this.name = "browser";
    this.size = "md";
  }
  render() {
    this.style.cssText = `
       --local-size: var(--wui-visual-size-${this.size});
   `;
    return x$3`${svgOptions[this.name]}`;
  }
};
WuiVisual.styles = [resetStyles, styles$2f];
__decorate$2T([
  n$3()
], WuiVisual.prototype, "name", void 0);
__decorate$2T([
  n$3()
], WuiVisual.prototype, "size", void 0);
WuiVisual = __decorate$2T([
  customElement("cross-wui-visual")
], WuiVisual);
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o$2 = (o3) => o3 ?? E$2;
const UiHelperUtil = {
  getSpacingStyles(spacing, index2) {
    if (Array.isArray(spacing)) {
      return spacing[index2] ? `var(--wui-spacing-${spacing[index2]})` : void 0;
    } else if (typeof spacing === "string") {
      return `var(--wui-spacing-${spacing})`;
    }
    return void 0;
  },
  getFormattedDate(date) {
    return new Intl.DateTimeFormat("en-US", { month: "short", day: "numeric" }).format(date);
  },
  getHostName(url) {
    try {
      const newUrl = new URL(url);
      return newUrl.hostname;
    } catch (error) {
      return "";
    }
  },
  getTruncateString({ string: string2, charsStart, charsEnd, truncate }) {
    if (string2.length <= charsStart + charsEnd) {
      return string2;
    }
    if (truncate === "end") {
      return `${string2.substring(0, charsStart)}...`;
    } else if (truncate === "start") {
      return `...${string2.substring(string2.length - charsEnd)}`;
    }
    return `${string2.substring(0, Math.floor(charsStart))}...${string2.substring(string2.length - Math.floor(charsEnd))}`;
  },
  generateAvatarColors(address) {
    const hash3 = address.toLowerCase().replace(/^0x/iu, "").replace(/[^a-f0-9]/gu, "");
    const baseColor = hash3.substring(0, 6).padEnd(6, "0");
    const rgbColor = this.hexToRgb(baseColor);
    const masterBorderRadius = getComputedStyle(document.documentElement).getPropertyValue("--w3m-border-radius-master");
    const radius = Number(masterBorderRadius == null ? void 0 : masterBorderRadius.replace("px", ""));
    const edge = 100 - 3 * radius;
    const gradientCircle = `${edge}% ${edge}% at 65% 40%`;
    const colors = [];
    for (let i4 = 0; i4 < 5; i4 += 1) {
      const tintedColor = this.tintColor(rgbColor, 0.15 * i4);
      colors.push(`rgb(${tintedColor[0]}, ${tintedColor[1]}, ${tintedColor[2]})`);
    }
    return `
    --local-color-1: ${colors[0]};
    --local-color-2: ${colors[1]};
    --local-color-3: ${colors[2]};
    --local-color-4: ${colors[3]};
    --local-color-5: ${colors[4]};
    --local-radial-circle: ${gradientCircle}
   `;
  },
  hexToRgb(hex) {
    const bigint = parseInt(hex, 16);
    const r3 = bigint >> 16 & 255;
    const g2 = bigint >> 8 & 255;
    const b2 = bigint & 255;
    return [r3, g2, b2];
  },
  tintColor(rgb, tint) {
    const [r3, g2, b2] = rgb;
    const tintedR = Math.round(r3 + (255 - r3) * tint);
    const tintedG = Math.round(g2 + (255 - g2) * tint);
    const tintedB = Math.round(b2 + (255 - b2) * tint);
    return [tintedR, tintedG, tintedB];
  },
  isNumber(character) {
    const regex2 = {
      number: /^[0-9]+$/u
    };
    return regex2.number.test(character);
  },
  getColorTheme(theme) {
    if (theme) {
      return theme;
    } else if (typeof window !== "undefined" && window.matchMedia) {
      if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
        return "dark";
      }
      return "light";
    }
    return "dark";
  },
  splitBalance(input) {
    const parts = input.split(".");
    if (parts.length === 2) {
      return [parts[0], parts[1]];
    }
    return ["0", "00"];
  },
  roundNumber(number2, threshold, fixed) {
    const roundedNumber = number2.toString().length >= threshold ? Number(number2).toFixed(fixed) : number2;
    return roundedNumber;
  },
  formatNumberToLocalString(value, decimals = 2) {
    if (value === void 0) {
      return "0.00";
    }
    if (typeof value === "number") {
      return value.toLocaleString("en-US", {
        maximumFractionDigits: decimals,
        minimumFractionDigits: decimals
      });
    }
    return parseFloat(value).toLocaleString("en-US", {
      maximumFractionDigits: decimals,
      minimumFractionDigits: decimals
    });
  }
};
const styles$2e = i$4`
  :host {
    display: flex;
    width: inherit;
    height: inherit;
  }
`;
var __decorate$2S = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiFlex = class WuiFlex2 extends i$1 {
  render() {
    this.style.cssText = `
      flex-direction: ${this.flexDirection};
      flex-wrap: ${this.flexWrap};
      flex-basis: ${this.flexBasis};
      flex-grow: ${this.flexGrow};
      flex-shrink: ${this.flexShrink};
      align-items: ${this.alignItems};
      justify-content: ${this.justifyContent};
      column-gap: ${this.columnGap && `var(--wui-spacing-${this.columnGap})`};
      row-gap: ${this.rowGap && `var(--wui-spacing-${this.rowGap})`};
      gap: ${this.gap && `var(--wui-spacing-${this.gap})`};
      padding-top: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 0)};
      padding-right: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 1)};
      padding-bottom: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 2)};
      padding-left: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 3)};
      margin-top: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 0)};
      margin-right: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 1)};
      margin-bottom: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 2)};
      margin-left: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 3)};
    `;
    return x$3`<slot></slot>`;
  }
};
WuiFlex.styles = [resetStyles, styles$2e];
__decorate$2S([
  n$3()
], WuiFlex.prototype, "flexDirection", void 0);
__decorate$2S([
  n$3()
], WuiFlex.prototype, "flexWrap", void 0);
__decorate$2S([
  n$3()
], WuiFlex.prototype, "flexBasis", void 0);
__decorate$2S([
  n$3()
], WuiFlex.prototype, "flexGrow", void 0);
__decorate$2S([
  n$3()
], WuiFlex.prototype, "flexShrink", void 0);
__decorate$2S([
  n$3()
], WuiFlex.prototype, "alignItems", void 0);
__decorate$2S([
  n$3()
], WuiFlex.prototype, "justifyContent", void 0);
__decorate$2S([
  n$3()
], WuiFlex.prototype, "columnGap", void 0);
__decorate$2S([
  n$3()
], WuiFlex.prototype, "rowGap", void 0);
__decorate$2S([
  n$3()
], WuiFlex.prototype, "gap", void 0);
__decorate$2S([
  n$3()
], WuiFlex.prototype, "padding", void 0);
__decorate$2S([
  n$3()
], WuiFlex.prototype, "margin", void 0);
WuiFlex = __decorate$2S([
  customElement("cross-wui-flex")
], WuiFlex);
const styles$2d = i$4`
  :host {
    display: block;
    width: var(--local-width);
    height: var(--local-height);
    border-radius: var(--wui-border-radius-3xl);
    box-shadow: 0 0 0 8px var(--wui-color-gray-glass-005);
    overflow: hidden;
    position: relative;
  }

  :host([data-variant='generated']) {
    --mixed-local-color-1: var(--local-color-1);
    --mixed-local-color-2: var(--local-color-2);
    --mixed-local-color-3: var(--local-color-3);
    --mixed-local-color-4: var(--local-color-4);
    --mixed-local-color-5: var(--local-color-5);
  }

  @supports (background: color-mix(in srgb, white 50%, black)) {
    :host([data-variant='generated']) {
      --mixed-local-color-1: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-1)
      );
      --mixed-local-color-2: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-2)
      );
      --mixed-local-color-3: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-3)
      );
      --mixed-local-color-4: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-4)
      );
      --mixed-local-color-5: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-5)
      );
    }
  }

  :host([data-variant='generated']) {
    box-shadow: 0 0 0 8px var(--wui-color-gray-glass-005);
    background: radial-gradient(
      var(--local-radial-circle),
      #fff 0.52%,
      var(--mixed-local-color-5) 31.25%,
      var(--mixed-local-color-3) 51.56%,
      var(--mixed-local-color-2) 65.63%,
      var(--mixed-local-color-1) 82.29%,
      var(--mixed-local-color-4) 100%
    );
  }

  :host([data-variant='default']) {
    box-shadow: 0 0 0 8px var(--wui-color-gray-glass-005);
    background: radial-gradient(
      75.29% 75.29% at 64.96% 24.36%,
      #fff 0.52%,
      #f5ccfc 31.25%,
      #dba4f5 51.56%,
      #9a8ee8 65.63%,
      #6493da 82.29%,
      #6ebdea 100%
    );
  }
`;
var __decorate$2R = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiAvatar = class WuiAvatar2 extends i$1 {
  constructor() {
    super(...arguments);
    this.imageSrc = void 0;
    this.alt = void 0;
    this.address = void 0;
    this.size = "xl";
  }
  render() {
    this.style.cssText = `
    --local-width: var(--wui-icon-box-size-${this.size});
    --local-height: var(--wui-icon-box-size-${this.size});
    `;
    return x$3`${this.visualTemplate()}`;
  }
  visualTemplate() {
    if (this.imageSrc) {
      this.dataset["variant"] = "image";
      return x$3`<cross-wui-image src=${this.imageSrc} alt=${this.alt ?? "avatar"}></cross-wui-image>`;
    } else if (this.address) {
      this.dataset["variant"] = "generated";
      const cssColors = UiHelperUtil.generateAvatarColors(this.address);
      this.style.cssText += `
 ${cssColors}`;
      return null;
    }
    this.dataset["variant"] = "default";
    return null;
  }
};
WuiAvatar.styles = [resetStyles, styles$2d];
__decorate$2R([
  n$3()
], WuiAvatar.prototype, "imageSrc", void 0);
__decorate$2R([
  n$3()
], WuiAvatar.prototype, "alt", void 0);
__decorate$2R([
  n$3()
], WuiAvatar.prototype, "address", void 0);
__decorate$2R([
  n$3()
], WuiAvatar.prototype, "size", void 0);
WuiAvatar = __decorate$2R([
  customElement("cross-wui-avatar")
], WuiAvatar);
const styles$2c = i$4`
  :host {
    display: inline-flex;
    justify-content: center;
    align-items: center;
    position: relative;
    overflow: hidden;
    background-color: var(--wui-color-gray-glass-020);
    border-radius: var(--local-border-radius);
    border: var(--local-border);
    box-sizing: content-box;
    width: var(--local-size);
    height: var(--local-size);
    min-height: var(--local-size);
    min-width: var(--local-size);
  }

  @supports (background: color-mix(in srgb, white 50%, black)) {
    :host {
      background-color: color-mix(in srgb, var(--local-bg-value) var(--local-bg-mix), transparent);
    }
  }
`;
var __decorate$2Q = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiIconBox = class WuiIconBox2 extends i$1 {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.backgroundColor = "accent-100";
    this.iconColor = "accent-100";
    this.background = "transparent";
    this.border = false;
    this.borderColor = "wui-color-bg-125";
    this.icon = "copy";
  }
  render() {
    const iconSize = this.iconSize || this.size;
    const isLg = this.size === "lg";
    const isXl = this.size === "xl";
    const bgMix = isLg ? "12%" : "16%";
    const borderRadius = isLg ? "xxs" : isXl ? "s" : "3xl";
    const isGray = this.background === "gray";
    const isOpaque = this.background === "opaque";
    const isColorChange = this.backgroundColor === "accent-100" && isOpaque || this.backgroundColor === "success-100" && isOpaque || this.backgroundColor === "error-100" && isOpaque || this.backgroundColor === "inverse-100" && isOpaque;
    let bgValueVariable = `var(--wui-color-${this.backgroundColor})`;
    if (isColorChange) {
      bgValueVariable = `var(--wui-icon-box-bg-${this.backgroundColor})`;
    } else if (isGray) {
      bgValueVariable = `var(--wui-color-gray-${this.backgroundColor})`;
    }
    this.style.cssText = `
       --local-bg-value: ${bgValueVariable};
       --local-bg-mix: ${isColorChange || isGray ? `100%` : bgMix};
       --local-border-radius: var(--wui-border-radius-${borderRadius});
       --local-size: var(--wui-icon-box-size-${this.size});
       --local-border: ${this.borderColor === "wui-color-bg-125" ? `2px` : `1px`} solid ${this.border ? `var(--${this.borderColor})` : `transparent`}
   `;
    return x$3` <cross-wui-icon color=${this.iconColor} size=${iconSize} name=${this.icon}></cross-wui-icon> `;
  }
};
WuiIconBox.styles = [resetStyles, elementStyles, styles$2c];
__decorate$2Q([
  n$3()
], WuiIconBox.prototype, "size", void 0);
__decorate$2Q([
  n$3()
], WuiIconBox.prototype, "backgroundColor", void 0);
__decorate$2Q([
  n$3()
], WuiIconBox.prototype, "iconColor", void 0);
__decorate$2Q([
  n$3()
], WuiIconBox.prototype, "iconSize", void 0);
__decorate$2Q([
  n$3()
], WuiIconBox.prototype, "background", void 0);
__decorate$2Q([
  n$3({ type: Boolean })
], WuiIconBox.prototype, "border", void 0);
__decorate$2Q([
  n$3()
], WuiIconBox.prototype, "borderColor", void 0);
__decorate$2Q([
  n$3()
], WuiIconBox.prototype, "icon", void 0);
WuiIconBox = __decorate$2Q([
  customElement("cross-wui-icon-box")
], WuiIconBox);
const styles$2b = i$4`
  :host {
    display: block;
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
    background: var(--wui-color-gray-glass-002);
    display: flex;
    gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-3xs) var(--wui-spacing-xs) var(--wui-spacing-3xs)
      var(--wui-spacing-xs);
    border: 1px solid var(--wui-color-gray-glass-005);
  }

  button:disabled {
    background: var(--wui-color-gray-glass-015);
  }

  button:disabled > cross-wui-text {
    color: var(--wui-color-gray-glass-015);
  }

  button:disabled > wui-flex > cross-wui-text {
    color: var(--wui-color-gray-glass-015);
  }

  button:disabled > cross-wui-image,
  button:disabled > wui-flex > cross-wui-avatar {
    filter: grayscale(1);
  }

  button:has(wui-image) {
    padding: var(--wui-spacing-3xs) var(--wui-spacing-3xs) var(--wui-spacing-3xs)
      var(--wui-spacing-xs);
  }

  cross-wui-text {
    color: var(--wui-color-fg-100);
  }

  wui-flex > cross-wui-text {
    color: var(--wui-color-fg-200);
  }

  cross-wui-image,
  cross-wui-icon-box {
    border-radius: var(--wui-border-radius-3xl);
    width: 24px;
    height: 24px;
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
  }

  cross-wui-flex {
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-color-gray-glass-005);
    background: var(--wui-color-gray-glass-005);
    padding: 4px var(--wui-spacing-m) 4px var(--wui-spacing-xxs);
  }

  button.local-no-balance {
    border-radius: 0px;
    border: none;
    background: transparent;
  }

  cross-wui-avatar {
    width: 20px;
    height: 20px;
    box-shadow: 0 0 0 2px var(--wui-color-accent-glass-010);
  }

  @media (max-width: 500px) {
    button {
      gap: 0px;
      padding: var(--wui-spacing-3xs) var(--wui-spacing-xs) !important;
      height: 32px;
    }
    cross-wui-image,
    cross-wui-icon-box,
    button > cross-wui-text {
      visibility: hidden;
      width: 0px;
      height: 0px;
    }
    button {
      border-radius: 0px;
      border: none;
      background: transparent;
      padding: 0px;
    }
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled > wui-flex > cross-wui-text {
      color: var(--wui-color-fg-175);
    }

    button:active:enabled > wui-flex > cross-wui-text {
      color: var(--wui-color-fg-175);
    }
  }
`;
var __decorate$2P = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiAccountButton = class WuiAccountButton2 extends i$1 {
  constructor() {
    super(...arguments);
    this.networkSrc = void 0;
    this.avatarSrc = void 0;
    this.balance = void 0;
    this.isUnsupportedChain = void 0;
    this.disabled = false;
    this.loading = false;
    this.address = "";
    this.profileName = "";
    this.charsStart = 4;
    this.charsEnd = 6;
  }
  render() {
    return x$3`
      <button
        ?disabled=${this.disabled}
        class=${o$2(this.balance ? void 0 : "local-no-balance")}
      >
        ${this.balanceTemplate()}
        <cross-wui-flex gap="xxs" alignItems="center">
          <cross-wui-avatar
            .imageSrc=${this.avatarSrc}
            alt=${this.address}
            address=${this.address}
          ></cross-wui-avatar>
          <cross-wui-text variant="paragraph-600" color="inherit">
            ${this.address ? UiHelperUtil.getTruncateString({
      string: this.profileName || this.address,
      charsStart: this.profileName ? 18 : this.charsStart,
      charsEnd: this.profileName ? 0 : this.charsEnd,
      truncate: this.profileName ? "end" : "middle"
    }) : null}
          </cross-wui-text>
        </cross-wui-flex>
      </button>
    `;
  }
  balanceTemplate() {
    if (this.isUnsupportedChain) {
      return x$3` <cross-wui-icon-box
          size="sm"
          iconColor="error-100"
          backgroundColor="error-100"
          icon="warningCircle"
        ></cross-wui-icon-box>
        <cross-wui-text variant="paragraph-600" color="inherit"> Switch Network</cross-wui-text>`;
    }
    if (this.balance) {
      const networkElement = this.networkSrc ? x$3`<cross-wui-image src=${this.networkSrc}></cross-wui-image>` : x$3`
            <cross-wui-icon-box
              size="sm"
              iconColor="fg-200"
              backgroundColor="fg-300"
              icon="networkPlaceholder"
            ></cross-wui-icon-box>
          `;
      const balanceTemplate = this.loading ? x$3`<cross-wui-loading-spinner size="md" color="fg-200"></cross-wui-loading-spinner>` : x$3`<cross-wui-text variant="paragraph-600" color="inherit"> ${this.balance}</cross-wui-text>`;
      return x$3`${networkElement} ${balanceTemplate}`;
    }
    return null;
  }
};
WuiAccountButton.styles = [resetStyles, elementStyles, styles$2b];
__decorate$2P([
  n$3()
], WuiAccountButton.prototype, "networkSrc", void 0);
__decorate$2P([
  n$3()
], WuiAccountButton.prototype, "avatarSrc", void 0);
__decorate$2P([
  n$3()
], WuiAccountButton.prototype, "balance", void 0);
__decorate$2P([
  n$3({ type: Boolean })
], WuiAccountButton.prototype, "isUnsupportedChain", void 0);
__decorate$2P([
  n$3({ type: Boolean })
], WuiAccountButton.prototype, "disabled", void 0);
__decorate$2P([
  n$3({ type: Boolean })
], WuiAccountButton.prototype, "loading", void 0);
__decorate$2P([
  n$3()
], WuiAccountButton.prototype, "address", void 0);
__decorate$2P([
  n$3()
], WuiAccountButton.prototype, "profileName", void 0);
__decorate$2P([
  n$3()
], WuiAccountButton.prototype, "charsStart", void 0);
__decorate$2P([
  n$3()
], WuiAccountButton.prototype, "charsEnd", void 0);
WuiAccountButton = __decorate$2P([
  customElement("cross-wui-account-button")
], WuiAccountButton);
const styles$2a = i$4`
  :host {
    position: relative;
    background-color: var(--wui-color-gray-glass-002);
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--local-size);
    height: var(--local-size);
    border-radius: inherit;
    border-radius: var(--local-border-radius);
  }

  :host > cross-wui-flex {
    overflow: hidden;
    border-radius: inherit;
    border-radius: var(--local-border-radius);
  }

  :host::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-color-gray-glass-010);
    pointer-events: none;
  }

  :host([name='Extension'])::after {
    border: 1px solid var(--wui-color-accent-glass-010);
  }

  :host([data-wallet-icon='allWallets']) {
    background-color: var(--wui-all-wallets-bg-100);
  }

  :host([data-wallet-icon='allWallets'])::after {
    border: 1px solid var(--wui-color-accent-glass-010);
  }

  wui-icon[data-parent-size='inherit'] {
    width: 75%;
    height: 75%;
    align-items: center;
  }

  wui-icon[data-parent-size='sm'] {
    width: 18px;
    height: 18px;
  }

  wui-icon[data-parent-size='md'] {
    width: 24px;
    height: 24px;
  }

  wui-icon[data-parent-size='lg'] {
    width: 42px;
    height: 42px;
  }

  wui-icon[data-parent-size='full'] {
    width: 100%;
    height: 100%;
  }

  :host > cross-wui-icon-box {
    position: absolute;
    overflow: hidden;
    right: -1px;
    bottom: -2px;
    z-index: 1;
    border: 2px solid var(--wui-color-bg-150, #1e1f1f);
    padding: 1px;
  }
`;
var __decorate$2O = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiWalletImage = class WuiWalletImage2 extends i$1 {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.name = "";
    this.installed = false;
    this.badgeSize = "xs";
  }
  render() {
    let borderRadius = "xxs";
    if (this.size === "lg") {
      borderRadius = "m";
    } else if (this.size === "md") {
      borderRadius = "xs";
    } else {
      borderRadius = "xxs";
    }
    this.style.cssText = `
       --local-border-radius: var(--wui-border-radius-${borderRadius});
       --local-size: var(--wui-wallet-image-size-${this.size});
   `;
    if (this.walletIcon) {
      this.dataset["walletIcon"] = this.walletIcon;
    }
    return x$3`
      <cross-wui-flex justifyContent="center" alignItems="center"> ${this.templateVisual()} </cross-wui-flex>
    `;
  }
  templateVisual() {
    if (this.imageSrc) {
      return x$3`<cross-wui-image src=${this.imageSrc} alt=${this.name}></cross-wui-image>`;
    } else if (this.walletIcon) {
      return x$3`<cross-wui-icon
        data-parent-size="md"
        size="md"
        color="inherit"
        name=${this.walletIcon}
      ></cross-wui-icon>`;
    }
    return x$3`<cross-wui-icon
      data-parent-size=${this.size}
      size="inherit"
      color="inherit"
      name="walletPlaceholder"
    ></cross-wui-icon>`;
  }
};
WuiWalletImage.styles = [elementStyles, resetStyles, styles$2a];
__decorate$2O([
  n$3()
], WuiWalletImage.prototype, "size", void 0);
__decorate$2O([
  n$3()
], WuiWalletImage.prototype, "name", void 0);
__decorate$2O([
  n$3()
], WuiWalletImage.prototype, "imageSrc", void 0);
__decorate$2O([
  n$3()
], WuiWalletImage.prototype, "walletIcon", void 0);
__decorate$2O([
  n$3({ type: Boolean })
], WuiWalletImage.prototype, "installed", void 0);
__decorate$2O([
  n$3()
], WuiWalletImage.prototype, "badgeSize", void 0);
WuiWalletImage = __decorate$2O([
  customElement("cross-wui-wallet-image")
], WuiWalletImage);
const styles$29 = i$4`
  :host {
    position: relative;
    border-radius: var(--wui-border-radius-xxs);
    width: 40px;
    height: 40px;
    overflow: hidden;
    background: var(--wui-color-gray-glass-002);
    display: flex;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
    gap: var(--wui-spacing-4xs);
    padding: 3.75px !important;
  }

  :host::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-color-gray-glass-010);
    pointer-events: none;
  }

  :host > cross-wui-wallet-image {
    width: 14px;
    height: 14px;
    border-radius: var(--wui-border-radius-5xs);
  }

  :host > cross-wui-flex {
    padding: 2px;
    position: fixed;
    overflow: hidden;
    left: 34px;
    bottom: 8px;
    background: var(--dark-background-150, #1e1f1f);
    border-radius: 50%;
    z-index: 2;
    display: flex;
  }
`;
var __decorate$2N = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
const TOTAL_IMAGES = 4;
let WuiAllWalletsImage = class WuiAllWalletsImage2 extends i$1 {
  constructor() {
    super(...arguments);
    this.walletImages = [];
  }
  render() {
    const isPlaceholders = this.walletImages.length < TOTAL_IMAGES;
    return x$3`${this.walletImages.slice(0, TOTAL_IMAGES).map(({ src: src2, walletName }) => x$3`
            <cross-wui-wallet-image
              size="inherit"
              imageSrc=${src2}
              name=${o$2(walletName)}
            ></cross-wui-wallet-image>
          `)}
      ${isPlaceholders ? [...Array(TOTAL_IMAGES - this.walletImages.length)].map(() => x$3` <cross-wui-wallet-image size="inherit" name=""></cross-wui-wallet-image>`) : null}
      <cross-wui-flex>
        <cross-wui-icon-box
          size="xxs"
          iconSize="xxs"
          iconcolor="success-100"
          backgroundcolor="success-100"
          icon="checkmark"
          background="opaque"
        ></cross-wui-icon-box>
      </cross-wui-flex>`;
  }
};
WuiAllWalletsImage.styles = [resetStyles, styles$29];
__decorate$2N([
  n$3({ type: Array })
], WuiAllWalletsImage.prototype, "walletImages", void 0);
WuiAllWalletsImage = __decorate$2N([
  customElement("cross-wui-all-wallets-image")
], WuiAllWalletsImage);
const styles$28 = i$4`
  :host {
    width: var(--local-width);
    position: relative;
  }

  button {
    border: none;
    border-radius: var(--local-border-radius);
    width: var(--local-width);
    white-space: nowrap;
  }

  /* -- Sizes --------------------------------------------------- */
  button[data-size='md'] {
    padding: 8.2px var(--wui-spacing-l) 9px var(--wui-spacing-l);
    height: 36px;
  }

  button[data-size='md'][data-icon-left='true'][data-icon-right='false'] {
    padding: 8.2px var(--wui-spacing-l) 9px var(--wui-spacing-s);
  }

  button[data-size='md'][data-icon-right='true'][data-icon-left='false'] {
    padding: 8.2px var(--wui-spacing-s) 9px var(--wui-spacing-l);
  }

  button[data-size='lg'] {
    padding: var(--wui-spacing-m) var(--wui-spacing-2l);
    height: 48px;
  }

  /* -- Variants --------------------------------------------------------- */
  button[data-variant='main'] {
    background-color: var(--wui-color-accent-100);
    color: var(--wui-color-inverse-100);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  button[data-variant='inverse'] {
    background-color: var(--wui-color-inverse-100);
    color: var(--wui-color-inverse-000);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  button[data-variant='accent'] {
    background-color: var(--wui-color-accent-glass-010);
    color: var(--wui-color-accent-100);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  button[data-variant='accent-error'] {
    background: var(--wui-color-error-glass-015);
    color: var(--wui-color-error-100);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-error-glass-010);
  }

  button[data-variant='accent-success'] {
    background: var(--wui-color-success-glass-015);
    color: var(--wui-color-success-100);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-success-glass-010);
  }

  button[data-variant='neutral'] {
    background: transparent;
    color: var(--wui-color-fg-100);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  /* -- Focus states --------------------------------------------------- */
  button[data-variant='main']:focus-visible:enabled {
    background-color: var(--wui-color-accent-090);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-accent-100),
      0 0 0 4px var(--wui-color-accent-glass-020);
  }
  button[data-variant='inverse']:focus-visible:enabled {
    background-color: var(--wui-color-inverse-100);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-gray-glass-010),
      0 0 0 4px var(--wui-color-accent-glass-020);
  }
  button[data-variant='accent']:focus-visible:enabled {
    background-color: var(--wui-color-accent-glass-010);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-accent-100),
      0 0 0 4px var(--wui-color-accent-glass-020);
  }
  button[data-variant='accent-error']:focus-visible:enabled {
    background: var(--wui-color-error-glass-015);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-error-100),
      0 0 0 4px var(--wui-color-error-glass-020);
  }
  button[data-variant='accent-success']:focus-visible:enabled {
    background: var(--wui-color-success-glass-015);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-success-100),
      0 0 0 4px var(--wui-color-success-glass-020);
  }
  button[data-variant='neutral']:focus-visible:enabled {
    background: var(--wui-color-gray-glass-005);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-gray-glass-010),
      0 0 0 4px var(--wui-color-gray-glass-002);
  }

  /* -- Hover & Active states ----------------------------------------------------------- */
  @media (hover: hover) and (pointer: fine) {
    button[data-variant='main']:hover:enabled {
      background-color: var(--wui-color-accent-090);
    }

    button[data-variant='main']:active:enabled {
      background-color: var(--wui-color-accent-080);
    }

    button[data-variant='accent']:hover:enabled {
      background-color: var(--wui-color-accent-glass-015);
    }

    button[data-variant='accent']:active:enabled {
      background-color: var(--wui-color-accent-glass-020);
    }

    button[data-variant='accent-error']:hover:enabled {
      background: var(--wui-color-error-glass-020);
      color: var(--wui-color-error-100);
    }

    button[data-variant='accent-error']:active:enabled {
      background: var(--wui-color-error-glass-030);
      color: var(--wui-color-error-100);
    }

    button[data-variant='accent-success']:hover:enabled {
      background: var(--wui-color-success-glass-020);
      color: var(--wui-color-success-100);
    }

    button[data-variant='accent-success']:active:enabled {
      background: var(--wui-color-success-glass-030);
      color: var(--wui-color-success-100);
    }

    button[data-variant='neutral']:hover:enabled {
      background: var(--wui-color-gray-glass-002);
    }

    button[data-variant='neutral']:active:enabled {
      background: var(--wui-color-gray-glass-005);
    }

    button[data-size='lg'][data-icon-left='true'][data-icon-right='false'] {
      padding-left: var(--wui-spacing-m);
    }

    button[data-size='lg'][data-icon-right='true'][data-icon-left='false'] {
      padding-right: var(--wui-spacing-m);
    }
  }

  /* -- Disabled state --------------------------------------------------- */
  button:disabled {
    background-color: var(--wui-color-gray-glass-002);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    color: var(--wui-color-gray-glass-020);
    cursor: not-allowed;
  }

  button > cross-wui-text {
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
    opacity: var(--local-opacity-100);
  }

  ::slotted(*) {
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
    opacity: var(--local-opacity-100);
  }

  cross-wui-loading-spinner {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    opacity: var(--local-opacity-000);
  }
`;
var __decorate$2M = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
const SPINNER_COLOR_BY_VARIANT = {
  main: "inverse-100",
  inverse: "inverse-000",
  accent: "accent-100",
  "accent-error": "error-100",
  "accent-success": "success-100",
  neutral: "fg-100",
  disabled: "gray-glass-020"
};
const TEXT_VARIANT_BY_SIZE = {
  lg: "paragraph-600",
  md: "small-600"
};
const SPINNER_SIZE_BY_SIZE = {
  lg: "md",
  md: "md"
};
let WuiButton = class WuiButton2 extends i$1 {
  constructor() {
    super(...arguments);
    this.size = "lg";
    this.disabled = false;
    this.fullWidth = false;
    this.loading = false;
    this.variant = "main";
    this.hasIconLeft = false;
    this.hasIconRight = false;
    this.borderRadius = "m";
  }
  render() {
    this.style.cssText = `
    --local-width: ${this.fullWidth ? "100%" : "auto"};
    --local-opacity-100: ${this.loading ? 0 : 1};
    --local-opacity-000: ${this.loading ? 1 : 0};
    --local-border-radius: var(--wui-border-radius-${this.borderRadius});
    `;
    const textVariant = this.textVariant ?? TEXT_VARIANT_BY_SIZE[this.size];
    return x$3`
      <button
        data-variant=${this.variant}
        data-icon-left=${this.hasIconLeft}
        data-icon-right=${this.hasIconRight}
        data-size=${this.size}
        ?disabled=${this.disabled}
      >
        ${this.loadingTemplate()}
        <slot name="iconLeft" @slotchange=${() => this.handleSlotLeftChange()}></slot>
        <cross-wui-text variant=${textVariant} color="inherit">
          <slot></slot>
        </cross-wui-text>
        <slot name="iconRight" @slotchange=${() => this.handleSlotRightChange()}></slot>
      </button>
    `;
  }
  handleSlotLeftChange() {
    this.hasIconLeft = true;
  }
  handleSlotRightChange() {
    this.hasIconRight = true;
  }
  loadingTemplate() {
    if (this.loading) {
      const size2 = SPINNER_SIZE_BY_SIZE[this.size];
      const color = this.disabled ? SPINNER_COLOR_BY_VARIANT["disabled"] : SPINNER_COLOR_BY_VARIANT[this.variant];
      return x$3`<cross-wui-loading-spinner color=${color} size=${size2}></cross-wui-loading-spinner>`;
    }
    return x$3``;
  }
};
WuiButton.styles = [resetStyles, elementStyles, styles$28];
__decorate$2M([
  n$3()
], WuiButton.prototype, "size", void 0);
__decorate$2M([
  n$3({ type: Boolean })
], WuiButton.prototype, "disabled", void 0);
__decorate$2M([
  n$3({ type: Boolean })
], WuiButton.prototype, "fullWidth", void 0);
__decorate$2M([
  n$3({ type: Boolean })
], WuiButton.prototype, "loading", void 0);
__decorate$2M([
  n$3()
], WuiButton.prototype, "variant", void 0);
__decorate$2M([
  n$3({ type: Boolean })
], WuiButton.prototype, "hasIconLeft", void 0);
__decorate$2M([
  n$3({ type: Boolean })
], WuiButton.prototype, "hasIconRight", void 0);
__decorate$2M([
  n$3()
], WuiButton.prototype, "borderRadius", void 0);
__decorate$2M([
  n$3()
], WuiButton.prototype, "textVariant", void 0);
WuiButton = __decorate$2M([
  customElement("cross-wui-button")
], WuiButton);
const networkSvgMd = b$2`<svg  viewBox="0 0 48 54" fill="none">
  <path
    d="M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z"
  />
</svg>`;
const styles$27 = i$4`
  :host {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 104px;
    row-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xs) 10px;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
    position: relative;
  }

  wui-shimmer[data-type='network'] {
    border: none;
    -webkit-clip-path: var(--wui-path-network);
    clip-path: var(--wui-path-network);
  }

  svg {
    position: absolute;
    width: 48px;
    height: 54px;
    z-index: 1;
  }

  svg > path {
    stroke: var(--wui-color-gray-glass-010);
    stroke-width: 1px;
  }

  @media (max-width: 350px) {
    :host {
      width: 100%;
    }
  }
`;
var __decorate$2L = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiCardSelectLoader = class WuiCardSelectLoader2 extends i$1 {
  constructor() {
    super(...arguments);
    this.type = "wallet";
  }
  render() {
    return x$3`
      ${this.shimmerTemplate()}
      <cross-wui-shimmer width="56px" height="20px" borderRadius="xs"></cross-wui-shimmer>
    `;
  }
  shimmerTemplate() {
    if (this.type === "network") {
      return x$3` <cross-wui-shimmer
          data-type=${this.type}
          width="48px"
          height="54px"
          borderRadius="xs"
        ></cross-wui-shimmer>
        ${networkSvgMd}`;
    }
    return x$3`<cross-wui-shimmer width="56px" height="56px" borderRadius="xs"></cross-wui-shimmer>`;
  }
};
WuiCardSelectLoader.styles = [resetStyles, elementStyles, styles$27];
__decorate$2L([
  n$3()
], WuiCardSelectLoader.prototype, "type", void 0);
WuiCardSelectLoader = __decorate$2L([
  customElement("cross-wui-card-select-loader")
], WuiCardSelectLoader);
const networkSvgLg = b$2`<svg width="86" height="96" fill="none">
  <path
    d="M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z"
  />
</svg>`;
const networkSvgSm = b$2`
  <svg fill="none" viewBox="0 0 36 40">
    <path
      d="M15.4 2.1a5.21 5.21 0 0 1 5.2 0l11.61 6.7a5.21 5.21 0 0 1 2.61 4.52v13.4c0 1.87-1 3.59-2.6 4.52l-11.61 6.7c-1.62.93-3.6.93-5.22 0l-11.6-6.7a5.21 5.21 0 0 1-2.61-4.51v-13.4c0-1.87 1-3.6 2.6-4.52L15.4 2.1Z"
    />
  </svg>
`;
const styles$26 = i$4`
  :host {
    position: relative;
    border-radius: inherit;
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--local-width);
    height: var(--local-height);
  }

  :host([data-round='true']) {
    background: var(--wui-color-gray-glass-002);
    border-radius: 100%;
    outline: 1px solid var(--wui-color-gray-glass-005);
  }

  svg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
    fill: var(--wui-color-gray-glass-002);
  }

  svg > path {
    stroke: var(--local-stroke);
  }

  cross-wui-image {
    width: 100%;
    height: 100%;
    -webkit-clip-path: var(--local-path);
    clip-path: var(--local-path);
    background: var(--wui-color-gray-glass-002);
  }

  cross-wui-icon {
    transform: translateY(-5%);
    width: var(--local-icon-size);
    height: var(--local-icon-size);
  }
`;
var __decorate$2K = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiNetworkImage = class WuiNetworkImage2 extends i$1 {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.name = "uknown";
    this.networkImagesBySize = {
      sm: networkSvgSm,
      md: networkSvgMd,
      lg: networkSvgLg
    };
    this.selected = false;
    this.round = false;
  }
  render() {
    if (this.round) {
      this.dataset["round"] = "true";
      this.style.cssText = `
      --local-width: var(--wui-spacing-3xl);
      --local-height: var(--wui-spacing-3xl);
      --local-icon-size: var(--wui-spacing-l);
    `;
    } else {
      this.style.cssText = `

      --local-path: var(--wui-path-network-${this.size});
      --local-width:  var(--wui-width-network-${this.size});
      --local-height:  var(--wui-height-network-${this.size});
      --local-icon-size:  var(--wui-icon-size-network-${this.size});
    `;
    }
    return x$3`${this.templateVisual()} ${this.svgTemplate()} `;
  }
  svgTemplate() {
    if (this.round) {
      return null;
    }
    return this.networkImagesBySize[this.size];
  }
  templateVisual() {
    if (this.imageSrc) {
      return x$3`<cross-wui-image src=${this.imageSrc} alt=${this.name}></cross-wui-image>`;
    }
    return x$3`<cross-wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></cross-wui-icon>`;
  }
};
WuiNetworkImage.styles = [resetStyles, styles$26];
__decorate$2K([
  n$3()
], WuiNetworkImage.prototype, "size", void 0);
__decorate$2K([
  n$3()
], WuiNetworkImage.prototype, "name", void 0);
__decorate$2K([
  n$3({ type: Object })
], WuiNetworkImage.prototype, "networkImagesBySize", void 0);
__decorate$2K([
  n$3()
], WuiNetworkImage.prototype, "imageSrc", void 0);
__decorate$2K([
  n$3({ type: Boolean })
], WuiNetworkImage.prototype, "selected", void 0);
__decorate$2K([
  n$3({ type: Boolean })
], WuiNetworkImage.prototype, "round", void 0);
WuiNetworkImage = __decorate$2K([
  customElement("cross-wui-network-image")
], WuiNetworkImage);
const styles$25 = i$4`
  button {
    flex-direction: column;
    width: 76px;
    row-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xs) var(--wui-spacing-0);
    background-color: var(--wui-color-gray-glass-002);
    border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
  }

  button > cross-wui-text {
    color: var(--wui-color-fg-100);
    max-width: var(--wui-icon-box-size-xl);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    justify-content: center;
  }

  button:disabled > cross-wui-text {
    color: var(--wui-color-gray-glass-015);
  }

  [data-selected='true'] {
    background-color: var(--wui-color-accent-glass-020);
  }

  @media (hover: hover) and (pointer: fine) {
    [data-selected='true']:hover:enabled {
      background-color: var(--wui-color-accent-glass-015);
    }
  }

  [data-selected='true']:active:enabled {
    background-color: var(--wui-color-accent-glass-010);
  }
`;
var __decorate$2J = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiCardSelect = class WuiCardSelect2 extends i$1 {
  constructor() {
    super(...arguments);
    this.name = "Unknown";
    this.type = "wallet";
    this.imageSrc = void 0;
    this.disabled = false;
    this.selected = false;
    this.installed = false;
  }
  render() {
    return x$3`
      <button data-selected=${o$2(this.selected)} ?disabled=${this.disabled}>
        ${this.imageTemplate()}
        <cross-wui-text variant="tiny-500" color=${this.selected ? "accent-100" : "inherit"}>
          ${this.name}
        </cross-wui-text>
      </button>
    `;
  }
  imageTemplate() {
    if (this.type === "network") {
      return x$3`
        <cross-wui-network-image
          .selected=${this.selected}
          imageSrc=${o$2(this.imageSrc)}
          name=${this.name}
        >
        </cross-wui-network-image>
      `;
    }
    return x$3`
      <cross-wui-wallet-image
        size="md"
        imageSrc=${o$2(this.imageSrc)}
        name=${this.name}
        .installed=${this.installed}
        badgeSize="sm"
      >
      </cross-wui-wallet-image>
    `;
  }
};
WuiCardSelect.styles = [resetStyles, elementStyles, styles$25];
__decorate$2J([
  n$3()
], WuiCardSelect.prototype, "name", void 0);
__decorate$2J([
  n$3()
], WuiCardSelect.prototype, "type", void 0);
__decorate$2J([
  n$3()
], WuiCardSelect.prototype, "imageSrc", void 0);
__decorate$2J([
  n$3({ type: Boolean })
], WuiCardSelect.prototype, "disabled", void 0);
__decorate$2J([
  n$3({ type: Boolean })
], WuiCardSelect.prototype, "selected", void 0);
__decorate$2J([
  n$3({ type: Boolean })
], WuiCardSelect.prototype, "installed", void 0);
WuiCardSelect = __decorate$2J([
  customElement("cross-wui-card-select")
], WuiCardSelect);
const styles$24 = i$4`
  a {
    border: 1px solid var(--wui-color-gray-glass-010);
    border-radius: var(--wui-border-radius-3xl);
  }

  cross-wui-image {
    border-radius: var(--wui-border-radius-3xl);
    overflow: hidden;
  }

  a.disabled > wui-icon:not(.image-icon),
  a.disabled > cross-wui-image {
    filter: grayscale(1);
  }

  a[data-variant='fill'] {
    color: var(--wui-color-inverse-100);
    background-color: var(--wui-color-accent-100);
  }

  a[data-variant='shade'],
  a[data-variant='shadeSmall'] {
    background-color: transparent;
    background-color: var(--wui-color-gray-glass-010);
    color: var(--wui-color-fg-200);
  }

  a[data-variant='success'] {
    column-gap: var(--wui-spacing-xxs);
    border: 1px solid var(--wui-color-success-glass-010);
    background-color: var(--wui-color-success-glass-010);
    color: var(--wui-color-success-100);
  }

  a[data-variant='error'] {
    column-gap: var(--wui-spacing-xxs);
    border: 1px solid var(--wui-color-error-glass-010);
    background-color: var(--wui-color-error-glass-010);
    color: var(--wui-color-error-100);
  }

  a[data-variant='transparent'] {
    column-gap: var(--wui-spacing-xxs);
    background-color: transparent;
    color: var(--wui-color-fg-150);
  }

  a[data-variant='transparent'],
  a[data-variant='success'],
  a[data-variant='shadeSmall'],
  a[data-variant='error'] {
    padding: 7px var(--wui-spacing-s) 7px 10px;
  }

  a[data-variant='transparent']:has(wui-text:first-child),
  a[data-variant='success']:has(wui-text:first-child),
  a[data-variant='shadeSmall']:has(wui-text:first-child),
  a[data-variant='error']:has(wui-text:first-child) {
    padding: 7px var(--wui-spacing-s);
  }

  a[data-variant='fill'],
  a[data-variant='shade'] {
    column-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xxs) var(--wui-spacing-m) var(--wui-spacing-xxs)
      var(--wui-spacing-xs);
  }

  a[data-variant='fill']:has(wui-text:first-child),
  a[data-variant='shade']:has(wui-text:first-child) {
    padding: 9px var(--wui-spacing-m) 9px var(--wui-spacing-m);
  }

  a[data-variant='fill'] > cross-wui-image,
  a[data-variant='shade'] > cross-wui-image {
    width: 24px;
    height: 24px;
  }

  a[data-variant='fill'] > cross-wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-color-accent-090);
  }

  a[data-variant='shade'] > cross-wui-image,
  a[data-variant='shadeSmall'] > cross-wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  a[data-variant='fill'] > wui-icon:not(.image-icon),
  a[data-variant='shade'] > wui-icon:not(.image-icon) {
    width: 14px;
    height: 14px;
  }

  a[data-variant='transparent'] > cross-wui-image,
  a[data-variant='success'] > cross-wui-image,
  a[data-variant='shadeSmall'] > cross-wui-image,
  a[data-variant='error'] > cross-wui-image {
    width: 14px;
    height: 14px;
  }

  a[data-variant='transparent'] > wui-icon:not(.image-icon),
  a[data-variant='success'] > wui-icon:not(.image-icon),
  a[data-variant='shadeSmall'] > wui-icon:not(.image-icon),
  a[data-variant='error'] > wui-icon:not(.image-icon) {
    width: 12px;
    height: 12px;
  }

  a[data-variant='fill']:focus-visible {
    background-color: var(--wui-color-accent-090);
  }

  a[data-variant='shade']:focus-visible,
  a[data-variant='shadeSmall']:focus-visible {
    background-color: var(--wui-color-gray-glass-015);
  }

  a[data-variant='transparent']:focus-visible {
    background-color: var(--wui-color-gray-glass-005);
  }

  a[data-variant='success']:focus-visible {
    background-color: var(--wui-color-success-glass-015);
  }

  a[data-variant='error']:focus-visible {
    background-color: var(--wui-color-error-glass-015);
  }

  a.disabled {
    color: var(--wui-color-gray-glass-015);
    background-color: var(--wui-color-gray-glass-015);
    pointer-events: none;
  }

  @media (hover: hover) and (pointer: fine) {
    a[data-variant='fill']:hover {
      background-color: var(--wui-color-accent-090);
    }

    a[data-variant='shade']:hover,
    a[data-variant='shadeSmall']:hover {
      background-color: var(--wui-color-gray-glass-015);
    }

    a[data-variant='transparent']:hover {
      background-color: var(--wui-color-gray-glass-005);
    }

    a[data-variant='success']:hover {
      background-color: var(--wui-color-success-glass-015);
    }

    a[data-variant='error']:hover {
      background-color: var(--wui-color-error-glass-015);
    }
  }

  a[data-variant='fill']:active {
    background-color: var(--wui-color-accent-080);
  }

  a[data-variant='shade']:active,
  a[data-variant='shadeSmall']:active {
    background-color: var(--wui-color-gray-glass-020);
  }

  a[data-variant='transparent']:active {
    background-color: var(--wui-color-gray-glass-010);
  }

  a[data-variant='success']:active {
    background-color: var(--wui-color-success-glass-020);
  }

  a[data-variant='error']:active {
    background-color: var(--wui-color-error-glass-020);
  }
`;
var __decorate$2I = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiChip = class WuiChip2 extends i$1 {
  constructor() {
    super(...arguments);
    this.variant = "fill";
    this.imageSrc = void 0;
    this.imageIcon = void 0;
    this.imageIconSize = "md";
    this.disabled = false;
    this.icon = "externalLink";
    this.href = "";
    this.text = void 0;
  }
  render() {
    const isSmall = this.variant === "success" || this.variant === "transparent" || this.variant === "shadeSmall";
    const textVariant = isSmall ? "small-600" : "paragraph-600";
    return x$3`
      <a
        rel="noreferrer"
        target="_blank"
        href=${this.href}
        class=${this.disabled ? "disabled" : ""}
        data-variant=${this.variant}
      >
        ${this.imageTemplate()}
        <cross-wui-text variant=${textVariant} color="inherit">
          ${this.title ? this.title : UiHelperUtil.getHostName(this.href)}
        </cross-wui-text>
        <cross-wui-icon name=${this.icon} color="inherit" size="inherit"></cross-wui-icon>
      </a>
    `;
  }
  imageTemplate() {
    if (this.imageSrc) {
      return x$3`<cross-wui-image src=${this.imageSrc}></cross-wui-image>`;
    }
    if (this.imageIcon) {
      return x$3`<cross-wui-icon
        name=${this.imageIcon}
        color="inherit"
        size=${this.imageIconSize}
        class="image-icon"
      ></cross-wui-icon>`;
    }
    return null;
  }
};
WuiChip.styles = [resetStyles, elementStyles, styles$24];
__decorate$2I([
  n$3()
], WuiChip.prototype, "variant", void 0);
__decorate$2I([
  n$3()
], WuiChip.prototype, "imageSrc", void 0);
__decorate$2I([
  n$3()
], WuiChip.prototype, "imageIcon", void 0);
__decorate$2I([
  n$3()
], WuiChip.prototype, "imageIconSize", void 0);
__decorate$2I([
  n$3({ type: Boolean })
], WuiChip.prototype, "disabled", void 0);
__decorate$2I([
  n$3()
], WuiChip.prototype, "icon", void 0);
__decorate$2I([
  n$3()
], WuiChip.prototype, "href", void 0);
__decorate$2I([
  n$3()
], WuiChip.prototype, "text", void 0);
WuiChip = __decorate$2I([
  customElement("cross-wui-chip")
], WuiChip);
const styles$23 = i$4`
  :host {
    position: relative;
    display: block;
  }

  button {
    background: var(--wui-color-accent-100);
    border: 1px solid var(--wui-color-gray-glass-010);
    border-radius: var(--wui-border-radius-m);
    gap: var(--wui-spacing-xs);
  }

  button.loading {
    background: var(--wui-color-gray-glass-010);
    border: 1px solid var(--wui-color-gray-glass-010);
    pointer-events: none;
  }

  button:disabled {
    background-color: var(--wui-color-gray-glass-015);
    border: 1px solid var(--wui-color-gray-glass-010);
  }

  button:disabled > cross-wui-text {
    color: var(--wui-color-gray-glass-015);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-accent-090);
    }

    button:active:enabled {
      background-color: var(--wui-color-accent-080);
    }
  }

  button:focus-visible {
    border: 1px solid var(--wui-color-gray-glass-010);
    background-color: var(--wui-color-accent-090);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  button[data-size='sm'] {
    padding: 6.75px 10px 7.25px;
  }

  ::slotted(*) {
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
    opacity: var(--local-opacity-100);
  }

  button > cross-wui-text {
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
    opacity: var(--local-opacity-100);
    color: var(--wui-color-inverse-100);
  }

  button[data-size='md'] {
    padding: 9px var(--wui-spacing-l) 9px var(--wui-spacing-l);
  }

  button[data-size='md'] + cross-wui-text {
    padding-left: var(--wui-spacing-3xs);
  }

  @media (max-width: 500px) {
    button[data-size='md'] {
      height: 32px;
      padding: 5px 12px;
    }

    button[data-size='md'] > wui-text > slot {
      font-size: 14px !important;
    }
  }

  cross-wui-loading-spinner {
    width: 14px;
    height: 14px;
  }

  wui-loading-spinner::slotted(svg) {
    width: 10px !important;
    height: 10px !important;
  }

  button[data-size='sm'] > cross-wui-loading-spinner {
    width: 12px;
    height: 12px;
  }
`;
var __decorate$2H = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiConnectButton = class WuiConnectButton2 extends i$1 {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.loading = false;
  }
  render() {
    const textVariant = this.size === "md" ? "paragraph-600" : "small-600";
    return x$3`
      <button data-size=${this.size} ?disabled=${this.loading}>
        ${this.loadingTemplate()}
        <cross-wui-text variant=${textVariant} color=${this.loading ? "accent-100" : "inherit"}>
          <slot></slot>
        </cross-wui-text>
      </button>
    `;
  }
  loadingTemplate() {
    if (!this.loading) {
      return null;
    }
    return x$3`<cross-wui-loading-spinner size=${this.size} color="accent-100"></cross-wui-loading-spinner>`;
  }
};
WuiConnectButton.styles = [resetStyles, elementStyles, styles$23];
__decorate$2H([
  n$3()
], WuiConnectButton.prototype, "size", void 0);
__decorate$2H([
  n$3({ type: Boolean })
], WuiConnectButton.prototype, "loading", void 0);
WuiConnectButton = __decorate$2H([
  customElement("cross-wui-connect-button")
], WuiConnectButton);
const styles$22 = i$4`
  cross-wui-flex {
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }
`;
var __decorate$2G = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiCtaButton = class WuiCtaButton2 extends i$1 {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.label = "";
    this.buttonLabel = "";
  }
  render() {
    return x$3`
      <cross-wui-flex
        justifyContent="space-between"
        alignItems="center"
        .padding=${["1xs", "2l", "1xs", "2l"]}
      >
        <cross-wui-text variant="paragraph-500" color="fg-200">${this.label}</cross-wui-text>
        <cross-wui-chip-button size="sm" variant="shade" text=${this.buttonLabel} icon="chevronRight">
        </cross-wui-chip-button>
      </cross-wui-flex>
    `;
  }
};
WuiCtaButton.styles = [resetStyles, elementStyles, styles$22];
__decorate$2G([
  n$3({ type: Boolean })
], WuiCtaButton.prototype, "disabled", void 0);
__decorate$2G([
  n$3()
], WuiCtaButton.prototype, "label", void 0);
__decorate$2G([
  n$3()
], WuiCtaButton.prototype, "buttonLabel", void 0);
WuiCtaButton = __decorate$2G([
  customElement("cross-wui-cta-button")
], WuiCtaButton);
const styles$21 = i$4`
  :host {
    display: block;
    padding: var(--wui-spacing-l) var(--wui-spacing-m);
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    width: 100%;
  }
`;
var __decorate$2F = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiDetailsGroup = class WuiDetailsGroup2 extends i$1 {
  render() {
    return x$3`
      <cross-wui-flex gap="xl" flexDirection="column" justifyContent="space-between" alignItems="center">
        <slot></slot>
      </cross-wui-flex>
    `;
  }
};
WuiDetailsGroup.styles = [resetStyles, elementStyles, styles$21];
WuiDetailsGroup = __decorate$2F([
  customElement("cross-wui-details-group")
], WuiDetailsGroup);
const styles$20 = i$4`
  :host {
    display: flex;
    flex-direction: row;
    gap: var(--wui-spacing-l);
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
  }
`;
var __decorate$2E = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiDetailsGroupItem = class WuiDetailsGroupItem2 extends i$1 {
  constructor() {
    super(...arguments);
    this.name = "";
  }
  render() {
    return x$3`
      <cross-wui-flex justifyContent="space-between" alignItems="center">
        <cross-wui-text variant="paragraph-500" color="fg-200">${this.name}</cross-wui-text>
        <cross-wui-flex gap="xs" alignItems="center">
          <slot></slot>
        </cross-wui-flex>
      </cross-wui-flex>
    `;
  }
};
WuiDetailsGroupItem.styles = [resetStyles, elementStyles, styles$20];
__decorate$2E([
  n$3()
], WuiDetailsGroupItem.prototype, "name", void 0);
WuiDetailsGroupItem = __decorate$2E([
  customElement("cross-wui-details-group-item")
], WuiDetailsGroupItem);
const styles$1$ = i$4`
  :host {
    z-index: calc(var(--w3m-z-index) + 1);
    width: 200px;
    padding: var(--wui-spacing-3xs);
    align-items: center;
    display: inherit;
    border-radius: var(--wui-border-radius-xs);
    border: 1px solid var(--wui-color-gray-glass-002);
    background: var(--wui-color-fg-base-125);
    /* Dark/Elevation/L */
    box-shadow:
      0px 8px 22px -6px rgba(0, 0, 0, 0.12),
      0px 14px 64px -4px rgba(0, 0, 0, 0.12);
  }
`;
var __decorate$2D = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiDropdownMenu = class WuiDropdownMenu2 extends i$1 {
  constructor() {
    super(...arguments);
    this.actions = [];
    this.isOpen = false;
  }
  render() {
    if (!this.isOpen) {
      return null;
    }
    return x$3`
      <cross-wui-flex flexDirection="column" gap="4xs">
        ${this.actions.map((action) => x$3`
            <cross-wui-list-item
              icon=${action.icon}
              iconSize="sm"
              variant="icon"
              @click=${action.onClick}
            >
              <cross-wui-text variant="small-400" color="fg-100">${action.label}</cross-wui-text>
            </cross-wui-list-item>
          `)}
      </cross-wui-flex>
    `;
  }
};
WuiDropdownMenu.styles = [resetStyles, elementStyles, styles$1$];
__decorate$2D([
  n$3({ type: Array })
], WuiDropdownMenu.prototype, "actions", void 0);
__decorate$2D([
  n$3({ type: Boolean })
], WuiDropdownMenu.prototype, "isOpen", void 0);
WuiDropdownMenu = __decorate$2D([
  customElement("cross-wui-dropdown-menu")
], WuiDropdownMenu);
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const f$2 = (o3) => void 0 === o3.strings;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const s = (i4, t2) => {
  var _a3;
  const e3 = i4._$AN;
  if (void 0 === e3) return false;
  for (const i5 of e3) (_a3 = i5._$AO) == null ? void 0 : _a3.call(i5, t2, false), s(i5, t2);
  return true;
}, o$1 = (i4) => {
  let t2, e3;
  do {
    if (void 0 === (t2 = i4._$AM)) break;
    e3 = t2._$AN, e3.delete(i4), i4 = t2;
  } while (0 === (e3 == null ? void 0 : e3.size));
}, r = (i4) => {
  for (let t2; t2 = i4._$AM; i4 = t2) {
    let e3 = t2._$AN;
    if (void 0 === e3) t2._$AN = e3 = /* @__PURE__ */ new Set();
    else if (e3.has(i4)) break;
    e3.add(i4), c$1(t2);
  }
};
function h$2(i4) {
  void 0 !== this._$AN ? (o$1(this), this._$AM = i4, r(this)) : this._$AM = i4;
}
function n$2(i4, t2 = false, e3 = 0) {
  const r3 = this._$AH, h5 = this._$AN;
  if (void 0 !== h5 && 0 !== h5.size) if (t2) if (Array.isArray(r3)) for (let i5 = e3; i5 < r3.length; i5++) s(r3[i5], false), o$1(r3[i5]);
  else null != r3 && (s(r3, false), o$1(r3));
  else s(this, i4);
}
const c$1 = (i4) => {
  i4.type == t.CHILD && (i4._$AP ?? (i4._$AP = n$2), i4._$AQ ?? (i4._$AQ = h$2));
};
let f$1 = class f5 extends i {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(i4, t2, e3) {
    super._$AT(i4, t2, e3), r(this), this.isConnected = i4._$AU;
  }
  _$AO(i4, t2 = true) {
    var _a3, _b2;
    i4 !== this.isConnected && (this.isConnected = i4, i4 ? (_a3 = this.reconnected) == null ? void 0 : _a3.call(this) : (_b2 = this.disconnected) == null ? void 0 : _b2.call(this)), t2 && (s(this, i4), o$1(this));
  }
  setValue(t2) {
    if (f$2(this._$Ct)) this._$Ct._$AI(t2, this);
    else {
      const i4 = [...this._$Ct._$AH];
      i4[this._$Ci] = t2, this._$Ct._$AI(i4, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
};
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e = () => new h$1();
let h$1 = class h4 {
};
const o = /* @__PURE__ */ new WeakMap(), n$1 = e$2(class extends f$1 {
  render(i4) {
    return E$2;
  }
  update(i4, [s2]) {
    var _a3;
    const e3 = s2 !== this.G;
    return e3 && void 0 !== this.G && this.rt(void 0), (e3 || this.lt !== this.ct) && (this.G = s2, this.ht = (_a3 = i4.options) == null ? void 0 : _a3.host, this.rt(this.ct = i4.element)), E$2;
  }
  rt(t2) {
    if (this.isConnected || (t2 = void 0), "function" == typeof this.G) {
      const i4 = this.ht ?? globalThis;
      let s2 = o.get(i4);
      void 0 === s2 && (s2 = /* @__PURE__ */ new WeakMap(), o.set(i4, s2)), void 0 !== s2.get(this.G) && this.G.call(this.ht, void 0), s2.set(this.G, t2), void 0 !== t2 && this.G.call(this.ht, t2);
    } else this.G.value = t2;
  }
  get lt() {
    var _a3, _b2;
    return "function" == typeof this.G ? (_a3 = o.get(this.ht ?? globalThis)) == null ? void 0 : _a3.get(this.G) : (_b2 = this.G) == null ? void 0 : _b2.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
const styles$1_ = i$4`
  :host {
    position: relative;
    width: 100%;
    display: inline-block;
    color: var(--wui-color-fg-275);
  }

  input {
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    background: var(--wui-color-gray-glass-002);
    font-size: var(--wui-font-size-paragraph);
    letter-spacing: var(--wui-letter-spacing-paragraph);
    color: var(--wui-color-fg-100);
    transition:
      background-color var(--wui-ease-inout-power-1) var(--wui-duration-md),
      border-color var(--wui-ease-inout-power-1) var(--wui-duration-md),
      box-shadow var(--wui-ease-inout-power-1) var(--wui-duration-md);
    will-change: background-color, border-color, box-shadow;
    caret-color: var(--wui-color-accent-100);
  }

  input:disabled {
    cursor: not-allowed;
    border: 1px solid var(--wui-color-gray-glass-010);
  }

  input:disabled::placeholder,
  input:disabled + cross-wui-icon {
    color: var(--wui-color-fg-300);
  }

  input::placeholder {
    color: var(--wui-color-fg-275);
  }

  input:focus:enabled {
    background-color: var(--wui-color-gray-glass-005);
    -webkit-box-shadow:
      inset 0 0 0 1px var(--wui-color-accent-100),
      0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow:
      inset 0 0 0 1px var(--wui-color-accent-100),
      0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-accent-100),
      0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  input:hover:enabled {
    background-color: var(--wui-color-gray-glass-005);
  }

  cross-wui-icon {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    pointer-events: none;
  }

  .cross-wui-size-sm {
    padding: 9px var(--wui-spacing-m) 10px var(--wui-spacing-s);
  }

  wui-icon + .cross-wui-size-sm {
    padding: 9px var(--wui-spacing-m) 10px 36px;
  }

  wui-icon[data-input='sm'] {
    left: var(--wui-spacing-s);
  }

  .cross-wui-size-md {
    padding: 15px var(--wui-spacing-m) var(--wui-spacing-l) var(--wui-spacing-m);
  }

  wui-icon + .cross-wui-size-md,
  wui-loading-spinner + .cross-wui-size-md {
    padding: 10.5px var(--wui-spacing-3xl) 10.5px var(--wui-spacing-3xl);
  }

  wui-icon[data-input='md'] {
    left: var(--wui-spacing-l);
  }

  .cross-wui-size-lg {
    padding: var(--wui-spacing-s) var(--wui-spacing-s) var(--wui-spacing-s) var(--wui-spacing-l);
    letter-spacing: var(--wui-letter-spacing-medium-title);
    font-size: var(--wui-font-size-medium-title);
    font-weight: var(--wui-font-weight-light);
    line-height: 130%;
    color: var(--wui-color-fg-100);
    height: 64px;
  }

  .cross-wui-padding-right-xs {
    padding-right: var(--wui-spacing-xs);
  }

  .cross-wui-padding-right-s {
    padding-right: var(--wui-spacing-s);
  }

  .cross-wui-padding-right-m {
    padding-right: var(--wui-spacing-m);
  }

  .cross-wui-padding-right-l {
    padding-right: var(--wui-spacing-l);
  }

  .cross-wui-padding-right-xl {
    padding-right: var(--wui-spacing-xl);
  }

  .wui-padding-right-2xl {
    padding-right: var(--wui-spacing-2xl);
  }

  .wui-padding-right-3xl {
    padding-right: var(--wui-spacing-3xl);
  }

  .wui-padding-right-4xl {
    padding-right: var(--wui-spacing-4xl);
  }

  .wui-padding-right-5xl {
    padding-right: var(--wui-spacing-5xl);
  }

  wui-icon + .cross-wui-size-lg,
  wui-loading-spinner + .cross-wui-size-lg {
    padding-left: 50px;
  }

  wui-icon[data-input='lg'] {
    left: var(--wui-spacing-l);
  }

  .cross-wui-size-mdl {
    padding: 17.25px var(--wui-spacing-m) 17.25px var(--wui-spacing-m);
  }
  wui-icon + .cross-wui-size-mdl,
  wui-loading-spinner + .cross-wui-size-mdl {
    padding: 17.25px var(--wui-spacing-3xl) 17.25px 40px;
  }
  wui-icon[data-input='mdl'] {
    left: var(--wui-spacing-m);
  }

  input:placeholder-shown ~ ::slotted(wui-input-element),
  input:placeholder-shown ~ ::slotted(wui-icon) {
    opacity: 0;
    pointer-events: none;
  }

  input::-webkit-outer-spin-button,
  input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  input[type='number'] {
    -moz-appearance: textfield;
  }

  ::slotted(wui-input-element),
  ::slotted(wui-icon) {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
  }

  ::slotted(wui-input-element) {
    right: var(--wui-spacing-m);
  }

  ::slotted(wui-icon) {
    right: 0px;
  }
`;
var __decorate$2C = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiInputText = class WuiInputText2 extends i$1 {
  constructor() {
    super(...arguments);
    this.inputElementRef = e();
    this.size = "md";
    this.disabled = false;
    this.placeholder = "";
    this.type = "text";
    this.value = "";
  }
  render() {
    const inputClass = `wui-padding-right-${this.inputRightPadding}`;
    const sizeClass = `wui-size-${this.size}`;
    const classes = {
      [sizeClass]: true,
      [inputClass]: Boolean(this.inputRightPadding)
    };
    return x$3`${this.templateIcon()}
      <input
        data-testid="wui-input-text"
        ${n$1(this.inputElementRef)}
        class=${e$1(classes)}
        type=${this.type}
        enterkeyhint=${o$2(this.enterKeyHint)}
        ?disabled=${this.disabled}
        placeholder=${this.placeholder}
        @input=${this.dispatchInputChangeEvent.bind(this)}
        .value=${this.value || ""}
        tabindex=${o$2(this.tabIdx)}
      />
      <slot></slot>`;
  }
  templateIcon() {
    if (this.icon) {
      return x$3`<cross-wui-icon
        data-input=${this.size}
        size=${this.size}
        color="inherit"
        name=${this.icon}
      ></cross-wui-icon>`;
    }
    return null;
  }
  dispatchInputChangeEvent() {
    var _a3;
    this.dispatchEvent(new CustomEvent("inputChange", {
      detail: (_a3 = this.inputElementRef.value) == null ? void 0 : _a3.value,
      bubbles: true,
      composed: true
    }));
  }
};
WuiInputText.styles = [resetStyles, elementStyles, styles$1_];
__decorate$2C([
  n$3()
], WuiInputText.prototype, "size", void 0);
__decorate$2C([
  n$3()
], WuiInputText.prototype, "icon", void 0);
__decorate$2C([
  n$3({ type: Boolean })
], WuiInputText.prototype, "disabled", void 0);
__decorate$2C([
  n$3()
], WuiInputText.prototype, "placeholder", void 0);
__decorate$2C([
  n$3()
], WuiInputText.prototype, "type", void 0);
__decorate$2C([
  n$3()
], WuiInputText.prototype, "keyHint", void 0);
__decorate$2C([
  n$3()
], WuiInputText.prototype, "value", void 0);
__decorate$2C([
  n$3()
], WuiInputText.prototype, "inputRightPadding", void 0);
__decorate$2C([
  n$3()
], WuiInputText.prototype, "tabIdx", void 0);
WuiInputText = __decorate$2C([
  customElement("cross-wui-input-text")
], WuiInputText);
const styles$1Z = i$4`
  :host {
    position: relative;
    display: inline-block;
  }

  cross-wui-text {
    margin: var(--wui-spacing-xxs) var(--wui-spacing-m) var(--wui-spacing-0) var(--wui-spacing-m);
  }
`;
var __decorate$2B = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiEmailInput = class WuiEmailInput2 extends i$1 {
  constructor() {
    super(...arguments);
    this.disabled = false;
  }
  render() {
    return x$3`
      <cross-wui-input-text
        type="email"
        placeholder="Email"
        icon="mail"
        size="mdl"
        .disabled=${this.disabled}
        .value=${this.value}
        data-testid="wui-email-input"
        tabIdx=${o$2(this.tabIdx)}
      ></cross-wui-input-text>
      ${this.templateError()}
    `;
  }
  templateError() {
    if (this.errorMessage) {
      return x$3`<cross-wui-text variant="tiny-500" color="error-100">${this.errorMessage}</cross-wui-text>`;
    }
    return null;
  }
};
WuiEmailInput.styles = [resetStyles, styles$1Z];
__decorate$2B([
  n$3()
], WuiEmailInput.prototype, "errorMessage", void 0);
__decorate$2B([
  n$3({ type: Boolean })
], WuiEmailInput.prototype, "disabled", void 0);
__decorate$2B([
  n$3()
], WuiEmailInput.prototype, "value", void 0);
__decorate$2B([
  n$3()
], WuiEmailInput.prototype, "tabIdx", void 0);
WuiEmailInput = __decorate$2B([
  customElement("cross-wui-email-input")
], WuiEmailInput);
const styles$1Y = i$4`
  :host {
    position: relative;
    width: 100%;
    display: inline-block;
    color: var(--wui-color-fg-275);
  }

  .error {
    margin: var(--wui-spacing-xxs) var(--wui-spacing-m) var(--wui-spacing-0) var(--wui-spacing-m);
  }

  .base-name {
    position: absolute;
    right: 45px;
    top: 15px;
    text-align: right;
  }
`;
var __decorate$2A = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiEnsInput = class WuiEnsInput2 extends i$1 {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.loading = false;
  }
  render() {
    return x$3`
      <cross-wui-input-text
        value=${o$2(this.value)}
        ?disabled=${this.disabled}
        .value=${this.value || ""}
        data-testid="wui-ens-input"
        inputRightPadding="5xl"
      >
        ${this.baseNameTemplate()} ${this.errorTemplate()}${this.loadingTemplate()}
      </cross-wui-input-text>
    `;
  }
  baseNameTemplate() {
    return x$3`<cross-wui-text variant="paragraph-400" color="fg-200" class="base-name">
      ${ConstantsUtil$4.WC_NAME_SUFFIX}
    </cross-wui-text>`;
  }
  loadingTemplate() {
    return this.loading ? x$3`<cross-wui-loading-spinner size="md" color="accent-100"></cross-wui-loading-spinner>` : null;
  }
  errorTemplate() {
    if (this.errorMessage) {
      return x$3`<cross-wui-text variant="tiny-500" color="error-100" class="error"
        >${this.errorMessage}</wui-text
      >`;
    }
    return null;
  }
};
WuiEnsInput.styles = [resetStyles, styles$1Y];
__decorate$2A([
  n$3()
], WuiEnsInput.prototype, "errorMessage", void 0);
__decorate$2A([
  n$3({ type: Boolean })
], WuiEnsInput.prototype, "disabled", void 0);
__decorate$2A([
  n$3()
], WuiEnsInput.prototype, "value", void 0);
__decorate$2A([
  n$3({ type: Boolean })
], WuiEnsInput.prototype, "loading", void 0);
WuiEnsInput = __decorate$2A([
  customElement("cross-wui-ens-input")
], WuiEnsInput);
const styles$1X = i$4`
  button {
    border-radius: var(--local-border-radius);
    color: var(--wui-color-fg-100);
    padding: var(--local-padding);
  }

  @media (max-width: 700px) {
    button {
      padding: var(--wui-spacing-s);
    }
  }

  button > cross-wui-icon {
    pointer-events: none;
  }

  button:disabled > cross-wui-icon {
    color: var(--wui-color-bg-300) !important;
  }

  button:disabled {
    background-color: transparent;
  }
`;
var __decorate$2z = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiIconLink = class WuiIconLink2 extends i$1 {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.disabled = false;
    this.icon = "copy";
    this.iconColor = "inherit";
  }
  render() {
    const borderRadius = this.size === "lg" ? "--wui-border-radius-xs" : "--wui-border-radius-xxs";
    const padding2 = this.size === "lg" ? "--wui-spacing-1xs" : "--wui-spacing-2xs";
    this.style.cssText = `
    --local-border-radius: var(${borderRadius});
    --local-padding: var(${padding2});
`;
    return x$3`
      <button ?disabled=${this.disabled}>
        <cross-wui-icon color=${this.iconColor} size=${this.size} name=${this.icon}></cross-wui-icon>
      </button>
    `;
  }
};
WuiIconLink.styles = [resetStyles, elementStyles, colorStyles, styles$1X];
__decorate$2z([
  n$3()
], WuiIconLink.prototype, "size", void 0);
__decorate$2z([
  n$3({ type: Boolean })
], WuiIconLink.prototype, "disabled", void 0);
__decorate$2z([
  n$3()
], WuiIconLink.prototype, "icon", void 0);
__decorate$2z([
  n$3()
], WuiIconLink.prototype, "iconColor", void 0);
WuiIconLink = __decorate$2z([
  customElement("cross-wui-icon-link")
], WuiIconLink);
const styles$1W = i$4`
  button {
    background-color: var(--wui-color-fg-300);
    border-radius: var(--wui-border-radius-4xs);
    width: 16px;
    height: 16px;
  }

  button:disabled {
    background-color: var(--wui-color-bg-300);
  }

  cross-wui-icon {
    color: var(--wui-color-bg-200) !important;
  }

  button:focus-visible {
    background-color: var(--wui-color-fg-250);
    border: 1px solid var(--wui-color-accent-100);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-fg-250);
    }

    button:active:enabled {
      background-color: var(--wui-color-fg-225);
    }
  }
`;
var __decorate$2y = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiInputElement = class WuiInputElement2 extends i$1 {
  constructor() {
    super(...arguments);
    this.icon = "copy";
  }
  render() {
    return x$3`
      <button>
        <cross-wui-icon color="inherit" size="xxs" name=${this.icon}></cross-wui-icon>
      </button>
    `;
  }
};
WuiInputElement.styles = [resetStyles, elementStyles, styles$1W];
__decorate$2y([
  n$3()
], WuiInputElement.prototype, "icon", void 0);
WuiInputElement = __decorate$2y([
  customElement("cross-wui-input-element")
], WuiInputElement);
const styles$1V = i$4`
  :host {
    position: relative;
    display: inline-block;
  }

  input {
    width: 50px;
    height: 50px;
    background: var(--wui-color-gray-glass-010);
    border-radius: var(--wui-border-radius-xs);
    border: 1px solid var(--wui-color-gray-glass-005);
    font-family: var(--wui-font-family);
    font-size: var(--wui-font-size-large);
    font-weight: var(--wui-font-weight-regular);
    letter-spacing: var(--wui-letter-spacing-large);
    text-align: center;
    color: var(--wui-color-fg-100);
    caret-color: var(--wui-color-accent-100);
    transition:
      background-color var(--wui-ease-inout-power-1) var(--wui-duration-md),
      border-color var(--wui-ease-inout-power-1) var(--wui-duration-md),
      box-shadow var(--wui-ease-inout-power-1) var(--wui-duration-md);
    will-change: background-color, border-color, box-shadow;
    box-sizing: border-box;
    -webkit-appearance: none;
    -moz-appearance: textfield;
    padding: 0px;
  }

  input::-webkit-outer-spin-button,
  input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  input[type='number'] {
    -moz-appearance: textfield;
  }

  input:disabled {
    cursor: not-allowed;
    border: 1px solid var(--wui-color-gray-glass-010);
    background: var(--wui-color-gray-glass-005);
  }

  input:focus:enabled {
    background-color: var(--wui-color-gray-glass-015);
    border: 1px solid var(--wui-color-accent-100);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  @media (hover: hover) and (pointer: fine) {
    input:hover:enabled {
      background-color: var(--wui-color-gray-glass-015);
    }
  }
`;
var __decorate$2x = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiInputNumeric = class WuiInputNumeric2 extends i$1 {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.value = "";
  }
  render() {
    return x$3`<input
      type="number"
      maxlength="1"
      inputmode="numeric"
      autofocus
      ?disabled=${this.disabled}
      value=${this.value}
    /> `;
  }
};
WuiInputNumeric.styles = [resetStyles, elementStyles, styles$1V];
__decorate$2x([
  n$3({ type: Boolean })
], WuiInputNumeric.prototype, "disabled", void 0);
__decorate$2x([
  n$3({ type: String })
], WuiInputNumeric.prototype, "value", void 0);
WuiInputNumeric = __decorate$2x([
  customElement("cross-wui-input-numeric")
], WuiInputNumeric);
const styles$1U = i$4`
  button {
    padding: var(--wui-spacing-4xs) var(--wui-spacing-xxs);
    border-radius: var(--wui-border-radius-3xs);
    background-color: transparent;
    color: var(--wui-color-accent-100);
  }

  button:disabled {
    background-color: transparent;
    color: var(--wui-color-gray-glass-015);
  }

  button:hover {
    background-color: var(--wui-color-gray-glass-005);
  }
`;
var __decorate$2w = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiLink = class WuiLink2 extends i$1 {
  constructor() {
    super(...arguments);
    this.tabIdx = void 0;
    this.disabled = false;
    this.color = "inherit";
  }
  render() {
    return x$3`
      <button ?disabled=${this.disabled} tabindex=${o$2(this.tabIdx)}>
        <slot name="iconLeft"></slot>
        <cross-wui-text variant="small-600" color=${this.color}>
          <slot></slot>
        </cross-wui-text>
        <slot name="iconRight"></slot>
      </button>
    `;
  }
};
WuiLink.styles = [resetStyles, elementStyles, styles$1U];
__decorate$2w([
  n$3()
], WuiLink.prototype, "tabIdx", void 0);
__decorate$2w([
  n$3({ type: Boolean })
], WuiLink.prototype, "disabled", void 0);
__decorate$2w([
  n$3()
], WuiLink.prototype, "color", void 0);
WuiLink = __decorate$2w([
  customElement("cross-wui-link")
], WuiLink);
const styles$1T = i$4`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 11px 18px 11px var(--wui-spacing-s);
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
    transition:
      color var(--wui-ease-out-power-1) var(--wui-duration-md),
      background-color var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: color, background-color;
  }

  button[data-iconvariant='square'],
  button[data-iconvariant='square-blue'] {
    padding: 6px 18px 6px 9px;
  }

  button > cross-wui-flex {
    flex: 1;
  }

  button > cross-wui-image {
    width: 32px;
    height: 32px;
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
    border-radius: var(--wui-border-radius-3xl);
  }

  button > cross-wui-icon {
    width: 36px;
    height: 36px;
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
  }

  button > wui-icon-box[data-variant='blue'] {
    box-shadow: 0 0 0 2px var(--wui-color-accent-glass-005);
  }

  button > wui-icon-box[data-variant='overlay'] {
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
  }

  button > wui-icon-box[data-variant='square-blue'] {
    border-radius: var(--wui-border-radius-3xs);
    position: relative;
    border: none;
    width: 36px;
    height: 36px;
  }

  button > wui-icon-box[data-variant='square-blue']::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-color-accent-glass-010);
    pointer-events: none;
  }

  button > wui-icon:last-child {
    width: 14px;
    height: 14px;
  }

  button:disabled {
    color: var(--wui-color-gray-glass-020);
  }

  button[data-loading='true'] > cross-wui-icon {
    opacity: 0;
  }

  cross-wui-loading-spinner {
    position: absolute;
    right: 18px;
    top: 50%;
    transform: translateY(-50%);
  }
`;
var __decorate$2v = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiListItem = class WuiListItem2 extends i$1 {
  constructor() {
    super(...arguments);
    this.tabIdx = void 0;
    this.variant = "icon";
    this.disabled = false;
    this.imageSrc = void 0;
    this.alt = void 0;
    this.chevron = false;
    this.loading = false;
  }
  render() {
    return x$3`
      <button
        ?disabled=${this.loading ? true : Boolean(this.disabled)}
        data-loading=${this.loading}
        data-iconvariant=${o$2(this.iconVariant)}
        tabindex=${o$2(this.tabIdx)}
      >
        ${this.loadingTemplate()} ${this.visualTemplate()}
        <cross-wui-flex gap="3xs">
          <slot></slot>
        </cross-wui-flex>
        ${this.chevronTemplate()}
      </button>
    `;
  }
  visualTemplate() {
    if (this.variant === "image" && this.imageSrc) {
      return x$3`<cross-wui-image src=${this.imageSrc} alt=${this.alt ?? "list item"}></cross-wui-image>`;
    }
    if (this.iconVariant === "square" && this.icon && this.variant === "icon") {
      return x$3`<cross-wui-icon name=${this.icon}></cross-wui-icon>`;
    }
    if (this.variant === "icon" && this.icon && this.iconVariant) {
      const color = ["blue", "square-blue"].includes(this.iconVariant) ? "accent-100" : "fg-200";
      const size2 = this.iconVariant === "square-blue" ? "mdl" : "md";
      const iconSize = this.iconSize ? this.iconSize : size2;
      return x$3`
        <cross-wui-icon-box
          data-variant=${this.iconVariant}
          icon=${this.icon}
          iconSize=${iconSize}
          background="transparent"
          iconColor=${color}
          backgroundColor=${color}
          size=${size2}
        ></cross-wui-icon-box>
      `;
    }
    return null;
  }
  loadingTemplate() {
    if (this.loading) {
      return x$3`<cross-wui-loading-spinner color="fg-300"></cross-wui-loading-spinner>`;
    }
    return x$3``;
  }
  chevronTemplate() {
    if (this.chevron) {
      return x$3`<cross-wui-icon size="inherit" color="fg-200" name="chevronRight"></cross-wui-icon>`;
    }
    return null;
  }
};
WuiListItem.styles = [resetStyles, elementStyles, styles$1T];
__decorate$2v([
  n$3()
], WuiListItem.prototype, "icon", void 0);
__decorate$2v([
  n$3()
], WuiListItem.prototype, "iconSize", void 0);
__decorate$2v([
  n$3()
], WuiListItem.prototype, "tabIdx", void 0);
__decorate$2v([
  n$3()
], WuiListItem.prototype, "variant", void 0);
__decorate$2v([
  n$3()
], WuiListItem.prototype, "iconVariant", void 0);
__decorate$2v([
  n$3({ type: Boolean })
], WuiListItem.prototype, "disabled", void 0);
__decorate$2v([
  n$3()
], WuiListItem.prototype, "imageSrc", void 0);
__decorate$2v([
  n$3()
], WuiListItem.prototype, "alt", void 0);
__decorate$2v([
  n$3({ type: Boolean })
], WuiListItem.prototype, "chevron", void 0);
__decorate$2v([
  n$3({ type: Boolean })
], WuiListItem.prototype, "loading", void 0);
WuiListItem = __decorate$2v([
  customElement("cross-wui-list-item")
], WuiListItem);
var TransactionTypePastTense;
(function(TransactionTypePastTense2) {
  TransactionTypePastTense2["approve"] = "approved";
  TransactionTypePastTense2["bought"] = "bought";
  TransactionTypePastTense2["borrow"] = "borrowed";
  TransactionTypePastTense2["burn"] = "burnt";
  TransactionTypePastTense2["cancel"] = "canceled";
  TransactionTypePastTense2["claim"] = "claimed";
  TransactionTypePastTense2["deploy"] = "deployed";
  TransactionTypePastTense2["deposit"] = "deposited";
  TransactionTypePastTense2["execute"] = "executed";
  TransactionTypePastTense2["mint"] = "minted";
  TransactionTypePastTense2["receive"] = "received";
  TransactionTypePastTense2["repay"] = "repaid";
  TransactionTypePastTense2["send"] = "sent";
  TransactionTypePastTense2["sell"] = "sold";
  TransactionTypePastTense2["stake"] = "staked";
  TransactionTypePastTense2["trade"] = "swapped";
  TransactionTypePastTense2["unstake"] = "unstaked";
  TransactionTypePastTense2["withdraw"] = "withdrawn";
})(TransactionTypePastTense || (TransactionTypePastTense = {}));
const styles$1S = i$4`
  :host > cross-wui-flex {
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    width: 40px;
    height: 40px;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
    background-color: var(--wui-color-gray-glass-005);
  }

  :host > wui-flex cross-wui-image {
    display: block;
  }

  :host > cross-wui-flex,
  :host > wui-flex cross-wui-image,
  .swap-images-container,
  .swap-images-container.nft,
  wui-image.nft {
    border-top-left-radius: var(--local-left-border-radius);
    border-top-right-radius: var(--local-right-border-radius);
    border-bottom-left-radius: var(--local-left-border-radius);
    border-bottom-right-radius: var(--local-right-border-radius);
  }

  cross-wui-icon {
    width: 20px;
    height: 20px;
  }

  cross-wui-icon-box {
    position: absolute;
    right: 0;
    bottom: 0;
    transform: translate(20%, 20%);
  }

  .swap-images-container {
    position: relative;
    width: 40px;
    height: 40px;
    overflow: hidden;
  }

  .swap-images-container wui-image:first-child {
    position: absolute;
    width: 40px;
    height: 40px;
    top: 0;
    left: 0%;
    clip-path: inset(0px calc(50% + 2px) 0px 0%);
  }

  .swap-images-container wui-image:last-child {
    clip-path: inset(0px 0px 0px calc(50% + 2px));
  }
`;
var __decorate$2u = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiTransactionVisual = class WuiTransactionVisual2 extends i$1 {
  constructor() {
    super(...arguments);
    this.images = [];
    this.secondImage = {
      type: void 0,
      url: ""
    };
  }
  render() {
    const [firstImage, secondImage] = this.images;
    const isLeftNFT = (firstImage == null ? void 0 : firstImage.type) === "NFT";
    const isRightNFT = (secondImage == null ? void 0 : secondImage.url) ? secondImage.type === "NFT" : isLeftNFT;
    const leftRadius = isLeftNFT ? "var(--wui-border-radius-xxs)" : "var(--wui-border-radius-s)";
    const rightRadius = isRightNFT ? "var(--wui-border-radius-xxs)" : "var(--wui-border-radius-s)";
    this.style.cssText = `
    --local-left-border-radius: ${leftRadius};
    --local-right-border-radius: ${rightRadius};
    `;
    return x$3`<cross-wui-flex> ${this.templateVisual()} ${this.templateIcon()} </cross-wui-flex>`;
  }
  templateVisual() {
    const [firstImage, secondImage] = this.images;
    const firstImageType = firstImage == null ? void 0 : firstImage.type;
    const haveTwoImages = this.images.length === 2;
    if (haveTwoImages && ((firstImage == null ? void 0 : firstImage.url) || (secondImage == null ? void 0 : secondImage.url))) {
      return x$3`<div class="swap-images-container">
        ${(firstImage == null ? void 0 : firstImage.url) ? x$3`<cross-wui-image src=${firstImage.url} alt="Transaction image"></cross-wui-image>` : null}
        ${(secondImage == null ? void 0 : secondImage.url) ? x$3`<cross-wui-image src=${secondImage.url} alt="Transaction image"></cross-wui-image>` : null}
      </div>`;
    } else if (firstImage == null ? void 0 : firstImage.url) {
      return x$3`<cross-wui-image src=${firstImage.url} alt="Transaction image"></cross-wui-image>`;
    } else if (firstImageType === "NFT") {
      return x$3`<cross-wui-icon size="inherit" color="fg-200" name="nftPlaceholder"></cross-wui-icon>`;
    }
    return x$3`<cross-wui-icon size="inherit" color="fg-200" name="coinPlaceholder"></cross-wui-icon>`;
  }
  templateIcon() {
    let color = "accent-100";
    let icon = void 0;
    icon = this.getIcon();
    if (this.status) {
      color = this.getStatusColor();
    }
    if (!icon) {
      return null;
    }
    return x$3`
      <cross-wui-icon-box
        size="xxs"
        iconColor=${color}
        backgroundColor=${color}
        background="opaque"
        icon=${icon}
        ?border=${true}
        borderColor="wui-color-bg-125"
      ></cross-wui-icon-box>
    `;
  }
  getDirectionIcon() {
    switch (this.direction) {
      case "in":
        return "arrowBottom";
      case "out":
        return "arrowTop";
      default:
        return void 0;
    }
  }
  getIcon() {
    if (this.onlyDirectionIcon) {
      return this.getDirectionIcon();
    }
    if (this.type === "trade") {
      return "swapHorizontalBold";
    } else if (this.type === "approve") {
      return "checkmark";
    } else if (this.type === "cancel") {
      return "close";
    }
    return this.getDirectionIcon();
  }
  getStatusColor() {
    switch (this.status) {
      case "confirmed":
        return "success-100";
      case "failed":
        return "error-100";
      case "pending":
        return "inverse-100";
      default:
        return "accent-100";
    }
  }
};
WuiTransactionVisual.styles = [styles$1S];
__decorate$2u([
  n$3()
], WuiTransactionVisual.prototype, "type", void 0);
__decorate$2u([
  n$3()
], WuiTransactionVisual.prototype, "status", void 0);
__decorate$2u([
  n$3()
], WuiTransactionVisual.prototype, "direction", void 0);
__decorate$2u([
  n$3({ type: Boolean })
], WuiTransactionVisual.prototype, "onlyDirectionIcon", void 0);
__decorate$2u([
  n$3({ type: Array })
], WuiTransactionVisual.prototype, "images", void 0);
__decorate$2u([
  n$3({ type: Object })
], WuiTransactionVisual.prototype, "secondImage", void 0);
WuiTransactionVisual = __decorate$2u([
  customElement("cross-wui-transaction-visual")
], WuiTransactionVisual);
const styles$1R = i$4`
  :host > wui-flex:first-child {
    align-items: center;
    column-gap: var(--wui-spacing-s);
    padding: 6.5px var(--wui-spacing-xs) 6.5px var(--wui-spacing-xs);
    width: 100%;
  }

  :host > wui-flex:first-child wui-text:nth-child(1) {
    text-transform: capitalize;
  }

  cross-wui-transaction-visual {
    width: 40px;
    height: 40px;
  }

  cross-wui-flex {
    flex: 1;
  }

  :host wui-flex cross-wui-flex {
    overflow: hidden;
  }

  :host .description-container wui-text span {
    word-break: break-all;
  }

  :host .description-container cross-wui-text {
    overflow: hidden;
  }

  :host .description-separator-icon {
    margin: 0px 6px;
  }

  :host wui-text > span {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 1;
  }
`;
var __decorate$2t = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiTransactionListItem = class WuiTransactionListItem2 extends i$1 {
  constructor() {
    super(...arguments);
    this.type = "approve";
    this.onlyDirectionIcon = false;
    this.images = [];
    this.price = [];
    this.amount = [];
    this.symbol = [];
  }
  render() {
    return x$3`
      <cross-wui-flex>
        <cross-wui-transaction-visual
          .status=${this.status}
          direction=${o$2(this.direction)}
          type=${this.type}
          onlyDirectionIcon=${o$2(this.onlyDirectionIcon)}
          .images=${this.images}
        ></cross-wui-transaction-visual>
        <cross-wui-flex flexDirection="column" gap="3xs">
          <cross-wui-text variant="paragraph-600" color="fg-100">
            ${TransactionTypePastTense[this.type] || this.type}
          </cross-wui-text>
          <cross-wui-flex class="description-container">
            ${this.templateDescription()} ${this.templateSecondDescription()}
          </cross-wui-flex>
        </cross-wui-flex>
        <cross-wui-text variant="micro-700" color="fg-300"><span>${this.date}</span></cross-wui-text>
      </cross-wui-flex>
    `;
  }
  templateDescription() {
    var _a3;
    const description = (_a3 = this.descriptions) == null ? void 0 : _a3[0];
    return description ? x$3`
          <cross-wui-text variant="small-500" color="fg-200">
            <span>${description}</span>
          </cross-wui-text>
        ` : null;
  }
  templateSecondDescription() {
    var _a3;
    const description = (_a3 = this.descriptions) == null ? void 0 : _a3[1];
    return description ? x$3`
          <cross-wui-icon class="description-separator-icon" size="xxs" name="arrowRight"></cross-wui-icon>
          <cross-wui-text variant="small-400" color="fg-200">
            <span>${description}</span>
          </cross-wui-text>
        ` : null;
  }
};
WuiTransactionListItem.styles = [resetStyles, styles$1R];
__decorate$2t([
  n$3()
], WuiTransactionListItem.prototype, "type", void 0);
__decorate$2t([
  n$3({ type: Array })
], WuiTransactionListItem.prototype, "descriptions", void 0);
__decorate$2t([
  n$3()
], WuiTransactionListItem.prototype, "date", void 0);
__decorate$2t([
  n$3({ type: Boolean })
], WuiTransactionListItem.prototype, "onlyDirectionIcon", void 0);
__decorate$2t([
  n$3()
], WuiTransactionListItem.prototype, "status", void 0);
__decorate$2t([
  n$3()
], WuiTransactionListItem.prototype, "direction", void 0);
__decorate$2t([
  n$3({ type: Array })
], WuiTransactionListItem.prototype, "images", void 0);
__decorate$2t([
  n$3({ type: Array })
], WuiTransactionListItem.prototype, "price", void 0);
__decorate$2t([
  n$3({ type: Array })
], WuiTransactionListItem.prototype, "amount", void 0);
__decorate$2t([
  n$3({ type: Array })
], WuiTransactionListItem.prototype, "symbol", void 0);
WuiTransactionListItem = __decorate$2t([
  customElement("cross-wui-transaction-list-item")
], WuiTransactionListItem);
const styles$1Q = i$4`
  :host > wui-flex:first-child {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
  }

  cross-wui-flex {
    display: flex;
    flex: 1;
  }
`;
var __decorate$2s = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiTransactionListItemLoader = class WuiTransactionListItemLoader2 extends i$1 {
  render() {
    return x$3`
      <cross-wui-flex alignItems="center">
        <cross-wui-shimmer width="40px" height="40px"></cross-wui-shimmer>
        <cross-wui-flex flexDirection="column" gap="2xs">
          <cross-wui-shimmer width="72px" height="16px" borderRadius="4xs"></cross-wui-shimmer>
          <cross-wui-shimmer width="148px" height="14px" borderRadius="4xs"></cross-wui-shimmer>
        </cross-wui-flex>
        <cross-wui-shimmer width="24px" height="12px" borderRadius="5xs"></cross-wui-shimmer>
      </cross-wui-flex>
    `;
  }
};
WuiTransactionListItemLoader.styles = [resetStyles, styles$1Q];
WuiTransactionListItemLoader = __decorate$2s([
  customElement("cross-wui-transaction-list-item-loader")
], WuiTransactionListItemLoader);
const styles$1P = i$4`
  :host {
    display: flex;
    justify-content: center;
    align-items: center;
    height: var(--wui-spacing-m);
    padding: 0 var(--wui-spacing-3xs) !important;
    border-radius: var(--wui-border-radius-5xs);
    transition:
      border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1),
      background-color var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: border-radius, background-color;
  }

  :host > cross-wui-text {
    transform: translateY(5%);
  }

  :host([data-variant='main']) {
    background-color: var(--wui-color-accent-glass-015);
    color: var(--wui-color-accent-100);
  }

  :host([data-variant='shade']) {
    background-color: var(--wui-color-gray-glass-010);
    color: var(--wui-color-fg-200);
  }

  :host([data-variant='success']) {
    background-color: var(--wui-icon-box-bg-success-100);
    color: var(--wui-color-success-100);
  }

  :host([data-variant='error']) {
    background-color: var(--wui-icon-box-bg-error-100);
    color: var(--wui-color-error-100);
  }

  :host([data-size='lg']) {
    padding: 11px 5px !important;
  }

  :host([data-size='lg']) > cross-wui-text {
    transform: translateY(2%);
  }
`;
var __decorate$2r = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiTag = class WuiTag2 extends i$1 {
  constructor() {
    super(...arguments);
    this.variant = "main";
    this.size = "lg";
  }
  render() {
    this.dataset["variant"] = this.variant;
    this.dataset["size"] = this.size;
    const textVariant = this.size === "md" ? "mini-700" : "micro-700";
    return x$3`
      <cross-wui-text data-variant=${this.variant} variant=${textVariant} color="inherit">
        <slot></slot>
      </cross-wui-text>
    `;
  }
};
WuiTag.styles = [resetStyles, styles$1P];
__decorate$2r([
  n$3()
], WuiTag.prototype, "variant", void 0);
__decorate$2r([
  n$3()
], WuiTag.prototype, "size", void 0);
WuiTag = __decorate$2r([
  customElement("cross-wui-tag")
], WuiTag);
const styles$1O = i$4`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-100);
  }

  button > wui-text:nth-child(2) {
    display: flex;
    flex: 1;
  }

  button:disabled {
    background-color: var(--wui-color-gray-glass-015);
    color: var(--wui-color-gray-glass-015);
  }

  button:disabled > cross-wui-tag {
    background-color: var(--wui-color-gray-glass-010);
    color: var(--wui-color-fg-300);
  }

  cross-wui-icon {
    color: var(--wui-color-fg-200) !important;
  }
`;
var __decorate$2q = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiListWallet = class WuiListWallet2 extends i$1 {
  constructor() {
    super(...arguments);
    this.walletImages = [];
    this.imageSrc = "";
    this.name = "";
    this.tabIdx = void 0;
    this.installed = false;
    this.disabled = false;
    this.showAllWallets = false;
    this.loading = false;
  }
  render() {
    return x$3`
      <button ?disabled=${this.disabled} tabindex=${o$2(this.tabIdx)}>
        ${this.templateAllWallets()} ${this.templateWalletImage()}
        <cross-wui-text variant="paragraph-500" color="inherit">${this.name}</cross-wui-text>
        ${this.templateStatus()}
      </button>
    `;
  }
  templateAllWallets() {
    if (this.showAllWallets && this.imageSrc) {
      return x$3` <cross-wui-all-wallets-image .imageeSrc=${this.imageSrc}> </cross-wui-all-wallets-image> `;
    } else if (this.showAllWallets && this.walletIcon) {
      return x$3` <cross-wui-wallet-image .walletIcon=${this.walletIcon} size="sm"> </cross-wui-wallet-image> `;
    }
    return null;
  }
  templateWalletImage() {
    if (!this.showAllWallets && this.imageSrc) {
      return x$3`<cross-wui-wallet-image
        size="sm"
        imageSrc=${this.imageSrc}
        name=${this.name}
        .installed=${this.installed}
      ></cross-wui-wallet-image>`;
    } else if (!this.showAllWallets && !this.imageSrc) {
      return x$3`<cross-wui-wallet-image size="sm" name=${this.name}></cross-wui-wallet-image>`;
    }
    return null;
  }
  templateStatus() {
    if (this.loading) {
      return x$3`<cross-wui-loading-spinner size="lg" color="accent-100"></cross-wui-loading-spinner>`;
    } else if (this.tagLabel && this.tagVariant) {
      return x$3`<cross-wui-tag variant=${this.tagVariant}>${this.tagLabel}</cross-wui-tag>`;
    } else if (this.icon) {
      return x$3`<cross-wui-icon color="inherit" size="sm" name=${this.icon}></cross-wui-icon>`;
    }
    return null;
  }
};
WuiListWallet.styles = [resetStyles, elementStyles, styles$1O];
__decorate$2q([
  n$3({ type: Array })
], WuiListWallet.prototype, "walletImages", void 0);
__decorate$2q([
  n$3()
], WuiListWallet.prototype, "imageSrc", void 0);
__decorate$2q([
  n$3()
], WuiListWallet.prototype, "name", void 0);
__decorate$2q([
  n$3()
], WuiListWallet.prototype, "tagLabel", void 0);
__decorate$2q([
  n$3()
], WuiListWallet.prototype, "tagVariant", void 0);
__decorate$2q([
  n$3()
], WuiListWallet.prototype, "icon", void 0);
__decorate$2q([
  n$3()
], WuiListWallet.prototype, "walletIcon", void 0);
__decorate$2q([
  n$3()
], WuiListWallet.prototype, "tabIdx", void 0);
__decorate$2q([
  n$3({ type: Boolean })
], WuiListWallet.prototype, "installed", void 0);
__decorate$2q([
  n$3({ type: Boolean })
], WuiListWallet.prototype, "disabled", void 0);
__decorate$2q([
  n$3({ type: Boolean })
], WuiListWallet.prototype, "showAllWallets", void 0);
__decorate$2q([
  n$3({ type: Boolean })
], WuiListWallet.prototype, "loading", void 0);
WuiListWallet = __decorate$2q([
  customElement("cross-wui-list-wallet")
], WuiListWallet);
const styles$1N = i$4`
  :host {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-color-gray-glass-005);
    overflow: hidden;
  }

  cross-wui-icon {
    width: 100%;
    height: 100%;
  }
`;
var __decorate$2p = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiLogo = class WuiLogo2 extends i$1 {
  constructor() {
    super(...arguments);
    this.logo = "google";
  }
  render() {
    return x$3`<cross-wui-icon color="inherit" size="inherit" name=${this.logo}></cross-wui-icon> `;
  }
};
WuiLogo.styles = [resetStyles, styles$1N];
__decorate$2p([
  n$3()
], WuiLogo.prototype, "logo", void 0);
WuiLogo = __decorate$2p([
  customElement("cross-wui-logo")
], WuiLogo);
const styles$1M = i$4`
  :host {
    display: block;
    width: 100%;
  }

  button {
    width: 100%;
    height: 56px;
    background: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }
`;
var __decorate$2o = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiLogoSelect = class WuiLogoSelect2 extends i$1 {
  constructor() {
    super(...arguments);
    this.logo = "google";
    this.disabled = false;
    this.tabIdx = void 0;
  }
  render() {
    return x$3`
      <button ?disabled=${this.disabled} tabindex=${o$2(this.tabIdx)}>
        <cross-wui-logo logo=${this.logo}></cross-wui-logo>
      </button>
    `;
  }
};
WuiLogoSelect.styles = [resetStyles, elementStyles, styles$1M];
__decorate$2o([
  n$3()
], WuiLogoSelect.prototype, "logo", void 0);
__decorate$2o([
  n$3({ type: Boolean })
], WuiLogoSelect.prototype, "disabled", void 0);
__decorate$2o([
  n$3()
], WuiLogoSelect.prototype, "tabIdx", void 0);
WuiLogoSelect = __decorate$2o([
  customElement("cross-wui-logo-select")
], WuiLogoSelect);
const styles$1L = i$4`
  :host {
    display: block;
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
    display: flex;
    gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-2xs) var(--wui-spacing-s) var(--wui-spacing-2xs)
      var(--wui-spacing-xs);
    border: 1px solid var(--wui-color-gray-glass-010);
    background-color: var(--wui-color-gray-glass-005);
    color: var(--wui-color-fg-100);
  }

  button:disabled {
    border: 1px solid var(--wui-color-gray-glass-005);
    background-color: var(--wui-color-gray-glass-015);
    color: var(--wui-color-gray-glass-015);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-gray-glass-010);
    }

    button:active:enabled {
      background-color: var(--wui-color-gray-glass-015);
    }
  }

  cross-wui-image,
  cross-wui-icon-box {
    border-radius: var(--wui-border-radius-3xl);
    width: 24px;
    height: 24px;
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
  }
`;
var __decorate$2n = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiNetworkButton = class WuiNetworkButton2 extends i$1 {
  constructor() {
    super(...arguments);
    this.imageSrc = void 0;
    this.isUnsupportedChain = void 0;
    this.disabled = false;
  }
  render() {
    return x$3`
      <button data-testid="wui-network-button" ?disabled=${this.disabled}>
        ${this.visualTemplate()}
        <cross-wui-text variant="paragraph-600" color="inherit">
          <slot></slot>
        </cross-wui-text>
      </button>
    `;
  }
  visualTemplate() {
    if (this.isUnsupportedChain) {
      return x$3`
        <cross-wui-icon-box
          size="sm"
          iconColor="error-100"
          backgroundColor="error-100"
          icon="warningCircle"
        ></cross-wui-icon-box>
      `;
    }
    if (this.imageSrc) {
      return x$3`<cross-wui-image src=${this.imageSrc}></cross-wui-image>`;
    }
    return x$3`
      <cross-wui-icon-box
        size="sm"
        iconColor="inverse-100"
        backgroundColor="fg-100"
        icon="networkPlaceholder"
      ></cross-wui-icon-box>
    `;
  }
};
WuiNetworkButton.styles = [resetStyles, elementStyles, styles$1L];
__decorate$2n([
  n$3()
], WuiNetworkButton.prototype, "imageSrc", void 0);
__decorate$2n([
  n$3({ type: Boolean })
], WuiNetworkButton.prototype, "isUnsupportedChain", void 0);
__decorate$2n([
  n$3({ type: Boolean })
], WuiNetworkButton.prototype, "disabled", void 0);
WuiNetworkButton = __decorate$2n([
  customElement("cross-wui-network-button")
], WuiNetworkButton);
const styles$1K = i$4`
  :host {
    position: relative;
    display: block;
  }
`;
var __decorate$2m = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiOtp = class WuiOtp2 extends i$1 {
  constructor() {
    super(...arguments);
    this.length = 6;
    this.otp = "";
    this.values = Array.from({ length: this.length }).map(() => "");
    this.numerics = [];
    this.shouldInputBeEnabled = (index2) => {
      const previousInputs = this.values.slice(0, index2);
      return previousInputs.every((input) => input !== "");
    };
    this.handleKeyDown = (e3, index2) => {
      const inputElement = e3.target;
      const input = this.getInputElement(inputElement);
      const keyArr = ["ArrowLeft", "ArrowRight", "Shift", "Delete"];
      if (!input) {
        return;
      }
      if (keyArr.includes(e3.key)) {
        e3.preventDefault();
      }
      const currentCaretPos = input.selectionStart;
      switch (e3.key) {
        case "ArrowLeft":
          if (currentCaretPos) {
            input.setSelectionRange(currentCaretPos + 1, currentCaretPos + 1);
          }
          this.focusInputField("prev", index2);
          break;
        case "ArrowRight":
          this.focusInputField("next", index2);
          break;
        case "Shift":
          this.focusInputField("next", index2);
          break;
        case "Delete":
          if (input.value === "") {
            this.focusInputField("prev", index2);
          } else {
            this.updateInput(input, index2, "");
          }
          break;
        case "Backspace":
          if (input.value === "") {
            this.focusInputField("prev", index2);
          } else {
            this.updateInput(input, index2, "");
          }
          break;
      }
    };
    this.focusInputField = (dir, index2) => {
      if (dir === "next") {
        const nextIndex = index2 + 1;
        if (!this.shouldInputBeEnabled(nextIndex)) {
          return;
        }
        const numeric2 = this.numerics[nextIndex < this.length ? nextIndex : index2];
        const input = numeric2 ? this.getInputElement(numeric2) : void 0;
        if (input) {
          input.disabled = false;
          input.focus();
        }
      }
      if (dir === "prev") {
        const nextIndex = index2 - 1;
        const numeric2 = this.numerics[nextIndex > -1 ? nextIndex : index2];
        const input = numeric2 ? this.getInputElement(numeric2) : void 0;
        if (input) {
          input.focus();
        }
      }
    };
  }
  firstUpdated() {
    var _a3, _b2;
    if (this.otp) {
      this.values = this.otp.split("");
    }
    const numericElements = (_a3 = this.shadowRoot) == null ? void 0 : _a3.querySelectorAll("wui-input-numeric");
    if (numericElements) {
      this.numerics = Array.from(numericElements);
    }
    (_b2 = this.numerics[0]) == null ? void 0 : _b2.focus();
  }
  render() {
    return x$3`
      <cross-wui-flex gap="xxs" data-testid="wui-otp-input">
        ${Array.from({ length: this.length }).map((_3, index2) => x$3`
            <cross-wui-input-numeric
              @input=${(e3) => this.handleInput(e3, index2)}
              @click=${(e3) => this.selectInput(e3)}
              @keydown=${(e3) => this.handleKeyDown(e3, index2)}
              .disabled=${!this.shouldInputBeEnabled(index2)}
              .value=${this.values[index2] || ""}
            >
            </cross-wui-input-numeric>
          `)}
      </cross-wui-flex>
    `;
  }
  updateInput(element, index2, value) {
    const numeric2 = this.numerics[index2];
    const input = element || (numeric2 ? this.getInputElement(numeric2) : void 0);
    if (input) {
      input.value = value;
      this.values = this.values.map((val, i4) => i4 === index2 ? value : val);
    }
  }
  selectInput(e3) {
    const targetElement = e3.target;
    if (targetElement) {
      const inputElement = this.getInputElement(targetElement);
      inputElement == null ? void 0 : inputElement.select();
    }
  }
  handleInput(e3, index2) {
    const inputElement = e3.target;
    const input = this.getInputElement(inputElement);
    if (input) {
      const inputValue = input.value;
      if (e3.inputType === "insertFromPaste") {
        this.handlePaste(input, inputValue, index2);
      } else {
        const isValid3 = UiHelperUtil.isNumber(inputValue);
        if (isValid3 && e3.data) {
          this.updateInput(input, index2, e3.data);
          this.focusInputField("next", index2);
        } else {
          this.updateInput(input, index2, "");
        }
      }
    }
    this.dispatchInputChangeEvent();
  }
  handlePaste(input, inputValue, index2) {
    const value = inputValue[0];
    const isValid3 = value && UiHelperUtil.isNumber(value);
    if (isValid3) {
      this.updateInput(input, index2, value);
      const inputString = inputValue.substring(1);
      if (index2 + 1 < this.length && inputString.length) {
        const nextNumeric = this.numerics[index2 + 1];
        const nextInput = nextNumeric ? this.getInputElement(nextNumeric) : void 0;
        if (nextInput) {
          this.handlePaste(nextInput, inputString, index2 + 1);
        }
      } else {
        this.focusInputField("next", index2);
      }
    } else {
      this.updateInput(input, index2, "");
    }
  }
  getInputElement(el) {
    var _a3;
    if ((_a3 = el.shadowRoot) == null ? void 0 : _a3.querySelector("input")) {
      return el.shadowRoot.querySelector("input");
    }
    return null;
  }
  dispatchInputChangeEvent() {
    const value = this.values.join("");
    this.dispatchEvent(new CustomEvent("inputChange", {
      detail: value,
      bubbles: true,
      composed: true
    }));
  }
};
WuiOtp.styles = [resetStyles, styles$1K];
__decorate$2m([
  n$3({ type: Number })
], WuiOtp.prototype, "length", void 0);
__decorate$2m([
  n$3({ type: String })
], WuiOtp.prototype, "otp", void 0);
__decorate$2m([
  r$1()
], WuiOtp.prototype, "values", void 0);
WuiOtp = __decorate$2m([
  customElement("cross-wui-otp")
], WuiOtp);
var browser = {};
var canPromise$1 = function() {
  return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
};
var qrcode = {};
var utils$1 = {};
let toSJISFunction;
const CODEWORDS_COUNT = [
  0,
  // Not used
  26,
  44,
  70,
  100,
  134,
  172,
  196,
  242,
  292,
  346,
  404,
  466,
  532,
  581,
  655,
  733,
  815,
  901,
  991,
  1085,
  1156,
  1258,
  1364,
  1474,
  1588,
  1706,
  1828,
  1921,
  2051,
  2185,
  2323,
  2465,
  2611,
  2761,
  2876,
  3034,
  3196,
  3362,
  3532,
  3706
];
utils$1.getSymbolSize = function getSymbolSize2(version2) {
  if (!version2) throw new Error('"version" cannot be null or undefined');
  if (version2 < 1 || version2 > 40) throw new Error('"version" should be in range from 1 to 40');
  return version2 * 4 + 17;
};
utils$1.getSymbolTotalCodewords = function getSymbolTotalCodewords(version2) {
  return CODEWORDS_COUNT[version2];
};
utils$1.getBCHDigit = function(data2) {
  let digit = 0;
  while (data2 !== 0) {
    digit++;
    data2 >>>= 1;
  }
  return digit;
};
utils$1.setToSJISFunction = function setToSJISFunction(f6) {
  if (typeof f6 !== "function") {
    throw new Error('"toSJISFunc" is not a valid function.');
  }
  toSJISFunction = f6;
};
utils$1.isKanjiModeEnabled = function() {
  return typeof toSJISFunction !== "undefined";
};
utils$1.toSJIS = function toSJIS(kanji2) {
  return toSJISFunction(kanji2);
};
var errorCorrectionLevel = {};
(function(exports2) {
  exports2.L = { bit: 1 };
  exports2.M = { bit: 0 };
  exports2.Q = { bit: 3 };
  exports2.H = { bit: 2 };
  function fromString2(string2) {
    if (typeof string2 !== "string") {
      throw new Error("Param is not a string");
    }
    const lcStr = string2.toLowerCase();
    switch (lcStr) {
      case "l":
      case "low":
        return exports2.L;
      case "m":
      case "medium":
        return exports2.M;
      case "q":
      case "quartile":
        return exports2.Q;
      case "h":
      case "high":
        return exports2.H;
      default:
        throw new Error("Unknown EC Level: " + string2);
    }
  }
  exports2.isValid = function isValid3(level) {
    return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
  };
  exports2.from = function from2(value, defaultValue) {
    if (exports2.isValid(value)) {
      return value;
    }
    try {
      return fromString2(value);
    } catch (e3) {
      return defaultValue;
    }
  };
})(errorCorrectionLevel);
function BitBuffer$1() {
  this.buffer = [];
  this.length = 0;
}
BitBuffer$1.prototype = {
  get: function(index2) {
    const bufIndex = Math.floor(index2 / 8);
    return (this.buffer[bufIndex] >>> 7 - index2 % 8 & 1) === 1;
  },
  put: function(num, length) {
    for (let i4 = 0; i4 < length; i4++) {
      this.putBit((num >>> length - i4 - 1 & 1) === 1);
    }
  },
  getLengthInBits: function() {
    return this.length;
  },
  putBit: function(bit) {
    const bufIndex = Math.floor(this.length / 8);
    if (this.buffer.length <= bufIndex) {
      this.buffer.push(0);
    }
    if (bit) {
      this.buffer[bufIndex] |= 128 >>> this.length % 8;
    }
    this.length++;
  }
};
var bitBuffer = BitBuffer$1;
function BitMatrix$1(size2) {
  if (!size2 || size2 < 1) {
    throw new Error("BitMatrix size must be defined and greater than 0");
  }
  this.size = size2;
  this.data = new Uint8Array(size2 * size2);
  this.reservedBit = new Uint8Array(size2 * size2);
}
BitMatrix$1.prototype.set = function(row, col, value, reserved) {
  const index2 = row * this.size + col;
  this.data[index2] = value;
  if (reserved) this.reservedBit[index2] = true;
};
BitMatrix$1.prototype.get = function(row, col) {
  return this.data[row * this.size + col];
};
BitMatrix$1.prototype.xor = function(row, col, value) {
  this.data[row * this.size + col] ^= value;
};
BitMatrix$1.prototype.isReserved = function(row, col) {
  return this.reservedBit[row * this.size + col];
};
var bitMatrix = BitMatrix$1;
var alignmentPattern = {};
(function(exports2) {
  const getSymbolSize3 = utils$1.getSymbolSize;
  exports2.getRowColCoords = function getRowColCoords(version2) {
    if (version2 === 1) return [];
    const posCount = Math.floor(version2 / 7) + 2;
    const size2 = getSymbolSize3(version2);
    const intervals = size2 === 145 ? 26 : Math.ceil((size2 - 13) / (2 * posCount - 2)) * 2;
    const positions = [size2 - 7];
    for (let i4 = 1; i4 < posCount - 1; i4++) {
      positions[i4] = positions[i4 - 1] - intervals;
    }
    positions.push(6);
    return positions.reverse();
  };
  exports2.getPositions = function getPositions2(version2) {
    const coords = [];
    const pos = exports2.getRowColCoords(version2);
    const posLength = pos.length;
    for (let i4 = 0; i4 < posLength; i4++) {
      for (let j2 = 0; j2 < posLength; j2++) {
        if (i4 === 0 && j2 === 0 || // top-left
        i4 === 0 && j2 === posLength - 1 || // bottom-left
        i4 === posLength - 1 && j2 === 0) {
          continue;
        }
        coords.push([pos[i4], pos[j2]]);
      }
    }
    return coords;
  };
})(alignmentPattern);
var finderPattern = {};
const getSymbolSize = utils$1.getSymbolSize;
const FINDER_PATTERN_SIZE = 7;
finderPattern.getPositions = function getPositions(version2) {
  const size2 = getSymbolSize(version2);
  return [
    // top-left
    [0, 0],
    // top-right
    [size2 - FINDER_PATTERN_SIZE, 0],
    // bottom-left
    [0, size2 - FINDER_PATTERN_SIZE]
  ];
};
var maskPattern = {};
(function(exports2) {
  exports2.Patterns = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7
  };
  const PenaltyScores = {
    N1: 3,
    N2: 3,
    N3: 40,
    N4: 10
  };
  exports2.isValid = function isValid3(mask2) {
    return mask2 != null && mask2 !== "" && !isNaN(mask2) && mask2 >= 0 && mask2 <= 7;
  };
  exports2.from = function from2(value) {
    return exports2.isValid(value) ? parseInt(value, 10) : void 0;
  };
  exports2.getPenaltyN1 = function getPenaltyN1(data2) {
    const size2 = data2.size;
    let points = 0;
    let sameCountCol = 0;
    let sameCountRow = 0;
    let lastCol = null;
    let lastRow = null;
    for (let row = 0; row < size2; row++) {
      sameCountCol = sameCountRow = 0;
      lastCol = lastRow = null;
      for (let col = 0; col < size2; col++) {
        let module = data2.get(row, col);
        if (module === lastCol) {
          sameCountCol++;
        } else {
          if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
          lastCol = module;
          sameCountCol = 1;
        }
        module = data2.get(col, row);
        if (module === lastRow) {
          sameCountRow++;
        } else {
          if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
          lastRow = module;
          sameCountRow = 1;
        }
      }
      if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
      if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
    }
    return points;
  };
  exports2.getPenaltyN2 = function getPenaltyN2(data2) {
    const size2 = data2.size;
    let points = 0;
    for (let row = 0; row < size2 - 1; row++) {
      for (let col = 0; col < size2 - 1; col++) {
        const last = data2.get(row, col) + data2.get(row, col + 1) + data2.get(row + 1, col) + data2.get(row + 1, col + 1);
        if (last === 4 || last === 0) points++;
      }
    }
    return points * PenaltyScores.N2;
  };
  exports2.getPenaltyN3 = function getPenaltyN3(data2) {
    const size2 = data2.size;
    let points = 0;
    let bitsCol = 0;
    let bitsRow = 0;
    for (let row = 0; row < size2; row++) {
      bitsCol = bitsRow = 0;
      for (let col = 0; col < size2; col++) {
        bitsCol = bitsCol << 1 & 2047 | data2.get(row, col);
        if (col >= 10 && (bitsCol === 1488 || bitsCol === 93)) points++;
        bitsRow = bitsRow << 1 & 2047 | data2.get(col, row);
        if (col >= 10 && (bitsRow === 1488 || bitsRow === 93)) points++;
      }
    }
    return points * PenaltyScores.N3;
  };
  exports2.getPenaltyN4 = function getPenaltyN4(data2) {
    let darkCount = 0;
    const modulesCount = data2.data.length;
    for (let i4 = 0; i4 < modulesCount; i4++) darkCount += data2.data[i4];
    const k3 = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
    return k3 * PenaltyScores.N4;
  };
  function getMaskAt(maskPattern2, i4, j2) {
    switch (maskPattern2) {
      case exports2.Patterns.PATTERN000:
        return (i4 + j2) % 2 === 0;
      case exports2.Patterns.PATTERN001:
        return i4 % 2 === 0;
      case exports2.Patterns.PATTERN010:
        return j2 % 3 === 0;
      case exports2.Patterns.PATTERN011:
        return (i4 + j2) % 3 === 0;
      case exports2.Patterns.PATTERN100:
        return (Math.floor(i4 / 2) + Math.floor(j2 / 3)) % 2 === 0;
      case exports2.Patterns.PATTERN101:
        return i4 * j2 % 2 + i4 * j2 % 3 === 0;
      case exports2.Patterns.PATTERN110:
        return (i4 * j2 % 2 + i4 * j2 % 3) % 2 === 0;
      case exports2.Patterns.PATTERN111:
        return (i4 * j2 % 3 + (i4 + j2) % 2) % 2 === 0;
      default:
        throw new Error("bad maskPattern:" + maskPattern2);
    }
  }
  exports2.applyMask = function applyMask(pattern, data2) {
    const size2 = data2.size;
    for (let col = 0; col < size2; col++) {
      for (let row = 0; row < size2; row++) {
        if (data2.isReserved(row, col)) continue;
        data2.xor(row, col, getMaskAt(pattern, row, col));
      }
    }
  };
  exports2.getBestMask = function getBestMask(data2, setupFormatFunc) {
    const numPatterns = Object.keys(exports2.Patterns).length;
    let bestPattern = 0;
    let lowerPenalty = Infinity;
    for (let p2 = 0; p2 < numPatterns; p2++) {
      setupFormatFunc(p2);
      exports2.applyMask(p2, data2);
      const penalty = exports2.getPenaltyN1(data2) + exports2.getPenaltyN2(data2) + exports2.getPenaltyN3(data2) + exports2.getPenaltyN4(data2);
      exports2.applyMask(p2, data2);
      if (penalty < lowerPenalty) {
        lowerPenalty = penalty;
        bestPattern = p2;
      }
    }
    return bestPattern;
  };
})(maskPattern);
var errorCorrectionCode = {};
const ECLevel$1 = errorCorrectionLevel;
const EC_BLOCKS_TABLE = [
  // L  M  Q  H
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  2,
  1,
  2,
  2,
  4,
  1,
  2,
  4,
  4,
  2,
  4,
  4,
  4,
  2,
  4,
  6,
  5,
  2,
  4,
  6,
  6,
  2,
  5,
  8,
  8,
  4,
  5,
  8,
  8,
  4,
  5,
  8,
  11,
  4,
  8,
  10,
  11,
  4,
  9,
  12,
  16,
  4,
  9,
  16,
  16,
  6,
  10,
  12,
  18,
  6,
  10,
  17,
  16,
  6,
  11,
  16,
  19,
  6,
  13,
  18,
  21,
  7,
  14,
  21,
  25,
  8,
  16,
  20,
  25,
  8,
  17,
  23,
  25,
  9,
  17,
  23,
  34,
  9,
  18,
  25,
  30,
  10,
  20,
  27,
  32,
  12,
  21,
  29,
  35,
  12,
  23,
  34,
  37,
  12,
  25,
  34,
  40,
  13,
  26,
  35,
  42,
  14,
  28,
  38,
  45,
  15,
  29,
  40,
  48,
  16,
  31,
  43,
  51,
  17,
  33,
  45,
  54,
  18,
  35,
  48,
  57,
  19,
  37,
  51,
  60,
  19,
  38,
  53,
  63,
  20,
  40,
  56,
  66,
  21,
  43,
  59,
  70,
  22,
  45,
  62,
  74,
  24,
  47,
  65,
  77,
  25,
  49,
  68,
  81
];
const EC_CODEWORDS_TABLE = [
  // L  M  Q  H
  7,
  10,
  13,
  17,
  10,
  16,
  22,
  28,
  15,
  26,
  36,
  44,
  20,
  36,
  52,
  64,
  26,
  48,
  72,
  88,
  36,
  64,
  96,
  112,
  40,
  72,
  108,
  130,
  48,
  88,
  132,
  156,
  60,
  110,
  160,
  192,
  72,
  130,
  192,
  224,
  80,
  150,
  224,
  264,
  96,
  176,
  260,
  308,
  104,
  198,
  288,
  352,
  120,
  216,
  320,
  384,
  132,
  240,
  360,
  432,
  144,
  280,
  408,
  480,
  168,
  308,
  448,
  532,
  180,
  338,
  504,
  588,
  196,
  364,
  546,
  650,
  224,
  416,
  600,
  700,
  224,
  442,
  644,
  750,
  252,
  476,
  690,
  816,
  270,
  504,
  750,
  900,
  300,
  560,
  810,
  960,
  312,
  588,
  870,
  1050,
  336,
  644,
  952,
  1110,
  360,
  700,
  1020,
  1200,
  390,
  728,
  1050,
  1260,
  420,
  784,
  1140,
  1350,
  450,
  812,
  1200,
  1440,
  480,
  868,
  1290,
  1530,
  510,
  924,
  1350,
  1620,
  540,
  980,
  1440,
  1710,
  570,
  1036,
  1530,
  1800,
  570,
  1064,
  1590,
  1890,
  600,
  1120,
  1680,
  1980,
  630,
  1204,
  1770,
  2100,
  660,
  1260,
  1860,
  2220,
  720,
  1316,
  1950,
  2310,
  750,
  1372,
  2040,
  2430
];
errorCorrectionCode.getBlocksCount = function getBlocksCount(version2, errorCorrectionLevel2) {
  switch (errorCorrectionLevel2) {
    case ECLevel$1.L:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 0];
    case ECLevel$1.M:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 1];
    case ECLevel$1.Q:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 2];
    case ECLevel$1.H:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 3];
    default:
      return void 0;
  }
};
errorCorrectionCode.getTotalCodewordsCount = function getTotalCodewordsCount(version2, errorCorrectionLevel2) {
  switch (errorCorrectionLevel2) {
    case ECLevel$1.L:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 0];
    case ECLevel$1.M:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 1];
    case ECLevel$1.Q:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 2];
    case ECLevel$1.H:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 3];
    default:
      return void 0;
  }
};
var polynomial = {};
var galoisField = {};
const EXP_TABLE = new Uint8Array(512);
const LOG_TABLE = new Uint8Array(256);
(function initTables() {
  let x2 = 1;
  for (let i4 = 0; i4 < 255; i4++) {
    EXP_TABLE[i4] = x2;
    LOG_TABLE[x2] = i4;
    x2 <<= 1;
    if (x2 & 256) {
      x2 ^= 285;
    }
  }
  for (let i4 = 255; i4 < 512; i4++) {
    EXP_TABLE[i4] = EXP_TABLE[i4 - 255];
  }
})();
galoisField.log = function log(n5) {
  if (n5 < 1) throw new Error("log(" + n5 + ")");
  return LOG_TABLE[n5];
};
galoisField.exp = function exp(n5) {
  return EXP_TABLE[n5];
};
galoisField.mul = function mul5(x2, y4) {
  if (x2 === 0 || y4 === 0) return 0;
  return EXP_TABLE[LOG_TABLE[x2] + LOG_TABLE[y4]];
};
(function(exports2) {
  const GF = galoisField;
  exports2.mul = function mul6(p1, p2) {
    const coeff = new Uint8Array(p1.length + p2.length - 1);
    for (let i4 = 0; i4 < p1.length; i4++) {
      for (let j2 = 0; j2 < p2.length; j2++) {
        coeff[i4 + j2] ^= GF.mul(p1[i4], p2[j2]);
      }
    }
    return coeff;
  };
  exports2.mod = function mod2(divident, divisor) {
    let result = new Uint8Array(divident);
    while (result.length - divisor.length >= 0) {
      const coeff = result[0];
      for (let i4 = 0; i4 < divisor.length; i4++) {
        result[i4] ^= GF.mul(divisor[i4], coeff);
      }
      let offset = 0;
      while (offset < result.length && result[offset] === 0) offset++;
      result = result.slice(offset);
    }
    return result;
  };
  exports2.generateECPolynomial = function generateECPolynomial(degree) {
    let poly = new Uint8Array([1]);
    for (let i4 = 0; i4 < degree; i4++) {
      poly = exports2.mul(poly, new Uint8Array([1, GF.exp(i4)]));
    }
    return poly;
  };
})(polynomial);
const Polynomial = polynomial;
function ReedSolomonEncoder$1(degree) {
  this.genPoly = void 0;
  this.degree = degree;
  if (this.degree) this.initialize(this.degree);
}
ReedSolomonEncoder$1.prototype.initialize = function initialize(degree) {
  this.degree = degree;
  this.genPoly = Polynomial.generateECPolynomial(this.degree);
};
ReedSolomonEncoder$1.prototype.encode = function encode3(data2) {
  if (!this.genPoly) {
    throw new Error("Encoder not initialized");
  }
  const paddedData = new Uint8Array(data2.length + this.degree);
  paddedData.set(data2);
  const remainder = Polynomial.mod(paddedData, this.genPoly);
  const start = this.degree - remainder.length;
  if (start > 0) {
    const buff = new Uint8Array(this.degree);
    buff.set(remainder, start);
    return buff;
  }
  return remainder;
};
var reedSolomonEncoder = ReedSolomonEncoder$1;
var version$2 = {};
var mode = {};
var versionCheck = {};
versionCheck.isValid = function isValid2(version2) {
  return !isNaN(version2) && version2 >= 1 && version2 <= 40;
};
var regex = {};
const numeric = "[0-9]+";
const alphanumeric = "[A-Z $%*+\\-./:]+";
let kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
kanji = kanji.replace(/u/g, "\\u");
const byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
regex.KANJI = new RegExp(kanji, "g");
regex.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
regex.BYTE = new RegExp(byte, "g");
regex.NUMERIC = new RegExp(numeric, "g");
regex.ALPHANUMERIC = new RegExp(alphanumeric, "g");
const TEST_KANJI = new RegExp("^" + kanji + "$");
const TEST_NUMERIC = new RegExp("^" + numeric + "$");
const TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
regex.testKanji = function testKanji(str) {
  return TEST_KANJI.test(str);
};
regex.testNumeric = function testNumeric(str) {
  return TEST_NUMERIC.test(str);
};
regex.testAlphanumeric = function testAlphanumeric(str) {
  return TEST_ALPHANUMERIC.test(str);
};
(function(exports2) {
  const VersionCheck = versionCheck;
  const Regex = regex;
  exports2.NUMERIC = {
    id: "Numeric",
    bit: 1 << 0,
    ccBits: [10, 12, 14]
  };
  exports2.ALPHANUMERIC = {
    id: "Alphanumeric",
    bit: 1 << 1,
    ccBits: [9, 11, 13]
  };
  exports2.BYTE = {
    id: "Byte",
    bit: 1 << 2,
    ccBits: [8, 16, 16]
  };
  exports2.KANJI = {
    id: "Kanji",
    bit: 1 << 3,
    ccBits: [8, 10, 12]
  };
  exports2.MIXED = {
    bit: -1
  };
  exports2.getCharCountIndicator = function getCharCountIndicator(mode2, version2) {
    if (!mode2.ccBits) throw new Error("Invalid mode: " + mode2);
    if (!VersionCheck.isValid(version2)) {
      throw new Error("Invalid version: " + version2);
    }
    if (version2 >= 1 && version2 < 10) return mode2.ccBits[0];
    else if (version2 < 27) return mode2.ccBits[1];
    return mode2.ccBits[2];
  };
  exports2.getBestModeForData = function getBestModeForData(dataStr) {
    if (Regex.testNumeric(dataStr)) return exports2.NUMERIC;
    else if (Regex.testAlphanumeric(dataStr)) return exports2.ALPHANUMERIC;
    else if (Regex.testKanji(dataStr)) return exports2.KANJI;
    else return exports2.BYTE;
  };
  exports2.toString = function toString2(mode2) {
    if (mode2 && mode2.id) return mode2.id;
    throw new Error("Invalid mode");
  };
  exports2.isValid = function isValid3(mode2) {
    return mode2 && mode2.bit && mode2.ccBits;
  };
  function fromString2(string2) {
    if (typeof string2 !== "string") {
      throw new Error("Param is not a string");
    }
    const lcStr = string2.toLowerCase();
    switch (lcStr) {
      case "numeric":
        return exports2.NUMERIC;
      case "alphanumeric":
        return exports2.ALPHANUMERIC;
      case "kanji":
        return exports2.KANJI;
      case "byte":
        return exports2.BYTE;
      default:
        throw new Error("Unknown mode: " + string2);
    }
  }
  exports2.from = function from2(value, defaultValue) {
    if (exports2.isValid(value)) {
      return value;
    }
    try {
      return fromString2(value);
    } catch (e3) {
      return defaultValue;
    }
  };
})(mode);
(function(exports2) {
  const Utils2 = utils$1;
  const ECCode2 = errorCorrectionCode;
  const ECLevel2 = errorCorrectionLevel;
  const Mode2 = mode;
  const VersionCheck = versionCheck;
  const G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
  const G18_BCH = Utils2.getBCHDigit(G18);
  function getBestVersionForDataLength(mode2, length, errorCorrectionLevel2) {
    for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
      if (length <= exports2.getCapacity(currentVersion, errorCorrectionLevel2, mode2)) {
        return currentVersion;
      }
    }
    return void 0;
  }
  function getReservedBitsCount(mode2, version2) {
    return Mode2.getCharCountIndicator(mode2, version2) + 4;
  }
  function getTotalBitsFromDataArray(segments2, version2) {
    let totalBits = 0;
    segments2.forEach(function(data2) {
      const reservedBits = getReservedBitsCount(data2.mode, version2);
      totalBits += reservedBits + data2.getBitsLength();
    });
    return totalBits;
  }
  function getBestVersionForMixedData(segments2, errorCorrectionLevel2) {
    for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
      const length = getTotalBitsFromDataArray(segments2, currentVersion);
      if (length <= exports2.getCapacity(currentVersion, errorCorrectionLevel2, Mode2.MIXED)) {
        return currentVersion;
      }
    }
    return void 0;
  }
  exports2.from = function from2(value, defaultValue) {
    if (VersionCheck.isValid(value)) {
      return parseInt(value, 10);
    }
    return defaultValue;
  };
  exports2.getCapacity = function getCapacity(version2, errorCorrectionLevel2, mode2) {
    if (!VersionCheck.isValid(version2)) {
      throw new Error("Invalid QR Code version");
    }
    if (typeof mode2 === "undefined") mode2 = Mode2.BYTE;
    const totalCodewords = Utils2.getSymbolTotalCodewords(version2);
    const ecTotalCodewords = ECCode2.getTotalCodewordsCount(version2, errorCorrectionLevel2);
    const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
    if (mode2 === Mode2.MIXED) return dataTotalCodewordsBits;
    const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode2, version2);
    switch (mode2) {
      case Mode2.NUMERIC:
        return Math.floor(usableBits / 10 * 3);
      case Mode2.ALPHANUMERIC:
        return Math.floor(usableBits / 11 * 2);
      case Mode2.KANJI:
        return Math.floor(usableBits / 13);
      case Mode2.BYTE:
      default:
        return Math.floor(usableBits / 8);
    }
  };
  exports2.getBestVersionForData = function getBestVersionForData(data2, errorCorrectionLevel2) {
    let seg;
    const ecl = ECLevel2.from(errorCorrectionLevel2, ECLevel2.M);
    if (Array.isArray(data2)) {
      if (data2.length > 1) {
        return getBestVersionForMixedData(data2, ecl);
      }
      if (data2.length === 0) {
        return 1;
      }
      seg = data2[0];
    } else {
      seg = data2;
    }
    return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
  };
  exports2.getEncodedBits = function getEncodedBits2(version2) {
    if (!VersionCheck.isValid(version2) || version2 < 7) {
      throw new Error("Invalid QR Code version");
    }
    let d4 = version2 << 12;
    while (Utils2.getBCHDigit(d4) - G18_BCH >= 0) {
      d4 ^= G18 << Utils2.getBCHDigit(d4) - G18_BCH;
    }
    return version2 << 12 | d4;
  };
})(version$2);
var formatInfo = {};
const Utils$3 = utils$1;
const G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
const G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
const G15_BCH = Utils$3.getBCHDigit(G15);
formatInfo.getEncodedBits = function getEncodedBits(errorCorrectionLevel2, mask2) {
  const data2 = errorCorrectionLevel2.bit << 3 | mask2;
  let d4 = data2 << 10;
  while (Utils$3.getBCHDigit(d4) - G15_BCH >= 0) {
    d4 ^= G15 << Utils$3.getBCHDigit(d4) - G15_BCH;
  }
  return (data2 << 10 | d4) ^ G15_MASK;
};
var segments = {};
const Mode$4 = mode;
function NumericData(data2) {
  this.mode = Mode$4.NUMERIC;
  this.data = data2.toString();
}
NumericData.getBitsLength = function getBitsLength(length) {
  return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
};
NumericData.prototype.getLength = function getLength2() {
  return this.data.length;
};
NumericData.prototype.getBitsLength = function getBitsLength2() {
  return NumericData.getBitsLength(this.data.length);
};
NumericData.prototype.write = function write(bitBuffer2) {
  let i4, group, value;
  for (i4 = 0; i4 + 3 <= this.data.length; i4 += 3) {
    group = this.data.substr(i4, 3);
    value = parseInt(group, 10);
    bitBuffer2.put(value, 10);
  }
  const remainingNum = this.data.length - i4;
  if (remainingNum > 0) {
    group = this.data.substr(i4);
    value = parseInt(group, 10);
    bitBuffer2.put(value, remainingNum * 3 + 1);
  }
};
var numericData = NumericData;
const Mode$3 = mode;
const ALPHA_NUM_CHARS = [
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  " ",
  "$",
  "%",
  "*",
  "+",
  "-",
  ".",
  "/",
  ":"
];
function AlphanumericData(data2) {
  this.mode = Mode$3.ALPHANUMERIC;
  this.data = data2;
}
AlphanumericData.getBitsLength = function getBitsLength3(length) {
  return 11 * Math.floor(length / 2) + 6 * (length % 2);
};
AlphanumericData.prototype.getLength = function getLength3() {
  return this.data.length;
};
AlphanumericData.prototype.getBitsLength = function getBitsLength4() {
  return AlphanumericData.getBitsLength(this.data.length);
};
AlphanumericData.prototype.write = function write2(bitBuffer2) {
  let i4;
  for (i4 = 0; i4 + 2 <= this.data.length; i4 += 2) {
    let value = ALPHA_NUM_CHARS.indexOf(this.data[i4]) * 45;
    value += ALPHA_NUM_CHARS.indexOf(this.data[i4 + 1]);
    bitBuffer2.put(value, 11);
  }
  if (this.data.length % 2) {
    bitBuffer2.put(ALPHA_NUM_CHARS.indexOf(this.data[i4]), 6);
  }
};
var alphanumericData = AlphanumericData;
var encodeUtf8$1 = function encodeUtf82(input) {
  var result = [];
  var size2 = input.length;
  for (var index2 = 0; index2 < size2; index2++) {
    var point5 = input.charCodeAt(index2);
    if (point5 >= 55296 && point5 <= 56319 && size2 > index2 + 1) {
      var second = input.charCodeAt(index2 + 1);
      if (second >= 56320 && second <= 57343) {
        point5 = (point5 - 55296) * 1024 + second - 56320 + 65536;
        index2 += 1;
      }
    }
    if (point5 < 128) {
      result.push(point5);
      continue;
    }
    if (point5 < 2048) {
      result.push(point5 >> 6 | 192);
      result.push(point5 & 63 | 128);
      continue;
    }
    if (point5 < 55296 || point5 >= 57344 && point5 < 65536) {
      result.push(point5 >> 12 | 224);
      result.push(point5 >> 6 & 63 | 128);
      result.push(point5 & 63 | 128);
      continue;
    }
    if (point5 >= 65536 && point5 <= 1114111) {
      result.push(point5 >> 18 | 240);
      result.push(point5 >> 12 & 63 | 128);
      result.push(point5 >> 6 & 63 | 128);
      result.push(point5 & 63 | 128);
      continue;
    }
    result.push(239, 191, 189);
  }
  return new Uint8Array(result).buffer;
};
const encodeUtf8 = encodeUtf8$1;
const Mode$2 = mode;
function ByteData(data2) {
  this.mode = Mode$2.BYTE;
  if (typeof data2 === "string") {
    data2 = encodeUtf8(data2);
  }
  this.data = new Uint8Array(data2);
}
ByteData.getBitsLength = function getBitsLength5(length) {
  return length * 8;
};
ByteData.prototype.getLength = function getLength4() {
  return this.data.length;
};
ByteData.prototype.getBitsLength = function getBitsLength6() {
  return ByteData.getBitsLength(this.data.length);
};
ByteData.prototype.write = function(bitBuffer2) {
  for (let i4 = 0, l2 = this.data.length; i4 < l2; i4++) {
    bitBuffer2.put(this.data[i4], 8);
  }
};
var byteData = ByteData;
const Mode$1 = mode;
const Utils$2 = utils$1;
function KanjiData(data2) {
  this.mode = Mode$1.KANJI;
  this.data = data2;
}
KanjiData.getBitsLength = function getBitsLength7(length) {
  return length * 13;
};
KanjiData.prototype.getLength = function getLength5() {
  return this.data.length;
};
KanjiData.prototype.getBitsLength = function getBitsLength8() {
  return KanjiData.getBitsLength(this.data.length);
};
KanjiData.prototype.write = function(bitBuffer2) {
  let i4;
  for (i4 = 0; i4 < this.data.length; i4++) {
    let value = Utils$2.toSJIS(this.data[i4]);
    if (value >= 33088 && value <= 40956) {
      value -= 33088;
    } else if (value >= 57408 && value <= 60351) {
      value -= 49472;
    } else {
      throw new Error(
        "Invalid SJIS character: " + this.data[i4] + "\nMake sure your charset is UTF-8"
      );
    }
    value = (value >>> 8 & 255) * 192 + (value & 255);
    bitBuffer2.put(value, 13);
  }
};
var kanjiData = KanjiData;
var dijkstra = { exports: {} };
(function(module) {
  var dijkstra2 = {
    single_source_shortest_paths: function(graph, s2, d4) {
      var predecessors = {};
      var costs = {};
      costs[s2] = 0;
      var open = dijkstra2.PriorityQueue.make();
      open.push(s2, 0);
      var closest, u2, v2, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
      while (!open.empty()) {
        closest = open.pop();
        u2 = closest.value;
        cost_of_s_to_u = closest.cost;
        adjacent_nodes = graph[u2] || {};
        for (v2 in adjacent_nodes) {
          if (adjacent_nodes.hasOwnProperty(v2)) {
            cost_of_e = adjacent_nodes[v2];
            cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
            cost_of_s_to_v = costs[v2];
            first_visit = typeof costs[v2] === "undefined";
            if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
              costs[v2] = cost_of_s_to_u_plus_cost_of_e;
              open.push(v2, cost_of_s_to_u_plus_cost_of_e);
              predecessors[v2] = u2;
            }
          }
        }
      }
      if (typeof d4 !== "undefined" && typeof costs[d4] === "undefined") {
        var msg = ["Could not find a path from ", s2, " to ", d4, "."].join("");
        throw new Error(msg);
      }
      return predecessors;
    },
    extract_shortest_path_from_predecessor_list: function(predecessors, d4) {
      var nodes = [];
      var u2 = d4;
      while (u2) {
        nodes.push(u2);
        predecessors[u2];
        u2 = predecessors[u2];
      }
      nodes.reverse();
      return nodes;
    },
    find_path: function(graph, s2, d4) {
      var predecessors = dijkstra2.single_source_shortest_paths(graph, s2, d4);
      return dijkstra2.extract_shortest_path_from_predecessor_list(
        predecessors,
        d4
      );
    },
    /**
     * A very naive priority queue implementation.
     */
    PriorityQueue: {
      make: function(opts) {
        var T2 = dijkstra2.PriorityQueue, t2 = {}, key2;
        opts = opts || {};
        for (key2 in T2) {
          if (T2.hasOwnProperty(key2)) {
            t2[key2] = T2[key2];
          }
        }
        t2.queue = [];
        t2.sorter = opts.sorter || T2.default_sorter;
        return t2;
      },
      default_sorter: function(a2, b2) {
        return a2.cost - b2.cost;
      },
      /**
       * Add a new item to the queue and ensure the highest priority element
       * is at the front of the queue.
       */
      push: function(value, cost) {
        var item = { value, cost };
        this.queue.push(item);
        this.queue.sort(this.sorter);
      },
      /**
       * Return the highest priority element in the queue.
       */
      pop: function() {
        return this.queue.shift();
      },
      empty: function() {
        return this.queue.length === 0;
      }
    }
  };
  {
    module.exports = dijkstra2;
  }
})(dijkstra);
var dijkstraExports = dijkstra.exports;
(function(exports2) {
  const Mode2 = mode;
  const NumericData2 = numericData;
  const AlphanumericData2 = alphanumericData;
  const ByteData2 = byteData;
  const KanjiData2 = kanjiData;
  const Regex = regex;
  const Utils2 = utils$1;
  const dijkstra2 = dijkstraExports;
  function getStringByteLength(str) {
    return unescape(encodeURIComponent(str)).length;
  }
  function getSegments(regex2, mode2, str) {
    const segments2 = [];
    let result;
    while ((result = regex2.exec(str)) !== null) {
      segments2.push({
        data: result[0],
        index: result.index,
        mode: mode2,
        length: result[0].length
      });
    }
    return segments2;
  }
  function getSegmentsFromString(dataStr) {
    const numSegs = getSegments(Regex.NUMERIC, Mode2.NUMERIC, dataStr);
    const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode2.ALPHANUMERIC, dataStr);
    let byteSegs;
    let kanjiSegs;
    if (Utils2.isKanjiModeEnabled()) {
      byteSegs = getSegments(Regex.BYTE, Mode2.BYTE, dataStr);
      kanjiSegs = getSegments(Regex.KANJI, Mode2.KANJI, dataStr);
    } else {
      byteSegs = getSegments(Regex.BYTE_KANJI, Mode2.BYTE, dataStr);
      kanjiSegs = [];
    }
    const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
    return segs.sort(function(s1, s2) {
      return s1.index - s2.index;
    }).map(function(obj) {
      return {
        data: obj.data,
        mode: obj.mode,
        length: obj.length
      };
    });
  }
  function getSegmentBitsLength(length, mode2) {
    switch (mode2) {
      case Mode2.NUMERIC:
        return NumericData2.getBitsLength(length);
      case Mode2.ALPHANUMERIC:
        return AlphanumericData2.getBitsLength(length);
      case Mode2.KANJI:
        return KanjiData2.getBitsLength(length);
      case Mode2.BYTE:
        return ByteData2.getBitsLength(length);
    }
  }
  function mergeSegments(segs) {
    return segs.reduce(function(acc, curr) {
      const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
      if (prevSeg && prevSeg.mode === curr.mode) {
        acc[acc.length - 1].data += curr.data;
        return acc;
      }
      acc.push(curr);
      return acc;
    }, []);
  }
  function buildNodes(segs) {
    const nodes = [];
    for (let i4 = 0; i4 < segs.length; i4++) {
      const seg = segs[i4];
      switch (seg.mode) {
        case Mode2.NUMERIC:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.ALPHANUMERIC, length: seg.length },
            { data: seg.data, mode: Mode2.BYTE, length: seg.length }
          ]);
          break;
        case Mode2.ALPHANUMERIC:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.BYTE, length: seg.length }
          ]);
          break;
        case Mode2.KANJI:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.BYTE, length: getStringByteLength(seg.data) }
          ]);
          break;
        case Mode2.BYTE:
          nodes.push([
            { data: seg.data, mode: Mode2.BYTE, length: getStringByteLength(seg.data) }
          ]);
      }
    }
    return nodes;
  }
  function buildGraph(nodes, version2) {
    const table = {};
    const graph = { start: {} };
    let prevNodeIds = ["start"];
    for (let i4 = 0; i4 < nodes.length; i4++) {
      const nodeGroup = nodes[i4];
      const currentNodeIds = [];
      for (let j2 = 0; j2 < nodeGroup.length; j2++) {
        const node2 = nodeGroup[j2];
        const key2 = "" + i4 + j2;
        currentNodeIds.push(key2);
        table[key2] = { node: node2, lastCount: 0 };
        graph[key2] = {};
        for (let n5 = 0; n5 < prevNodeIds.length; n5++) {
          const prevNodeId = prevNodeIds[n5];
          if (table[prevNodeId] && table[prevNodeId].node.mode === node2.mode) {
            graph[prevNodeId][key2] = getSegmentBitsLength(table[prevNodeId].lastCount + node2.length, node2.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node2.mode);
            table[prevNodeId].lastCount += node2.length;
          } else {
            if (table[prevNodeId]) table[prevNodeId].lastCount = node2.length;
            graph[prevNodeId][key2] = getSegmentBitsLength(node2.length, node2.mode) + 4 + Mode2.getCharCountIndicator(node2.mode, version2);
          }
        }
      }
      prevNodeIds = currentNodeIds;
    }
    for (let n5 = 0; n5 < prevNodeIds.length; n5++) {
      graph[prevNodeIds[n5]].end = 0;
    }
    return { map: graph, table };
  }
  function buildSingleSegment(data2, modesHint) {
    let mode2;
    const bestMode = Mode2.getBestModeForData(data2);
    mode2 = Mode2.from(modesHint, bestMode);
    if (mode2 !== Mode2.BYTE && mode2.bit < bestMode.bit) {
      throw new Error('"' + data2 + '" cannot be encoded with mode ' + Mode2.toString(mode2) + ".\n Suggested mode is: " + Mode2.toString(bestMode));
    }
    if (mode2 === Mode2.KANJI && !Utils2.isKanjiModeEnabled()) {
      mode2 = Mode2.BYTE;
    }
    switch (mode2) {
      case Mode2.NUMERIC:
        return new NumericData2(data2);
      case Mode2.ALPHANUMERIC:
        return new AlphanumericData2(data2);
      case Mode2.KANJI:
        return new KanjiData2(data2);
      case Mode2.BYTE:
        return new ByteData2(data2);
    }
  }
  exports2.fromArray = function fromArray(array) {
    return array.reduce(function(acc, seg) {
      if (typeof seg === "string") {
        acc.push(buildSingleSegment(seg, null));
      } else if (seg.data) {
        acc.push(buildSingleSegment(seg.data, seg.mode));
      }
      return acc;
    }, []);
  };
  exports2.fromString = function fromString2(data2, version2) {
    const segs = getSegmentsFromString(data2, Utils2.isKanjiModeEnabled());
    const nodes = buildNodes(segs);
    const graph = buildGraph(nodes, version2);
    const path = dijkstra2.find_path(graph.map, "start", "end");
    const optimizedSegs = [];
    for (let i4 = 1; i4 < path.length - 1; i4++) {
      optimizedSegs.push(graph.table[path[i4]].node);
    }
    return exports2.fromArray(mergeSegments(optimizedSegs));
  };
  exports2.rawSplit = function rawSplit(data2) {
    return exports2.fromArray(
      getSegmentsFromString(data2, Utils2.isKanjiModeEnabled())
    );
  };
})(segments);
const Utils$1 = utils$1;
const ECLevel = errorCorrectionLevel;
const BitBuffer = bitBuffer;
const BitMatrix = bitMatrix;
const AlignmentPattern = alignmentPattern;
const FinderPattern = finderPattern;
const MaskPattern = maskPattern;
const ECCode = errorCorrectionCode;
const ReedSolomonEncoder = reedSolomonEncoder;
const Version = version$2;
const FormatInfo = formatInfo;
const Mode = mode;
const Segments = segments;
function setupFinderPattern(matrix, version2) {
  const size2 = matrix.size;
  const pos = FinderPattern.getPositions(version2);
  for (let i4 = 0; i4 < pos.length; i4++) {
    const row = pos[i4][0];
    const col = pos[i4][1];
    for (let r3 = -1; r3 <= 7; r3++) {
      if (row + r3 <= -1 || size2 <= row + r3) continue;
      for (let c2 = -1; c2 <= 7; c2++) {
        if (col + c2 <= -1 || size2 <= col + c2) continue;
        if (r3 >= 0 && r3 <= 6 && (c2 === 0 || c2 === 6) || c2 >= 0 && c2 <= 6 && (r3 === 0 || r3 === 6) || r3 >= 2 && r3 <= 4 && c2 >= 2 && c2 <= 4) {
          matrix.set(row + r3, col + c2, true, true);
        } else {
          matrix.set(row + r3, col + c2, false, true);
        }
      }
    }
  }
}
function setupTimingPattern(matrix) {
  const size2 = matrix.size;
  for (let r3 = 8; r3 < size2 - 8; r3++) {
    const value = r3 % 2 === 0;
    matrix.set(r3, 6, value, true);
    matrix.set(6, r3, value, true);
  }
}
function setupAlignmentPattern(matrix, version2) {
  const pos = AlignmentPattern.getPositions(version2);
  for (let i4 = 0; i4 < pos.length; i4++) {
    const row = pos[i4][0];
    const col = pos[i4][1];
    for (let r3 = -2; r3 <= 2; r3++) {
      for (let c2 = -2; c2 <= 2; c2++) {
        if (r3 === -2 || r3 === 2 || c2 === -2 || c2 === 2 || r3 === 0 && c2 === 0) {
          matrix.set(row + r3, col + c2, true, true);
        } else {
          matrix.set(row + r3, col + c2, false, true);
        }
      }
    }
  }
}
function setupVersionInfo(matrix, version2) {
  const size2 = matrix.size;
  const bits = Version.getEncodedBits(version2);
  let row, col, mod2;
  for (let i4 = 0; i4 < 18; i4++) {
    row = Math.floor(i4 / 3);
    col = i4 % 3 + size2 - 8 - 3;
    mod2 = (bits >> i4 & 1) === 1;
    matrix.set(row, col, mod2, true);
    matrix.set(col, row, mod2, true);
  }
}
function setupFormatInfo(matrix, errorCorrectionLevel2, maskPattern2) {
  const size2 = matrix.size;
  const bits = FormatInfo.getEncodedBits(errorCorrectionLevel2, maskPattern2);
  let i4, mod2;
  for (i4 = 0; i4 < 15; i4++) {
    mod2 = (bits >> i4 & 1) === 1;
    if (i4 < 6) {
      matrix.set(i4, 8, mod2, true);
    } else if (i4 < 8) {
      matrix.set(i4 + 1, 8, mod2, true);
    } else {
      matrix.set(size2 - 15 + i4, 8, mod2, true);
    }
    if (i4 < 8) {
      matrix.set(8, size2 - i4 - 1, mod2, true);
    } else if (i4 < 9) {
      matrix.set(8, 15 - i4 - 1 + 1, mod2, true);
    } else {
      matrix.set(8, 15 - i4 - 1, mod2, true);
    }
  }
  matrix.set(size2 - 8, 8, 1, true);
}
function setupData(matrix, data2) {
  const size2 = matrix.size;
  let inc = -1;
  let row = size2 - 1;
  let bitIndex = 7;
  let byteIndex = 0;
  for (let col = size2 - 1; col > 0; col -= 2) {
    if (col === 6) col--;
    while (true) {
      for (let c2 = 0; c2 < 2; c2++) {
        if (!matrix.isReserved(row, col - c2)) {
          let dark = false;
          if (byteIndex < data2.length) {
            dark = (data2[byteIndex] >>> bitIndex & 1) === 1;
          }
          matrix.set(row, col - c2, dark);
          bitIndex--;
          if (bitIndex === -1) {
            byteIndex++;
            bitIndex = 7;
          }
        }
      }
      row += inc;
      if (row < 0 || size2 <= row) {
        row -= inc;
        inc = -inc;
        break;
      }
    }
  }
}
function createData(version2, errorCorrectionLevel2, segments2) {
  const buffer2 = new BitBuffer();
  segments2.forEach(function(data2) {
    buffer2.put(data2.mode.bit, 4);
    buffer2.put(data2.getLength(), Mode.getCharCountIndicator(data2.mode, version2));
    data2.write(buffer2);
  });
  const totalCodewords = Utils$1.getSymbolTotalCodewords(version2);
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
  if (buffer2.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
    buffer2.put(0, 4);
  }
  while (buffer2.getLengthInBits() % 8 !== 0) {
    buffer2.putBit(0);
  }
  const remainingByte = (dataTotalCodewordsBits - buffer2.getLengthInBits()) / 8;
  for (let i4 = 0; i4 < remainingByte; i4++) {
    buffer2.put(i4 % 2 ? 17 : 236, 8);
  }
  return createCodewords(buffer2, version2, errorCorrectionLevel2);
}
function createCodewords(bitBuffer2, version2, errorCorrectionLevel2) {
  const totalCodewords = Utils$1.getSymbolTotalCodewords(version2);
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
  const dataTotalCodewords = totalCodewords - ecTotalCodewords;
  const ecTotalBlocks = ECCode.getBlocksCount(version2, errorCorrectionLevel2);
  const blocksInGroup2 = totalCodewords % ecTotalBlocks;
  const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
  const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
  const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
  const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
  const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
  const rs2 = new ReedSolomonEncoder(ecCount);
  let offset = 0;
  const dcData = new Array(ecTotalBlocks);
  const ecData = new Array(ecTotalBlocks);
  let maxDataSize = 0;
  const buffer2 = new Uint8Array(bitBuffer2.buffer);
  for (let b2 = 0; b2 < ecTotalBlocks; b2++) {
    const dataSize = b2 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
    dcData[b2] = buffer2.slice(offset, offset + dataSize);
    ecData[b2] = rs2.encode(dcData[b2]);
    offset += dataSize;
    maxDataSize = Math.max(maxDataSize, dataSize);
  }
  const data2 = new Uint8Array(totalCodewords);
  let index2 = 0;
  let i4, r3;
  for (i4 = 0; i4 < maxDataSize; i4++) {
    for (r3 = 0; r3 < ecTotalBlocks; r3++) {
      if (i4 < dcData[r3].length) {
        data2[index2++] = dcData[r3][i4];
      }
    }
  }
  for (i4 = 0; i4 < ecCount; i4++) {
    for (r3 = 0; r3 < ecTotalBlocks; r3++) {
      data2[index2++] = ecData[r3][i4];
    }
  }
  return data2;
}
function createSymbol(data2, version2, errorCorrectionLevel2, maskPattern2) {
  let segments2;
  if (Array.isArray(data2)) {
    segments2 = Segments.fromArray(data2);
  } else if (typeof data2 === "string") {
    let estimatedVersion = version2;
    if (!estimatedVersion) {
      const rawSegments = Segments.rawSplit(data2);
      estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel2);
    }
    segments2 = Segments.fromString(data2, estimatedVersion || 40);
  } else {
    throw new Error("Invalid data");
  }
  const bestVersion = Version.getBestVersionForData(segments2, errorCorrectionLevel2);
  if (!bestVersion) {
    throw new Error("The amount of data is too big to be stored in a QR Code");
  }
  if (!version2) {
    version2 = bestVersion;
  } else if (version2 < bestVersion) {
    throw new Error(
      "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
    );
  }
  const dataBits = createData(version2, errorCorrectionLevel2, segments2);
  const moduleCount = Utils$1.getSymbolSize(version2);
  const modules = new BitMatrix(moduleCount);
  setupFinderPattern(modules, version2);
  setupTimingPattern(modules);
  setupAlignmentPattern(modules, version2);
  setupFormatInfo(modules, errorCorrectionLevel2, 0);
  if (version2 >= 7) {
    setupVersionInfo(modules, version2);
  }
  setupData(modules, dataBits);
  if (isNaN(maskPattern2)) {
    maskPattern2 = MaskPattern.getBestMask(
      modules,
      setupFormatInfo.bind(null, modules, errorCorrectionLevel2)
    );
  }
  MaskPattern.applyMask(maskPattern2, modules);
  setupFormatInfo(modules, errorCorrectionLevel2, maskPattern2);
  return {
    modules,
    version: version2,
    errorCorrectionLevel: errorCorrectionLevel2,
    maskPattern: maskPattern2,
    segments: segments2
  };
}
qrcode.create = function create(data2, options) {
  if (typeof data2 === "undefined" || data2 === "") {
    throw new Error("No input text");
  }
  let errorCorrectionLevel2 = ECLevel.M;
  let version2;
  let mask2;
  if (typeof options !== "undefined") {
    errorCorrectionLevel2 = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
    version2 = Version.from(options.version);
    mask2 = MaskPattern.from(options.maskPattern);
    if (options.toSJISFunc) {
      Utils$1.setToSJISFunction(options.toSJISFunc);
    }
  }
  return createSymbol(data2, version2, errorCorrectionLevel2, mask2);
};
var canvas = {};
var utils = {};
(function(exports2) {
  function hex2rgba(hex) {
    if (typeof hex === "number") {
      hex = hex.toString();
    }
    if (typeof hex !== "string") {
      throw new Error("Color should be defined as hex string");
    }
    let hexCode = hex.slice().replace("#", "").split("");
    if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
      throw new Error("Invalid hex color: " + hex);
    }
    if (hexCode.length === 3 || hexCode.length === 4) {
      hexCode = Array.prototype.concat.apply([], hexCode.map(function(c2) {
        return [c2, c2];
      }));
    }
    if (hexCode.length === 6) hexCode.push("F", "F");
    const hexValue = parseInt(hexCode.join(""), 16);
    return {
      r: hexValue >> 24 & 255,
      g: hexValue >> 16 & 255,
      b: hexValue >> 8 & 255,
      a: hexValue & 255,
      hex: "#" + hexCode.slice(0, 6).join("")
    };
  }
  exports2.getOptions = function getOptions(options) {
    if (!options) options = {};
    if (!options.color) options.color = {};
    const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
    const width = options.width && options.width >= 21 ? options.width : void 0;
    const scale = options.scale || 4;
    return {
      width,
      scale: width ? 4 : scale,
      margin,
      color: {
        dark: hex2rgba(options.color.dark || "#000000ff"),
        light: hex2rgba(options.color.light || "#ffffffff")
      },
      type: options.type,
      rendererOpts: options.rendererOpts || {}
    };
  };
  exports2.getScale = function getScale(qrSize, opts) {
    return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
  };
  exports2.getImageWidth = function getImageWidth(qrSize, opts) {
    const scale = exports2.getScale(qrSize, opts);
    return Math.floor((qrSize + opts.margin * 2) * scale);
  };
  exports2.qrToImageData = function qrToImageData(imgData, qr2, opts) {
    const size2 = qr2.modules.size;
    const data2 = qr2.modules.data;
    const scale = exports2.getScale(size2, opts);
    const symbolSize = Math.floor((size2 + opts.margin * 2) * scale);
    const scaledMargin = opts.margin * scale;
    const palette = [opts.color.light, opts.color.dark];
    for (let i4 = 0; i4 < symbolSize; i4++) {
      for (let j2 = 0; j2 < symbolSize; j2++) {
        let posDst = (i4 * symbolSize + j2) * 4;
        let pxColor = opts.color.light;
        if (i4 >= scaledMargin && j2 >= scaledMargin && i4 < symbolSize - scaledMargin && j2 < symbolSize - scaledMargin) {
          const iSrc = Math.floor((i4 - scaledMargin) / scale);
          const jSrc = Math.floor((j2 - scaledMargin) / scale);
          pxColor = palette[data2[iSrc * size2 + jSrc] ? 1 : 0];
        }
        imgData[posDst++] = pxColor.r;
        imgData[posDst++] = pxColor.g;
        imgData[posDst++] = pxColor.b;
        imgData[posDst] = pxColor.a;
      }
    }
  };
})(utils);
(function(exports2) {
  const Utils2 = utils;
  function clearCanvas(ctx, canvas2, size2) {
    ctx.clearRect(0, 0, canvas2.width, canvas2.height);
    if (!canvas2.style) canvas2.style = {};
    canvas2.height = size2;
    canvas2.width = size2;
    canvas2.style.height = size2 + "px";
    canvas2.style.width = size2 + "px";
  }
  function getCanvasElement() {
    try {
      return document.createElement("canvas");
    } catch (e3) {
      throw new Error("You need to specify a canvas element");
    }
  }
  exports2.render = function render2(qrData, canvas2, options) {
    let opts = options;
    let canvasEl = canvas2;
    if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
      opts = canvas2;
      canvas2 = void 0;
    }
    if (!canvas2) {
      canvasEl = getCanvasElement();
    }
    opts = Utils2.getOptions(opts);
    const size2 = Utils2.getImageWidth(qrData.modules.size, opts);
    const ctx = canvasEl.getContext("2d");
    const image = ctx.createImageData(size2, size2);
    Utils2.qrToImageData(image.data, qrData, opts);
    clearCanvas(ctx, canvasEl, size2);
    ctx.putImageData(image, 0, 0);
    return canvasEl;
  };
  exports2.renderToDataURL = function renderToDataURL(qrData, canvas2, options) {
    let opts = options;
    if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
      opts = canvas2;
      canvas2 = void 0;
    }
    if (!opts) opts = {};
    const canvasEl = exports2.render(qrData, canvas2, opts);
    const type2 = opts.type || "image/png";
    const rendererOpts = opts.rendererOpts || {};
    return canvasEl.toDataURL(type2, rendererOpts.quality);
  };
})(canvas);
var svgTag = {};
const Utils = utils;
function getColorAttrib(color, attrib) {
  const alpha = color.a / 255;
  const str = attrib + '="' + color.hex + '"';
  return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
}
function svgCmd(cmd, x2, y4) {
  let str = cmd + x2;
  if (typeof y4 !== "undefined") str += " " + y4;
  return str;
}
function qrToPath(data2, size2, margin) {
  let path = "";
  let moveBy = 0;
  let newRow = false;
  let lineLength = 0;
  for (let i4 = 0; i4 < data2.length; i4++) {
    const col = Math.floor(i4 % size2);
    const row = Math.floor(i4 / size2);
    if (!col && !newRow) newRow = true;
    if (data2[i4]) {
      lineLength++;
      if (!(i4 > 0 && col > 0 && data2[i4 - 1])) {
        path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
        moveBy = 0;
        newRow = false;
      }
      if (!(col + 1 < size2 && data2[i4 + 1])) {
        path += svgCmd("h", lineLength);
        lineLength = 0;
      }
    } else {
      moveBy++;
    }
  }
  return path;
}
svgTag.render = function render(qrData, options, cb) {
  const opts = Utils.getOptions(options);
  const size2 = qrData.modules.size;
  const data2 = qrData.modules.data;
  const qrcodesize = size2 + opts.margin * 2;
  const bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
  const path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data2, size2, opts.margin) + '"/>';
  const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
  const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
  const svgTag2 = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
  if (typeof cb === "function") {
    cb(null, svgTag2);
  }
  return svgTag2;
};
const canPromise = canPromise$1;
const QRCode = qrcode;
const CanvasRenderer = canvas;
const SvgRenderer = svgTag;
function renderCanvas(renderFunc, canvas2, text, opts, cb) {
  const args = [].slice.call(arguments, 1);
  const argsNum = args.length;
  const isLastArgCb = typeof args[argsNum - 1] === "function";
  if (!isLastArgCb && !canPromise()) {
    throw new Error("Callback required as last argument");
  }
  if (isLastArgCb) {
    if (argsNum < 2) {
      throw new Error("Too few arguments provided");
    }
    if (argsNum === 2) {
      cb = text;
      text = canvas2;
      canvas2 = opts = void 0;
    } else if (argsNum === 3) {
      if (canvas2.getContext && typeof cb === "undefined") {
        cb = opts;
        opts = void 0;
      } else {
        cb = opts;
        opts = text;
        text = canvas2;
        canvas2 = void 0;
      }
    }
  } else {
    if (argsNum < 1) {
      throw new Error("Too few arguments provided");
    }
    if (argsNum === 1) {
      text = canvas2;
      canvas2 = opts = void 0;
    } else if (argsNum === 2 && !canvas2.getContext) {
      opts = text;
      text = canvas2;
      canvas2 = void 0;
    }
    return new Promise(function(resolve, reject) {
      try {
        const data2 = QRCode.create(text, opts);
        resolve(renderFunc(data2, canvas2, opts));
      } catch (e3) {
        reject(e3);
      }
    });
  }
  try {
    const data2 = QRCode.create(text, opts);
    cb(null, renderFunc(data2, canvas2, opts));
  } catch (e3) {
    cb(e3);
  }
}
browser.create = QRCode.create;
browser.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
browser.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
browser.toString = renderCanvas.bind(null, function(data2, _3, opts) {
  return SvgRenderer.render(data2, opts);
});
const CONNECTING_ERROR_MARGIN = 0.1;
const CIRCLE_SIZE_MODIFIER = 2.5;
const QRCODE_MATRIX_MARGIN = 7;
function isAdjecentDots(cy, otherCy, cellSize) {
  if (cy === otherCy) {
    return false;
  }
  const diff = cy - otherCy < 0 ? otherCy - cy : cy - otherCy;
  return diff <= cellSize + CONNECTING_ERROR_MARGIN;
}
function getMatrix(value, errorCorrectionLevel2) {
  const arr = Array.prototype.slice.call(browser.create(value, { errorCorrectionLevel: errorCorrectionLevel2 }).modules.data, 0);
  const sqrt = Math.sqrt(arr.length);
  return arr.reduce((rows, key2, index2) => (index2 % sqrt === 0 ? rows.push([key2]) : rows[rows.length - 1].push(key2)) && rows, []);
}
const QrCodeUtil = {
  generate({ uri: uri2, size: size2, logoSize, dotColor = "#141414" }) {
    const edgeColor = "transparent";
    const strokeWidth = 5;
    const dots = [];
    const matrix = getMatrix(uri2, "Q");
    const cellSize = size2 / matrix.length;
    const qrList = [
      { x: 0, y: 0 },
      { x: 1, y: 0 },
      { x: 0, y: 1 }
    ];
    qrList.forEach(({ x: x2, y: y4 }) => {
      const x1 = (matrix.length - QRCODE_MATRIX_MARGIN) * cellSize * x2;
      const y1 = (matrix.length - QRCODE_MATRIX_MARGIN) * cellSize * y4;
      const borderRadius = 0.45;
      for (let i4 = 0; i4 < qrList.length; i4 += 1) {
        const dotSize = cellSize * (QRCODE_MATRIX_MARGIN - i4 * 2);
        dots.push(b$2`
            <rect
              fill=${i4 === 2 ? dotColor : edgeColor}
              width=${i4 === 0 ? dotSize - strokeWidth : dotSize}
              rx= ${i4 === 0 ? (dotSize - strokeWidth) * borderRadius : dotSize * borderRadius}
              ry= ${i4 === 0 ? (dotSize - strokeWidth) * borderRadius : dotSize * borderRadius}
              stroke=${dotColor}
              stroke-width=${i4 === 0 ? strokeWidth : 0}
              height=${i4 === 0 ? dotSize - strokeWidth : dotSize}
              x= ${i4 === 0 ? y1 + cellSize * i4 + strokeWidth / 2 : y1 + cellSize * i4}
              y= ${i4 === 0 ? x1 + cellSize * i4 + strokeWidth / 2 : x1 + cellSize * i4}
            />
          `);
      }
    });
    const clearArenaSize = Math.floor((logoSize + 25) / cellSize);
    const matrixMiddleStart = matrix.length / 2 - clearArenaSize / 2;
    const matrixMiddleEnd = matrix.length / 2 + clearArenaSize / 2 - 1;
    const circles = [];
    matrix.forEach((row, i4) => {
      row.forEach((_3, j2) => {
        if (matrix[i4][j2]) {
          if (!(i4 < QRCODE_MATRIX_MARGIN && j2 < QRCODE_MATRIX_MARGIN || i4 > matrix.length - (QRCODE_MATRIX_MARGIN + 1) && j2 < QRCODE_MATRIX_MARGIN || i4 < QRCODE_MATRIX_MARGIN && j2 > matrix.length - (QRCODE_MATRIX_MARGIN + 1))) {
            if (!(i4 > matrixMiddleStart && i4 < matrixMiddleEnd && j2 > matrixMiddleStart && j2 < matrixMiddleEnd)) {
              const cx = i4 * cellSize + cellSize / 2;
              const cy = j2 * cellSize + cellSize / 2;
              circles.push([cx, cy]);
            }
          }
        }
      });
    });
    const circlesToConnect = {};
    circles.forEach(([cx, cy]) => {
      var _a3;
      if (circlesToConnect[cx]) {
        (_a3 = circlesToConnect[cx]) == null ? void 0 : _a3.push(cy);
      } else {
        circlesToConnect[cx] = [cy];
      }
    });
    Object.entries(circlesToConnect).map(([cx, cys]) => {
      const newCys = cys.filter((cy) => cys.every((otherCy) => !isAdjecentDots(cy, otherCy, cellSize)));
      return [Number(cx), newCys];
    }).forEach(([cx, cys]) => {
      cys.forEach((cy) => {
        dots.push(b$2`<circle cx=${cx} cy=${cy} fill=${dotColor} r=${cellSize / CIRCLE_SIZE_MODIFIER} />`);
      });
    });
    Object.entries(circlesToConnect).filter(([_3, cys]) => cys.length > 1).map(([cx, cys]) => {
      const newCys = cys.filter((cy) => cys.some((otherCy) => isAdjecentDots(cy, otherCy, cellSize)));
      return [Number(cx), newCys];
    }).map(([cx, cys]) => {
      cys.sort((a2, b2) => a2 < b2 ? -1 : 1);
      const groups = [];
      for (const cy of cys) {
        const group = groups.find((item) => item.some((otherCy) => isAdjecentDots(cy, otherCy, cellSize)));
        if (group) {
          group.push(cy);
        } else {
          groups.push([cy]);
        }
      }
      return [cx, groups.map((item) => [item[0], item[item.length - 1]])];
    }).forEach(([cx, groups]) => {
      groups.forEach(([y1, y22]) => {
        dots.push(b$2`
              <line
                x1=${cx}
                x2=${cx}
                y1=${y1}
                y2=${y22}
                stroke=${dotColor}
                stroke-width=${cellSize / (CIRCLE_SIZE_MODIFIER / 2)}
                stroke-linecap="round"
              />
            `);
      });
    });
    return dots;
  }
};
const styles$1J = i$4`
  :host {
    position: relative;
    user-select: none;
    display: block;
    overflow: hidden;
    aspect-ratio: 1 / 1;
    width: var(--local-size);
  }

  :host([data-theme='dark']) {
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px);
    background-color: var(--wui-color-inverse-100);
    padding: var(--wui-spacing-l);
  }

  :host([data-theme='light']) {
    box-shadow: 0 0 0 1px var(--wui-color-bg-125);
    background-color: var(--wui-color-bg-125);
  }

  :host([data-clear='true']) > cross-wui-icon {
    display: none;
  }

  svg:first-child,
  cross-wui-image,
  cross-wui-icon {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translateY(-50%) translateX(-50%);
  }

  cross-wui-image {
    width: 25%;
    height: 25%;
    border-radius: var(--wui-border-radius-xs);
  }

  cross-wui-icon {
    width: 100%;
    height: 100%;
    color: var(--local-icon-color) !important;
    transform: translateY(-50%) translateX(-50%) scale(0.25);
  }
`;
var __decorate$2l = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
const DEFAULT_ICON_COLOR = "#3396ff";
let WuiQrCode = class WuiQrCode2 extends i$1 {
  constructor() {
    super(...arguments);
    this.uri = "";
    this.size = 0;
    this.theme = "dark";
    this.imageSrc = void 0;
    this.alt = void 0;
    this.arenaClear = void 0;
    this.farcaster = void 0;
  }
  render() {
    this.dataset["theme"] = this.theme;
    this.dataset["clear"] = String(this.arenaClear);
    this.style.cssText = `
     --local-size: ${this.size}px;
     --local-icon-color: ${this.color ?? DEFAULT_ICON_COLOR}
    `;
    return x$3`${this.templateVisual()} ${this.templateSvg()}`;
  }
  templateSvg() {
    const size2 = this.theme === "light" ? this.size : this.size - 16 * 2;
    return b$2`
      <svg height=${size2} width=${size2}>
        ${QrCodeUtil.generate({
      uri: this.uri,
      size: size2,
      logoSize: this.arenaClear ? 0 : size2 / 4,
      dotColor: this.color
    })}
      </svg>
    `;
  }
  templateVisual() {
    if (this.imageSrc) {
      return x$3`<cross-wui-image src=${this.imageSrc} alt=${this.alt ?? "logo"}></cross-wui-image>`;
    }
    if (this.farcaster) {
      return x$3`<cross-wui-icon
        class="farcaster"
        size="inherit"
        color="inherit"
        name="farcaster"
      ></cross-wui-icon>`;
    }
    return x$3`<cross-wui-icon size="inherit" color="inherit" name="walletConnect"></cross-wui-icon>`;
  }
};
WuiQrCode.styles = [resetStyles, styles$1J];
__decorate$2l([
  n$3()
], WuiQrCode.prototype, "uri", void 0);
__decorate$2l([
  n$3({ type: Number })
], WuiQrCode.prototype, "size", void 0);
__decorate$2l([
  n$3()
], WuiQrCode.prototype, "theme", void 0);
__decorate$2l([
  n$3()
], WuiQrCode.prototype, "imageSrc", void 0);
__decorate$2l([
  n$3()
], WuiQrCode.prototype, "alt", void 0);
__decorate$2l([
  n$3()
], WuiQrCode.prototype, "color", void 0);
__decorate$2l([
  n$3({ type: Boolean })
], WuiQrCode.prototype, "arenaClear", void 0);
__decorate$2l([
  n$3({ type: Boolean })
], WuiQrCode.prototype, "farcaster", void 0);
WuiQrCode = __decorate$2l([
  customElement("cross-wui-qr-code")
], WuiQrCode);
const styles$1I = i$4`
  :host {
    position: relative;
    display: inline-block;
    width: 100%;
  }
`;
var __decorate$2k = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiSearchBar = class WuiSearchBar2 extends i$1 {
  constructor() {
    super(...arguments);
    this.inputComponentRef = e();
  }
  render() {
    return x$3`
      <cross-wui-input-text
        ${n$1(this.inputComponentRef)}
        placeholder="Search wallet"
        icon="search"
        type="search"
        enterKeyHint="search"
        size="sm"
      >
        <cross-wui-input-element @click=${this.clearValue} icon="close"></cross-wui-input-element>
      </cross-wui-input-text>
    `;
  }
  clearValue() {
    const inputComponent = this.inputComponentRef.value;
    const inputElement = inputComponent == null ? void 0 : inputComponent.inputElementRef.value;
    if (inputElement) {
      inputElement.value = "";
      inputElement.focus();
      inputElement.dispatchEvent(new Event("input"));
    }
  }
};
WuiSearchBar.styles = [resetStyles, styles$1I];
WuiSearchBar = __decorate$2k([
  customElement("cross-wui-search-bar")
], WuiSearchBar);
const styles$1H = i$4`
  :host {
    display: flex;
    column-gap: var(--wui-spacing-s);
    align-items: center;
    padding: var(--wui-spacing-xs) var(--wui-spacing-m) var(--wui-spacing-xs) var(--wui-spacing-xs);
    border-radius: var(--wui-border-radius-s);
    border: 1px solid var(--wui-color-gray-glass-005);
    box-sizing: border-box;
    background-color: var(--wui-color-bg-175);
    box-shadow:
      0px 14px 64px -4px rgba(0, 0, 0, 0.15),
      0px 8px 22px -6px rgba(0, 0, 0, 0.15);

    max-width: 300px;
  }

  :host cross-wui-loading-spinner {
    margin-left: var(--wui-spacing-3xs);
  }
`;
var __decorate$2j = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiSnackbar = class WuiSnackbar2 extends i$1 {
  constructor() {
    super(...arguments);
    this.backgroundColor = "accent-100";
    this.iconColor = "accent-100";
    this.icon = "checkmark";
    this.message = "";
    this.loading = false;
    this.iconType = "default";
  }
  render() {
    return x$3`
      ${this.templateIcon()}
      <cross-wui-text variant="paragraph-500" color="fg-100" data-testid="wui-snackbar-message"
        >${this.message}</wui-text
      >
    `;
  }
  templateIcon() {
    if (this.loading) {
      return x$3`<cross-wui-loading-spinner size="md" color="accent-100"></cross-wui-loading-spinner>`;
    }
    if (this.iconType === "default") {
      return x$3`<cross-wui-icon size="xl" color=${this.iconColor} name=${this.icon}></cross-wui-icon>`;
    }
    return x$3`<cross-wui-icon-box
      size="sm"
      iconSize="xs"
      iconColor=${this.iconColor}
      backgroundColor=${this.backgroundColor}
      icon=${this.icon}
      background="opaque"
    ></cross-wui-icon-box>`;
  }
};
WuiSnackbar.styles = [resetStyles, styles$1H];
__decorate$2j([
  n$3()
], WuiSnackbar.prototype, "backgroundColor", void 0);
__decorate$2j([
  n$3()
], WuiSnackbar.prototype, "iconColor", void 0);
__decorate$2j([
  n$3()
], WuiSnackbar.prototype, "icon", void 0);
__decorate$2j([
  n$3()
], WuiSnackbar.prototype, "message", void 0);
__decorate$2j([
  n$3()
], WuiSnackbar.prototype, "loading", void 0);
__decorate$2j([
  n$3()
], WuiSnackbar.prototype, "iconType", void 0);
WuiSnackbar = __decorate$2j([
  customElement("cross-wui-snackbar")
], WuiSnackbar);
const styles$1G = i$4`
  :host {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-s);
    border: 1px solid var(--wui-color-dark-glass-100);
    box-sizing: border-box;
    background-color: var(--wui-color-bg-325);
    box-shadow: 0px 0px 16px 0px rgba(0, 0, 0, 0.25);
  }

  cross-wui-flex {
    width: 100%;
  }

  cross-wui-text {
    word-break: break-word;
    flex: 1;
  }

  .close {
    cursor: pointer;
  }

  .icon-box {
    height: 40px;
    width: 40px;
    border-radius: var(--wui-border-radius-3xs);
    background-color: var(--local-icon-bg-value);
  }
`;
var __decorate$2i = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiAlertBar = class WuiAlertBar2 extends i$1 {
  constructor() {
    super(...arguments);
    this.message = "";
    this.backgroundColor = "accent-100";
    this.iconColor = "accent-100";
    this.icon = "info";
  }
  render() {
    this.style.cssText = `
      --local-icon-bg-value: var(--wui-color-${this.backgroundColor});
   `;
    return x$3`
      <cross-wui-flex flexDirection="row" justifyContent="space-between" alignItems="center">
        <cross-wui-flex columnGap="xs" flexDirection="row" alignItems="center">
          <cross-wui-flex
            flexDirection="row"
            alignItems="center"
            justifyContent="center"
            class="icon-box"
          >
            <cross-wui-icon color=${this.iconColor} size="md" name=${this.icon}></cross-wui-icon>
          </cross-wui-flex>
          <cross-wui-text variant="small-500" color="bg-350" data-testid="wui-alertbar-text"
            >${this.message}</wui-text
          >
        </cross-wui-flex>
        <cross-wui-icon
          class="close"
          color="bg-350"
          size="sm"
          name="close"
          @click=${this.onClose}
        ></cross-wui-icon>
      </cross-wui-flex>
    `;
  }
  onClose() {
    AlertController.close();
  }
};
WuiAlertBar.styles = [resetStyles, styles$1G];
__decorate$2i([
  n$3()
], WuiAlertBar.prototype, "message", void 0);
__decorate$2i([
  n$3()
], WuiAlertBar.prototype, "backgroundColor", void 0);
__decorate$2i([
  n$3()
], WuiAlertBar.prototype, "iconColor", void 0);
__decorate$2i([
  n$3()
], WuiAlertBar.prototype, "icon", void 0);
WuiAlertBar = __decorate$2i([
  customElement("cross-wui-alertbar")
], WuiAlertBar);
const styles$1F = i$4`
  :host {
    display: inline-flex;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-3xl);
    padding: var(--wui-spacing-3xs);
    position: relative;
    height: 36px;
    min-height: 36px;
    overflow: hidden;
  }

  :host::before {
    content: '';
    position: absolute;
    pointer-events: none;
    top: 4px;
    left: 4px;
    display: block;
    width: var(--local-tab-width);
    height: 28px;
    border-radius: var(--wui-border-radius-3xl);
    background-color: var(--cross-wui-tabs-active-bg, var(--wui-color-gray-glass-002));
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    transform: translateX(calc(var(--local-tab) * var(--local-tab-width)));
    transition: transform var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color, opacity;
  }

  :host([data-type='flex'])::before {
    left: 3px;
    transform: translateX(calc((var(--local-tab) * 34px) + (var(--local-tab) * 4px)));
  }

  :host([data-type='flex']) {
    display: flex;
    padding: 0px 0px 0px 12px;
    gap: 4px;
  }

  :host([data-type='flex']) > button > cross-wui-text {
    position: absolute;
    left: 18px;
    opacity: 0;
  }

  button[data-active='true'] > cross-wui-icon,
  button[data-active='true']:hover:enabled > cross-wui-icon,
  button[data-active='true']:active:enabled > cross-wui-icon {
    color: var(--cross-wui-tabs-active-icon-color, var(--wui-color-fg-100));
  }

  button[data-active='true'] > cross-wui-text,
  button[data-active='true']:hover:enabled > cross-wui-text,
  button[data-active='true']:active:enabled > cross-wui-text {
    color: var(--cross-wui-tabs-active-text-color, var(--wui-color-fg-100));
  }

  button[data-active='false'] > cross-wui-icon,
  button[data-active='false'] > cross-wui-text {
    color: var(--wui-color-fg-200);
  }

  button[data-active='true']:disabled,
  button[data-active='false']:disabled {
    background-color: transparent;
    opacity: var(--cross-wui-tabs-disabled-opacity, 0.5);
    cursor: not-allowed;
  }

  button[data-active='true']:disabled > cross-wui-text {
    color: var(
      --cross-wui-tabs-active-disabled-text-color,
      var(--cross-wui-tabs-active-text-color, var(--wui-color-fg-200))
    );
  }

  button[data-active='true']:disabled > cross-wui-icon {
    color: var(
      --cross-wui-tabs-active-disabled-icon-color,
      var(--cross-wui-tabs-active-icon-color, var(--wui-color-fg-200))
    );
  }

  button[data-active='false']:disabled > cross-wui-text {
    color: var(--wui-color-fg-300);
  }

  button > cross-wui-icon,
  button > cross-wui-text {
    pointer-events: none;
    transition: color var(--wui-e ase-out-power-1) var(--wui-duration-md);
    will-change: color;
  }

  button {
    width: var(--local-tab-width);
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color;
  }

  :host([data-type='flex']) > button {
    width: 34px;
    position: relative;
    display: flex;
    justify-content: flex-start;
  }

  button:hover:enabled,
  button:active:enabled {
    background-color: transparent !important;
  }

  button:hover:enabled > cross-wui-icon,
  button:active:enabled > cross-wui-icon {
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-lg);
    color: var(--wui-color-fg-125);
  }

  button:hover:enabled > cross-wui-text,
  button:active:enabled > cross-wui-text {
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-lg);
    color: var(--wui-color-fg-125);
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
  }
`;
var __decorate$2h = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiTabs = class WuiTabs2 extends i$1 {
  constructor() {
    super(...arguments);
    this.tabs = [];
    this.onTabChange = () => null;
    this.buttons = [];
    this.disabled = false;
    this.localTabWidth = "100px";
    this.activeTab = 0;
    this.isDense = false;
  }
  render() {
    this.isDense = this.tabs.length > 3;
    this.style.cssText = `
      --local-tab: ${this.activeTab};
      --local-tab-width: ${this.localTabWidth};
    `;
    this.dataset["type"] = this.isDense ? "flex" : "block";
    return this.tabs.map((tab, index2) => {
      var _a3;
      const isActive = index2 === this.activeTab;
      return x$3`
        <button
          ?disabled=${this.disabled}
          @click=${() => this.onTabClick(index2)}
          data-active=${isActive}
          data-testid="tab-${(_a3 = tab.label) == null ? void 0 : _a3.toLowerCase()}"
        >
          ${this.iconTemplate(tab)}
          <cross-wui-text variant="small-600" color="inherit"> ${tab.label} </cross-wui-text>
        </button>
      `;
    });
  }
  firstUpdated() {
    if (this.shadowRoot && this.isDense) {
      this.buttons = [...this.shadowRoot.querySelectorAll("button")];
      setTimeout(() => {
        this.animateTabs(0, true);
      }, 0);
    }
  }
  iconTemplate(tab) {
    if (tab.icon) {
      return x$3`<cross-wui-icon size="xs" color="inherit" name=${tab.icon}></cross-wui-icon>`;
    }
    return null;
  }
  onTabClick(index2) {
    if (this.buttons) {
      this.animateTabs(index2, false);
    }
    this.activeTab = index2;
    this.onTabChange(index2);
  }
  animateTabs(index2, initialAnimation) {
    const passiveBtn = this.buttons[this.activeTab];
    const activeBtn = this.buttons[index2];
    const passiveBtnText = passiveBtn == null ? void 0 : passiveBtn.querySelector("cross-wui-text");
    const activeBtnText = activeBtn == null ? void 0 : activeBtn.querySelector("cross-wui-text");
    const activeBtnBounds = activeBtn == null ? void 0 : activeBtn.getBoundingClientRect();
    const activeBtnTextBounds = activeBtnText == null ? void 0 : activeBtnText.getBoundingClientRect();
    if (passiveBtn && passiveBtnText && !initialAnimation && index2 !== this.activeTab) {
      passiveBtnText.animate([{ opacity: 0 }], {
        duration: 50,
        easing: "ease",
        fill: "forwards"
      });
      passiveBtn.animate([{ width: `34px` }], {
        duration: 500,
        easing: "ease",
        fill: "forwards"
      });
    }
    if (activeBtn && activeBtnBounds && activeBtnTextBounds && activeBtnText) {
      if (index2 !== this.activeTab || initialAnimation) {
        this.localTabWidth = `${Math.round(activeBtnBounds.width + activeBtnTextBounds.width) + 6}px`;
        activeBtn.animate([{ width: `${activeBtnBounds.width + activeBtnTextBounds.width}px` }], {
          duration: initialAnimation ? 0 : 500,
          fill: "forwards",
          easing: "ease"
        });
        activeBtnText.animate([{ opacity: 1 }], {
          duration: initialAnimation ? 0 : 125,
          delay: initialAnimation ? 0 : 200,
          fill: "forwards",
          easing: "ease"
        });
      }
    }
  }
};
WuiTabs.styles = [resetStyles, elementStyles, styles$1F];
__decorate$2h([
  n$3({ type: Array })
], WuiTabs.prototype, "tabs", void 0);
__decorate$2h([
  n$3()
], WuiTabs.prototype, "onTabChange", void 0);
__decorate$2h([
  n$3({ type: Array })
], WuiTabs.prototype, "buttons", void 0);
__decorate$2h([
  n$3({ type: Boolean })
], WuiTabs.prototype, "disabled", void 0);
__decorate$2h([
  n$3()
], WuiTabs.prototype, "localTabWidth", void 0);
__decorate$2h([
  r$1()
], WuiTabs.prototype, "activeTab", void 0);
__decorate$2h([
  r$1()
], WuiTabs.prototype, "isDense", void 0);
WuiTabs = __decorate$2h([
  customElement("cross-wui-tabs")
], WuiTabs);
const styles$1E = i$4`
  :host {
    display: block;
  }

  :host > button {
    gap: var(--wui-spacing-xxs);
    padding: var(--wui-spacing-xs);
    padding-right: var(--wui-spacing-1xs);
    height: 40px;
    border-radius: var(--wui-border-radius-l);
    background: var(--wui-color-gray-glass-002);
    border-width: 0px;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
  }

  :host > button cross-wui-image {
    width: 24px;
    height: 24px;
    border-radius: var(--wui-border-radius-s);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }
`;
var __decorate$2g = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiTokenButton = class WuiTokenButton2 extends i$1 {
  constructor() {
    super(...arguments);
    this.text = "";
  }
  render() {
    return x$3`
      <button>
        ${this.tokenTemplate()}
        <cross-wui-text variant="paragraph-600" color="fg-100">${this.text}</cross-wui-text>
      </button>
    `;
  }
  tokenTemplate() {
    if (this.imageSrc) {
      return x$3`<cross-wui-image src=${this.imageSrc}></cross-wui-image>`;
    }
    return x$3`
      <cross-wui-icon-box
        size="sm"
        iconColor="fg-200"
        backgroundColor="fg-300"
        icon="networkPlaceholder"
      ></cross-wui-icon-box>
    `;
  }
};
WuiTokenButton.styles = [resetStyles, elementStyles, styles$1E];
__decorate$2g([
  n$3()
], WuiTokenButton.prototype, "imageSrc", void 0);
__decorate$2g([
  n$3()
], WuiTokenButton.prototype, "text", void 0);
WuiTokenButton = __decorate$2g([
  customElement("cross-wui-token-button")
], WuiTokenButton);
const styles$1D = i$4`
  :host {
    display: block;
    padding: 9px var(--wui-spacing-s) 10px var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);

    color: var(--wui-color-bg-100);
    position: relative;
  }

  :host([data-variant='shade']) {
    background-color: var(--wui-color-bg-150);
    border: 1px solid var(--wui-color-gray-glass-005);
  }

  :host([data-variant='shade']) > cross-wui-text {
    color: var(--wui-color-fg-150);
  }

  :host([data-variant='fill']) {
    background-color: var(--wui-color-fg-100);
    border: none;
  }

  cross-wui-icon {
    position: absolute;
    width: 12px !important;
    height: 4px !important;
  }

  wui-icon[data-placement='top'] {
    bottom: 0px;
    left: 50%;
    transform: translate(-50%, 95%);
  }

  wui-icon[data-placement='bottom'] {
    top: 0;
    left: 50%;
    transform: translate(-50%, -95%) rotate(180deg);
  }

  wui-icon[data-placement='right'] {
    top: 50%;
    left: 0;
    transform: translate(-65%, -50%) rotate(90deg);
  }

  wui-icon[data-placement='left'] {
    top: 50%;
    right: 0%;
    transform: translate(65%, -50%) rotate(270deg);
  }
`;
var __decorate$2f = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiTooltip = class WuiTooltip2 extends i$1 {
  constructor() {
    super(...arguments);
    this.placement = "top";
    this.variant = "fill";
    this.message = "";
  }
  render() {
    this.dataset["variant"] = this.variant;
    return x$3`<cross-wui-icon
        data-placement=${this.placement}
        color="fg-100"
        size="inherit"
        name=${this.variant === "fill" ? "cursor" : "cursorTransparent"}
      ></cross-wui-icon>
      <cross-wui-text color="inherit" variant="small-500">${this.message}</cross-wui-text>`;
  }
};
WuiTooltip.styles = [resetStyles, elementStyles, styles$1D];
__decorate$2f([
  n$3()
], WuiTooltip.prototype, "placement", void 0);
__decorate$2f([
  n$3()
], WuiTooltip.prototype, "variant", void 0);
__decorate$2f([
  n$3()
], WuiTooltip.prototype, "message", void 0);
WuiTooltip = __decorate$2f([
  customElement("cross-wui-tooltip")
], WuiTooltip);
const styles$1C = i$4`
  :host {
    height: 60px;
    min-height: 60px;
  }

  :host > cross-wui-flex {
    cursor: pointer;
    height: 100%;
    display: flex;
    column-gap: var(--wui-spacing-s);
    padding: var(--wui-spacing-xs);
    padding-right: var(--wui-spacing-l);
    width: 100%;
    background-color: transparent;
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
    transition:
      background-color var(--wui-ease-out-power-1) var(--wui-duration-lg),
      opacity var(--wui-ease-out-power-1) var(--wui-duration-lg);
    will-change: background-color, opacity;
  }

  @media (hover: hover) and (pointer: fine) {
    :host > wui-flex:hover {
      background-color: var(--wui-color-gray-glass-002);
    }

    :host > wui-flex:active {
      background-color: var(--wui-color-gray-glass-005);
    }
  }

  :host([disabled]) > cross-wui-flex {
    opacity: 0.6;
  }

  :host([disabled]) > wui-flex:hover {
    background-color: transparent;
  }

  :host > wui-flex > cross-wui-flex {
    flex: 1;
  }

  :host > wui-flex > cross-wui-image,
  :host > wui-flex > .token-item-image-placeholder {
    width: 40px;
    max-width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-3xl);
    position: relative;
  }

  :host > wui-flex > .token-item-image-placeholder {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  :host > wui-flex > wui-image::after,
  :host > wui-flex > .token-item-image-placeholder::after {
    position: absolute;
    content: '';
    inset: 0;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
    border-radius: var(--wui-border-radius-l);
  }

  button > wui-icon-box[data-variant='square-blue'] {
    border-radius: var(--wui-border-radius-3xs);
    position: relative;
    border: none;
    width: 36px;
    height: 36px;
  }
`;
var __decorate$2e = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiTokenListItem = class WuiTokenListItem2 extends i$1 {
  constructor() {
    super();
    this.observer = new IntersectionObserver(() => void 0);
    this.imageSrc = void 0;
    this.name = void 0;
    this.symbol = void 0;
    this.price = void 0;
    this.amount = void 0;
    this.visible = false;
    this.imageError = false;
    this.observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          this.visible = true;
        } else {
          this.visible = false;
        }
      });
    }, { threshold: 0.1 });
  }
  firstUpdated() {
    this.observer.observe(this);
  }
  disconnectedCallback() {
    this.observer.disconnect();
  }
  render() {
    var _a3;
    if (!this.visible) {
      return null;
    }
    const value = this.amount && this.price ? (_a3 = NumberUtil.multiply(this.price, this.amount)) == null ? void 0 : _a3.toFixed(3) : null;
    return x$3`
      <cross-wui-flex alignItems="center">
        ${this.visualTemplate()}
        <cross-wui-flex flexDirection="column" gap="3xs">
          <cross-wui-flex justifyContent="space-between">
            <cross-wui-text variant="paragraph-500" color="fg-100" lineClamp="1">${this.name}</cross-wui-text>
            ${value ? x$3`
                  <cross-wui-text variant="paragraph-500" color="fg-100">
                    $${UiHelperUtil.formatNumberToLocalString(value, 3)}
                  </cross-wui-text>
                ` : null}
          </cross-wui-flex>
          <cross-wui-flex justifyContent="space-between">
            <cross-wui-text variant="small-400" color="fg-200" lineClamp="1">${this.symbol}</cross-wui-text>
            ${this.amount ? x$3`<cross-wui-text variant="small-400" color="fg-200">
                  ${UiHelperUtil.formatNumberToLocalString(this.amount, 4)}
                </cross-wui-text>` : null}
          </cross-wui-flex>
        </cross-wui-flex>
      </cross-wui-flex>
    `;
  }
  visualTemplate() {
    if (this.imageError) {
      return x$3`<cross-wui-flex class="token-item-image-placeholder">
        <cross-wui-icon name="image" color="inherit"></cross-wui-icon>
      </cross-wui-flex>`;
    }
    if (this.imageSrc) {
      return x$3`<cross-wui-image
        width="40"
        height="40"
        src=${this.imageSrc}
        @onLoadError=${this.imageLoadError}
      ></cross-wui-image>`;
    }
    return null;
  }
  imageLoadError() {
    this.imageError = true;
  }
};
WuiTokenListItem.styles = [resetStyles, elementStyles, styles$1C];
__decorate$2e([
  n$3()
], WuiTokenListItem.prototype, "imageSrc", void 0);
__decorate$2e([
  n$3()
], WuiTokenListItem.prototype, "name", void 0);
__decorate$2e([
  n$3()
], WuiTokenListItem.prototype, "symbol", void 0);
__decorate$2e([
  n$3()
], WuiTokenListItem.prototype, "price", void 0);
__decorate$2e([
  n$3()
], WuiTokenListItem.prototype, "amount", void 0);
__decorate$2e([
  r$1()
], WuiTokenListItem.prototype, "visible", void 0);
__decorate$2e([
  r$1()
], WuiTokenListItem.prototype, "imageError", void 0);
WuiTokenListItem = __decorate$2e([
  customElement("cross-wui-token-list-item")
], WuiTokenListItem);
const styles$1B = i$4`
  :host {
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--wui-icon-box-size-xl);
    height: var(--wui-icon-box-size-xl);
    box-shadow: 0 0 0 8px var(--wui-thumbnail-border);
    border-radius: var(--local-border-radius);
    overflow: hidden;
  }

  cross-wui-icon {
    width: 32px;
    height: 32px;
  }
`;
var __decorate$2d = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiVisualThumbnail = class WuiVisualThumbnail2 extends i$1 {
  render() {
    this.style.cssText = `--local-border-radius: ${this.borderRadiusFull ? "1000px" : "20px"}; background-color: var(--wui-color-modal-bg);`;
    return x$3`${this.templateVisual()}`;
  }
  templateVisual() {
    if (this.imageSrc) {
      return x$3`<cross-wui-image src=${this.imageSrc} alt=${this.alt ?? ""}></cross-wui-image>`;
    }
    return x$3`<cross-wui-icon
      data-parent-size="md"
      size="inherit"
      color="inherit"
      name="walletPlaceholder"
    ></cross-wui-icon>`;
  }
};
WuiVisualThumbnail.styles = [resetStyles, styles$1B];
__decorate$2d([
  n$3()
], WuiVisualThumbnail.prototype, "imageSrc", void 0);
__decorate$2d([
  n$3()
], WuiVisualThumbnail.prototype, "alt", void 0);
__decorate$2d([
  n$3({ type: Boolean })
], WuiVisualThumbnail.prototype, "borderRadiusFull", void 0);
WuiVisualThumbnail = __decorate$2d([
  customElement("cross-wui-visual-thumbnail")
], WuiVisualThumbnail);
const styles$1A = i$4`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  :host > button {
    min-width: 40px;
    display: inline-flex;
    justify-content: center;
    align-items: center;
    background-color: var(--wui-wallet-button-bg);
    column-gap: var(--wui-spacing-2xs);
    border-radius: var(--wui-border-radius-s);
    border: 1px solid var(--wui-color-gray-glass-002);
    height: var(--wui-spacing-3xl);
    padding: var(--wui-spacing-xs) var(--wui-spacing-m) var(--wui-spacing-xs) var(--wui-spacing-xs);
    box-shadow:
      0px 8px 22px -6px var(--wui-color-gray-glass-010),
      0px 14px 64px -4px var(--wui-color-gray-glass-010);
  }

  :host > button > cross-wui-text {
    text-transform: capitalize;
  }

  :host > button > cross-wui-image {
    height: 24px;
    width: 24px;
    border-radius: var(--wui-border-radius-s);
  }

  :host([data-error='true']) > button {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  /* -- Disabled state --------------------------------------------------- */
  :host > button:disabled {
    cursor: default;
  }

  :host > button:disabled > cross-wui-icon {
    filter: grayscale(1);
  }
`;
var __decorate$2c = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiWalletButton = class WuiWalletButton2 extends i$1 {
  constructor() {
    super(...arguments);
    this.imageSrc = "";
    this.name = "";
    this.walletConnect = false;
    this.loading = false;
    this.error = false;
    this.disabled = false;
    this.shake = false;
  }
  render() {
    this.dataset["error"] = `${this.error}`;
    return x$3`
      <button ?disabled=${this.disabled}>
        ${this.leftViewTemplate()} ${this.rightViewTemplate()}
      </button>
    `;
  }
  leftViewTemplate() {
    if (this.error) {
      return x$3`<cross-wui-icon-box
        icon="warningCircle"
        iconColor="error-100"
        backgroundColor="error-100"
        size="sm"
        iconSize="xs"
      ></cross-wui-icon-box>`;
    }
    if (this.loading) {
      return x$3`<cross-wui-loading-spinner size="md" color="fg-100"></cross-wui-loading-spinner>`;
    }
    if (this.icon) {
      return x$3`<cross-wui-icon size="xl" color="inherit" name=${this.icon}></cross-wui-icon>`;
    }
    if (this.imageSrc) {
      return x$3`<cross-wui-image src=${this.imageSrc} alt=${this.name}></cross-wui-image>`;
    }
    return x$3`<cross-wui-icon size="xl" color="fg-100" name="walletPlaceholder"></cross-wui-icon>`;
  }
  rightViewTemplate() {
    return x$3`
      <cross-wui-text variant="paragraph-500" color="fg-100">${this.name || "Unknown"} </cross-wui-text>
    `;
  }
};
WuiWalletButton.styles = [resetStyles, elementStyles, styles$1A];
__decorate$2c([
  n$3()
], WuiWalletButton.prototype, "imageSrc", void 0);
__decorate$2c([
  n$3()
], WuiWalletButton.prototype, "name", void 0);
__decorate$2c([
  n$3({ type: Boolean })
], WuiWalletButton.prototype, "walletConnect", void 0);
__decorate$2c([
  n$3({ type: Boolean })
], WuiWalletButton.prototype, "icon", void 0);
__decorate$2c([
  n$3({ type: Boolean })
], WuiWalletButton.prototype, "loading", void 0);
__decorate$2c([
  n$3({ type: Boolean })
], WuiWalletButton.prototype, "error", void 0);
__decorate$2c([
  n$3({ type: Boolean })
], WuiWalletButton.prototype, "disabled", void 0);
__decorate$2c([
  n$3({ type: Boolean })
], WuiWalletButton.prototype, "shake", void 0);
WuiWalletButton = __decorate$2c([
  customElement("cross-wui-wallet-button")
], WuiWalletButton);
const styles$1z = i$4`
  :host {
    display: block;
  }

  button {
    width: 100%;
    display: block;
    padding-top: var(--wui-spacing-l);
    padding-bottom: var(--wui-spacing-l);
    padding-left: var(--wui-spacing-s);
    padding-right: var(--wui-spacing-2l);
    border-radius: var(--wui-border-radius-s);
    background-color: var(--wui-color-accent-glass-010);
  }

  button:hover {
    background-color: var(--wui-color-accent-glass-015) !important;
  }

  button:active {
    background-color: var(--wui-color-accent-glass-020) !important;
  }
`;
var __decorate$2b = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiNoticeCard = class WuiNoticeCard2 extends i$1 {
  constructor() {
    super(...arguments);
    this.label = "";
    this.description = "";
    this.icon = "wallet";
  }
  render() {
    return x$3`
      <button>
        <cross-wui-flex gap="m" alignItems="center" justifyContent="space-between">
          <cross-wui-icon-box
            size="lg"
            iconcolor="accent-100"
            backgroundcolor="accent-100"
            icon=${this.icon}
            background="transparent"
          ></cross-wui-icon-box>

          <cross-wui-flex flexDirection="column" gap="3xs">
            <cross-wui-text variant="paragraph-500" color="fg-100">${this.label}</cross-wui-text>
            <cross-wui-text variant="small-400" color="fg-200">${this.description}</cross-wui-text>
          </cross-wui-flex>

          <cross-wui-icon size="md" color="fg-200" name="chevronRight"></cross-wui-icon>
        </cross-wui-flex>
      </button>
    `;
  }
};
WuiNoticeCard.styles = [resetStyles, elementStyles, styles$1z];
__decorate$2b([
  n$3()
], WuiNoticeCard.prototype, "label", void 0);
__decorate$2b([
  n$3()
], WuiNoticeCard.prototype, "description", void 0);
__decorate$2b([
  n$3()
], WuiNoticeCard.prototype, "icon", void 0);
WuiNoticeCard = __decorate$2b([
  customElement("cross-wui-notice-card")
], WuiNoticeCard);
const styles$1y = i$4`
  button {
    height: auto;
    position: relative;
    flex-direction: column;
    gap: var(--wui-spacing-s);
    padding: 17px 18px 17px var(--wui-spacing-m);
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  .overflowedContent {
    width: 100%;
    overflow: hidden;
  }

  .overflowedContent[data-active='false']:after {
    content: '';
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(to top, var(--wui-color-bg-150), transparent);
    border-bottom-left-radius: var(--wui-border-radius-xs);
    border-bottom-right-radius: var(--wui-border-radius-xs);
  }

  .heightContent {
    max-height: 100px;
  }

  pre {
    text-align: left;
    white-space: pre-wrap;
    height: auto;
    overflow-x: auto;
    overflow-wrap: anywhere;
  }
`;
var __decorate$2a = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
const MAX_HEIGHT = 100;
let WuiListAccordion = class WuiListAccordion2 extends i$1 {
  constructor() {
    super(...arguments);
    this.textTitle = "";
    this.overflowedContent = "";
    this.toggled = false;
    this.enableAccordion = false;
    this.scrollElement = void 0;
    this.scrollHeightElement = 0;
  }
  updated(changedProperties) {
    super.updated(changedProperties);
    if (changedProperties.has("textTitle") || changedProperties.has("overflowedContent")) {
      setTimeout(() => {
        this.checkHeight();
      }, 1);
    }
  }
  checkHeight() {
    this.updateComplete.then(() => {
      var _a3, _b2;
      const heightElement = (_a3 = this.shadowRoot) == null ? void 0 : _a3.querySelector(".heightContent");
      const textElement = (_b2 = this.shadowRoot) == null ? void 0 : _b2.querySelector(".textContent");
      if (heightElement && textElement) {
        this.scrollElement = heightElement;
        const scrollHeight = textElement == null ? void 0 : textElement.scrollHeight;
        if (scrollHeight && scrollHeight > MAX_HEIGHT) {
          this.enableAccordion = true;
          this.scrollHeightElement = scrollHeight;
          this.requestUpdate();
        }
      }
    });
  }
  render() {
    return x$3`
      <button @click=${() => this.onClick()}>
        <cross-wui-flex justifyContent="space-between" alignItems="center">
          <cross-wui-text variant="paragraph-500" color="fg-100">${this.textTitle}</cross-wui-text>
          ${this.chevronTemplate()}
        </cross-wui-flex>
        <div
          data-active=${this.enableAccordion ? Boolean(this.toggled) : true}
          class="overflowedContent"
        >
          <div class="heightContent">
            <cross-wui-text class="textContent" variant="paragraph-400" color="fg-200">
              <pre>${this.overflowedContent}</pre>
            </cross-wui-text>
          </div>
        </div>
      </button>
    `;
  }
  onClick() {
    var _a3;
    const icon = (_a3 = this.shadowRoot) == null ? void 0 : _a3.querySelector("cross-wui-icon");
    if (this.enableAccordion) {
      this.toggled = !this.toggled;
      this.requestUpdate();
      if (this.scrollElement) {
        this.scrollElement.animate([
          { maxHeight: this.toggled ? `${MAX_HEIGHT}px` : `${this.scrollHeightElement}px` },
          { maxHeight: this.toggled ? `${this.scrollHeightElement}px` : `${MAX_HEIGHT}px` }
        ], {
          duration: 300,
          fill: "forwards",
          easing: "ease"
        });
      }
      if (icon) {
        icon.animate([
          { transform: this.toggled ? `rotate(0deg)` : `rotate(180deg)` },
          { transform: this.toggled ? `rotate(180deg)` : `rotate(0deg)` }
        ], {
          duration: 300,
          fill: "forwards",
          easing: "ease"
        });
      }
    }
  }
  chevronTemplate() {
    if (this.enableAccordion) {
      return x$3` <cross-wui-icon color="fg-100" size="sm" name="chevronBottom"></cross-wui-icon>`;
    }
    return null;
  }
};
WuiListAccordion.styles = [resetStyles, elementStyles, styles$1y];
__decorate$2a([
  n$3()
], WuiListAccordion.prototype, "textTitle", void 0);
__decorate$2a([
  n$3()
], WuiListAccordion.prototype, "overflowedContent", void 0);
WuiListAccordion = __decorate$2a([
  customElement("cross-wui-list-accordion")
], WuiListAccordion);
const styles$1x = i$4`
  :host {
    display: flex;
    column-gap: var(--wui-spacing-s);
    padding: 17px 18px 17px var(--wui-spacing-m);
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  cross-wui-image {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
    border-radius: var(--wui-border-radius-3xl);
  }

  cross-wui-icon {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
  }
`;
var __decorate$29 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiListContent = class WuiListContent2 extends i$1 {
  constructor() {
    super(...arguments);
    this.imageSrc = void 0;
    this.textTitle = "";
    this.textValue = void 0;
  }
  render() {
    return x$3`
      <cross-wui-flex justifyContent="space-between" alignItems="center">
        <cross-wui-text variant="paragraph-500" color=${this.textValue ? "fg-200" : "fg-100"}>
          ${this.textTitle}
        </cross-wui-text>
        ${this.templateContent()}
      </cross-wui-flex>
    `;
  }
  templateContent() {
    if (this.imageSrc) {
      return x$3`<cross-wui-image src=${this.imageSrc} alt=${this.textTitle}></cross-wui-image>`;
    } else if (this.textValue) {
      return x$3` <cross-wui-text variant="paragraph-400" color="fg-100"> ${this.textValue} </cross-wui-text>`;
    }
    return x$3`<cross-wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></cross-wui-icon>`;
  }
};
WuiListContent.styles = [resetStyles, elementStyles, styles$1x];
__decorate$29([
  n$3()
], WuiListContent.prototype, "imageSrc", void 0);
__decorate$29([
  n$3()
], WuiListContent.prototype, "textTitle", void 0);
__decorate$29([
  n$3()
], WuiListContent.prototype, "textValue", void 0);
WuiListContent = __decorate$29([
  customElement("cross-wui-list-content")
], WuiListContent);
const styles$1w = i$4`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-md);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-100);
  }

  button > wui-text:nth-child(2) {
    display: flex;
    flex: 1;
  }

  button[data-transparent='true'] {
    pointer-events: none;
    background-color: transparent;
  }

  button:hover {
    background-color: var(--wui-color-gray-glass-002);
  }

  button:active {
    background-color: var(--wui-color-gray-glass-005);
  }

  cross-wui-image {
    width: var(--wui-spacing-3xl);
    height: var(--wui-spacing-3xl);
    border-radius: 100%;
  }

  button:disabled {
    background-color: var(--wui-color-gray-glass-002);
    opacity: 0.5;
    cursor: not-allowed;
  }

  button:disabled > cross-wui-tag {
    background-color: var(--wui-color-gray-glass-010);
    color: var(--wui-color-fg-300);
  }
`;
var __decorate$28 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiListNetwork = class WuiListNetwork2 extends i$1 {
  constructor() {
    super(...arguments);
    this.imageSrc = "";
    this.name = "";
    this.disabled = false;
    this.selected = false;
    this.transparent = false;
  }
  render() {
    return x$3`
      <button data-transparent=${this.transparent} ?disabled=${this.disabled}>
        <cross-wui-flex gap="s" alignItems="center">
          ${this.templateNetworkImage()}
          <cross-wui-text variant="paragraph-500" color="inherit">${this.name}</cross-wui-text></wui-flex
        >
        ${this.checkmarkTemplate()}
      </button>
    `;
  }
  checkmarkTemplate() {
    if (this.selected) {
      return x$3`<cross-wui-icon size="sm" color="accent-100" name="checkmarkBold"></cross-wui-icon>`;
    }
    return null;
  }
  templateNetworkImage() {
    if (this.imageSrc) {
      return x$3`<cross-wui-image size="sm" src=${this.imageSrc} name=${this.name}></cross-wui-image>`;
    }
    if (!this.imageSrc) {
      return x$3`<cross-wui-network-image
        ?round=${true}
        size="md"
        name=${this.name}
      ></cross-wui-network-image>`;
    }
    return null;
  }
};
WuiListNetwork.styles = [resetStyles, elementStyles, styles$1w];
__decorate$28([
  n$3()
], WuiListNetwork.prototype, "imageSrc", void 0);
__decorate$28([
  n$3()
], WuiListNetwork.prototype, "name", void 0);
__decorate$28([
  n$3({ type: Boolean })
], WuiListNetwork.prototype, "disabled", void 0);
__decorate$28([
  n$3({ type: Boolean })
], WuiListNetwork.prototype, "selected", void 0);
__decorate$28([
  n$3({ type: Boolean })
], WuiListNetwork.prototype, "transparent", void 0);
WuiListNetwork = __decorate$28([
  customElement("cross-wui-list-network")
], WuiListNetwork);
const styles$1v = i$4`
  :host {
    display: flex;
    flex-direction: column;
    gap: var(--wui-spacing-l);
    padding: 17px 18px 17px var(--wui-spacing-m);
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  cross-wui-image {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
    border-radius: var(--wui-border-radius-3xl);
  }

  cross-wui-icon {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
  }
`;
var __decorate$27 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiListWalletTransaction = class WuiListWalletTransaction2 extends i$1 {
  constructor() {
    super(...arguments);
    this.amount = "";
    this.networkCurreny = "";
    this.networkImageUrl = "";
    this.receiverAddress = "";
    this.addressExplorerUrl = "";
  }
  render() {
    return x$3`
      <cross-wui-flex justifyContent="space-between" alignItems="center">
        <cross-wui-text variant="paragraph-500" color="fg-200">Sending</cross-wui-text>
        <cross-wui-flex gap="xs" alignItems="center">
          <cross-wui-text variant="paragraph-400" color="fg-100">
            ${this.amount} ${this.networkCurreny}
          </cross-wui-text>
          ${this.templateNetworkVisual()}
        </cross-wui-flex>
      </cross-wui-flex>
      <cross-wui-flex justifyContent="space-between" alignItems="center">
        <cross-wui-text variant="paragraph-500" color="fg-200">To</cross-wui-text>
        <cross-wui-chip
          icon="externalLink"
          variant="shadeSmall"
          href=${this.addressExplorerUrl}
          title=${this.receiverAddress}
        ></cross-wui-chip>
      </cross-wui-flex>
    `;
  }
  templateNetworkVisual() {
    if (this.networkImageUrl) {
      return x$3`<cross-wui-image src=${this.networkImageUrl} alt="Network Image"></cross-wui-image>`;
    }
    return x$3`<cross-wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></cross-wui-icon>`;
  }
};
WuiListWalletTransaction.styles = [resetStyles, elementStyles, styles$1v];
__decorate$27([
  n$3()
], WuiListWalletTransaction.prototype, "amount", void 0);
__decorate$27([
  n$3()
], WuiListWalletTransaction.prototype, "networkCurreny", void 0);
__decorate$27([
  n$3()
], WuiListWalletTransaction.prototype, "networkImageUrl", void 0);
__decorate$27([
  n$3()
], WuiListWalletTransaction.prototype, "receiverAddress", void 0);
__decorate$27([
  n$3()
], WuiListWalletTransaction.prototype, "addressExplorerUrl", void 0);
WuiListWalletTransaction = __decorate$27([
  customElement("cross-wui-list-wallet-transaction")
], WuiListWalletTransaction);
const styles$1u = i$4`
  button {
    display: flex;
    gap: var(--wui-spacing-3xs);
    align-items: center;
    padding: 6.25px var(--wui-spacing-xs) 7.25px var(--wui-spacing-s);
    background-color: var(--wui-color-gray-glass-090);
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-color-gray-glass-060);
    transition: background-color var(--wui-duration-md) var(--wui-ease-inout-power-1);
    will-change: background-color;
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-gray-glass-080);
    }

    button:active:enabled {
      background-color: var(--wui-color-gray-glass-060);
    }
  }
`;
var __decorate$26 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiPromo = class WuiPromo2 extends i$1 {
  constructor() {
    super(...arguments);
    this.text = "";
  }
  render() {
    return x$3`<button>
      <cross-wui-text variant="small-600" color="bg-100">${this.text}</cross-wui-text>
      <cross-wui-icon color="bg-100" size="xs" name="arrowRight"></cross-wui-icon>
    </button>`;
  }
};
WuiPromo.styles = [resetStyles, elementStyles, styles$1u];
__decorate$26([
  n$3()
], WuiPromo.prototype, "text", void 0);
WuiPromo = __decorate$26([
  customElement("cross-wui-promo")
], WuiPromo);
const styles$1t = i$4`
  span {
    font-weight: 500;
    font-size: 40px;
    color: var(--wui-color-fg-100);
    line-height: 130%; /* 52px */
    letter-spacing: -1.6px;
    text-align: center;
  }

  .pennies {
    color: var(--wui-color-fg-200);
  }
`;
var __decorate$25 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiBalance = class WuiBalance2 extends i$1 {
  constructor() {
    super(...arguments);
    this.dollars = "0";
    this.pennies = "00";
  }
  render() {
    return x$3`<span>$${this.dollars}<span class="pennies">.${this.pennies}</span></span>`;
  }
};
WuiBalance.styles = [resetStyles, styles$1t];
__decorate$25([
  n$3()
], WuiBalance.prototype, "dollars", void 0);
__decorate$25([
  n$3()
], WuiBalance.prototype, "pennies", void 0);
WuiBalance = __decorate$25([
  customElement("cross-wui-balance")
], WuiBalance);
const styles$1s = i$4`
  button {
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-color-gray-glass-002);
    padding: var(--wui-spacing-xs) var(--wui-spacing-s) var(--wui-spacing-xs) var(--wui-spacing-xs);
    position: relative;
  }

  cross-wui-avatar {
    width: 32px;
    height: 32px;
    box-shadow: 0 0 0 0;
    outline: 3px solid var(--wui-color-gray-glass-005);
  }

  cross-wui-icon-box,
  cross-wui-image {
    width: 16px;
    height: 16px;
    border-radius: var(--wui-border-radius-3xl);
    position: absolute;
    left: 26px;
    top: 24px;
  }

  cross-wui-image {
    outline: 2px solid var(--wui-color-bg-125);
  }

  cross-wui-icon-box {
    outline: 2px solid var(--wui-color-bg-200);
    background-color: var(--wui-color-bg-250);
  }
`;
var __decorate$24 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiProfileButton = class WuiProfileButton2 extends i$1 {
  constructor() {
    super(...arguments);
    this.networkSrc = void 0;
    this.avatarSrc = void 0;
    this.profileName = "";
    this.address = "";
    this.icon = "chevronBottom";
  }
  render() {
    return x$3`<button data-testid="wui-profile-button">
      <cross-wui-flex gap="xs" alignItems="center">
        <cross-wui-avatar
          .imageSrc=${this.avatarSrc}
          alt=${this.address}
          address=${this.address}
        ></cross-wui-avatar>
        ${this.networkImageTemplate()}
        <cross-wui-flex gap="xs" alignItems="center">
          <cross-wui-text variant="large-600" color="fg-100">
            ${UiHelperUtil.getTruncateString({
      string: this.profileName || this.address,
      charsStart: this.profileName ? 18 : 4,
      charsEnd: this.profileName ? 0 : 4,
      truncate: this.profileName ? "end" : "middle"
    })}
          </cross-wui-text>
          <cross-wui-icon size="sm" color="fg-200" name=${this.icon}></cross-wui-icon>
        </cross-wui-flex>
      </cross-wui-flex>
    </button>`;
  }
  networkImageTemplate() {
    if (this.networkSrc) {
      return x$3`<cross-wui-image src=${this.networkSrc}></cross-wui-image>`;
    }
    return x$3`
      <cross-wui-icon-box
        size="xxs"
        iconColor="fg-200"
        backgroundColor="bg-100"
        icon="networkPlaceholder"
      ></cross-wui-icon-box>
    `;
  }
};
WuiProfileButton.styles = [resetStyles, elementStyles, styles$1s];
__decorate$24([
  n$3()
], WuiProfileButton.prototype, "networkSrc", void 0);
__decorate$24([
  n$3()
], WuiProfileButton.prototype, "avatarSrc", void 0);
__decorate$24([
  n$3()
], WuiProfileButton.prototype, "profileName", void 0);
__decorate$24([
  n$3()
], WuiProfileButton.prototype, "address", void 0);
__decorate$24([
  n$3()
], WuiProfileButton.prototype, "icon", void 0);
WuiProfileButton = __decorate$24([
  customElement("cross-wui-profile-button")
], WuiProfileButton);
const styles$1r = i$4`
  button {
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-color-gray-glass-002);
    padding: var(--wui-spacing-xs) var(--wui-spacing-s) var(--wui-spacing-xs) var(--wui-spacing-xs);
    position: relative;
  }

  cross-wui-avatar {
    width: 32px;
    height: 32px;
    box-shadow: 0 0 0 0;
    outline: 3px solid var(--wui-color-gray-glass-005);
  }

  cross-wui-icon-box,
  cross-wui-image {
    width: 16px;
    height: 16px;
    border-radius: var(--wui-border-radius-3xl);
    position: absolute;
    left: 26px;
    top: 24px;
  }

  cross-wui-image {
    outline: 2px solid var(--wui-color-bg-125);
  }

  cross-wui-icon-box {
    outline: 2px solid var(--wui-color-bg-200);
    background-color: var(--wui-color-bg-250);
  }
`;
var __decorate$23 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiProfileButtonV2 = class WuiProfileButtonV22 extends i$1 {
  constructor() {
    super(...arguments);
    this.avatarSrc = void 0;
    this.profileName = "";
    this.address = "";
    this.icon = "mail";
  }
  render() {
    const namespace = ChainController.state.activeChain;
    const connectorId = StorageUtil.getConnectedConnectorId(namespace);
    const shouldShowIcon = connectorId === ConstantsUtil$4.CONNECTOR_ID.AUTH;
    return x$3`<button data-testid="wui-profile-button" @click=${this.handleClick}>
      <cross-wui-flex gap="xs" alignItems="center">
        <cross-wui-avatar
          .imageSrc=${this.avatarSrc}
          alt=${this.address}
          address=${this.address}
        ></cross-wui-avatar>
        ${shouldShowIcon ? this.getIconTemplate(this.icon) : ""}
        <cross-wui-flex gap="xs" alignItems="center">
          <cross-wui-text variant="large-600" color="fg-100">
            ${UiHelperUtil.getTruncateString({
      string: this.profileName || this.address,
      charsStart: this.profileName ? 18 : 4,
      charsEnd: this.profileName ? 0 : 4,
      truncate: this.profileName ? "end" : "middle"
    })}
          </cross-wui-text>
          <cross-wui-icon size="sm" color="fg-200" name="copy" id="copy-address"></cross-wui-icon>
        </cross-wui-flex>
      </cross-wui-flex>
    </button>`;
  }
  handleClick(event) {
    var _a3, _b2;
    if (event.target instanceof HTMLElement && event.target.id === "copy-address") {
      (_a3 = this.onCopyClick) == null ? void 0 : _a3.call(this, event);
      return;
    }
    (_b2 = this.onProfileClick) == null ? void 0 : _b2.call(this, event);
  }
  getIconTemplate(icon) {
    return x$3`
      <cross-wui-icon-box
        size="xxs"
        iconColor="fg-200"
        backgroundColor="bg-100"
        icon="${icon || "networkPlaceholder"}"
      ></cross-wui-icon-box>
    `;
  }
};
WuiProfileButtonV2.styles = [resetStyles, elementStyles, styles$1r];
__decorate$23([
  n$3()
], WuiProfileButtonV2.prototype, "avatarSrc", void 0);
__decorate$23([
  n$3()
], WuiProfileButtonV2.prototype, "profileName", void 0);
__decorate$23([
  n$3()
], WuiProfileButtonV2.prototype, "address", void 0);
__decorate$23([
  n$3()
], WuiProfileButtonV2.prototype, "icon", void 0);
__decorate$23([
  n$3()
], WuiProfileButtonV2.prototype, "onProfileClick", void 0);
__decorate$23([
  n$3()
], WuiProfileButtonV2.prototype, "onCopyClick", void 0);
WuiProfileButtonV2 = __decorate$23([
  customElement("cross-wui-profile-button-v2")
], WuiProfileButtonV2);
const styles$1q = i$4`
  button {
    border: none;
    border-radius: var(--wui-border-radius-3xl);
  }

  button[data-variant='main'] {
    background-color: var(--wui-color-accent-100);
    color: var(--wui-color-inverse-100);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  button[data-variant='accent'] {
    background-color: var(--wui-color-accent-glass-010);
    color: var(--wui-color-accent-100);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  button[data-variant='gray'] {
    background-color: transparent;
    color: var(--wui-color-fg-200);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  button[data-variant='shade'] {
    background-color: transparent;
    color: var(--wui-color-accent-100);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  button[data-size='sm'] {
    height: 32px;
    padding: 0 var(--wui-spacing-s);
  }

  button[data-size='md'] {
    height: 40px;
    padding: 0 var(--wui-spacing-l);
  }

  button[data-size='sm'] > cross-wui-image {
    width: 16px;
    height: 16px;
  }

  button[data-size='md'] > cross-wui-image {
    width: 24px;
    height: 24px;
  }

  button[data-size='sm'] > cross-wui-icon {
    width: 12px;
    height: 12px;
  }

  button[data-size='md'] > cross-wui-icon {
    width: 14px;
    height: 14px;
  }

  cross-wui-image {
    border-radius: var(--wui-border-radius-3xl);
    overflow: hidden;
  }

  button.disabled > cross-wui-icon,
  button.disabled > cross-wui-image {
    filter: grayscale(1);
  }

  button[data-variant='main'] > cross-wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-color-accent-090);
  }

  button[data-variant='shade'] > cross-wui-image,
  button[data-variant='gray'] > cross-wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  @media (hover: hover) and (pointer: fine) {
    button[data-variant='main']:focus-visible {
      background-color: var(--wui-color-accent-090);
    }

    button[data-variant='main']:hover:enabled {
      background-color: var(--wui-color-accent-090);
    }

    button[data-variant='main']:active:enabled {
      background-color: var(--wui-color-accent-080);
    }

    button[data-variant='accent']:hover:enabled {
      background-color: var(--wui-color-accent-glass-015);
    }

    button[data-variant='accent']:active:enabled {
      background-color: var(--wui-color-accent-glass-020);
    }

    button[data-variant='shade']:focus-visible,
    button[data-variant='gray']:focus-visible,
    button[data-variant='shade']:hover,
    button[data-variant='gray']:hover {
      background-color: var(--wui-color-gray-glass-002);
    }

    button[data-variant='gray']:active,
    button[data-variant='shade']:active {
      background-color: var(--wui-color-gray-glass-005);
    }
  }

  button.disabled {
    color: var(--wui-color-gray-glass-020);
    background-color: var(--wui-color-gray-glass-002);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    pointer-events: none;
  }
`;
var __decorate$22 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiChipButton = class WuiChipButton2 extends i$1 {
  constructor() {
    super(...arguments);
    this.variant = "accent";
    this.imageSrc = "";
    this.disabled = false;
    this.icon = "externalLink";
    this.size = "md";
    this.text = "";
  }
  render() {
    const textVariant = this.size === "sm" ? "small-600" : "paragraph-600";
    return x$3`
      <button
        class=${this.disabled ? "disabled" : ""}
        data-variant=${this.variant}
        data-size=${this.size}
      >
        ${this.imageSrc ? x$3`<cross-wui-image src=${this.imageSrc}></cross-wui-image>` : null}
        <cross-wui-text variant=${textVariant} color="inherit"> ${this.text} </cross-wui-text>
        <cross-wui-icon name=${this.icon} color="inherit" size="inherit"></cross-wui-icon>
      </button>
    `;
  }
};
WuiChipButton.styles = [resetStyles, elementStyles, styles$1q];
__decorate$22([
  n$3()
], WuiChipButton.prototype, "variant", void 0);
__decorate$22([
  n$3()
], WuiChipButton.prototype, "imageSrc", void 0);
__decorate$22([
  n$3({ type: Boolean })
], WuiChipButton.prototype, "disabled", void 0);
__decorate$22([
  n$3()
], WuiChipButton.prototype, "icon", void 0);
__decorate$22([
  n$3()
], WuiChipButton.prototype, "size", void 0);
__decorate$22([
  n$3()
], WuiChipButton.prototype, "text", void 0);
WuiChipButton = __decorate$22([
  customElement("cross-wui-chip-button")
], WuiChipButton);
const styles$1p = i$4`
  button {
    display: flex;
    gap: var(--wui-spacing-xl);
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xxs);
    padding: var(--wui-spacing-m) var(--wui-spacing-s);
  }

  cross-wui-text {
    width: 100%;
  }

  cross-wui-flex {
    width: auto;
  }

  .network-icon {
    width: var(--wui-spacing-2l);
    height: var(--wui-spacing-2l);
    border-radius: calc(var(--wui-spacing-2l) / 2);
    overflow: hidden;
    box-shadow:
      0 0 0 3px var(--wui-color-gray-glass-002),
      0 0 0 3px var(--wui-color-modal-bg);
  }
`;
var __decorate$21 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiCompatibleNetwork = class WuiCompatibleNetwork2 extends i$1 {
  constructor() {
    super(...arguments);
    this.networkImages = [""];
    this.text = "";
  }
  render() {
    return x$3`
      <button>
        <cross-wui-text variant="small-400" color="fg-200">${this.text}</cross-wui-text>
        <cross-wui-flex gap="3xs" alignItems="center">
          ${this.networksTemplate()}
          <cross-wui-icon name="chevronRight" size="sm" color="fg-200"></cross-wui-icon>
        </cross-wui-flex>
      </button>
    `;
  }
  networksTemplate() {
    const slicedNetworks = this.networkImages.slice(0, 5);
    return x$3` <cross-wui-flex class="networks">
      ${slicedNetworks == null ? void 0 : slicedNetworks.map((network) => x$3` <cross-wui-flex class="network-icon"> <cross-wui-image src=${network}></cross-wui-image> </cross-wui-flex>`)}
    </cross-wui-flex>`;
  }
};
WuiCompatibleNetwork.styles = [resetStyles, elementStyles, styles$1p];
__decorate$21([
  n$3({ type: Array })
], WuiCompatibleNetwork.prototype, "networkImages", void 0);
__decorate$21([
  n$3()
], WuiCompatibleNetwork.prototype, "text", void 0);
WuiCompatibleNetwork = __decorate$21([
  customElement("cross-wui-compatible-network")
], WuiCompatibleNetwork);
const styles$1o = i$4`
  cross-wui-flex {
    width: 100%;
    background-color: var(--wui-color-gray-glass-005);
    border-radius: var(--wui-border-radius-s);
    padding: var(--wui-spacing-1xs) var(--wui-spacing-s) var(--wui-spacing-1xs)
      var(--wui-spacing-1xs);
  }
`;
var __decorate$20 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiBanner = class WuiBanner2 extends i$1 {
  constructor() {
    super(...arguments);
    this.icon = "externalLink";
    this.text = "";
  }
  render() {
    return x$3`
      <cross-wui-flex gap="1xs" alignItems="center">
        <cross-wui-icon-box
          size="sm"
          iconcolor="fg-200"
          backgroundcolor="fg-200"
          icon=${this.icon}
          background="transparent"
        ></cross-wui-icon-box>
        <cross-wui-text variant="small-400" color="fg-200">${this.text}</cross-wui-text>
      </cross-wui-flex>
    `;
  }
};
WuiBanner.styles = [resetStyles, elementStyles, styles$1o];
__decorate$20([
  n$3()
], WuiBanner.prototype, "icon", void 0);
__decorate$20([
  n$3()
], WuiBanner.prototype, "text", void 0);
WuiBanner = __decorate$20([
  customElement("cross-wui-banner")
], WuiBanner);
const styles$1n = i$4`
  cross-wui-flex {
    width: 100%;
    background-color: var(--wui-color-gray-glass-005);
    border-radius: var(--wui-border-radius-m);
    padding: var(--wui-spacing-1xs) var(--wui-spacing-s) var(--wui-spacing-1xs)
      var(--wui-spacing-1xs);
  }
`;
var __decorate$1$ = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiBannerImg = class WuiBannerImg2 extends i$1 {
  constructor() {
    super(...arguments);
    this.imageSrc = "";
    this.text = "";
    this.size = "";
  }
  render() {
    return x$3`
      <cross-wui-flex gap="1xs" alignItems="center">
        <cross-wui-avatar size=${this.size} imageSrc=${this.imageSrc}></cross-wui-avatar>
        <cross-wui-text variant="small-400" color="fg-200">${this.text}</cross-wui-text>
      </cross-wui-flex>
    `;
  }
};
WuiBannerImg.styles = [resetStyles, elementStyles, styles$1n];
__decorate$1$([
  n$3()
], WuiBannerImg.prototype, "imageSrc", void 0);
__decorate$1$([
  n$3()
], WuiBannerImg.prototype, "text", void 0);
__decorate$1$([
  n$3()
], WuiBannerImg.prototype, "size", void 0);
WuiBannerImg = __decorate$1$([
  customElement("cross-wui-banner-img")
], WuiBannerImg);
const styles$1m = i$4`
  button {
    padding: 6.5px var(--wui-spacing-l) 6.5px var(--wui-spacing-xs);
    display: flex;
    justify-content: space-between;
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
    background-color: var(--wui-color-gray-glass-002);
  }

  button[data-clickable='false'] {
    pointer-events: none;
    background-color: transparent;
  }

  cross-wui-image,
  cross-wui-icon {
    width: var(--wui-spacing-3xl);
    height: var(--wui-spacing-3xl);
  }

  cross-wui-image {
    border-radius: var(--wui-border-radius-3xl);
  }
`;
var __decorate$1_ = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiListToken = class WuiListToken2 extends i$1 {
  constructor() {
    super(...arguments);
    this.tokenName = "";
    this.tokenImageUrl = "";
    this.tokenValue = 0;
    this.tokenAmount = "0.0";
    this.tokenCurrency = "";
    this.clickable = false;
  }
  render() {
    return x$3`
      <button data-clickable=${String(this.clickable)}>
        <cross-wui-flex gap="s" alignItems="center">
          ${this.visualTemplate()}
          <cross-wui-flex flexDirection="column" justifyContent="spaceBetween">
            <cross-wui-text variant="paragraph-500" color="fg-100">${this.tokenName}</cross-wui-text>
            <cross-wui-text variant="small-400" color="fg-200">
              ${UiHelperUtil.formatNumberToLocalString(this.tokenAmount, 4)} ${this.tokenCurrency}
            </cross-wui-text>
          </cross-wui-flex>
        </cross-wui-flex>
        <cross-wui-text variant="paragraph-500" color="fg-100">$${this.tokenValue.toFixed(2)}</cross-wui-text>
      </button>
    `;
  }
  visualTemplate() {
    if (this.tokenName && this.tokenImageUrl) {
      return x$3`<cross-wui-image alt=${this.tokenName} src=${this.tokenImageUrl}></cross-wui-image>`;
    }
    return x$3`<cross-wui-icon name="coinPlaceholder" color="fg-100"></cross-wui-icon>`;
  }
};
WuiListToken.styles = [resetStyles, elementStyles, styles$1m];
__decorate$1_([
  n$3()
], WuiListToken.prototype, "tokenName", void 0);
__decorate$1_([
  n$3()
], WuiListToken.prototype, "tokenImageUrl", void 0);
__decorate$1_([
  n$3({ type: Number })
], WuiListToken.prototype, "tokenValue", void 0);
__decorate$1_([
  n$3()
], WuiListToken.prototype, "tokenAmount", void 0);
__decorate$1_([
  n$3()
], WuiListToken.prototype, "tokenCurrency", void 0);
__decorate$1_([
  n$3({ type: Boolean })
], WuiListToken.prototype, "clickable", void 0);
WuiListToken = __decorate$1_([
  customElement("cross-wui-list-token")
], WuiListToken);
const styles$1l = i$4`
  button {
    width: 100%;
    display: flex;
    gap: var(--wui-spacing-s);
    align-items: center;
    justify-content: flex-start;
    padding: var(--wui-spacing-s) var(--wui-spacing-m) var(--wui-spacing-s) var(--wui-spacing-s);
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }

  cross-wui-icon-box {
    width: var(--wui-spacing-2xl);
    height: var(--wui-spacing-2xl);
  }

  cross-wui-flex {
    width: auto;
  }
`;
var __decorate$1Z = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiListDescription = class WuiListDescription2 extends i$1 {
  constructor() {
    super(...arguments);
    this.icon = "card";
    this.text = "";
    this.description = "";
    this.tag = void 0;
    this.iconBackgroundColor = "accent-100";
    this.iconColor = "accent-100";
    this.disabled = false;
  }
  render() {
    return x$3`
      <button ?disabled=${this.disabled}>
        <cross-wui-icon-box
          iconColor=${this.iconColor}
          backgroundColor=${this.iconBackgroundColor}
          size="inherit"
          icon=${this.icon}
          iconSize="md"
        ></cross-wui-icon-box>
        <cross-wui-flex flexDirection="column" justifyContent="spaceBetween">
          ${this.titleTemplate()}
          <cross-wui-text variant="small-400" color="fg-200"> ${this.description}</cross-wui-text></wui-flex
        >
      </button>
    `;
  }
  titleTemplate() {
    if (this.tag) {
      return x$3` <cross-wui-flex alignItems="center" gap="xxs"
        ><cross-wui-text variant="paragraph-500" color="fg-100">${this.text}</wui-text
        ><cross-wui-tag tagType="main" size="md">${this.tag}</cross-wui-tag>
      </cross-wui-flex>`;
    }
    return x$3`<cross-wui-text variant="paragraph-500" color="fg-100">${this.text}</cross-wui-text>`;
  }
};
WuiListDescription.styles = [resetStyles, elementStyles, styles$1l];
__decorate$1Z([
  n$3()
], WuiListDescription.prototype, "icon", void 0);
__decorate$1Z([
  n$3()
], WuiListDescription.prototype, "text", void 0);
__decorate$1Z([
  n$3()
], WuiListDescription.prototype, "description", void 0);
__decorate$1Z([
  n$3()
], WuiListDescription.prototype, "tag", void 0);
__decorate$1Z([
  n$3()
], WuiListDescription.prototype, "iconBackgroundColor", void 0);
__decorate$1Z([
  n$3()
], WuiListDescription.prototype, "iconColor", void 0);
__decorate$1Z([
  n$3({ type: Boolean })
], WuiListDescription.prototype, "disabled", void 0);
WuiListDescription = __decorate$1Z([
  customElement("cross-wui-list-description")
], WuiListDescription);
const specialCharactersRegex = /[.*+?^${}()|[\]\\]/gu;
const numbersRegex = /[0-9,.]/u;
const styles$1k = i$4`
  :host {
    position: relative;
    display: inline-block;
  }

  input {
    background: transparent;
    width: 100%;
    height: auto;
    font-family: var(--wui-font-family);
    color: var(--wui-color-fg-100);

    font-feature-settings: 'case' on;
    font-size: 32px;
    font-weight: var(--wui-font-weight-light);
    caret-color: var(--wui-color-accent-100);
    line-height: 130%;
    letter-spacing: -1.28px;
    box-sizing: border-box;
    -webkit-appearance: none;
    -moz-appearance: textfield;
    padding: 0px;
  }

  input::-webkit-outer-spin-button,
  input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  input::placeholder {
    color: var(--wui-color-fg-275);
  }
`;
var __decorate$1Y = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiInputAmount = class WuiInputAmount2 extends i$1 {
  constructor() {
    super(...arguments);
    this.inputElementRef = e();
    this.disabled = false;
    this.value = "";
    this.placeholder = "0";
  }
  render() {
    var _a3;
    if (((_a3 = this.inputElementRef) == null ? void 0 : _a3.value) && this.value) {
      this.inputElementRef.value.value = this.value;
    }
    return x$3`<input
      ${n$1(this.inputElementRef)}
      type="text"
      inputmode="decimal"
      pattern="[0-9,.]*"
      placeholder=${this.placeholder}
      ?disabled=${this.disabled}
      autofocus
      value=${this.value ?? ""}
      @input=${this.dispatchInputChangeEvent.bind(this)}
    /> `;
  }
  dispatchInputChangeEvent(e3) {
    var _a3, _b2;
    const inputChar = e3.data;
    if (inputChar && ((_a3 = this.inputElementRef) == null ? void 0 : _a3.value)) {
      if (inputChar === ",") {
        const inputValue = this.inputElementRef.value.value.replace(",", ".");
        this.inputElementRef.value.value = inputValue;
        this.value = `${this.value}${inputValue}`;
      } else if (!numbersRegex.test(inputChar)) {
        this.inputElementRef.value.value = this.value.replace(new RegExp(inputChar.replace(specialCharactersRegex, "\\$&"), "gu"), "");
      }
    }
    this.dispatchEvent(new CustomEvent("inputChange", {
      detail: (_b2 = this.inputElementRef.value) == null ? void 0 : _b2.value,
      bubbles: true,
      composed: true
    }));
  }
};
WuiInputAmount.styles = [resetStyles, elementStyles, styles$1k];
__decorate$1Y([
  n$3({ type: Boolean })
], WuiInputAmount.prototype, "disabled", void 0);
__decorate$1Y([
  n$3({ type: String })
], WuiInputAmount.prototype, "value", void 0);
__decorate$1Y([
  n$3({ type: String })
], WuiInputAmount.prototype, "placeholder", void 0);
WuiInputAmount = __decorate$1Y([
  customElement("cross-wui-input-amount")
], WuiInputAmount);
const styles$1j = i$4`
  :host {
    display: flex;
    gap: var(--wui-spacing-xs);
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-color-gray-glass-002);
    background: var(--wui-color-gray-glass-002);
    padding: var(--wui-spacing-2xs) var(--wui-spacing-xs) var(--wui-spacing-2xs)
      var(--wui-spacing-s);
    align-items: center;
  }

  cross-wui-avatar,
  cross-wui-icon,
  cross-wui-image {
    width: 32px;
    height: 32px;
    border: 1px solid var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-3xl);
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-002);
  }
`;
var __decorate$1X = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiPreviewItem = class WuiPreviewItem2 extends i$1 {
  constructor() {
    super(...arguments);
    this.text = "";
    this.address = "";
    this.isAddress = false;
  }
  render() {
    return x$3`<cross-wui-text variant="large-500" color="fg-100">${this.text}</cross-wui-text>
      ${this.imageTemplate()}`;
  }
  imageTemplate() {
    if (this.isAddress) {
      return x$3`<cross-wui-avatar address=${this.address} .imageSrc=${this.imageSrc}></cross-wui-avatar>`;
    } else if (this.imageSrc) {
      return x$3`<cross-wui-image src=${this.imageSrc}></cross-wui-image>`;
    }
    return x$3`<cross-wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></cross-wui-icon>`;
  }
};
WuiPreviewItem.styles = [resetStyles, elementStyles, styles$1j];
__decorate$1X([
  n$3()
], WuiPreviewItem.prototype, "text", void 0);
__decorate$1X([
  n$3()
], WuiPreviewItem.prototype, "address", void 0);
__decorate$1X([
  n$3()
], WuiPreviewItem.prototype, "imageSrc", void 0);
__decorate$1X([
  n$3({ type: Boolean })
], WuiPreviewItem.prototype, "isAddress", void 0);
WuiPreviewItem = __decorate$1X([
  customElement("cross-wui-preview-item")
], WuiPreviewItem);
const styles$1i = i$4`
  button {
    padding: 6.5px var(--wui-spacing-l) 6.5px var(--wui-spacing-xs);
    display: flex;
    justify-content: space-between;
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
    background-color: var(--wui-color-gray-glass-002);
  }

  button[data-clickable='false'] {
    pointer-events: none;
    background-color: transparent;
  }

  cross-wui-image {
    width: var(--wui-spacing-3xl);
    height: var(--wui-spacing-3xl);
    border-radius: var(--wui-border-radius-3xl);
  }

  cross-wui-avatar {
    width: var(--wui-spacing-3xl);
    height: var(--wui-spacing-3xl);
    box-shadow: 0 0 0 0;
  }
  .address {
    color: var(--wui-color-fg-base-100);
  }
  .address-description {
    text-transform: capitalize;
    color: var(--wui-color-fg-base-200);
  }

  cross-wui-icon-box {
    position: relative;
    right: 15px;
    top: 15px;
    border: 2px solid var(--wui-color-bg-150);
    background-color: var(--wui-color-bg-125);
  }
`;
var __decorate$1W = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiListAccount = class WuiListAccount2 extends i$1 {
  constructor() {
    super(...arguments);
    this.accountAddress = "";
    this.accountType = "";
    this.labels = AccountController.state.addressLabels;
    this.caipNetwork = ChainController.state.activeCaipNetwork;
    this.socialProvider = StorageUtil.getConnectedSocialProvider();
    this.balance = 0;
    this.fetchingBalance = true;
    this.shouldShowIcon = false;
    this.selected = false;
  }
  connectedCallback() {
    var _a3;
    super.connectedCallback();
    ApiController$1.getBalance(this.accountAddress, (_a3 = this.caipNetwork) == null ? void 0 : _a3.caipNetworkId).then((response) => {
      let total = this.balance;
      if (response.length > 0) {
        total = response.reduce((acc, balance) => acc + ((balance == null ? void 0 : balance.value) || 0), 0);
      }
      this.balance = total;
      this.fetchingBalance = false;
      this.requestUpdate();
    }).catch(() => {
      this.fetchingBalance = false;
      this.requestUpdate();
    });
  }
  render() {
    const label = this.getLabel();
    const namespace = ChainController.state.activeChain;
    const connectorId = StorageUtil.getConnectedConnectorId(namespace);
    this.shouldShowIcon = connectorId === ConstantsUtil$4.CONNECTOR_ID.AUTH;
    return x$3`
      <cross-wui-flex
        flexDirection="row"
        justifyContent="space-between"
        .padding=${["0", "0", "s", "1xs"]}
      >
        <cross-wui-flex gap="md" alignItems="center">
          <cross-wui-avatar address=${this.accountAddress}></cross-wui-avatar>
          ${this.shouldShowIcon ? x$3`<cross-wui-icon-box
                size="sm"
                iconcolor="fg-200"
                backgroundcolor="fg-300"
                icon=${this.accountType === W3mFrameRpcConstants.ACCOUNT_TYPES.EOA ? this.socialProvider ?? "mail" : "lightbulb"}
                background="fg-300"
              ></cross-wui-icon-box>` : x$3`<cross-wui-flex .padding="${["0", "0", "0", "s"]}"></cross-wui-flex>`}
          <cross-wui-flex flexDirection="column">
            <cross-wui-text class="address" variant="paragraph-500" color="fg-100"
              >${UiHelperUtil.getTruncateString({
      string: this.accountAddress,
      charsStart: 4,
      charsEnd: 6,
      truncate: "middle"
    })}</wui-text
            >
            <cross-wui-text class="address-description" variant="small-400">${label}</cross-wui-text></wui-flex
          >
        </cross-wui-flex>
        <cross-wui-flex gap="s" alignItems="center">
          <slot name="action"></slot>
          ${this.fetchingBalance ? x$3`<cross-wui-loading-spinner size="sm" color="accent-100"></cross-wui-loading-spinner>` : x$3` <cross-wui-text variant="small-400">$${this.balance.toFixed(2)}</cross-wui-text>`}
        </cross-wui-flex>
      </cross-wui-flex>
    `;
  }
  getLabel() {
    var _a3;
    let label = (_a3 = this.labels) == null ? void 0 : _a3.get(this.accountAddress);
    const namespace = ChainController.state.activeChain;
    const connectorId = StorageUtil.getConnectedConnectorId(namespace);
    if (!label && connectorId === ConstantsUtil$4.CONNECTOR_ID.AUTH) {
      label = `${this.accountType === "eoa" ? this.socialProvider ?? "Email" : "Smart"} Account`;
    } else if (!label) {
      label = "EOA";
    }
    return label;
  }
};
WuiListAccount.styles = [resetStyles, elementStyles, styles$1i];
__decorate$1W([
  n$3()
], WuiListAccount.prototype, "accountAddress", void 0);
__decorate$1W([
  n$3()
], WuiListAccount.prototype, "accountType", void 0);
__decorate$1W([
  n$3({ type: Boolean })
], WuiListAccount.prototype, "selected", void 0);
__decorate$1W([
  n$3({ type: Function })
], WuiListAccount.prototype, "onSelect", void 0);
WuiListAccount = __decorate$1W([
  customElement("cross-wui-list-account")
], WuiListAccount);
const styles$1h = i$4`
  :host {
    position: relative;
  }

  button {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 48px;
    width: 100%;
    background-color: var(--wui-color-accent-glass-010);
    border-radius: var(--wui-border-radius-xs);
    border: 1px solid var(--wui-color-accent-glass-010);
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color;
  }

  cross-wui-tooltip {
    padding: 7px var(--wui-spacing-s) 8px var(--wui-spacing-s);
    position: absolute;
    top: -8px;
    left: 50%;
    transform: translate(-50%, -100%);
    opacity: 0;
    display: none;
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-accent-glass-015);
    }

    button:active:enabled {
      background-color: var(--wui-color-accent-glass-020);
    }
  }
`;
var __decorate$1V = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiIconButton = class WuiIconButton2 extends i$1 {
  constructor() {
    super(...arguments);
    this.text = "";
    this.icon = "card";
  }
  render() {
    return x$3`<button>
      <cross-wui-icon color="accent-100" name=${this.icon} size="lg"></cross-wui-icon>
    </button>`;
  }
};
WuiIconButton.styles = [resetStyles, elementStyles, styles$1h];
__decorate$1V([
  n$3()
], WuiIconButton.prototype, "text", void 0);
__decorate$1V([
  n$3()
], WuiIconButton.prototype, "icon", void 0);
WuiIconButton = __decorate$1V([
  customElement("cross-wui-icon-button")
], WuiIconButton);
const styles$1g = i$4`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 16.5px var(--wui-spacing-l) 16.5px var(--wui-spacing-xs);
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-100);
    justify-content: center;
    align-items: center;
  }

  button:disabled {
    background-color: var(--wui-color-gray-glass-015);
    color: var(--wui-color-gray-glass-015);
  }
`;
var __decorate$1U = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiListButton = class WuiListButton2 extends i$1 {
  constructor() {
    super(...arguments);
    this.text = "";
    this.disabled = false;
    this.tabIdx = void 0;
  }
  render() {
    return x$3`
      <button ?disabled=${this.disabled} tabindex=${o$2(this.tabIdx)}>
        <cross-wui-text align="center" variant="paragraph-500" color="inherit">${this.text}</cross-wui-text>
      </button>
    `;
  }
};
WuiListButton.styles = [resetStyles, elementStyles, styles$1g];
__decorate$1U([
  n$3()
], WuiListButton.prototype, "text", void 0);
__decorate$1U([
  n$3({ type: Boolean })
], WuiListButton.prototype, "disabled", void 0);
__decorate$1U([
  n$3()
], WuiListButton.prototype, "tabIdx", void 0);
WuiListButton = __decorate$1U([
  customElement("cross-wui-list-button")
], WuiListButton);
const styles$1f = i$4`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
    justify-content: flex-start;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-100);
  }

  cross-wui-text {
    text-transform: capitalize;
  }

  wui-text[data-align='left'] {
    display: flex;
    flex: 1;
  }

  wui-text[data-align='center'] {
    display: flex;
    flex: 1;
    justify-content: center;
  }

  .invisible {
    opacity: 0;
    pointer-events: none;
  }

  button:disabled {
    background-color: var(--wui-color-gray-glass-015);
    color: var(--wui-color-gray-glass-015);
  }
`;
var __decorate$1T = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiListSocial = class WuiListSocial2 extends i$1 {
  constructor() {
    super(...arguments);
    this.logo = "google";
    this.name = "Continue with google";
    this.align = "left";
    this.disabled = false;
  }
  render() {
    return x$3`
      <button ?disabled=${this.disabled} tabindex=${o$2(this.tabIdx)}>
        <cross-wui-logo logo=${this.logo}></cross-wui-logo>
        <cross-wui-text
          data-align=${this.align}
          variant="paragraph-500"
          color="inherit"
          align=${this.align}
          >${this.name}</wui-text
        >
        ${this.templatePlacement()}
      </button>
    `;
  }
  templatePlacement() {
    if (this.align === "center") {
      return x$3` <cross-wui-logo class="invisible" logo=${this.logo}></cross-wui-logo>`;
    }
    return null;
  }
};
WuiListSocial.styles = [resetStyles, elementStyles, styles$1f];
__decorate$1T([
  n$3()
], WuiListSocial.prototype, "logo", void 0);
__decorate$1T([
  n$3()
], WuiListSocial.prototype, "name", void 0);
__decorate$1T([
  n$3()
], WuiListSocial.prototype, "align", void 0);
__decorate$1T([
  n$3()
], WuiListSocial.prototype, "tabIdx", void 0);
__decorate$1T([
  n$3({ type: Boolean })
], WuiListSocial.prototype, "disabled", void 0);
WuiListSocial = __decorate$1T([
  customElement("cross-wui-list-social")
], WuiListSocial);
const styles$1e = i$4`
  button {
    display: block;
    display: flex;
    align-items: center;
    padding: var(--wui-spacing-xxs);
    gap: var(--wui-spacing-xxs);
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-md);
    border-radius: var(--wui-border-radius-xxs);
  }

  cross-wui-image {
    border-radius: 100%;
    width: var(--wui-spacing-xl);
    height: var(--wui-spacing-xl);
  }

  cross-wui-icon-box {
    width: var(--wui-spacing-xl);
    height: var(--wui-spacing-xl);
  }

  button:hover {
    background-color: var(--wui-color-gray-glass-002);
  }

  button:active {
    background-color: var(--wui-color-gray-glass-005);
  }
`;
var __decorate$1S = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiSelect = class WuiSelect2 extends i$1 {
  constructor() {
    super(...arguments);
    this.imageSrc = "";
  }
  render() {
    return x$3`<button>
      ${this.imageTemplate()}
      <cross-wui-icon size="xs" color="fg-200" name="chevronBottom"></cross-wui-icon>
    </button>`;
  }
  imageTemplate() {
    if (this.imageSrc) {
      return x$3`<cross-wui-image src=${this.imageSrc} alt="select visual"></cross-wui-image>`;
    }
    return x$3`<cross-wui-icon-box
      size="xxs"
      iconColor="fg-200"
      backgroundColor="fg-100"
      background="opaque"
      icon="networkPlaceholder"
    ></cross-wui-icon-box>`;
  }
};
WuiSelect.styles = [resetStyles, elementStyles, colorStyles, styles$1e];
__decorate$1S([
  n$3()
], WuiSelect.prototype, "imageSrc", void 0);
WuiSelect = __decorate$1S([
  customElement("cross-wui-select")
], WuiSelect);
const styles$1d = i$4`
  label {
    display: flex;
    align-items: center;
    cursor: pointer;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    column-gap: var(--wui-spacing-1xs);
  }

  label > input[type='checkbox'] {
    height: 0;
    width: 0;
    opacity: 0;
    pointer-events: none;
    position: absolute;
  }

  label > span {
    width: var(--wui-spacing-xl);
    height: var(--wui-spacing-xl);
    min-width: var(--wui-spacing-xl);
    min-height: var(--wui-spacing-xl);
    border-radius: var(--wui-border-radius-3xs);
    border-width: 1px;
    border-style: solid;
    border-color: var(--wui-color-gray-glass-010);
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-lg);
    will-change: background-color;
  }

  label > span:hover,
  label > input[type='checkbox']:focus-visible + span {
    background-color: var(--wui-color-gray-glass-010);
  }

  label input[type='checkbox']:checked + span {
    background-color: var(--wui-color-blue-base-90);
  }

  label > span > cross-wui-icon {
    opacity: 0;
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-lg);
    will-change: opacity;
  }

  label > input[type='checkbox']:checked + span cross-wui-icon {
    opacity: 1;
  }
`;
var __decorate$1R = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiCheckBox = class WuiCheckBox2 extends i$1 {
  constructor() {
    super(...arguments);
    this.inputElementRef = e();
    this.checked = void 0;
  }
  render() {
    return x$3`
      <label>
        <input
          ${n$1(this.inputElementRef)}
          ?checked=${o$2(this.checked)}
          type="checkbox"
          @change=${this.dispatchChangeEvent}
        />
        <span>
          <cross-wui-icon name="checkmarkBold" color="inverse-100" size="xxs"></cross-wui-icon>
        </span>
        <slot></slot>
      </label>
    `;
  }
  dispatchChangeEvent() {
    var _a3;
    this.dispatchEvent(new CustomEvent("checkboxChange", {
      detail: (_a3 = this.inputElementRef.value) == null ? void 0 : _a3.checked,
      bubbles: true,
      composed: true
    }));
  }
};
WuiCheckBox.styles = [resetStyles, styles$1d];
__decorate$1R([
  n$3({ type: Boolean })
], WuiCheckBox.prototype, "checked", void 0);
WuiCheckBox = __decorate$1R([
  customElement("cross-wui-checkbox")
], WuiCheckBox);
const styles$1c = i$4`
  :host {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  label {
    position: relative;
    display: inline-block;
    width: 32px;
    height: 22px;
  }

  input {
    width: 0;
    height: 0;
    opacity: 0;
  }

  span {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: var(--wui-color-blue-100);
    border-width: 1px;
    border-style: solid;
    border-color: var(--wui-color-gray-glass-002);
    border-radius: 999px;
    transition:
      background-color var(--wui-ease-inout-power-1) var(--wui-duration-md),
      border-color var(--wui-ease-inout-power-1) var(--wui-duration-md);
    will-change: background-color, border-color;
  }

  span:before {
    position: absolute;
    content: '';
    height: 16px;
    width: 16px;
    left: 3px;
    top: 2px;
    background-color: var(--wui-color-inverse-100);
    transition: transform var(--wui-ease-inout-power-1) var(--wui-duration-lg);
    will-change: transform;
    border-radius: 50%;
  }

  input:checked + span {
    border-color: var(--wui-color-gray-glass-005);
    background-color: var(--wui-color-blue-100);
  }

  input:not(:checked) + span {
    background-color: var(--wui-color-gray-glass-010);
  }

  input:checked + span:before {
    transform: translateX(calc(100% - 7px));
  }
`;
var __decorate$1Q = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiSwitch = class WuiSwitch2 extends i$1 {
  constructor() {
    super(...arguments);
    this.inputElementRef = e();
    this.checked = void 0;
  }
  render() {
    return x$3`
      <label>
        <input
          ${n$1(this.inputElementRef)}
          type="checkbox"
          ?checked=${o$2(this.checked)}
          @change=${this.dispatchChangeEvent.bind(this)}
        />
        <span></span>
      </label>
    `;
  }
  dispatchChangeEvent() {
    var _a3;
    this.dispatchEvent(new CustomEvent("switchChange", {
      detail: (_a3 = this.inputElementRef.value) == null ? void 0 : _a3.checked,
      bubbles: true,
      composed: true
    }));
  }
};
WuiSwitch.styles = [resetStyles, elementStyles, colorStyles, styles$1c];
__decorate$1Q([
  n$3({ type: Boolean })
], WuiSwitch.prototype, "checked", void 0);
WuiSwitch = __decorate$1Q([
  customElement("cross-wui-switch")
], WuiSwitch);
const styles$1b = i$4`
  :host {
    height: 100%;
  }

  button {
    display: flex;
    align-items: center;
    justify-content: center;
    column-gap: var(--wui-spacing-1xs);
    padding: var(--wui-spacing-xs) var(--wui-spacing-s);
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color;
    cursor: pointer;
  }

  cross-wui-switch {
    pointer-events: none;
  }
`;
var __decorate$1P = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiCertifiedSwitch = class WuiCertifiedSwitch2 extends i$1 {
  constructor() {
    super(...arguments);
    this.checked = void 0;
  }
  render() {
    return x$3`
      <button>
        <cross-wui-icon size="xl" name="walletConnectBrown"></cross-wui-icon>
        <cross-wui-switch ?checked=${o$2(this.checked)}></cross-wui-switch>
      </button>
    `;
  }
};
WuiCertifiedSwitch.styles = [resetStyles, elementStyles, styles$1b];
__decorate$1P([
  n$3({ type: Boolean })
], WuiCertifiedSwitch.prototype, "checked", void 0);
WuiCertifiedSwitch = __decorate$1P([
  customElement("cross-wui-certified-switch")
], WuiCertifiedSwitch);
const styles$1a = i$4`
  :host {
    display: grid;
    width: inherit;
    height: inherit;
  }
`;
var __decorate$1O = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiGrid = class WuiGrid2 extends i$1 {
  render() {
    this.style.cssText = `
      grid-template-rows: ${this.gridTemplateRows};
      grid-template-columns: ${this.gridTemplateColumns};
      justify-items: ${this.justifyItems};
      align-items: ${this.alignItems};
      justify-content: ${this.justifyContent};
      align-content: ${this.alignContent};
      column-gap: ${this.columnGap && `var(--wui-spacing-${this.columnGap})`};
      row-gap: ${this.rowGap && `var(--wui-spacing-${this.rowGap})`};
      gap: ${this.gap && `var(--wui-spacing-${this.gap})`};
      padding-top: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 0)};
      padding-right: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 1)};
      padding-bottom: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 2)};
      padding-left: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 3)};
      margin-top: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 0)};
      margin-right: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 1)};
      margin-bottom: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 2)};
      margin-left: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 3)};
    `;
    return x$3`<slot></slot>`;
  }
};
WuiGrid.styles = [resetStyles, styles$1a];
__decorate$1O([
  n$3()
], WuiGrid.prototype, "gridTemplateRows", void 0);
__decorate$1O([
  n$3()
], WuiGrid.prototype, "gridTemplateColumns", void 0);
__decorate$1O([
  n$3()
], WuiGrid.prototype, "justifyItems", void 0);
__decorate$1O([
  n$3()
], WuiGrid.prototype, "alignItems", void 0);
__decorate$1O([
  n$3()
], WuiGrid.prototype, "justifyContent", void 0);
__decorate$1O([
  n$3()
], WuiGrid.prototype, "alignContent", void 0);
__decorate$1O([
  n$3()
], WuiGrid.prototype, "columnGap", void 0);
__decorate$1O([
  n$3()
], WuiGrid.prototype, "rowGap", void 0);
__decorate$1O([
  n$3()
], WuiGrid.prototype, "gap", void 0);
__decorate$1O([
  n$3()
], WuiGrid.prototype, "padding", void 0);
__decorate$1O([
  n$3()
], WuiGrid.prototype, "margin", void 0);
WuiGrid = __decorate$1O([
  customElement("cross-wui-grid")
], WuiGrid);
const styles$19 = i$4`
  :host {
    position: relative;
    display: flex;
    width: 100%;
    height: 1px;
    background-color: var(--wui-color-gray-glass-005);
    justify-content: center;
    align-items: center;
  }

  :host > cross-wui-text {
    position: absolute;
    padding: 0px 10px;
    background-color: var(--wui-color-modal-bg);
    transition: background-color var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: background-color;
  }
`;
var __decorate$1N = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiSeparator = class WuiSeparator2 extends i$1 {
  constructor() {
    super(...arguments);
    this.text = "";
  }
  render() {
    return x$3`${this.template()}`;
  }
  template() {
    if (this.text) {
      return x$3`<cross-wui-text variant="small-500" color="fg-200">${this.text}</cross-wui-text>`;
    }
    return null;
  }
};
WuiSeparator.styles = [resetStyles, styles$19];
__decorate$1N([
  n$3()
], WuiSeparator.prototype, "text", void 0);
WuiSeparator = __decorate$1N([
  customElement("cross-wui-separator")
], WuiSeparator);
const MathUtil = {
  interpolate(inputRange, outputRange, value) {
    if (inputRange.length !== 2 || outputRange.length !== 2) {
      throw new Error("inputRange and outputRange must be an array of length 2");
    }
    const originalRangeMin = inputRange[0] || 0;
    const originalRangeMax = inputRange[1] || 0;
    const newRangeMin = outputRange[0] || 0;
    const newRangeMax = outputRange[1] || 0;
    if (value < originalRangeMin) {
      return newRangeMin;
    }
    if (value > originalRangeMax) {
      return newRangeMax;
    }
    return (newRangeMax - newRangeMin) / (originalRangeMax - originalRangeMin) * (value - originalRangeMin) + newRangeMin;
  }
};
const FLOAT_FIXED_VALUE = 3;
const plusTypes = ["receive", "deposit", "borrow", "claim"];
const minusTypes = ["withdraw", "repay", "burn"];
const TransactionUtil = {
  getTransactionGroupTitle(year, month) {
    const currentYear = DateUtil.getYear();
    const monthName = DateUtil.getMonthNameByIndex(month);
    const isCurrentYear = year === currentYear;
    const groupTitle = isCurrentYear ? monthName : `${monthName} ${year}`;
    return groupTitle;
  },
  getTransactionImages(transfers) {
    const [transfer, secondTransfer] = transfers;
    const isAllNFT = Boolean(transfer) && (transfers == null ? void 0 : transfers.every((item) => Boolean(item.nft_info)));
    const haveMultipleTransfers = (transfers == null ? void 0 : transfers.length) > 1;
    const haveTwoTransfers = (transfers == null ? void 0 : transfers.length) === 2;
    if (haveTwoTransfers && !isAllNFT) {
      return [this.getTransactionImage(transfer), this.getTransactionImage(secondTransfer)];
    }
    if (haveMultipleTransfers) {
      return transfers.map((item) => this.getTransactionImage(item));
    }
    return [this.getTransactionImage(transfer)];
  },
  getTransactionImage(transfer) {
    return {
      type: TransactionUtil.getTransactionTransferTokenType(transfer),
      url: TransactionUtil.getTransactionImageURL(transfer)
    };
  },
  getTransactionImageURL(transfer) {
    var _a3, _b2, _c3, _d, _e4;
    let imageURL = void 0;
    const isNFT = Boolean(transfer == null ? void 0 : transfer.nft_info);
    const isFungible = Boolean(transfer == null ? void 0 : transfer.fungible_info);
    if (transfer && isNFT) {
      imageURL = (_c3 = (_b2 = (_a3 = transfer == null ? void 0 : transfer.nft_info) == null ? void 0 : _a3.content) == null ? void 0 : _b2.preview) == null ? void 0 : _c3.url;
    } else if (transfer && isFungible) {
      imageURL = (_e4 = (_d = transfer == null ? void 0 : transfer.fungible_info) == null ? void 0 : _d.icon) == null ? void 0 : _e4.url;
    }
    return imageURL;
  },
  getTransactionTransferTokenType(transfer) {
    if (transfer == null ? void 0 : transfer.fungible_info) {
      return "FUNGIBLE";
    } else if (transfer == null ? void 0 : transfer.nft_info) {
      return "NFT";
    }
    return void 0;
  },
  getTransactionDescriptions(transaction) {
    var _a3, _b2, _c3;
    const type2 = (_a3 = transaction == null ? void 0 : transaction.metadata) == null ? void 0 : _a3.operationType;
    const transfers = transaction == null ? void 0 : transaction.transfers;
    const haveTransfer = ((_b2 = transaction == null ? void 0 : transaction.transfers) == null ? void 0 : _b2.length) > 0;
    const haveMultipleTransfers = ((_c3 = transaction == null ? void 0 : transaction.transfers) == null ? void 0 : _c3.length) > 1;
    const isFungible = haveTransfer && (transfers == null ? void 0 : transfers.every((transfer) => Boolean(transfer == null ? void 0 : transfer.fungible_info)));
    const [firstTransfer, secondTransfer] = transfers;
    let firstDescription = this.getTransferDescription(firstTransfer);
    let secondDescription = this.getTransferDescription(secondTransfer);
    if (!haveTransfer) {
      const isSendOrReceive = type2 === "send" || type2 === "receive";
      if (isSendOrReceive && isFungible) {
        firstDescription = UiHelperUtil.getTruncateString({
          string: transaction == null ? void 0 : transaction.metadata.sentFrom,
          charsStart: 4,
          charsEnd: 6,
          truncate: "middle"
        });
        secondDescription = UiHelperUtil.getTruncateString({
          string: transaction == null ? void 0 : transaction.metadata.sentTo,
          charsStart: 4,
          charsEnd: 6,
          truncate: "middle"
        });
        return [firstDescription, secondDescription];
      }
      return [transaction.metadata.status];
    }
    if (haveMultipleTransfers) {
      return transfers.map((item) => this.getTransferDescription(item));
    }
    let prefix = "";
    if (plusTypes.includes(type2)) {
      prefix = "+";
    } else if (minusTypes.includes(type2)) {
      prefix = "-";
    }
    firstDescription = prefix.concat(firstDescription);
    return [firstDescription];
  },
  getTransferDescription(transfer) {
    var _a3;
    let description = "";
    if (!transfer) {
      return description;
    }
    if (transfer == null ? void 0 : transfer.nft_info) {
      description = ((_a3 = transfer == null ? void 0 : transfer.nft_info) == null ? void 0 : _a3.name) || "-";
    } else if (transfer == null ? void 0 : transfer.fungible_info) {
      description = this.getFungibleTransferDescription(transfer) || "-";
    }
    return description;
  },
  getFungibleTransferDescription(transfer) {
    var _a3;
    if (!transfer) {
      return null;
    }
    const quantity = this.getQuantityFixedValue(transfer == null ? void 0 : transfer.quantity.numeric);
    const description = [quantity, (_a3 = transfer == null ? void 0 : transfer.fungible_info) == null ? void 0 : _a3.symbol].join(" ").trim();
    return description;
  },
  getQuantityFixedValue(value) {
    if (!value) {
      return null;
    }
    const parsedValue = parseFloat(value);
    return parsedValue.toFixed(FLOAT_FIXED_VALUE);
  }
};
const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MathUtil,
  TransactionUtil,
  UiHelperUtil,
  get WuiAccountButton() {
    return WuiAccountButton;
  },
  get WuiAlertBar() {
    return WuiAlertBar;
  },
  get WuiAllWalletsImage() {
    return WuiAllWalletsImage;
  },
  get WuiAvatar() {
    return WuiAvatar;
  },
  get WuiBalance() {
    return WuiBalance;
  },
  get WuiBanner() {
    return WuiBanner;
  },
  get WuiBannerImg() {
    return WuiBannerImg;
  },
  get WuiButton() {
    return WuiButton;
  },
  get WuiCard() {
    return WuiCard;
  },
  get WuiCardSelect() {
    return WuiCardSelect;
  },
  get WuiCardSelectLoader() {
    return WuiCardSelectLoader;
  },
  get WuiCertifiedSwitch() {
    return WuiCertifiedSwitch;
  },
  get WuiCheckBox() {
    return WuiCheckBox;
  },
  get WuiChip() {
    return WuiChip;
  },
  get WuiChipButton() {
    return WuiChipButton;
  },
  get WuiCompatibleNetwork() {
    return WuiCompatibleNetwork;
  },
  get WuiConnectButton() {
    return WuiConnectButton;
  },
  get WuiCtaButton() {
    return WuiCtaButton;
  },
  get WuiDetailsGroup() {
    return WuiDetailsGroup;
  },
  get WuiDetailsGroupItem() {
    return WuiDetailsGroupItem;
  },
  get WuiDropdownMenu() {
    return WuiDropdownMenu;
  },
  get WuiEmailInput() {
    return WuiEmailInput;
  },
  get WuiEnsInput() {
    return WuiEnsInput;
  },
  get WuiFlex() {
    return WuiFlex;
  },
  get WuiGrid() {
    return WuiGrid;
  },
  get WuiIcon() {
    return WuiIcon;
  },
  get WuiIconBox() {
    return WuiIconBox;
  },
  get WuiIconButton() {
    return WuiIconButton;
  },
  get WuiIconLink() {
    return WuiIconLink;
  },
  get WuiImage() {
    return WuiImage;
  },
  get WuiInputAmount() {
    return WuiInputAmount;
  },
  get WuiInputElement() {
    return WuiInputElement;
  },
  get WuiInputNumeric() {
    return WuiInputNumeric;
  },
  get WuiInputText() {
    return WuiInputText;
  },
  get WuiLink() {
    return WuiLink;
  },
  get WuiListAccordion() {
    return WuiListAccordion;
  },
  get WuiListAccount() {
    return WuiListAccount;
  },
  get WuiListButton() {
    return WuiListButton;
  },
  get WuiListContent() {
    return WuiListContent;
  },
  get WuiListDescription() {
    return WuiListDescription;
  },
  get WuiListItem() {
    return WuiListItem;
  },
  get WuiListNetwork() {
    return WuiListNetwork;
  },
  get WuiListSocial() {
    return WuiListSocial;
  },
  get WuiListToken() {
    return WuiListToken;
  },
  get WuiListWallet() {
    return WuiListWallet;
  },
  get WuiListWalletTransaction() {
    return WuiListWalletTransaction;
  },
  get WuiLoadingHexagon() {
    return WuiLoadingHexagon;
  },
  get WuiLoadingSpinner() {
    return WuiLoadingSpinner;
  },
  get WuiLoadingThumbnail() {
    return WuiLoadingThumbnail;
  },
  get WuiLogo() {
    return WuiLogo;
  },
  get WuiLogoSelect() {
    return WuiLogoSelect;
  },
  get WuiNetworkButton() {
    return WuiNetworkButton;
  },
  get WuiNetworkImage() {
    return WuiNetworkImage;
  },
  get WuiNoticeCard() {
    return WuiNoticeCard;
  },
  get WuiOtp() {
    return WuiOtp;
  },
  get WuiPreviewItem() {
    return WuiPreviewItem;
  },
  get WuiProfileButton() {
    return WuiProfileButton;
  },
  get WuiProfileButtonV2() {
    return WuiProfileButtonV2;
  },
  get WuiPromo() {
    return WuiPromo;
  },
  get WuiQrCode() {
    return WuiQrCode;
  },
  get WuiSearchBar() {
    return WuiSearchBar;
  },
  get WuiSelect() {
    return WuiSelect;
  },
  get WuiSeparator() {
    return WuiSeparator;
  },
  get WuiShimmer() {
    return WuiShimmer;
  },
  get WuiSnackbar() {
    return WuiSnackbar;
  },
  get WuiSwitch() {
    return WuiSwitch;
  },
  get WuiTabs() {
    return WuiTabs;
  },
  get WuiTag() {
    return WuiTag;
  },
  get WuiText() {
    return WuiText;
  },
  get WuiTokenButton() {
    return WuiTokenButton;
  },
  get WuiTokenListItem() {
    return WuiTokenListItem;
  },
  get WuiTooltip() {
    return WuiTooltip;
  },
  get WuiTransactionListItem() {
    return WuiTransactionListItem;
  },
  get WuiTransactionListItemLoader() {
    return WuiTransactionListItemLoader;
  },
  get WuiTransactionVisual() {
    return WuiTransactionVisual;
  },
  get WuiVisual() {
    return WuiVisual;
  },
  get WuiVisualThumbnail() {
    return WuiVisualThumbnail;
  },
  get WuiWalletButton() {
    return WuiWalletButton;
  },
  get WuiWalletImage() {
    return WuiWalletImage;
  },
  customElement,
  initializeTheming,
  setColorTheme,
  setThemeVariables,
  swapInputMaskBottomSvg,
  swapInputMaskTopSvg
}, Symbol.toStringTag, { value: "Module" }));
const ConstantsUtil$1 = {
  METMASK_CONNECTOR_NAME: "MetaMask",
  TRUST_CONNECTOR_NAME: "Trust Wallet",
  SOLFLARE_CONNECTOR_NAME: "Solflare",
  PHANTOM_CONNECTOR_NAME: "Phantom",
  COIN98_CONNECTOR_NAME: "Coin98",
  MAGIC_EDEN_CONNECTOR_NAME: "Magic Eden",
  BACKPACK_CONNECTOR_NAME: "Backpack",
  BITGET_CONNECTOR_NAME: "Bitget Wallet",
  FRONTIER_CONNECTOR_NAME: "Frontier",
  XVERSE_CONNECTOR_NAME: "Xverse Wallet",
  LEATHER_CONNECTOR_NAME: "Leather",
  EIP155: "eip155",
  ADD_CHAIN_METHOD: "wallet_addEthereumChain",
  EIP6963_ANNOUNCE_EVENT: "eip6963:announceProvider",
  EIP6963_REQUEST_EVENT: "eip6963:requestProvider",
  EIP6963_CROSS_ANNOUNCE_EVENT: "eip6963:crossAnnounceProvider",
  EIP6963_CROSS_REQUEST_EVENT: "eip6963:crossRequestProvider",
  CONNECTOR_RDNS_MAP: {
    coinbaseWallet: "com.coinbase.wallet",
    coinbaseWalletSDK: "com.coinbase.wallet"
  },
  CONNECTOR_TYPE_EXTERNAL: "EXTERNAL",
  CONNECTOR_TYPE_WALLET_CONNECT: "WALLET_CONNECT",
  CONNECTOR_TYPE_INJECTED: "INJECTED",
  CONNECTOR_TYPE_ANNOUNCED: "ANNOUNCED",
  CONNECTOR_TYPE_AUTH: "AUTH",
  CONNECTOR_TYPE_MULTI_CHAIN: "MULTI_CHAIN",
  CONNECTOR_TYPE_W3M_AUTH: "ID_AUTH"
};
const PresetsUtil = {
  ConnectorExplorerIds: {
    [ConstantsUtil$4.CONNECTOR_ID.COINBASE]: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
    [ConstantsUtil$4.CONNECTOR_ID.COINBASE_SDK]: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
    [ConstantsUtil$4.CONNECTOR_ID.SAFE]: "225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f",
    [ConstantsUtil$4.CONNECTOR_ID.LEDGER]: "19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927",
    [ConstantsUtil$4.CONNECTOR_ID.OKX]: "971e689d0a5be527bac79629b4ee9b925e82208e5168b733496a09c0faed0709",
    [ConstantsUtil$1.METMASK_CONNECTOR_NAME]: "c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96",
    [ConstantsUtil$1.TRUST_CONNECTOR_NAME]: "4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0",
    [ConstantsUtil$1.SOLFLARE_CONNECTOR_NAME]: "1ca0bdd4747578705b1939af023d120677c64fe6ca76add81fda36e350605e79",
    [ConstantsUtil$1.PHANTOM_CONNECTOR_NAME]: "a797aa35c0fadbfc1a53e7f675162ed5226968b44a19ee3d24385c64d1d3c393",
    [ConstantsUtil$1.COIN98_CONNECTOR_NAME]: "2a3c89040ac3b723a1972a33a125b1db11e258a6975d3a61252cd64e6ea5ea01",
    [ConstantsUtil$1.MAGIC_EDEN_CONNECTOR_NAME]: "8b830a2b724a9c3fbab63af6f55ed29c9dfa8a55e732dc88c80a196a2ba136c6",
    [ConstantsUtil$1.BACKPACK_CONNECTOR_NAME]: "2bd8c14e035c2d48f184aaa168559e86b0e3433228d3c4075900a221785019b0",
    [ConstantsUtil$1.BITGET_CONNECTOR_NAME]: "38f5d18bd8522c244bdd70cb4a68e0e718865155811c043f052fb9f1c51de662",
    [ConstantsUtil$1.FRONTIER_CONNECTOR_NAME]: "85db431492aa2e8672e93f4ea7acf10c88b97b867b0d373107af63dc4880f041",
    [ConstantsUtil$1.XVERSE_CONNECTOR_NAME]: "2a87d74ae02e10bdd1f51f7ce6c4e1cc53cd5f2c0b6b5ad0d7b3007d2b13de7b",
    [ConstantsUtil$1.LEATHER_CONNECTOR_NAME]: "483afe1df1df63daf313109971ff3ef8356ddf1cc4e45877d205eee0b7893a13"
  },
  NetworkImageIds: {
    1: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
    42161: "3bff954d-5cb0-47a0-9a23-d20192e74600",
    43114: "30c46e53-e989-45fb-4549-be3bd4eb3b00",
    56: "93564157-2e8e-4ce7-81df-b264dbee9b00",
    250: "06b26297-fe0c-4733-5d6b-ffa5498aac00",
    10: "ab9c186a-c52f-464b-2906-ca59d760a400",
    137: "41d04d42-da3b-4453-8506-668cc0727900",
    5e3: "e86fae9b-b770-4eea-e520-150e12c81100",
    295: "6a97d510-cac8-4e58-c7ce-e8681b044c00",
    11155111: "e909ea0a-f92a-4512-c8fc-748044ea6800",
    84532: "a18a7ecd-e307-4360-4746-283182228e00",
    1301: "4eeea7ef-0014-4649-5d1d-07271a80f600",
    130: "2257980a-3463-48c6-cbac-a42d2a956e00",
    10143: "0a728e83-bacb-46db-7844-948f05434900",
    100: "02b53f6a-e3d4-479e-1cb4-21178987d100",
    9001: "f926ff41-260d-4028-635e-91913fc28e00",
    324: "b310f07f-4ef7-49f3-7073-2a0a39685800",
    314: "5a73b3dd-af74-424e-cae0-0de859ee9400",
    4689: "34e68754-e536-40da-c153-6ef2e7188a00",
    1088: "3897a66d-40b9-4833-162f-a2c90531c900",
    1284: "161038da-44ae-4ec7-1208-0ea569454b00",
    1285: "f1d73bb6-5450-4e18-38f7-fb6484264a00",
    7777777: "845c60df-d429-4991-e687-91ae45791600",
    42220: "ab781bbc-ccc6-418d-d32d-789b15da1f00",
    8453: "7289c336-3981-4081-c5f4-efc26ac64a00",
    1313161554: "3ff73439-a619-4894-9262-4470c773a100",
    2020: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
    2021: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
    "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp": "a1b58899-f671-4276-6a5e-56ca5bd59700",
    "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z": "a1b58899-f671-4276-6a5e-56ca5bd59700",
    EtWTRABZaYq6iMfeYKouRu166VU2xqa1: "a1b58899-f671-4276-6a5e-56ca5bd59700",
    "000000000019d6689c085ae165831e93": "21c895fa-e105-4829-9434-378bb54fa600",
    "000000000933ea01ad0ee984209779ba": "220bcb01-ba47-41d3-fe5b-e29bbc4a4b00"
  },
  ConnectorImageIds: {
    [ConstantsUtil$4.CONNECTOR_ID.COINBASE]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
    [ConstantsUtil$4.CONNECTOR_ID.COINBASE_SDK]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
    [ConstantsUtil$4.CONNECTOR_ID.SAFE]: "461db637-8616-43ce-035a-d89b8a1d5800",
    [ConstantsUtil$4.CONNECTOR_ID.LEDGER]: "54a1aa77-d202-4f8d-0fb2-5d2bb6db0300",
    [ConstantsUtil$4.CONNECTOR_ID.WALLET_CONNECT]: "ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400",
    [ConstantsUtil$4.CONNECTOR_ID.INJECTED]: "07ba87ed-43aa-4adf-4540-9e6a2b9cae00"
  },
  ConnectorNamesMap: {
    [ConstantsUtil$4.CONNECTOR_ID.INJECTED]: "Browser Wallet",
    [ConstantsUtil$4.CONNECTOR_ID.WALLET_CONNECT]: "WalletConnect",
    [ConstantsUtil$4.CONNECTOR_ID.COINBASE]: "Coinbase",
    [ConstantsUtil$4.CONNECTOR_ID.COINBASE_SDK]: "Coinbase",
    [ConstantsUtil$4.CONNECTOR_ID.LEDGER]: "Ledger",
    [ConstantsUtil$4.CONNECTOR_ID.SAFE]: "Safe"
  },
  ConnectorTypesMap: {
    [ConstantsUtil$4.CONNECTOR_ID.INJECTED]: "INJECTED",
    [ConstantsUtil$4.CONNECTOR_ID.WALLET_CONNECT]: "WALLET_CONNECT",
    [ConstantsUtil$4.CONNECTOR_ID.EIP6963]: "ANNOUNCED",
    [ConstantsUtil$4.CONNECTOR_ID.AUTH]: "AUTH"
  }
};
const HelpersUtil = {
  getCaipTokens(tokens) {
    if (!tokens) {
      return void 0;
    }
    const caipTokens = {};
    Object.entries(tokens).forEach(([id2, token]) => {
      caipTokens[`${ConstantsUtil$1.EIP155}:${id2}`] = token;
    });
    return caipTokens;
  },
  isLowerCaseMatch(str1, str2) {
    return (str1 == null ? void 0 : str1.toLowerCase()) === (str2 == null ? void 0 : str2.toLowerCase());
  }
};
const ErrorUtil = {
  UniversalProviderErrors: {
    UNAUTHORIZED_DOMAIN_NOT_ALLOWED: {
      message: "Unauthorized: origin not allowed",
      alertErrorKey: "INVALID_APP_CONFIGURATION"
    },
    JWT_VALIDATION_ERROR: {
      message: "JWT validation error: JWT Token is not yet valid",
      alertErrorKey: "JWT_TOKEN_NOT_VALID"
    },
    INVALID_KEY: {
      message: "Unauthorized: invalid key",
      alertErrorKey: "INVALID_PROJECT_ID"
    }
  },
  ALERT_ERRORS: {
    SWITCH_NETWORK_NOT_FOUND: {
      shortMessage: "Network Not Found",
      longMessage: "Network not found - please make sure it is included in 'networks' array in createAppKit function"
    },
    INVALID_APP_CONFIGURATION: {
      shortMessage: "Invalid App Configuration",
      longMessage: () => `Origin ${isSafe() ? window.origin : "unknown"} not found on Allowlist - update configuration on cloud.reown.com`
    },
    SOCIALS_TIMEOUT: {
      shortMessage: "Invalid App Configuration",
      longMessage: () => "There was an issue loading the embedded wallet. Please verify that your domain is allowed at cloud.reown.com"
    },
    JWT_TOKEN_NOT_VALID: {
      shortMessage: "Session Expired",
      longMessage: "Invalid session found on UniversalProvider - please check your time settings and connect again"
    },
    INVALID_PROJECT_ID: {
      shortMessage: "Invalid App Configuration",
      longMessage: "Invalid Project ID - update configuration"
    },
    PROJECT_ID_NOT_CONFIGURED: {
      shortMessage: "Project ID Not Configured",
      longMessage: "Project ID Not Configured - update configuration on cloud.reown.com"
    }
  }
};
function isSafe() {
  return typeof window !== "undefined";
}
const LoggerUtil = {
  createLogger(onError, level = "error") {
    const loggerOptions = k$7({
      level
    });
    const { logger } = A$4({
      opts: loggerOptions
    });
    logger.error = (...args) => {
      for (const arg of args) {
        if (arg instanceof Error) {
          onError(arg, ...args);
          return;
        }
      }
      onError(void 0, ...args);
    };
    return logger;
  }
};
const RPC_URL_HOST = "rpc.walletconnect.org";
const WC_HTTP_RPC_SUPPORTED_CHAINS = [
  "near:mainnet",
  "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  "eip155:1101",
  "eip155:56",
  "eip155:42161",
  "eip155:7777777",
  "eip155:59144",
  "eip155:324",
  "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
  "eip155:5000",
  "solana:4sgjmw1sunhzsxgspuhpqldx6wiyjntz",
  "eip155:80084",
  "eip155:5003",
  "eip155:100",
  "eip155:8453",
  "eip155:42220",
  "eip155:1313161555",
  "eip155:17000",
  "eip155:1",
  "eip155:300",
  "eip155:1313161554",
  "eip155:1329",
  "eip155:84532",
  "eip155:421614",
  "eip155:11155111",
  "eip155:8217",
  "eip155:43114",
  "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
  "eip155:999999999",
  "eip155:11155420",
  "eip155:80002",
  "eip155:97",
  "eip155:43113",
  "eip155:137",
  "eip155:10",
  "eip155:1301",
  "bip122:000000000019d6689c085ae165831e93",
  "bip122:000000000933ea01ad0ee984209779ba"
];
const CaipNetworksUtil = {
  extendRpcUrlWithProjectId(rpcUrl, projectId) {
    let isReownUrl = false;
    try {
      const url = new URL(rpcUrl);
      isReownUrl = url.host === RPC_URL_HOST;
    } catch (e3) {
      isReownUrl = false;
    }
    if (isReownUrl) {
      const url = new URL(rpcUrl);
      if (!url.searchParams.has("projectId")) {
        url.searchParams.set("projectId", projectId);
      }
      return url.toString();
    }
    return rpcUrl;
  },
  isCaipNetwork(network) {
    return "chainNamespace" in network && "caipNetworkId" in network;
  },
  getChainNamespace(network) {
    if (this.isCaipNetwork(network)) {
      return network.chainNamespace;
    }
    return ConstantsUtil$4.CHAIN.EVM;
  },
  getCaipNetworkId(network) {
    if (this.isCaipNetwork(network)) {
      return network.caipNetworkId;
    }
    return `${ConstantsUtil$4.CHAIN.EVM}:${network.id}`;
  },
  getDefaultRpcUrl(caipNetwork, caipNetworkId, projectId) {
    var _a3, _b2, _c3;
    const defaultRpcUrl = (_c3 = (_b2 = (_a3 = caipNetwork.rpcUrls) == null ? void 0 : _a3.default) == null ? void 0 : _b2.http) == null ? void 0 : _c3[0];
    return defaultRpcUrl || "";
  },
  extendCaipNetwork(caipNetwork, { customNetworkImageUrls, projectId, customRpc }) {
    var _a3, _b2, _c3, _d;
    const caipNetworkId = this.getCaipNetworkId(caipNetwork);
    const chainNamespace = this.getChainNamespace(caipNetwork);
    const chainDefaultUrl = (_c3 = (_b2 = (_a3 = caipNetwork == null ? void 0 : caipNetwork.rpcUrls) == null ? void 0 : _a3["chainDefault"]) == null ? void 0 : _b2.http) == null ? void 0 : _c3[0];
    let rpcUrl = "";
    if (customRpc) {
      rpcUrl = ((_d = caipNetwork.rpcUrls.default.http) == null ? void 0 : _d[0]) || "";
    } else {
      rpcUrl = this.getDefaultRpcUrl(caipNetwork, caipNetworkId, projectId);
    }
    return {
      ...caipNetwork,
      chainNamespace,
      caipNetworkId,
      assets: {
        imageId: PresetsUtil.NetworkImageIds[caipNetwork.id],
        imageUrl: customNetworkImageUrls == null ? void 0 : customNetworkImageUrls[caipNetwork.id]
      },
      rpcUrls: {
        ...caipNetwork.rpcUrls,
        default: {
          http: [rpcUrl]
        },
        chainDefault: {
          http: [chainDefaultUrl || caipNetwork.rpcUrls.default.http[0] || ""]
        }
      }
    };
  },
  extendCaipNetworks(caipNetworks, { customNetworkImageUrls, projectId, customRpcChainIds }) {
    return caipNetworks.map((caipNetwork) => CaipNetworksUtil.extendCaipNetwork(caipNetwork, {
      customNetworkImageUrls,
      projectId,
      customRpc: customRpcChainIds == null ? void 0 : customRpcChainIds.includes(caipNetwork.id)
    }));
  },
  getViemTransport(caipNetwork) {
    var _a3;
    const defaultRpcUrl = (_a3 = caipNetwork.rpcUrls.default.http) == null ? void 0 : _a3[0];
    if (!WC_HTTP_RPC_SUPPORTED_CHAINS.includes(caipNetwork.caipNetworkId)) {
      return http(defaultRpcUrl);
    }
    return fallback([
      http(defaultRpcUrl, {
        fetchOptions: {
          headers: {
            "Content-Type": "text/plain"
          }
        }
      }),
      http(defaultRpcUrl)
    ]);
  }
};
var SocialProviderEnum;
(function(SocialProviderEnum2) {
  SocialProviderEnum2["Google"] = "google";
  SocialProviderEnum2["Github"] = "github";
  SocialProviderEnum2["Apple"] = "apple";
  SocialProviderEnum2["Facebook"] = "facebook";
  SocialProviderEnum2["X"] = "x";
  SocialProviderEnum2["Discord"] = "discord";
  SocialProviderEnum2["Farcaster"] = "farcaster";
})(SocialProviderEnum || (SocialProviderEnum = {}));
const PACKAGE_VERSION = "1.18.2-alpha.0";
class W3mFrameProviderSingleton {
  // eslint-disable-next-line @typescript-eslint/no-empty-function -- This is a singleton
  constructor() {
  }
  static getInstance({ projectId, chainId, enableLogger, onTimeout }) {
    if (!W3mFrameProviderSingleton.instance) {
      W3mFrameProviderSingleton.instance = new W3mFrameProvider({
        projectId,
        chainId,
        enableLogger,
        onTimeout
      });
    }
    return W3mFrameProviderSingleton.instance;
  }
}
const CLEAN_PROVIDERS_STATE = {
  eip155: void 0,
  solana: void 0,
  polkadot: void 0,
  bip122: void 0
};
const state$2 = proxy({
  providers: { ...CLEAN_PROVIDERS_STATE },
  providerIds: { ...CLEAN_PROVIDERS_STATE }
});
const ProviderUtil = {
  state: state$2,
  subscribeKey(key2, callback) {
    return subscribeKey(state$2, key2, callback);
  },
  subscribeProviders(callback) {
    return subscribe(state$2.providers, () => callback(state$2.providers));
  },
  setProvider(chainNamespace, provider) {
    if (provider) {
      state$2.providers[chainNamespace] = ref$1(provider);
    }
  },
  getProvider(chainNamespace) {
    const provider = state$2.providers[chainNamespace];
    return provider;
  },
  setProviderId(chainNamespace, providerId) {
    if (providerId) {
      state$2.providerIds[chainNamespace] = providerId;
    }
  },
  getProviderId(chainNamespace) {
    const providerId = state$2.providerIds[chainNamespace];
    return providerId;
  },
  reset() {
    state$2.providers = { ...CLEAN_PROVIDERS_STATE };
    state$2.providerIds = { ...CLEAN_PROVIDERS_STATE };
  },
  resetChain(chainNamespace) {
    state$2.providers[chainNamespace] = void 0;
    state$2.providerIds[chainNamespace] = void 0;
  }
};
function base(ALPHABET2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  const BASE_MAP = new Uint8Array(256);
  for (let j2 = 0; j2 < BASE_MAP.length; j2++) {
    BASE_MAP[j2] = 255;
  }
  for (let i4 = 0; i4 < ALPHABET2.length; i4++) {
    const x2 = ALPHABET2.charAt(i4);
    const xc3 = x2.charCodeAt(0);
    if (BASE_MAP[xc3] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc3] = i4;
  }
  const BASE = ALPHABET2.length;
  const LEADER = ALPHABET2.charAt(0);
  const FACTOR = Math.log(BASE) / Math.log(256);
  const iFACTOR = Math.log(256) / Math.log(BASE);
  function encode4(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    let zeroes = 0;
    let length = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    const size2 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    const b58 = new Uint8Array(size2);
    while (pbegin !== pend) {
      let carry = source[pbegin];
      let i4 = 0;
      for (let it1 = size2 - 1; (carry !== 0 || i4 < length) && it1 !== -1; it1--, i4++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i4;
      pbegin++;
    }
    let it22 = size2 - length;
    while (it22 !== size2 && b58[it22] === 0) {
      it22++;
    }
    let str = LEADER.repeat(zeroes);
    for (; it22 < size2; ++it22) {
      str += ALPHABET2.charAt(b58[it22]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    let psz = 0;
    let zeroes = 0;
    let length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    const size2 = (source.length - psz) * FACTOR + 1 >>> 0;
    const b256 = new Uint8Array(size2);
    while (psz < source.length) {
      const charCode = source.charCodeAt(psz);
      if (charCode > 255) {
        return;
      }
      let carry = BASE_MAP[charCode];
      if (carry === 255) {
        return;
      }
      let i4 = 0;
      for (let it32 = size2 - 1; (carry !== 0 || i4 < length) && it32 !== -1; it32--, i4++) {
        carry += BASE * b256[it32] >>> 0;
        b256[it32] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i4;
      psz++;
    }
    let it4 = size2 - length;
    while (it4 !== size2 && b256[it4] === 0) {
      it4++;
    }
    const vch = new Uint8Array(zeroes + (size2 - it4));
    let j2 = zeroes;
    while (it4 !== size2) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode2(string2) {
    const buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error("Non-base" + BASE + " character");
  }
  return {
    encode: encode4,
    decodeUnsafe,
    decode: decode2
  };
}
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const bs58 = base(ALPHABET);
const WcConstantsUtil = {
  ERROR_CODE_UNRECOGNIZED_CHAIN_ID: 4902,
  ERROR_CODE_DEFAULT: 5e3,
  ERROR_INVALID_CHAIN_ID: 32603
};
const bscMainnet = defineChain({
  id: 56,
  name: "BSC Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "BNB"
  },
  network: "bnb",
  rpcUrls: {
    default: {
      http: ["https://bsc-mainnet.crosstoken.io/2272489872e4f1475ff25d57ce93b51989f933c7"]
    }
  },
  blockExplorers: {
    default: {
      name: "BscScan",
      url: "https://bscscan.com",
      apiUrl: "https://api.bscscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15921452
    }
  },
  testnet: false,
  chainNamespace: "eip155",
  caipNetworkId: "eip155:56"
});
const bscTestnet = defineChain({
  id: 97,
  name: "BSC Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "tBNB"
  },
  network: "bsc-testnet",
  rpcUrls: {
    default: {
      http: ["https://bsc-testnet.crosstoken.io/110ea3628b77f244e5dbab16790d81bba874b962"]
    }
  },
  blockExplorers: {
    default: {
      name: "BscScan",
      url: "https://testnet.bscscan.com",
      apiUrl: "https://api-testnet.bscscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 17422483
    }
  },
  testnet: true,
  chainNamespace: "eip155",
  caipNetworkId: "eip155:97"
});
const crossMainnet = defineChain({
  id: 612055,
  name: "CROSS Mainnet",
  network: "cross",
  nativeCurrency: { name: "CROSS", symbol: "CROSS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.crosstoken.io:22001"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://www.crossscan.io"
    }
  },
  testnet: false,
  chainNamespace: "eip155",
  caipNetworkId: "eip155:612055"
});
const crossTestnet = defineChain({
  id: 612044,
  name: "CROSS Testnet",
  network: "cross-testnet",
  nativeCurrency: { name: "CROSS", symbol: "CROSS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.crosstoken.io:22001"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet.crossscan.io/"
    }
  },
  testnet: true,
  chainNamespace: "eip155",
  caipNetworkId: "eip155:612044"
});
const etherMainnet = defineChain({
  id: 1,
  name: "Ether Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  network: "ethereum",
  rpcUrls: {
    default: {
      http: ["https://eth-mainnet.crosstoken.io/fad29a23391f6d6e8fb41fb8eecbcca82343b378"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ether scan",
      url: "https://etherscan.io/"
      // ApiUrl: 'https://api.bscscan.com/api'
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  },
  testnet: false,
  chainNamespace: "eip155",
  caipNetworkId: "eip155:1"
});
const etherTestnet = defineChain({
  id: 11155111,
  name: "Ether Testnet (Sepolia)",
  nativeCurrency: {
    decimals: 18,
    name: "Sepolia",
    symbol: "ETH"
  },
  network: "sepolia",
  rpcUrls: {
    default: {
      http: ["https://sepolia.crosstoken.io/8de52516c154dce8cc2ceaae39d657a1e1e74d2f"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ether Sepolia scan",
      url: "https://sepolia.etherscan.io/"
      // ApiUrl: 'https://api.bscscan.com/api'
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 751532
    }
  },
  testnet: true,
  chainNamespace: "eip155",
  caipNetworkId: "eip155:11155111"
});
const kaiaMainnet = defineChain({
  id: 8217,
  name: "Kaia Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "KAIA",
    symbol: "KAIA"
  },
  network: "kaia",
  rpcUrls: {
    default: {
      http: ["https://kaia-mainnet-ext.crosstoken.io/815b8a6e389b34a4f82cfd1e501692dee2f4e8f5"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kaia Scan",
      url: "https://kaiascan.io/"
      // ApiUrl: 'https://api.bscscan.com/api'
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 96002415
    }
  },
  testnet: false,
  chainNamespace: "eip155",
  caipNetworkId: "eip155:8217"
});
const kaiaTestnet = defineChain({
  id: 1001,
  name: "Kaia Testnet (Kairos)",
  nativeCurrency: {
    decimals: 18,
    name: "KAIA",
    symbol: "tKAIA"
  },
  network: "kaia-testnet",
  rpcUrls: {
    default: {
      http: ["https://kaia-testnet.crosstoken.io/fda0d5a47e2d0768e9329444295a3f0681fff365"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kairos Scan",
      url: "https://kairos.kaiascan.io/"
      // ApiUrl: 'https://api-testnet.bscscan.com/api'
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 123390593
    }
  },
  testnet: true,
  chainNamespace: "eip155",
  caipNetworkId: "eip155:1001"
});
function defineChain(chain) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...chain
  };
}
const networkList = [
  crossTestnet,
  crossMainnet,
  bscTestnet,
  bscMainnet,
  kaiaTestnet,
  kaiaMainnet,
  etherTestnet,
  etherMainnet
];
const solana = defineChain({
  id: "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  name: "Solana",
  network: "solana-mainnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: false,
  chainNamespace: "solana",
  caipNetworkId: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  deprecatedCaipNetworkId: "solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ"
});
const solanaDevnet = defineChain({
  id: "EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
  name: "Solana Devnet",
  network: "solana-devnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: true,
  chainNamespace: "solana",
  caipNetworkId: "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
  deprecatedCaipNetworkId: "solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K"
});
defineChain({
  id: "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
  name: "Solana Testnet",
  network: "solana-testnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: true,
  chainNamespace: "solana",
  caipNetworkId: "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z"
});
defineChain({
  id: "000000000019d6689c085ae165831e93",
  caipNetworkId: "bip122:000000000019d6689c085ae165831e93",
  chainNamespace: "bip122",
  name: "Bitcoin",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 8
  },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  }
});
defineChain({
  id: "000000000933ea01ad0ee984209779ba",
  caipNetworkId: "bip122:000000000933ea01ad0ee984209779ba",
  chainNamespace: "bip122",
  name: "Bitcoin Testnet",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 8
  },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  testnet: true
});
const WcHelpersUtil = {
  getMethodsByChainNamespace(chainNamespace) {
    switch (chainNamespace) {
      case "solana":
        return [
          "solana_signMessage",
          "solana_signTransaction",
          "solana_requestAccounts",
          "solana_getAccounts",
          "solana_signAllTransactions",
          "solana_signAndSendTransaction"
        ];
      case "eip155":
        return [
          "eth_accounts",
          "eth_requestAccounts",
          "eth_sendRawTransaction",
          "eth_sign",
          "eth_signTransaction",
          "eth_signTypedData",
          "eth_signTypedData_v3",
          "eth_signTypedData_v4",
          "eth_sendTransaction",
          "personal_sign",
          "wallet_switchEthereumChain",
          "wallet_addEthereumChain",
          "wallet_getPermissions",
          "wallet_requestPermissions",
          "wallet_registerOnboarding",
          "wallet_watchAsset",
          "wallet_scanQRCode",
          // EIP-5792
          "wallet_getCallsStatus",
          "wallet_showCallsStatus",
          "wallet_sendCalls",
          "wallet_getCapabilities",
          // EIP-7715
          "wallet_grantPermissions",
          "wallet_revokePermissions",
          //EIP-7811
          "wallet_getAssets"
        ];
      case "bip122":
        return ["sendTransfer", "signMessage", "signPsbt", "getAccountAddresses"];
      default:
        return [];
    }
  },
  createNamespaces(caipNetworks) {
    return caipNetworks.reduce((acc, chain) => {
      const { id: id2, chainNamespace, rpcUrls } = chain;
      const rpcUrl = rpcUrls.default.http[0];
      const methods = this.getMethodsByChainNamespace(chainNamespace);
      if (!acc[chainNamespace]) {
        acc[chainNamespace] = {
          methods,
          events: ["accountsChanged", "chainChanged"],
          chains: [],
          rpcMap: {}
        };
      }
      const caipNetworkId = `${chainNamespace}:${id2}`;
      const namespace = acc[chainNamespace];
      namespace.chains.push(caipNetworkId);
      switch (caipNetworkId) {
        case solana.caipNetworkId:
          namespace.chains.push(solana.deprecatedCaipNetworkId);
          break;
        case solanaDevnet.caipNetworkId:
          namespace.chains.push(solanaDevnet.deprecatedCaipNetworkId);
          break;
      }
      if ((namespace == null ? void 0 : namespace.rpcMap) && rpcUrl) {
        namespace.rpcMap[id2] = rpcUrl;
      }
      return acc;
    }, {});
  },
  resolveReownName: async (name) => {
    var _a3;
    const wcNameAddress = await EnsController.resolveName(name);
    const networkNameAddresses = Object.values(wcNameAddress == null ? void 0 : wcNameAddress.addresses) || [];
    return ((_a3 = networkNameAddresses[0]) == null ? void 0 : _a3.address) || false;
  },
  getChainsFromNamespaces(namespaces = {}) {
    return Object.values(namespaces).flatMap((namespace) => {
      const chains = namespace.chains || [];
      const accountsChains = namespace.accounts.map((account) => {
        const [chainNamespace, chainId] = account.split(":");
        return `${chainNamespace}:${chainId}`;
      });
      return Array.from(/* @__PURE__ */ new Set([...chains, ...accountsChains]));
    });
  },
  isSessionEventData(data2) {
    return typeof data2 === "object" && data2 !== null && "id" in data2 && "topic" in data2 && "params" in data2 && typeof data2.params === "object" && data2.params !== null && "chainId" in data2.params && "event" in data2.params && typeof data2.params.event === "object" && data2.params.event !== null;
  }
};
class WalletConnectConnector {
  constructor({ provider, caipNetworks, namespace }) {
    this.id = ConstantsUtil$4.CONNECTOR_ID.WALLET_CONNECT;
    this.name = PresetsUtil.ConnectorNamesMap[ConstantsUtil$4.CONNECTOR_ID.WALLET_CONNECT];
    this.type = "WALLET_CONNECT";
    this.imageId = PresetsUtil.ConnectorImageIds[ConstantsUtil$4.CONNECTOR_ID.WALLET_CONNECT];
    this.caipNetworks = caipNetworks;
    this.provider = provider;
    this.chain = namespace;
  }
  get chains() {
    return this.caipNetworks;
  }
  async connectWalletConnect() {
    const optionalNamespaces = WcHelpersUtil.createNamespaces(this.caipNetworks);
    await this.provider.connect({
      optionalNamespaces
    });
    return {
      clientId: await this.provider.client.core.crypto.getClientId(),
      session: this.provider.session
    };
  }
  async authenticateWalletConnect() {
    const result = await this.authenticate();
    if (!result.authenticated) {
      const optionalNamespaces = WcHelpersUtil.createNamespaces(this.caipNetworks);
      await this.provider.connect({
        optionalNamespaces
      });
      return { authenticated: false, sessions: [] };
    }
    return result;
  }
  async disconnect() {
    await this.provider.disconnect();
  }
  async authenticate() {
    const chains = this.chains.map((network) => network.caipNetworkId);
    return SIWXUtil.universalProviderAuthenticate({
      universalProvider: this.provider,
      chains,
      methods: OPTIONAL_METHODS
    });
  }
}
const OPTIONAL_METHODS = [
  "eth_accounts",
  "eth_requestAccounts",
  "eth_sendRawTransaction",
  "eth_sign",
  "eth_signTransaction",
  "eth_signTypedData",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4",
  "eth_sendTransaction",
  "personal_sign",
  "wallet_switchEthereumChain",
  "wallet_addEthereumChain",
  "wallet_getPermissions",
  "wallet_requestPermissions",
  "wallet_registerOnboarding",
  "wallet_watchAsset",
  "wallet_scanQRCode",
  // EIP-5792
  "wallet_getCallsStatus",
  "wallet_sendCalls",
  "wallet_getCapabilities",
  // EIP-7715
  "wallet_grantPermissions",
  "wallet_revokePermissions",
  //EIP-7811
  "wallet_getAssets"
];
class AdapterBlueprint {
  /**
   * Creates an instance of AdapterBlueprint.
   * @param {AdapterBlueprint.Params} params - The parameters for initializing the adapter
   */
  constructor(params) {
    this.availableConnectors = [];
    this.eventListeners = /* @__PURE__ */ new Map();
    if (params) {
      this.construct(params);
    }
  }
  /**
   * Initializes the adapter with the given parameters.
   * @param {AdapterBlueprint.Params} params - The parameters for initializing the adapter
   */
  construct(params) {
    this.caipNetworks = params.networks;
    this.projectId = params.projectId;
    this.namespace = params.namespace;
  }
  /**
   * Gets the available connectors.
   * @returns {Connector[]} An array of available connectors
   */
  get connectors() {
    return this.availableConnectors;
  }
  /**
   * Gets the supported networks.
   * @returns {CaipNetwork[]} An array of supported networks
   */
  get networks() {
    return this.caipNetworks || [];
  }
  /**
   * Sets the auth provider.
   * @param {W3mFrameProvider} authProvider - The auth provider instance
   */
  setAuthProvider(authProvider) {
    this.addConnector({
      id: ConstantsUtil$4.CONNECTOR_ID.AUTH,
      type: "AUTH",
      name: ConstantsUtil$4.CONNECTOR_NAMES.AUTH,
      provider: authProvider,
      imageId: PresetsUtil.ConnectorImageIds[ConstantsUtil$4.CONNECTOR_ID.AUTH],
      chain: this.namespace,
      chains: []
    });
  }
  /**
   * Adds one or more connectors to the available connectors list.
   * @param {...Connector} connectors - The connectors to add
   */
  addConnector(...connectors) {
    const connectorsAdded = /* @__PURE__ */ new Set();
    this.availableConnectors = [...connectors, ...this.availableConnectors].filter((connector) => {
      if (connectorsAdded.has(connector.id)) {
        return false;
      }
      connectorsAdded.add(connector.id);
      return true;
    });
    this.emit("connectors", this.availableConnectors);
  }
  setStatus(status, chainNamespace) {
    AccountController.setStatus(status, chainNamespace);
  }
  /**
   * Adds an event listener for a specific event.
   * @template T
   * @param {T} eventName - The name of the event
   * @param {EventCallback<T>} callback - The callback function to be called when the event is emitted
   */
  on(eventName, callback) {
    var _a3;
    if (!this.eventListeners.has(eventName)) {
      this.eventListeners.set(eventName, /* @__PURE__ */ new Set());
    }
    (_a3 = this.eventListeners.get(eventName)) == null ? void 0 : _a3.add(callback);
  }
  /**
   * Removes an event listener for a specific event.
   * @template T
   * @param {T} eventName - The name of the event
   * @param {EventCallback<T>} callback - The callback function to be removed
   */
  off(eventName, callback) {
    const listeners2 = this.eventListeners.get(eventName);
    if (listeners2) {
      listeners2.delete(callback);
    }
  }
  /**
   * Removes all event listeners.
   */
  removeAllEventListeners() {
    this.eventListeners.forEach((listeners2) => {
      listeners2.clear();
    });
  }
  /**
   * Emits an event with the given name and optional data.
   * @template T
   * @param {T} eventName - The name of the event to emit
   * @param {EventData[T]} [data] - The optional data to be passed to the event listeners
   */
  emit(eventName, data2) {
    const listeners2 = this.eventListeners.get(eventName);
    if (listeners2) {
      listeners2.forEach((callback) => callback(data2));
    }
  }
  /**
   * Connects to WalletConnect.
   * @param {number | string} [_chainId] - Optional chain ID to connect to
   */
  async connectWalletConnect(_chainId3) {
    const connector = this.getWalletConnectConnector();
    const result = await connector.connectWalletConnect();
    return { clientId: result.clientId };
  }
  /**
   * Switches the network.
   * @param {AdapterBlueprint.SwitchNetworkParams} params - Network switching parameters
   */
  async switchNetwork(params) {
    const { caipNetwork, providerType } = params;
    if (!params.provider) {
      return;
    }
    const provider = "provider" in params.provider ? params.provider.provider : params.provider;
    if (providerType === "WALLET_CONNECT") {
      provider.setDefaultChain(caipNetwork.caipNetworkId);
      return;
    }
    if (provider && providerType === "AUTH") {
      const authProvider = provider;
      await authProvider.switchNetwork(caipNetwork.caipNetworkId);
      const user = await authProvider.getUser({
        chainId: caipNetwork.caipNetworkId,
        preferredAccountType: OptionsController.state.defaultAccountTypes[caipNetwork.chainNamespace]
      });
      this.emit("switchNetwork", user);
    }
  }
  getWalletConnectConnector() {
    const connector = this.connectors.find((c2) => c2 instanceof WalletConnectConnector);
    if (!connector) {
      throw new Error("WalletConnectConnector not found");
    }
    return connector;
  }
  async authenticateWalletConnect() {
    const connector = this.getWalletConnectConnector();
    const result = await connector.authenticateWalletConnect();
    return result;
  }
}
class UniversalAdapter extends AdapterBlueprint {
  setUniversalProvider(universalProvider) {
    this.addConnector(new WalletConnectConnector({
      provider: universalProvider,
      caipNetworks: this.caipNetworks || [],
      namespace: this.namespace
    }));
  }
  async connect(params) {
    return Promise.resolve({
      id: "WALLET_CONNECT",
      type: "WALLET_CONNECT",
      chainId: Number(params.chainId),
      provider: this.provider,
      address: ""
    });
  }
  async disconnect() {
    try {
      const connector = this.getWalletConnectConnector();
      await connector.disconnect();
    } catch (error) {
      console.warn("UniversalAdapter:disconnect - error", error);
    }
  }
  async getAccounts({ namespace }) {
    var _a3, _b2, _c3, _d;
    const provider = this.provider;
    const addresses = ((_d = (_c3 = (_b2 = (_a3 = provider == null ? void 0 : provider.session) == null ? void 0 : _a3.namespaces) == null ? void 0 : _b2[namespace]) == null ? void 0 : _c3.accounts) == null ? void 0 : _d.map((account) => {
      const [, , address] = account.split(":");
      return address;
    }).filter((address, index2, self2) => self2.indexOf(address) === index2)) || [];
    return Promise.resolve({
      accounts: addresses.map((address) => CoreHelperUtil.createAccount(namespace, address, namespace === "bip122" ? "payment" : "eoa"))
    });
  }
  async syncConnectors() {
    return Promise.resolve();
  }
  async getBalance(params) {
    var _a3, _b2, _c3, _d, _e4;
    const isBalanceSupported = params.caipNetwork && ConstantsUtil$3.BALANCE_SUPPORTED_CHAINS.includes((_a3 = params.caipNetwork) == null ? void 0 : _a3.chainNamespace);
    if (!isBalanceSupported || ((_b2 = params.caipNetwork) == null ? void 0 : _b2.testnet)) {
      return {
        balance: "0.00",
        symbol: ((_c3 = params.caipNetwork) == null ? void 0 : _c3.nativeCurrency.symbol) || ""
      };
    }
    if (AccountController.state.balanceLoading && params.chainId === ((_d = ChainController.state.activeCaipNetwork) == null ? void 0 : _d.id)) {
      return {
        balance: AccountController.state.balance || "0.00",
        symbol: AccountController.state.balanceSymbol || ""
      };
    }
    const balances = await AccountController.fetchTokenBalance();
    const balance = balances.find((b2) => {
      var _a4, _b3;
      return b2.chainId === `${(_a4 = params.caipNetwork) == null ? void 0 : _a4.chainNamespace}:${params.chainId}` && b2.symbol === ((_b3 = params.caipNetwork) == null ? void 0 : _b3.nativeCurrency.symbol);
    });
    return {
      balance: (balance == null ? void 0 : balance.quantity.numeric) || "0.00",
      symbol: (balance == null ? void 0 : balance.symbol) || ((_e4 = params.caipNetwork) == null ? void 0 : _e4.nativeCurrency.symbol) || ""
    };
  }
  async signEIP712(params) {
    return Promise.resolve({
      signature: ""
    });
  }
  async signTypedDataV4(params) {
    return Promise.resolve({
      signature: ""
    });
  }
  async etherSignMessage(params) {
    var _a3;
    const { provider, message, address } = params;
    if (!provider) {
      throw new Error("UniversalAdapter:etherSignMessage - provider is undefined");
    }
    let signature2 = "";
    if (((_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.chainNamespace) === ConstantsUtil$4.CHAIN.EVM) {
      signature2 = await provider.request({
        method: "eth_sign",
        params: [address, message]
      });
    }
    return { signature: signature2 };
  }
  async signMessage(params) {
    var _a3, _b2, _c3;
    const { provider, message, address, customData } = params;
    if (!provider) {
      throw new Error("UniversalAdapter:signMessage - provider is undefined");
    }
    let signature2 = "";
    if (((_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.chainNamespace) === ConstantsUtil$4.CHAIN.SOLANA) {
      const response = await provider.request({
        method: "solana_signMessage",
        params: {
          message: bs58.encode(new TextEncoder().encode(message)),
          pubkey: address
        }
      }, (_b2 = ChainController.state.activeCaipNetwork) == null ? void 0 : _b2.caipNetworkId);
      signature2 = response.signature;
    } else {
      signature2 = await provider.request({
        method: "personal_sign",
        params: [message, address, customData]
      }, (_c3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _c3.caipNetworkId);
    }
    return { signature: signature2 };
  }
  // -- Transaction methods ---------------------------------------------------
  /**
   *
   * These methods are supported only on `wagmi` and `ethers` since the Solana SDK does not support them in the same way.
   * These function definition is to have a type parity between the clients. Currently not in use.
   */
  async estimateGas() {
    return Promise.resolve({
      gas: BigInt(0)
    });
  }
  async getProfile() {
    return Promise.resolve({
      profileImage: "",
      profileName: ""
    });
  }
  async sendTransaction() {
    return Promise.resolve({
      hash: ""
    });
  }
  walletGetAssets(_params) {
    return Promise.resolve({});
  }
  async writeContract() {
    return Promise.resolve({
      hash: ""
    });
  }
  async readContract() {
    return Promise.resolve({});
  }
  async getEnsAddress() {
    return Promise.resolve({
      address: false
    });
  }
  parseUnits() {
    return 0n;
  }
  formatUnits() {
    return "0";
  }
  async getCapabilities() {
    return Promise.resolve({});
  }
  async grantPermissions() {
    return Promise.resolve({});
  }
  async revokePermissions() {
    return Promise.resolve("0x");
  }
  async syncConnection() {
    return Promise.resolve({
      id: "WALLET_CONNECT",
      type: "WALLET_CONNECT",
      chainId: 1,
      provider: this.provider,
      address: ""
    });
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async switchNetwork(params) {
    var _a3, _b2, _c3, _d, _e4, _f;
    const { caipNetwork } = params;
    const connector = this.getWalletConnectConnector();
    if (caipNetwork.chainNamespace === ConstantsUtil$4.CHAIN.EVM) {
      try {
        await ((_a3 = connector.provider) == null ? void 0 : _a3.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: toHex$2(caipNetwork.id) }]
        }));
      } catch (switchError) {
        if (switchError.code === WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID || switchError.code === WcConstantsUtil.ERROR_INVALID_CHAIN_ID || switchError.code === WcConstantsUtil.ERROR_CODE_DEFAULT || ((_c3 = (_b2 = switchError == null ? void 0 : switchError.data) == null ? void 0 : _b2.originalError) == null ? void 0 : _c3.code) === WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID) {
          try {
            await ((_f = connector.provider) == null ? void 0 : _f.request({
              method: "wallet_addEthereumChain",
              params: [
                {
                  chainId: toHex$2(caipNetwork.id),
                  rpcUrls: [(_d = caipNetwork == null ? void 0 : caipNetwork.rpcUrls["chainDefault"]) == null ? void 0 : _d.http],
                  chainName: caipNetwork.name,
                  nativeCurrency: caipNetwork.nativeCurrency,
                  blockExplorerUrls: [(_e4 = caipNetwork.blockExplorers) == null ? void 0 : _e4.default.url]
                }
              ]
            }));
          } catch (error) {
            throw new Error("Chain is not supported");
          }
        }
      }
    }
    connector.provider.setDefaultChain(caipNetwork.caipNetworkId);
  }
  getWalletConnectProvider() {
    const connector = this.connectors.find((c2) => c2.type === "WALLET_CONNECT");
    const provider = connector == null ? void 0 : connector.provider;
    return provider;
  }
}
const __vite_import_meta_env__ = {};
let isInitialized = false;
var EnvMode;
(function(EnvMode2) {
  EnvMode2["DEV"] = "development";
  EnvMode2["STAGE"] = "stage";
  EnvMode2["PROD"] = "production";
})(EnvMode || (EnvMode = {}));
function getEnv() {
  var _a3, _b2;
  if (__vite_import_meta_env__ == null ? void 0 : __vite_import_meta_env__["VITE_ENV_MODE"]) {
    return __vite_import_meta_env__["VITE_ENV_MODE"];
  }
  if ((_a3 = process$1 == null ? void 0 : process$1.env) == null ? void 0 : _a3["NEXT_PUBLIC_ENV_MODE"]) {
    return process$1.env["NEXT_PUBLIC_ENV_MODE"];
  }
  if ((_b2 = process$1 == null ? void 0 : process$1.env) == null ? void 0 : _b2["NODE_ENV"]) {
    return process$1.env["NODE_ENV"];
  }
  return "production";
}
class AppKit {
  constructor(options) {
    var _a3;
    this.chainNamespaces = [];
    this.initPromise = void 0;
    this.reportedAlertErrors = {};
    this.setStatus = (status, chain) => {
      StorageUtil.setConnectionStatus(status);
      AccountController.setStatus(status, chain);
    };
    this.getIsConnectedState = () => Boolean(ChainController.state.activeCaipAddress);
    this.setAllAccounts = (addresses, chain) => {
      AccountController.setAllAccounts(addresses, chain);
      OptionsController.setHasMultipleAddresses((addresses == null ? void 0 : addresses.length) > 1);
    };
    this.addAddressLabel = (address, label, chain) => {
      AccountController.addAddressLabel(address, label, chain);
    };
    this.removeAddressLabel = (address, chain) => {
      AccountController.removeAddressLabel(address, chain);
    };
    this.getCaipAddress = (chainNamespace) => {
      if (ChainController.state.activeChain === chainNamespace || !chainNamespace) {
        return ChainController.state.activeCaipAddress;
      }
      return ChainController.getAccountProp("caipAddress", chainNamespace);
    };
    this.getAddressByChainNamespace = (chainNamespace) => ChainController.getAccountProp("address", chainNamespace);
    this.getAddress = (chainNamespace) => {
      if (ChainController.state.activeChain === chainNamespace || !chainNamespace) {
        return AccountController.state.address;
      }
      return ChainController.getAccountProp("address", chainNamespace);
    };
    this.getProvider = (namespace) => ProviderUtil.getProvider(namespace);
    this.getProviderType = (namespace) => ProviderUtil.state.providerIds[namespace];
    this.getPreferredAccountType = () => AccountController.state.preferredAccountType;
    this.setCaipAddress = (caipAddress, chain) => {
      AccountController.setCaipAddress(caipAddress, chain);
    };
    this.setBalance = (balance, balanceSymbol, chain) => {
      AccountController.setBalance(balance, balanceSymbol, chain);
    };
    this.setProfileName = (profileName, chain) => {
      AccountController.setProfileName(profileName, chain);
    };
    this.setProfileImage = (profileImage, chain) => {
      AccountController.setProfileImage(profileImage, chain);
    };
    this.setUser = (user, chain) => {
      AccountController.setUser(user, chain);
      if (OptionsController.state.enableEmbedded) {
        ModalController.close();
      }
    };
    this.resetAccount = (chain) => {
      AccountController.resetAccount(chain);
    };
    this.setCaipNetwork = (caipNetwork) => {
      ChainController.setActiveCaipNetwork(caipNetwork);
    };
    this.getCaipNetwork = (chainNamespace) => {
      var _a4;
      if (chainNamespace) {
        return (_a4 = ChainController.getRequestedCaipNetworks(chainNamespace).filter((c2) => c2.chainNamespace === chainNamespace)) == null ? void 0 : _a4[0];
      }
      return ChainController.state.activeCaipNetwork || this.defaultCaipNetwork;
    };
    this.getCaipNetworkId = () => {
      const network = this.getCaipNetwork();
      if (network) {
        return network.id;
      }
      return void 0;
    };
    this.getCaipNetworks = (namespace) => ChainController.getRequestedCaipNetworks(namespace);
    this.getActiveChainNamespace = () => ChainController.state.activeChain;
    this.setRequestedCaipNetworks = (requestedCaipNetworks, chain) => {
      ChainController.setRequestedCaipNetworks(requestedCaipNetworks, chain);
    };
    this.getApprovedCaipNetworkIds = () => ChainController.getAllApprovedCaipNetworkIds();
    this.setApprovedCaipNetworksData = (namespace) => ChainController.setApprovedCaipNetworksData(namespace);
    this.resetNetwork = (namespace) => {
      ChainController.resetNetwork(namespace);
    };
    this.setConnectors = (connectors) => {
      const allConnectors = [...ConnectorController.getConnectors(), ...connectors];
      ConnectorController.setConnectors(allConnectors);
    };
    this.addConnector = (connector) => {
      ConnectorController.addConnector(connector);
    };
    this.getConnectors = () => ConnectorController.getConnectors();
    this.resetWcConnection = () => {
      ConnectionController.resetWcConnection();
    };
    this.fetchIdentity = (request) => BlockchainApiController.fetchIdentity(request);
    this.setAddressExplorerUrl = (addressExplorerUrl, chain) => {
      AccountController.setAddressExplorerUrl(addressExplorerUrl, chain);
    };
    this.setSmartAccountDeployed = (isDeployed, chain) => {
      AccountController.setSmartAccountDeployed(isDeployed, chain);
    };
    this.setConnectedWalletInfo = (connectedWalletInfo, chain) => {
      AccountController.setConnectedWalletInfo(connectedWalletInfo ? { type: ProviderUtil.getProviderId(chain), ...connectedWalletInfo } : void 0, chain);
    };
    this.setSmartAccountEnabledNetworks = (smartAccountEnabledNetworks, chain) => {
      ChainController.setSmartAccountEnabledNetworks(smartAccountEnabledNetworks, chain);
    };
    this.setPreferredAccountType = (preferredAccountType, chain) => {
      AccountController.setPreferredAccountType(preferredAccountType, chain);
    };
    this.getReownName = (address) => EnsController.getNamesForAddress(address);
    this.setEIP6963Enabled = (enabled) => {
      OptionsController.setEIP6963Enabled(enabled);
    };
    this.setClientId = (clientId) => {
      BlockchainApiController.setClientId(clientId);
    };
    this.getConnectorImage = (connector) => AssetUtil.getConnectorImage(connector);
    this.handleUnsafeRPCRequest = () => {
      if (this.isOpen()) {
        if (this.isTransactionStackEmpty()) {
          return;
        }
        this.redirect("ApproveTransaction");
      } else {
        this.open({ view: "ApproveTransaction" });
      }
    };
    this.options = options;
    this.version = options.sdkVersion;
    this.caipNetworks = this.extendCaipNetworks(options);
    this.chainNamespaces = [
      ...new Set((_a3 = this.caipNetworks) == null ? void 0 : _a3.map((caipNetwork) => caipNetwork.chainNamespace))
    ];
    this.defaultCaipNetwork = this.extendDefaultCaipNetwork(options);
    this.chainAdapters = this.createAdapters(options.adapters);
    this.exposeGlobalVersion();
    this.initialize(options);
  }
  static getInstance() {
    return this.instance;
  }
  async initialize(options) {
    this.initControllers(options);
    await this.initChainAdapters();
    await this.injectModalUi();
    await this.syncExistingConnection();
    await this.autoSwitchWalletNetwork();
    PublicStateController.set({ initialized: true });
  }
  /**
   *     SDK Active   
   */
  async autoSwitchWalletNetwork() {
    if (!AccountController.state.address || !ChainController.state.activeCaipNetwork) {
      console.log(`autoSwitchWalletNetwork, No address or activeCaipNetwork`);
      return;
    }
    try {
      const currentChainId = await this.getCurrentWalletChainId();
      console.log(`autoSwitchWalletNetwork, current wallet ChainId: ${currentChainId}`);
      if (currentChainId && currentChainId !== ChainController.state.activeCaipNetwork.id) {
        console.log(` Auto-switching wallet network from ${currentChainId} to ${ChainController.state.activeCaipNetwork.id}`);
        await this.switchNetwork(ChainController.state.activeCaipNetwork);
      } else {
        console.log(`autoSwitchWalletNetwork, current wallet ChainId: ${currentChainId} is the same as the active caip network`);
      }
    } catch (error) {
      console.warn("Failed to auto-switch wallet network:", error);
    }
  }
  /**
   *    ID 
   */
  async getCurrentWalletChainId() {
    try {
      const adapter = this.getAdapter(ChainController.state.activeChain);
      const provider = ProviderUtil.getProvider(ChainController.state.activeChain);
      if (provider) {
        return await provider.request({ method: "eth_chainId" });
      }
    } catch (error) {
      console.warn("Failed to get current wallet chain ID:", error);
    }
    return void 0;
  }
  /**
   *   SDK      
   */
  exposeGlobalVersion() {
    if (typeof window !== "undefined") {
      window.__nexus = {
        ...window.__nexus,
        sdkVersion: PACKAGE_VERSION
      };
      console.log("SDK version:", PACKAGE_VERSION);
    }
  }
  sendInitializeEvent(options) {
    var _a3;
    const { ...optionsCopy } = options;
    delete optionsCopy.adapters;
    EventsController.sendEvent({
      type: "track",
      event: "INITIALIZE",
      properties: {
        ...optionsCopy,
        networks: options.networks.map((n5) => n5.id),
        siweConfig: {
          options: ((_a3 = options.siweConfig) == null ? void 0 : _a3.options) || {}
        }
      }
    });
  }
  // -- Public -------------------------------------------------------------------
  async open(options) {
    await this.injectModalUi();
    if ((options == null ? void 0 : options.uri) && this.universalProvider) {
      ConnectionController.setUri(options.uri);
    }
    if (options == null ? void 0 : options.namespace) {
      ConnectorController.setFilterByNamespace(options.namespace);
    }
    await ModalController.open(options);
  }
  async close() {
    await this.injectModalUi();
    ModalController.close();
  }
  setLoading(loading) {
    ModalController.setLoading(loading);
  }
  // -- Adapter Methods ----------------------------------------------------------
  getError() {
    return "";
  }
  getChainId() {
    var _a3;
    return (_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.id;
  }
  async switchNetwork(appKitNetwork) {
    var _a3;
    const network = (_a3 = this.caipNetworks) == null ? void 0 : _a3.find((n5) => n5.id === appKitNetwork.id);
    if (!network) {
      AlertController.open(ErrorUtil.ALERT_ERRORS.SWITCH_NETWORK_NOT_FOUND, "error");
      return;
    }
    await ChainController.switchActiveNetwork(network);
  }
  getWalletProvider() {
    return ChainController.state.activeChain ? ProviderUtil.state.providers[ChainController.state.activeChain] : null;
  }
  getWalletProviderType() {
    return ChainController.state.activeChain ? ProviderUtil.state.providerIds[ChainController.state.activeChain] : null;
  }
  subscribeProviders(callback) {
    return ProviderUtil.subscribeProviders(callback);
  }
  getThemeMode() {
    return ThemeController.state.themeMode;
  }
  getThemeVariables() {
    return ThemeController.state.themeVariables;
  }
  setThemeMode(themeMode) {
    ThemeController.setThemeMode(themeMode);
    setColorTheme(ThemeController.state.themeMode);
  }
  setTermsConditionsUrl(termsConditionsUrl) {
    OptionsController.setTermsConditionsUrl(termsConditionsUrl);
  }
  setPrivacyPolicyUrl(privacyPolicyUrl) {
    OptionsController.setPrivacyPolicyUrl(privacyPolicyUrl);
  }
  setThemeVariables(themeVariables) {
    ThemeController.setThemeVariables(themeVariables);
    setThemeVariables(ThemeController.state.themeVariables);
  }
  subscribeTheme(callback) {
    return ThemeController.subscribe(callback);
  }
  getWalletInfo() {
    return AccountController.state.connectedWalletInfo;
  }
  subscribeAccount(callback, namespace) {
    function updateVal() {
      const authConnector = ConnectorController.getAuthConnector(namespace);
      const accountState2 = ChainController.getAccountDataByChainNamespace(namespace);
      if (!accountState2) {
        return;
      }
      callback({
        allAccounts: accountState2.allAccounts,
        caipAddress: accountState2.caipAddress,
        address: CoreHelperUtil.getPlainAddress(accountState2.caipAddress),
        isConnected: Boolean(accountState2.caipAddress),
        status: accountState2.status,
        balance: accountState2.balance,
        balanceSymbol: accountState2.balanceSymbol,
        balanceLoading: accountState2.balanceLoading,
        tokenBalance: accountState2.tokenBalance,
        embeddedWalletInfo: authConnector ? {
          user: accountState2.user,
          authProvider: accountState2.socialProvider || "email",
          accountType: accountState2.preferredAccountType,
          isSmartAccountDeployed: Boolean(accountState2.smartAccountDeployed)
        } : void 0
      });
    }
    if (namespace) {
      ChainController.subscribeChainProp("accountState", updateVal, namespace);
    } else {
      ChainController.subscribe(updateVal);
    }
    ConnectorController.subscribe(updateVal);
  }
  subscribeNetwork(callback) {
    return ChainController.subscribe(({ activeCaipNetwork }) => {
      callback({
        caipNetwork: activeCaipNetwork,
        chainId: activeCaipNetwork == null ? void 0 : activeCaipNetwork.id,
        caipNetworkId: activeCaipNetwork == null ? void 0 : activeCaipNetwork.caipNetworkId
      });
    });
  }
  subscribeWalletInfo(callback) {
    return AccountController.subscribeKey("connectedWalletInfo", callback);
  }
  subscribeShouldUpdateToAddress(callback) {
    AccountController.subscribeKey("shouldUpdateToAddress", callback);
  }
  subscribeCaipNetworkChange(callback) {
    ChainController.subscribeKey("activeCaipNetwork", callback);
  }
  getState() {
    return PublicStateController.state;
  }
  subscribeState(callback) {
    return PublicStateController.subscribe(callback);
  }
  showErrorMessage(message) {
    SnackController.showError(message);
  }
  showSuccessMessage(message) {
    SnackController.showSuccess(message);
  }
  getEvent() {
    return { ...EventsController.state };
  }
  subscribeEvents(callback) {
    return EventsController.subscribe(callback);
  }
  replace(route) {
    RouterController.replace(route);
  }
  redirect(route) {
    RouterController.push(route);
  }
  popTransactionStack(cancel) {
    RouterController.popTransactionStack(cancel);
  }
  isOpen() {
    return ModalController.state.open;
  }
  isTransactionStackEmpty() {
    return RouterController.state.transactionStack.length === 0;
  }
  updateFeatures(newFeatures) {
    OptionsController.setFeatures(newFeatures);
  }
  updateOptions(newOptions) {
    const currentOptions = OptionsController.state || {};
    const updatedOptions = { ...currentOptions, ...newOptions };
    OptionsController.setOptions(updatedOptions);
  }
  setConnectMethodsOrder(connectMethodsOrder) {
    OptionsController.setConnectMethodsOrder(connectMethodsOrder);
  }
  setWalletFeaturesOrder(walletFeaturesOrder) {
    OptionsController.setWalletFeaturesOrder(walletFeaturesOrder);
  }
  setCollapseWallets(collapseWallets) {
    OptionsController.setCollapseWallets(collapseWallets);
  }
  setSocialsOrder(socialsOrder) {
    OptionsController.setSocialsOrder(socialsOrder);
  }
  async disconnect() {
    await ConnectionController.disconnect();
  }
  async authenticateWalletConnect() {
    var _a3;
    const adapter = this.getAdapter(ChainController.state.activeChain);
    if (!adapter) {
      throw new Error("Adapter not found");
    }
    await this.open({ view: "ConnectingWalletConnectBasic" });
    const result = await adapter.authenticateWalletConnect();
    if (result.authenticated) {
      this.close();
      this.setClientId(await ((_a3 = this.universalProvider) == null ? void 0 : _a3.client.core.crypto.getClientId()) || null);
      StorageUtil.setConnectedNamespaces([...ChainController.state.chains.keys()]);
      await this.syncWalletConnectAccount();
      return result;
    }
    return { authenticated: false, sessions: [] };
  }
  getConnectMethodsOrder() {
    return WalletUtil$1.getConnectOrderMethod(OptionsController.state.features, ConnectorController.getConnectors());
  }
  /**
   * Removes an adapter from the AppKit.
   * @param namespace - The namespace of the adapter to remove.
   */
  removeAdapter(namespace) {
    var _a3;
    const isConnected = this.getIsConnectedState();
    const adapter = this.getAdapter(namespace);
    if (!adapter || !this.chainAdapters || isConnected) {
      return;
    }
    const newCaipNetworks = (_a3 = this.caipNetworks) == null ? void 0 : _a3.filter((network) => network.chainNamespace !== namespace);
    ChainController.removeAdapter(namespace);
    ConnectorController.removeAdapter(namespace);
    this.chainNamespaces = this.chainNamespaces.filter((n5) => n5 !== namespace);
    this.caipNetworks = newCaipNetworks;
    adapter.removeAllEventListeners();
    Reflect.deleteProperty(this.chainAdapters, namespace);
  }
  /**
   * Adds an adapter to the AppKit.
   * @param adapter - The adapter instance.
   * @param networks - The list of networks that this adapter supports / uses.
   */
  addAdapter(adapter, networks) {
    const namespace = adapter.namespace;
    if (!this.connectionControllerClient || !this.networkControllerClient) {
      return;
    }
    if (!this.chainAdapters || !namespace) {
      return;
    }
    const extendedAdapterNetworks = this.extendCaipNetworks({ ...this.options, networks });
    this.caipNetworks = [...this.caipNetworks || [], ...extendedAdapterNetworks];
    this.createAdapter(adapter);
    this.initChainAdapter(namespace);
    ChainController.addAdapter(adapter, {
      connectionControllerClient: this.connectionControllerClient,
      networkControllerClient: this.networkControllerClient
    }, extendedAdapterNetworks);
  }
  /**
   * Adds a network to an existing adapter in AppKit.
   * @param namespace - The chain namespace to add the network to (e.g. 'eip155', 'solana')
   * @param network - The network configuration to add
   * @throws Error if adapter for namespace doesn't exist
   */
  addNetwork(namespace, network) {
    var _a3;
    if (this.chainAdapters && !this.chainAdapters[namespace]) {
      throw new Error(`Adapter for namespace ${namespace} doesn't exist`);
    }
    const extendedNetwork = this.extendCaipNetwork(network, this.options);
    if (this.caipNetworks && !((_a3 = this.caipNetworks) == null ? void 0 : _a3.find((n5) => n5.id === extendedNetwork.id))) {
      this.caipNetworks.push(extendedNetwork);
      ChainController.addNetwork(extendedNetwork);
    }
  }
  /**
   * Removes a network from an existing adapter in AppKit.
   * @param namespace - The chain namespace the network belongs to
   * @param networkId - The network ID to remove
   * @throws Error if adapter for namespace doesn't exist or if removing last network
   */
  removeNetwork(namespace, networkId) {
    var _a3;
    if (this.chainAdapters && !this.chainAdapters[namespace]) {
      throw new Error(`Adapter for namespace ${namespace} doesn't exist`);
    }
    const networkToRemove = (_a3 = this.caipNetworks) == null ? void 0 : _a3.find((n5) => n5.id === networkId);
    if (!networkToRemove) {
      throw new Error(`Network with ID ${networkId} not found`);
    }
    if (!this.caipNetworks) {
      return;
    }
    const remainingAllNetworks = this.caipNetworks.filter((n5) => n5.id !== networkId);
    const remainingNamespaceNetworks = this.caipNetworks.filter((n5) => n5.id !== networkId && n5.chainNamespace === namespace);
    if (!(remainingNamespaceNetworks == null ? void 0 : remainingNamespaceNetworks.length)) {
      throw new Error("Cannot remove last network for a namespace");
    }
    ChainController.removeNetwork(namespace, networkId);
    this.caipNetworks = [...remainingAllNetworks];
  }
  // -- Private ------------------------------------------------------------------
  initializeOptionsController(options) {
    var _a3;
    OptionsController.setDebug(options.debug !== false);
    if (!options.projectId) {
      AlertController.open(ErrorUtil.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
      return;
    }
    OptionsController.setEnableWalletConnect(options.enableWalletConnect !== false);
    OptionsController.setEnableWalletGuide(options.enableWalletGuide !== false);
    OptionsController.setEnableWallets(options.enableWallets !== false);
    OptionsController.setEIP6963Enabled(options.enableEIP6963 !== false);
    OptionsController.setEnableAuthLogger(options.enableAuthLogger !== false);
    OptionsController.setSdkVersion(options.sdkVersion);
    OptionsController.setProjectId(options.projectId);
    OptionsController.setEnableEmbedded(options.enableEmbedded);
    OptionsController.setAllWallets(options.allWallets);
    OptionsController.setIncludeWalletIds(options.includeWalletIds);
    OptionsController.setExcludeWalletIds(options.excludeWalletIds);
    OptionsController.setFeaturedWalletIds(options.featuredWalletIds);
    OptionsController.setTokens(options.tokens);
    OptionsController.setTermsConditionsUrl(options.termsConditionsUrl);
    OptionsController.setPrivacyPolicyUrl(options.privacyPolicyUrl);
    OptionsController.setCustomWallets(options.customWallets);
    OptionsController.setFeatures(options.features);
    OptionsController.setAllowUnsupportedChain(options.allowUnsupportedChain);
    OptionsController.setDefaultAccountTypes(options.defaultAccountTypes);
    const defaultMetaData = this.getDefaultMetaData();
    if (!options.metadata && defaultMetaData) {
      options.metadata = defaultMetaData;
    }
    OptionsController.setMetadata(options.metadata);
    OptionsController.setDisableAppend(options.disableAppend);
    OptionsController.setEnableEmbedded(options.enableEmbedded);
    OptionsController.setSIWX(options.siwx);
    const evmAdapter = (_a3 = options.adapters) == null ? void 0 : _a3.find((adapter) => adapter.namespace === ConstantsUtil$4.CHAIN.EVM);
    if (evmAdapter) {
      if (options.siweConfig) {
        if (options.siwx) {
          throw new Error("Cannot set both `siweConfig` and `siwx` options");
        }
        OptionsController.setSIWX(options.siweConfig.mapToSIWX());
      }
    }
  }
  initializeThemeController(options) {
    if (options.themeMode) {
      ThemeController.setThemeMode(options.themeMode);
    }
    if (options.themeVariables) {
      ThemeController.setThemeVariables(options.themeVariables);
    }
  }
  initializeChainController(options) {
    if (!this.connectionControllerClient || !this.networkControllerClient) {
      throw new Error("ConnectionControllerClient and NetworkControllerClient must be set");
    }
    ChainController.initialize(options.adapters ?? [], this.caipNetworks, {
      connectionControllerClient: this.connectionControllerClient,
      networkControllerClient: this.networkControllerClient
    });
    const network = this.getDefaultNetwork();
    if (network) {
      ChainController.setActiveCaipNetwork(network);
    }
  }
  async initializeBlockchainApiController() {
  }
  initControllers(options) {
    this.initializeOptionsController(options);
    this.initializeChainController(options);
    this.initializeThemeController(options);
    this.initializeBlockchainApiController();
    if (options.excludeWalletIds) {
      ApiController$1.initializeExcludedWalletRdns({ ids: options.excludeWalletIds });
    }
  }
  getDefaultMetaData() {
    var _a3, _b2, _c3, _d;
    if (typeof window !== "undefined" && typeof document !== "undefined") {
      return {
        name: ((_b2 = (_a3 = document.getElementsByTagName("title")) == null ? void 0 : _a3[0]) == null ? void 0 : _b2.textContent) || "",
        description: ((_c3 = document.querySelector('meta[property="og:description"]')) == null ? void 0 : _c3.content) || "",
        url: window.location.origin,
        icons: [((_d = document.querySelector('link[rel~="icon"]')) == null ? void 0 : _d.href) || ""]
      };
    }
    return null;
  }
  setUnsupportedNetwork(chainId) {
    const namespace = this.getActiveChainNamespace();
    if (namespace) {
      const unsupportedNetwork = this.getUnsupportedNetwork(`${namespace}:${chainId}`);
      ChainController.setActiveCaipNetwork(unsupportedNetwork);
    }
  }
  extendCaipNetwork(network, options) {
    const extendedNetwork = CaipNetworksUtil.extendCaipNetwork(network, {
      customNetworkImageUrls: options.chainImages,
      projectId: options.projectId
    });
    return extendedNetwork;
  }
  extendCaipNetworks(options) {
    const extendedNetworks = CaipNetworksUtil.extendCaipNetworks(options.networks, {
      customNetworkImageUrls: options.chainImages,
      projectId: options.projectId
    });
    return extendedNetworks;
  }
  extendDefaultCaipNetwork(options) {
    const defaultNetwork = options.networks.find((n5) => {
      var _a3;
      return n5.id === ((_a3 = options.defaultNetwork) == null ? void 0 : _a3.id);
    });
    const extendedNetwork = defaultNetwork ? CaipNetworksUtil.extendCaipNetwork(defaultNetwork, {
      customNetworkImageUrls: options.chainImages,
      projectId: options.projectId
    }) : void 0;
    return extendedNetwork;
  }
  createClients() {
    this.connectionControllerClient = {
      connectWalletConnect: async () => {
        var _a3;
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!adapter) {
          throw new Error("Adapter not found");
        }
        const result = await adapter.connectWalletConnect((_a3 = this.getCaipNetwork()) == null ? void 0 : _a3.id);
        this.close();
        this.setClientId((result == null ? void 0 : result.clientId) || null);
        StorageUtil.setConnectedNamespaces([...ChainController.state.chains.keys()]);
        await this.syncWalletConnectAccount();
      },
      authenticateWalletConnect: async () => {
        var _a3;
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!adapter) {
          throw new Error("Adapter not found");
        }
        await this.open({ view: "ConnectingWalletConnectBasic" });
        const result = await adapter.authenticateWalletConnect();
        if (result.authenticated) {
          this.close();
          this.setClientId(await ((_a3 = this.universalProvider) == null ? void 0 : _a3.client.core.crypto.getClientId()) || null);
          StorageUtil.setConnectedNamespaces([...ChainController.state.chains.keys()]);
          await this.syncWalletConnectAccount();
          return result;
        }
        return { authenticated: false, sessions: [] };
      },
      connectExternal: async ({ id: id2, info, type: type2, provider, chain, caipNetwork }) => {
        var _a3, _b2, _c3, _d, _e4, _f, _g, _h, _i2;
        const activeChain = ChainController.state.activeChain;
        const chainToUse = chain || activeChain;
        await this.disconnectIfAlreadyConnected(chainToUse);
        const adapter = this.getAdapter(chainToUse);
        if (chain && chain !== activeChain && !caipNetwork) {
          const toConnectNetwork = (_a3 = this.caipNetworks) == null ? void 0 : _a3.find((network) => network.chainNamespace === chain);
          if (toConnectNetwork) {
            this.setCaipNetwork(toConnectNetwork);
          }
        }
        if (!adapter) {
          throw new Error("Adapter not found");
        }
        const res = await adapter.connect({
          id: id2,
          info,
          type: type2,
          provider,
          chainId: (caipNetwork == null ? void 0 : caipNetwork.id) || ((_b2 = this.getCaipNetwork()) == null ? void 0 : _b2.id),
          rpcUrl: ((_e4 = (_d = (_c3 = caipNetwork == null ? void 0 : caipNetwork.rpcUrls) == null ? void 0 : _c3.default) == null ? void 0 : _d.http) == null ? void 0 : _e4[0]) || ((_i2 = (_h = (_g = (_f = this.getCaipNetwork()) == null ? void 0 : _f.rpcUrls) == null ? void 0 : _g.default) == null ? void 0 : _h.http) == null ? void 0 : _i2[0])
        });
        if (!res) {
          return;
        }
        StorageUtil.addConnectedNamespace(chainToUse);
        this.syncProvider({ ...res, chainNamespace: chainToUse });
        await this.syncAccount({ ...res, chainNamespace: chainToUse });
        const { accounts } = await adapter.getAccounts({ namespace: chainToUse, id: id2 });
        this.setAllAccounts(accounts, chainToUse);
      },
      reconnectExternal: async ({ id: id2, info, type: type2, provider }) => {
        var _a3;
        const namespace = ChainController.state.activeChain;
        const adapter = this.getAdapter(namespace);
        if (adapter == null ? void 0 : adapter.reconnect) {
          await (adapter == null ? void 0 : adapter.reconnect({ id: id2, info, type: type2, provider, chainId: (_a3 = this.getCaipNetwork()) == null ? void 0 : _a3.id }));
          StorageUtil.addConnectedNamespace(namespace);
        }
      },
      disconnect: async () => {
        const namespace = ChainController.state.activeChain;
        const adapter = this.getAdapter(namespace);
        const provider = ProviderUtil.getProvider(namespace);
        const providerType = ProviderUtil.state.providerIds[namespace];
        try {
          await (adapter == null ? void 0 : adapter.disconnect({ provider, providerType }));
        } catch (e3) {
          console.log(`error on disconnect but proceeding next steps...: ${e3}`);
        }
        StorageUtil.removeConnectedNamespace(namespace);
        ProviderUtil.resetChain(namespace);
        this.setUser(void 0, namespace);
        this.setStatus("disconnected", namespace);
      },
      checkInstalled: (ids) => {
        if (!ids) {
          return Boolean(window.ethereum);
        }
        return ids.some((id2) => {
          var _a3;
          return Boolean((_a3 = window.ethereum) == null ? void 0 : _a3[String(id2)]);
        });
      },
      signMessage: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        const result = await (adapter == null ? void 0 : adapter.signMessage({
          message: params.message,
          address: AccountController.state.address,
          provider: ProviderUtil.getProvider(ChainController.state.activeChain),
          customData: params.customData
        }));
        return (result == null ? void 0 : result.signature) || "";
      },
      etherSignMessage: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        const result = await (adapter == null ? void 0 : adapter.etherSignMessage({
          message: params.message,
          address: AccountController.state.address,
          provider: ProviderUtil.getProvider(ChainController.state.activeChain)
        }));
        return (result == null ? void 0 : result.signature) || "";
      },
      signEIP712: async (args) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        const result = await (adapter == null ? void 0 : adapter.signEIP712({
          ...args,
          provider: ProviderUtil.getProvider(args.chainNamespace)
        }));
        return (result == null ? void 0 : result.signature) || "";
      },
      signTypedDataV4: async (paramsData, customData) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        const result = await (adapter == null ? void 0 : adapter.signTypedDataV4({
          paramsData,
          provider: ProviderUtil.getProvider(ChainController.state.activeChain),
          customData
        }));
        return (result == null ? void 0 : result.signature) || "";
      },
      sendTransaction: async (args) => {
        if (args.chainNamespace === ConstantsUtil$4.CHAIN.EVM) {
          const adapter = this.getAdapter(ChainController.state.activeChain);
          const provider = ProviderUtil.getProvider(ChainController.state.activeChain);
          const result = await (adapter == null ? void 0 : adapter.sendTransaction({ ...args, provider }));
          this.updateNativeBalance(true);
          return (result == null ? void 0 : result.hash) ? { hash: `${result.hash}` } : null;
        }
        return null;
      },
      estimateGas: async (args) => {
        if (args.chainNamespace === ConstantsUtil$4.CHAIN.EVM) {
          const adapter = this.getAdapter(ChainController.state.activeChain);
          const provider = ProviderUtil.getProvider(ChainController.state.activeChain);
          const caipNetwork = this.getCaipNetwork();
          if (!caipNetwork) {
            throw new Error("CaipNetwork is undefined");
          }
          const result = await (adapter == null ? void 0 : adapter.estimateGas({
            ...args,
            provider,
            caipNetwork
          }));
          return (result == null ? void 0 : result.gas) || 0n;
        }
        return 0n;
      },
      getEnsAvatar: async () => {
        var _a3;
        const adapter = this.getAdapter(ChainController.state.activeChain);
        const result = await (adapter == null ? void 0 : adapter.getProfile({
          address: AccountController.state.address,
          chainId: Number((_a3 = this.getCaipNetwork()) == null ? void 0 : _a3.id)
        }));
        return (result == null ? void 0 : result.profileImage) || false;
      },
      getEnsAddress: async (name) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        const caipNetwork = this.getCaipNetwork();
        if (!caipNetwork) {
          return false;
        }
        const result = await (adapter == null ? void 0 : adapter.getEnsAddress({
          name,
          caipNetwork
        }));
        return (result == null ? void 0 : result.address) || false;
      },
      writeContract: async (args) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        const caipNetwork = this.getCaipNetwork();
        const caipAddress = this.getCaipAddress();
        const provider = ProviderUtil.getProvider(ChainController.state.activeChain);
        if (!caipNetwork || !caipAddress) {
          throw new Error("CaipNetwork or CaipAddress is undefined");
        }
        const result = await (adapter == null ? void 0 : adapter.writeContract({ ...args, caipNetwork, provider, caipAddress }));
        return result ? { hash: result == null ? void 0 : result.hash } : null;
      },
      readContract: async (args) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        const caipNetwork = this.getCaipNetwork();
        const provider = ProviderUtil.getProvider(ChainController.state.activeChain);
        if (!caipNetwork) {
          throw new Error("CaipNetwork or CaipAddress is undefined");
        }
        const result = await (adapter == null ? void 0 : adapter.readContract({ ...args, provider, caipNetwork }));
        return result;
      },
      parseUnits: (value, decimals) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        return (adapter == null ? void 0 : adapter.parseUnits({ value, decimals })) ?? 0n;
      },
      formatUnits: (value, decimals) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        return (adapter == null ? void 0 : adapter.formatUnits({ value, decimals })) ?? "0";
      },
      getCapabilities: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        return await (adapter == null ? void 0 : adapter.getCapabilities(params));
      },
      grantPermissions: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        return await (adapter == null ? void 0 : adapter.grantPermissions(params));
      },
      revokePermissions: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (adapter == null ? void 0 : adapter.revokePermissions) {
          return await adapter.revokePermissions(params);
        }
        return "0x";
      },
      walletGetAssets: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        return await (adapter == null ? void 0 : adapter.walletGetAssets(params)) ?? {};
      }
    };
    this.networkControllerClient = {
      switchCaipNetwork: async (caipNetwork) => {
        var _a3, _b2;
        if (!caipNetwork) {
          return;
        }
        if (AccountController.state.address && caipNetwork.chainNamespace === ChainController.state.activeChain) {
          const adapter = this.getAdapter(ChainController.state.activeChain);
          const provider = ProviderUtil.getProvider(ChainController.state.activeChain);
          const providerType = ProviderUtil.state.providerIds[ChainController.state.activeChain];
          await (adapter == null ? void 0 : adapter.switchNetwork({ caipNetwork, provider, providerType }));
          this.setCaipNetwork(caipNetwork);
          await this.syncAccount({
            address: AccountController.state.address,
            chainId: caipNetwork.id,
            chainNamespace: caipNetwork.chainNamespace
          });
        } else if (AccountController.state.address) {
          const providerType = ProviderUtil.state.providerIds[ChainController.state.activeChain];
          if (providerType === ConstantsUtil$1.CONNECTOR_TYPE_AUTH) {
            try {
              ChainController.state.activeChain = caipNetwork.chainNamespace;
              await ((_b2 = (_a3 = this.connectionControllerClient) == null ? void 0 : _a3.connectExternal) == null ? void 0 : _b2.call(_a3, {
                id: ConstantsUtil$4.CONNECTOR_ID.AUTH,
                provider: this.authProvider,
                chain: caipNetwork.chainNamespace,
                chainId: caipNetwork.id,
                type: ConstantsUtil$1.CONNECTOR_TYPE_AUTH,
                caipNetwork
              }));
              this.setCaipNetwork(caipNetwork);
            } catch (error) {
              const adapter = this.getAdapter(caipNetwork.chainNamespace);
              await (adapter == null ? void 0 : adapter.switchNetwork({
                caipNetwork,
                provider: this.authProvider,
                providerType
              }));
            }
          } else if (providerType === "WALLET_CONNECT") {
            this.setCaipNetwork(caipNetwork);
            this.syncWalletConnectAccount();
          } else {
            this.setCaipNetwork(caipNetwork);
            const address = this.getAddressByChainNamespace(caipNetwork.chainNamespace);
            if (address) {
              this.syncAccount({
                address,
                chainId: caipNetwork.id,
                chainNamespace: caipNetwork.chainNamespace
              });
            }
          }
        } else {
          this.setCaipNetwork(caipNetwork);
        }
      },
      // eslint-disable-next-line @typescript-eslint/require-await
      getApprovedCaipNetworksData: async () => {
        var _a3, _b2, _c3, _d, _e4;
        const providerType = ProviderUtil.state.providerIds[ChainController.state.activeChain];
        if (providerType === ConstantsUtil$1.CONNECTOR_TYPE_WALLET_CONNECT) {
          const namespaces = (_b2 = (_a3 = this.universalProvider) == null ? void 0 : _a3.session) == null ? void 0 : _b2.namespaces;
          return {
            /*
             * MetaMask Wallet only returns 1 namespace in the session object. This makes it imposible
             * to switch to other networks. Setting supportsAllNetworks to true for MetaMask Wallet
             * will make it possible to switch to other networks.
             */
            supportsAllNetworks: ((_e4 = (_d = (_c3 = this.universalProvider) == null ? void 0 : _c3.session) == null ? void 0 : _d.peer) == null ? void 0 : _e4.metadata.name) === "MetaMask Wallet",
            approvedCaipNetworkIds: this.getChainsFromNamespaces(namespaces)
          };
        }
        return { supportsAllNetworks: true, approvedCaipNetworkIds: [] };
      }
    };
    ConnectionController.setClient(this.connectionControllerClient);
  }
  /**
   *        
   *        .
   */
  async disconnectIfAlreadyConnected(namespace = "eip155") {
    const currentProviderType = ProviderUtil.getProviderId(namespace);
    const isAlreadyConnected = Boolean(AccountController.state.address);
    const adapter = this.getAdapter(namespace);
    if (isAlreadyConnected && currentProviderType && adapter) {
      try {
        const provider = ProviderUtil.getProvider(namespace);
        await adapter.disconnect({ provider, providerType: currentProviderType });
        StorageUtil.removeConnectedNamespace(namespace);
        ProviderUtil.resetChain(namespace);
        this.setUser(void 0, namespace);
        this.setStatus("disconnected", namespace);
      } catch (error) {
        StorageUtil.removeConnectedNamespace(namespace);
        ProviderUtil.resetChain(namespace);
        this.setUser(void 0, namespace);
        this.setStatus("disconnected", namespace);
      }
    }
  }
  setupAuthConnectorListeners(provider) {
    provider.onRpcRequest((request) => {
      if (W3mFrameHelpers.checkIfRequestExists(request)) {
        if (!W3mFrameHelpers.checkIfRequestIsSafe(request)) {
          this.handleUnsafeRPCRequest();
        }
      } else {
        this.open();
        console.error(W3mFrameRpcConstants.RPC_METHOD_NOT_ALLOWED_MESSAGE, {
          method: request.method
        });
        setTimeout(() => {
          this.showErrorMessage(W3mFrameRpcConstants.RPC_METHOD_NOT_ALLOWED_UI_MESSAGE);
        }, 300);
        provider.rejectRpcRequests();
      }
    });
    provider.onRpcError(() => {
      const isModalOpen = this.isOpen();
      if (isModalOpen) {
        if (this.isTransactionStackEmpty()) {
          this.close();
        } else {
          this.popTransactionStack(true);
        }
      }
    });
    provider.onRpcSuccess((_3, request) => {
      var _a3;
      const isSafeRequest = W3mFrameHelpers.checkIfRequestIsSafe(request);
      if (isSafeRequest) {
        return;
      }
      if (AccountController.state.address && ((_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.id)) {
        this.updateNativeBalance();
      }
      if (this.isTransactionStackEmpty()) {
        this.close();
      } else {
        this.popTransactionStack();
      }
    });
    provider.onNotConnected(() => {
      const namespace = ChainController.state.activeChain;
      const connectorId = StorageUtil.getConnectedConnectorId(namespace);
      const isConnectedWithAuth = connectorId === ConstantsUtil$4.CONNECTOR_ID.AUTH;
      if (isConnectedWithAuth) {
        this.setCaipAddress(void 0, namespace);
        this.setLoading(false);
      }
    });
    provider.onConnect(async (user) => {
      var _a3;
      const namespace = ChainController.state.activeChain;
      const caipAddress = namespace === ConstantsUtil$4.CHAIN.EVM ? `eip155:${user.chainId}:${user.address}` : `${user.chainId}:${user.address}`;
      this.setSmartAccountDeployed(Boolean(user.smartAccountDeployed), namespace);
      this.setCaipAddress(caipAddress, namespace);
      this.setUser({ ...AccountController.state.user || {}, email: user.email }, namespace);
      const preferredAccountType = user.preferredAccountType || OptionsController.state.defaultAccountTypes[namespace];
      this.setPreferredAccountType(preferredAccountType, namespace);
      const userAccounts = (_a3 = user.accounts) == null ? void 0 : _a3.map((account) => CoreHelperUtil.createAccount(namespace, account.address, account.type || OptionsController.state.defaultAccountTypes[namespace]));
      this.setAllAccounts(userAccounts || [
        CoreHelperUtil.createAccount(namespace, user.address, preferredAccountType)
      ], namespace);
      await provider.getSmartAccountEnabledNetworks();
      this.setLoading(false);
    });
    provider.onSocialConnected(({ userName }) => {
      this.setUser({ ...AccountController.state.user || {}, username: userName }, ChainController.state.activeChain);
    });
    provider.onGetSmartAccountEnabledNetworks((networks) => {
      this.setSmartAccountEnabledNetworks(networks, ChainController.state.activeChain);
    });
    provider.onSetPreferredAccount(({ address, type: type2 }) => {
      if (!address) {
        return;
      }
      this.setPreferredAccountType(type2, ChainController.state.activeChain);
    });
  }
  async syncAuthConnector(provider) {
    var _a3, _b2, _c3, _d;
    this.setLoading(true);
    const isLoginEmailUsed = provider.getLoginEmailUsed();
    this.setLoading(isLoginEmailUsed);
    if (isLoginEmailUsed) {
      this.setStatus("connecting", ChainController.state.activeChain);
    }
    const email = provider.getEmail();
    const username = provider.getUsername();
    this.setUser({ ...((_a3 = AccountController.state) == null ? void 0 : _a3.user) || {}, username, email }, ChainController.state.activeChain);
    this.setupAuthConnectorListeners(provider);
    const { isConnected } = await provider.isConnected();
    const theme = ThemeController.getSnapshot();
    const options = OptionsController.getSnapshot();
    provider.syncDappData({
      metadata: options.metadata,
      sdkVersion: options.sdkVersion,
      projectId: options.projectId,
      sdkType: options.sdkType
    });
    provider.syncTheme({
      themeMode: theme.themeMode,
      themeVariables: theme.themeVariables,
      w3mThemeVariables: getW3mThemeVariables(theme.themeVariables, theme.themeMode)
    });
    const namespace = StorageUtil.getActiveNamespace();
    if (namespace) {
      if (isConnected && ((_b2 = this.connectionControllerClient) == null ? void 0 : _b2.connectExternal)) {
        await ((_d = this.connectionControllerClient) == null ? void 0 : _d.connectExternal({
          id: ConstantsUtil$4.CONNECTOR_ID.AUTH,
          info: { name: ConstantsUtil$4.CONNECTOR_ID.AUTH },
          type: ConstantsUtil$1.CONNECTOR_TYPE_AUTH,
          provider,
          chainId: (_c3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _c3.id,
          chain: namespace
        }));
        this.setStatus("connected", namespace);
      } else if (StorageUtil.getConnectedConnectorId(namespace) === ConstantsUtil$4.CONNECTOR_ID.AUTH) {
        this.setStatus("disconnected", namespace);
        StorageUtil.removeConnectedNamespace(namespace);
      }
    }
    this.setLoading(false);
  }
  listenWalletConnect() {
    if (this.universalProvider) {
      this.universalProvider.on("display_uri", (uri2) => {
        ConnectionController.setUri(uri2);
      });
      this.universalProvider.on("disconnect", () => {
        this.chainNamespaces.forEach((namespace) => {
          this.resetAccount(namespace);
        });
        ConnectionController.resetWcConnection();
      });
      this.universalProvider.on("chainChanged", (chainId) => {
        var _a3;
        const caipNetwork = (_a3 = this.caipNetworks) == null ? void 0 : _a3.find((c2) => c2.id == chainId);
        const currentCaipNetwork = this.getCaipNetwork();
        if (!caipNetwork) {
          this.setUnsupportedNetwork(chainId);
          return;
        }
        if ((currentCaipNetwork == null ? void 0 : currentCaipNetwork.id) !== (caipNetwork == null ? void 0 : caipNetwork.id)) {
          this.setCaipNetwork(caipNetwork);
        }
      });
      this.universalProvider.on("session_event", (callbackData) => {
        if (WcHelpersUtil.isSessionEventData(callbackData)) {
          const { name, data: data2 } = callbackData.params.event;
          if (name === "accountsChanged" && Array.isArray(data2) && CoreHelperUtil.isCaipAddress(data2[0])) {
            this.syncAccount(ParseUtil.parseCaipAddress(data2[0]));
          }
        }
      });
      this.listenMobileSessionDetection();
    }
  }
  /**
   *       account   
   */
  listenMobileSessionDetection() {
    var _a3, _b2;
    if ((_b2 = (_a3 = this.universalProvider) == null ? void 0 : _a3.client) == null ? void 0 : _b2.engine) {
      this.universalProvider.client.engine.events.on("session_disconnected", (event) => {
        var _a4, _b3;
        ((_a4 = event == null ? void 0 : event.result) == null ? void 0 : _a4.reason) || "unknown";
        ((_b3 = event == null ? void 0 : event.result) == null ? void 0 : _b3.topic) || "unknown";
        this.chainNamespaces.forEach((namespace) => {
          this.resetAccount(namespace);
          const accountState2 = ChainController.getAccountDataByChainNamespace(namespace);
          console.log(" [APPKIT] Account state after reset:", {
            namespace,
            caipAddress: accountState2 == null ? void 0 : accountState2.caipAddress,
            isConnected: Boolean(accountState2 == null ? void 0 : accountState2.caipAddress),
            status: accountState2 == null ? void 0 : accountState2.status
          });
        });
        ConnectionController.resetWcConnection();
        window.dispatchEvent(new CustomEvent("appkit_session_disconnected", {
          detail: event
        }));
      });
    }
  }
  listenAdapter(chainNamespace) {
    const adapter = this.getAdapter(chainNamespace);
    if (!adapter) {
      return;
    }
    const connectionStatus = StorageUtil.getConnectionStatus();
    if (connectionStatus === "connected") {
      this.setStatus("connecting", chainNamespace);
    } else if (connectionStatus === "disconnected") {
      StorageUtil.clearAddressCache();
      this.setStatus(connectionStatus, chainNamespace);
    } else {
      this.setStatus(connectionStatus, chainNamespace);
    }
    adapter.on("switchNetwork", ({ address, chainId }) => {
      var _a3;
      if (chainId && ((_a3 = this.caipNetworks) == null ? void 0 : _a3.find((n5) => n5.id === chainId || n5.caipNetworkId === chainId))) {
        if (ChainController.state.activeChain === chainNamespace && address) {
          this.syncAccount({ address, chainId, chainNamespace });
        } else if (ChainController.state.activeChain === chainNamespace && AccountController.state.address) {
          this.syncAccount({
            address: AccountController.state.address,
            chainId,
            chainNamespace
          });
        }
      } else {
        this.setUnsupportedNetwork(chainId);
      }
    });
    adapter.on("disconnect", this.disconnect.bind(this));
    adapter.on("pendingTransactions", () => {
      console.log(`pendingTransactions`);
      const address = AccountController.state.address;
      const activeCaipNetwork = ChainController.state.activeCaipNetwork;
      if (!address || !(activeCaipNetwork == null ? void 0 : activeCaipNetwork.id)) {
        return;
      }
      this.updateNativeBalance();
    });
    adapter.on("accountChanged", ({ address, chainId }) => {
      var _a3, _b2;
      if (ChainController.state.activeChain === chainNamespace && chainId) {
        this.syncAccount({
          address,
          chainId,
          chainNamespace
        });
      } else if (ChainController.state.activeChain === chainNamespace && ((_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.id)) {
        this.syncAccount({
          address,
          chainId: (_b2 = ChainController.state.activeCaipNetwork) == null ? void 0 : _b2.id,
          chainNamespace
        });
      }
    });
  }
  async updateNativeBalance(ignoreCache = false) {
    var _a3, _b2;
    const adapter = this.getAdapter(ChainController.state.activeChain);
    const activeChain = ChainController.state.activeChain;
    const address = AccountController.state.address;
    const chainId = (_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.id;
    if (adapter && activeChain && address) {
      const balance = await adapter.getBalance({
        address,
        chainId,
        caipNetwork: this.getCaipNetwork(),
        tokens: this.options.tokens,
        ignoreCache
      });
      console.log(`chainId: ${(_b2 = ChainController.state.activeCaipNetwork) == null ? void 0 : _b2.id} native balance: ${JSON.stringify(balance)} tokens: ${JSON.stringify(this.options.tokens, (key2, val) => typeof val === "bigint" ? val.toString() : val)}`);
      this.setBalance(balance.balance, balance.symbol, activeChain);
    }
  }
  getChainsFromNamespaces(namespaces = {}) {
    return Object.values(namespaces).flatMap((namespace) => {
      const chains = namespace.chains || [];
      const accountsChains = namespace.accounts.map((account) => {
        const { chainId, chainNamespace } = ParseUtil.parseCaipAddress(account);
        return `${chainNamespace}:${chainId}`;
      });
      return Array.from(/* @__PURE__ */ new Set([...chains, ...accountsChains]));
    });
  }
  async syncWalletConnectAccount() {
    var _a3, _b2;
    const sessionNamespaces = Object.keys(((_b2 = (_a3 = this.universalProvider) == null ? void 0 : _a3.session) == null ? void 0 : _b2.namespaces) || {});
    const adapter = this.getAdapter(ChainController.state.activeChain);
    this.chainNamespaces.forEach(async (chainNamespace) => {
      var _a4, _b3, _c3, _d, _e4;
      const namespaceAccounts = ((_d = (_c3 = (_b3 = (_a4 = this.universalProvider) == null ? void 0 : _a4.session) == null ? void 0 : _b3.namespaces) == null ? void 0 : _c3[chainNamespace]) == null ? void 0 : _d.accounts) || [];
      const activeChainId = (_e4 = ChainController.state.activeCaipNetwork) == null ? void 0 : _e4.id;
      const sessionAddress = namespaceAccounts.find((account) => {
        const { chainId } = ParseUtil.parseCaipAddress(account);
        return chainId === (activeChainId == null ? void 0 : activeChainId.toString());
      }) || namespaceAccounts[0];
      if (sessionAddress) {
        console.log(`Got ya!  sessionAddress: ${sessionAddress}`);
        const caipAddress = ParseUtil.validateCaipAddress(sessionAddress);
        const { chainId, address } = ParseUtil.parseCaipAddress(caipAddress);
        ProviderUtil.setProviderId(chainNamespace, ConstantsUtil$1.CONNECTOR_TYPE_WALLET_CONNECT);
        if (this.caipNetworks && ChainController.state.activeCaipNetwork && (adapter == null ? void 0 : adapter.namespace) !== ConstantsUtil$4.CHAIN.EVM) {
          const provider = adapter == null ? void 0 : adapter.getWalletConnectProvider({
            caipNetworks: this.caipNetworks,
            provider: this.universalProvider,
            activeCaipNetwork: ChainController.state.activeCaipNetwork
          });
          ProviderUtil.setProvider(chainNamespace, provider);
        } else {
          ProviderUtil.setProvider(chainNamespace, this.universalProvider);
        }
        StorageUtil.setConnectedConnectorId(chainNamespace, ConstantsUtil$4.CONNECTOR_ID.WALLET_CONNECT);
        StorageUtil.addConnectedNamespace(chainNamespace);
        this.syncWalletConnectAccounts(chainNamespace);
        await this.syncAccount({
          address,
          chainId,
          chainNamespace
        });
      } else if (sessionNamespaces.includes(chainNamespace)) {
        this.setStatus("disconnected", chainNamespace);
      } else if (sessionNamespaces.length === 0) {
        this.setStatus("disconnected", chainNamespace);
      } else {
        this.setStatus("disconnected", chainNamespace);
      }
    });
    await ChainController.setApprovedCaipNetworksData(ChainController.state.activeChain);
  }
  syncWalletConnectAccounts(chainNamespace) {
    var _a3, _b2, _c3, _d, _e4;
    const addresses = (_e4 = (_d = (_c3 = (_b2 = (_a3 = this.universalProvider) == null ? void 0 : _a3.session) == null ? void 0 : _b2.namespaces) == null ? void 0 : _c3[chainNamespace]) == null ? void 0 : _d.accounts) == null ? void 0 : _e4.map((account) => {
      const { address } = ParseUtil.parseCaipAddress(account);
      return address;
    }).filter((address, index2, self2) => self2.indexOf(address) === index2);
    if (addresses) {
      this.setAllAccounts(addresses.map((address) => CoreHelperUtil.createAccount(chainNamespace, address, chainNamespace === "bip122" ? "payment" : "eoa")), chainNamespace);
    }
  }
  syncProvider({ type: type2, provider, id: id2, chainNamespace }) {
    ProviderUtil.setProviderId(chainNamespace, type2);
    ProviderUtil.setProvider(chainNamespace, provider);
    StorageUtil.setConnectedConnectorId(chainNamespace, id2);
  }
  async syncAccount(params) {
    var _a3, _b2, _c3, _d, _e4, _f;
    const { address, chainId, chainNamespace } = params;
    const { chainId: activeChainId } = StorageUtil.getActiveNetworkProps();
    const chainIdToUse = chainId || activeChainId;
    const isUnsupportedNetwork = ((_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.name) === ConstantsUtil$4.UNSUPPORTED_NETWORK_NAME;
    const shouldSupportAllNetworks = ChainController.getNetworkProp("supportsAllNetworks", chainNamespace);
    this.setStatus("connected", chainNamespace);
    if (isUnsupportedNetwork && !shouldSupportAllNetworks) {
      return;
    }
    if (chainIdToUse) {
      console.log(`syncAccount - chainIdToUse: ${chainIdToUse}`);
      let caipNetwork = (_b2 = this.caipNetworks) == null ? void 0 : _b2.find((n5) => n5.id.toString() === chainIdToUse.toString());
      let fallbackCaipNetwork = (_c3 = this.caipNetworks) == null ? void 0 : _c3.find((n5) => n5.chainNamespace === chainNamespace);
      if (!shouldSupportAllNetworks && !caipNetwork && !fallbackCaipNetwork) {
        const caipNetworkIds = this.getApprovedCaipNetworkIds() || [];
        const caipNetworkId = caipNetworkIds.find((id2) => {
          var _a4;
          return ((_a4 = ParseUtil.parseCaipNetworkId(id2)) == null ? void 0 : _a4.chainId) === chainIdToUse.toString();
        });
        const fallBackCaipNetworkId = caipNetworkIds.find((id2) => {
          var _a4;
          return ((_a4 = ParseUtil.parseCaipNetworkId(id2)) == null ? void 0 : _a4.chainNamespace) === chainNamespace;
        });
        caipNetwork = (_d = this.caipNetworks) == null ? void 0 : _d.find((n5) => n5.caipNetworkId === caipNetworkId);
        fallbackCaipNetwork = (_e4 = this.caipNetworks) == null ? void 0 : _e4.find((n5) => n5.caipNetworkId === fallBackCaipNetworkId || // This is a workaround used in Solana network to support deprecated caipNetworkId
        "deprecatedCaipNetworkId" in n5 && n5.deprecatedCaipNetworkId === fallBackCaipNetworkId);
      }
      const network = caipNetwork || fallbackCaipNetwork;
      if ((network == null ? void 0 : network.chainNamespace) === ChainController.state.activeChain) {
        if (!OptionsController.state.allowUnsupportedChain && ((_f = ChainController.state.activeCaipNetwork) == null ? void 0 : _f.name) === ConstantsUtil$4.UNSUPPORTED_NETWORK_NAME) {
          ChainController.showUnsupportedChainUI();
        } else {
          this.setCaipNetwork(network);
        }
      }
      this.syncConnectedWalletInfo(chainNamespace);
      const currentAddress = AccountController.state.address;
      const addressChanged = !HelpersUtil.isLowerCaseMatch(address, currentAddress);
      if (addressChanged) {
        const caipAddress = `${chainNamespace}:${network == null ? void 0 : network.id}:${address}`;
        this.setCaipAddress(caipAddress, chainNamespace);
      }
      await this.syncBalance({ address, chainId: network == null ? void 0 : network.id, chainNamespace });
    }
  }
  async syncBalance(params) {
    const caipNetwork = NetworkUtil.getNetworksByNamespace(this.caipNetworks, params.chainNamespace).find((n5) => {
      var _a3;
      return n5.id.toString() === ((_a3 = params.chainId) == null ? void 0 : _a3.toString());
    });
    if (!caipNetwork) {
      return;
    }
    await this.updateNativeBalance();
  }
  syncConnectedWalletInfo(chainNamespace) {
    var _a3;
    const connectorId = StorageUtil.getConnectedConnectorId(chainNamespace);
    const providerType = ProviderUtil.getProviderId(chainNamespace);
    if (providerType === ConstantsUtil$1.CONNECTOR_TYPE_ANNOUNCED || providerType === ConstantsUtil$1.CONNECTOR_TYPE_INJECTED) {
      if (connectorId) {
        const connector = this.getConnectors().find((c2) => c2.id === connectorId);
        if (connector) {
          const { info, name, imageUrl } = connector;
          const icon = imageUrl || this.getConnectorImage(connector);
          this.setConnectedWalletInfo({ name, icon, ...info }, chainNamespace);
        }
      }
    } else if (providerType === ConstantsUtil$1.CONNECTOR_TYPE_WALLET_CONNECT) {
      const provider = ProviderUtil.getProvider(chainNamespace);
      if (provider == null ? void 0 : provider.session) {
        this.setConnectedWalletInfo({
          ...provider.session.peer.metadata,
          name: provider.session.peer.metadata.name,
          icon: (_a3 = provider.session.peer.metadata.icons) == null ? void 0 : _a3[0]
        }, chainNamespace);
      }
    } else if (providerType === ConstantsUtil$1.CONNECTOR_TYPE_AUTH) {
      const provider = this.authProvider;
      if (provider) {
        const social = StorageUtil.getConnectedSocialProvider() ?? "email";
        const identifier = provider.getEmail() ?? provider.getUsername();
        this.setConnectedWalletInfo({ name: providerType, identifier, social }, chainNamespace);
      }
    } else if (connectorId) {
      if (connectorId === ConstantsUtil$4.CONNECTOR_ID.COINBASE) {
        const connector = this.getConnectors().find((c2) => c2.id === ConstantsUtil$4.CONNECTOR_ID.COINBASE);
        this.setConnectedWalletInfo({ name: "Coinbase Wallet", icon: this.getConnectorImage(connector) }, chainNamespace);
      }
      this.setConnectedWalletInfo({ name: connectorId }, chainNamespace);
    }
  }
  async syncIdentity({ address, chainId, chainNamespace }) {
    var _a3;
    const caipNetworkId = `${chainNamespace}:${chainId}`;
    const activeCaipNetwork = (_a3 = this.caipNetworks) == null ? void 0 : _a3.find((n5) => n5.caipNetworkId === caipNetworkId);
    if (chainNamespace !== ConstantsUtil$4.CHAIN.EVM || (activeCaipNetwork == null ? void 0 : activeCaipNetwork.testnet)) {
      return;
    }
    try {
      const { name, avatar } = await this.fetchIdentity({
        address,
        caipNetworkId
      });
      this.setProfileName(name, chainNamespace);
      this.setProfileImage(avatar, chainNamespace);
      if (!name) {
        await this.syncReownName(address, chainNamespace);
        const adapter = this.getAdapter(chainNamespace);
        const result = await (adapter == null ? void 0 : adapter.getProfile({
          address,
          chainId: Number(chainId)
        }));
        if (result == null ? void 0 : result.profileName) {
          this.setProfileName(result.profileName, chainNamespace);
          if (result.profileImage) {
            this.setProfileImage(result.profileImage, chainNamespace);
          }
        } else {
          await this.syncReownName(address, chainNamespace);
          this.setProfileImage(null, chainNamespace);
        }
      }
    } catch {
      if (chainId === 1) {
        await this.syncReownName(address, chainNamespace);
      } else {
        await this.syncReownName(address, chainNamespace);
        this.setProfileImage(null, chainNamespace);
      }
    }
  }
  async syncReownName(address, chainNamespace) {
    try {
      const registeredWcNames = await this.getReownName(address);
      if (registeredWcNames[0]) {
        const wcName = registeredWcNames[0];
        this.setProfileName(wcName.name, chainNamespace);
      } else {
        this.setProfileName(null, chainNamespace);
      }
    } catch {
      this.setProfileName(null, chainNamespace);
    }
  }
  async syncAdapterConnection(namespace) {
    var _a3, _b2, _c3;
    const adapter = this.getAdapter(namespace);
    const connectorId = StorageUtil.getConnectedConnectorId(namespace);
    const caipNetwork = this.getCaipNetwork();
    try {
      if (!adapter || !connectorId) {
        throw new Error(`Adapter or connectorId not found for namespace ${namespace}`);
      }
      const connection = await (adapter == null ? void 0 : adapter.syncConnection({
        namespace,
        id: connectorId,
        chainId: caipNetwork == null ? void 0 : caipNetwork.id,
        rpcUrl: (_c3 = (_b2 = (_a3 = caipNetwork == null ? void 0 : caipNetwork.rpcUrls) == null ? void 0 : _a3.default) == null ? void 0 : _b2.http) == null ? void 0 : _c3[0]
      }));
      if (connection) {
        const accounts = await (adapter == null ? void 0 : adapter.getAccounts({
          namespace,
          id: connectorId
        }));
        if (accounts && accounts.accounts.length > 0) {
          this.setAllAccounts(accounts.accounts, namespace);
        } else {
          this.setAllAccounts([CoreHelperUtil.createAccount(namespace, connection.address, "eoa")], namespace);
        }
        this.syncProvider({ ...connection, chainNamespace: namespace });
        await this.syncAccount({ ...connection, chainNamespace: namespace });
        this.setStatus("connected", namespace);
      } else {
        this.setStatus("disconnected", namespace);
      }
    } catch (e3) {
      StorageUtil.deleteConnectedConnectorId(namespace);
      this.setStatus("disconnected", namespace);
    }
  }
  async syncNamespaceConnection(namespace) {
    var _a3;
    try {
      const connectorId = StorageUtil.getConnectedConnectorId(namespace);
      const isEmailUsed = (_a3 = this.authProvider) == null ? void 0 : _a3.getLoginEmailUsed();
      if (isEmailUsed) {
        return;
      }
      this.setStatus("connecting", namespace);
      switch (connectorId) {
        case ConstantsUtil$4.CONNECTOR_ID.WALLET_CONNECT:
          await this.syncWalletConnectAccount();
          break;
        case ConstantsUtil$4.CONNECTOR_ID.AUTH:
          break;
        default:
          await this.syncAdapterConnection(namespace);
      }
    } catch (err) {
      console.warn("AppKit couldn't sync existing connection", err);
      StorageUtil.deleteConnectedConnectorId(namespace);
      this.setStatus("disconnected", namespace);
    }
  }
  async syncExistingConnection() {
    await Promise.allSettled(this.chainNamespaces.map((namespace) => this.syncNamespaceConnection(namespace)));
  }
  getAdapter(namespace) {
    var _a3;
    if (!namespace) {
      return void 0;
    }
    return (_a3 = this.chainAdapters) == null ? void 0 : _a3[namespace];
  }
  createUniversalProvider() {
    var _a3;
    if (!this.universalProviderInitPromise && CoreHelperUtil.isClient() && ((_a3 = this.options) == null ? void 0 : _a3.projectId)) {
      this.universalProviderInitPromise = this.initializeUniversalAdapter();
    }
    return this.universalProviderInitPromise;
  }
  handleAlertError(error) {
    const matchedUniversalProviderError = Object.entries(ErrorUtil.UniversalProviderErrors).find(([, { message: message2 }]) => error.message.includes(message2));
    const [errorKey, errorValue] = matchedUniversalProviderError ?? [];
    const { message, alertErrorKey } = errorValue ?? {};
    if (errorKey && message && !this.reportedAlertErrors[errorKey]) {
      const alertError = ErrorUtil.ALERT_ERRORS[alertErrorKey];
      if (alertError) {
        AlertController.open(alertError, "error");
        this.reportedAlertErrors[errorKey] = true;
      }
    }
  }
  async initializeUniversalAdapter() {
    var _a3, _b2, _c3, _d, _e4, _f, _g, _h, _i2, _j, _k, _l, _m, _n2, _o2, _p, _q;
    const logger = LoggerUtil.createLogger((error, ...args) => {
      if (error) {
        this.handleAlertError(error);
      }
      console.error(...args);
    });
    const envKey = getEnv().toUpperCase();
    const verifyUrl = ((_a3 = ConstantsUtil$4.getVerifyUrl) == null ? void 0 : _a3.call(ConstantsUtil$4)) || ((_b2 = ConstantsUtil$4.VERIFY_URL) == null ? void 0 : _b2[envKey]) || "http://cross-verify.crosstoken.io";
    const relayUrl = ((_c3 = ConstantsUtil$4.getRelayUrl) == null ? void 0 : _c3.call(ConstantsUtil$4)) || ((_d = ConstantsUtil$4.RELAY_URL) == null ? void 0 : _d[envKey]) || "wss://cross-relay.crosstoken.io/ws";
    const universalProviderOptions = {
      projectId: (_e4 = this.options) == null ? void 0 : _e4.projectId,
      metadata: {
        name: ((_f = this.options) == null ? void 0 : _f.metadata) ? (_g = this.options) == null ? void 0 : _g.metadata.name : "",
        description: ((_h = this.options) == null ? void 0 : _h.metadata) ? (_i2 = this.options) == null ? void 0 : _i2.metadata.description : "",
        url: ((_j = this.options) == null ? void 0 : _j.metadata) ? (_k = this.options) == null ? void 0 : _k.metadata.url : "",
        icons: ((_l = this.options) == null ? void 0 : _l.metadata) ? (_m = this.options) == null ? void 0 : _m.metadata.icons : [""],
        verifyUrl,
        redirect: {
          universal: (_p = (_o2 = (_n2 = this.options) == null ? void 0 : _n2.metadata) == null ? void 0 : _o2.redirect) == null ? void 0 : _p.universal
        }
      },
      logger,
      relayUrl,
      // Use unique storage prefix to avoid conflicts with other WalletConnect/Reown instances
      customStoragePrefix: "nexus-"
    };
    console.log(`relayUrl: ${universalProviderOptions.relayUrl}`);
    OptionsController.setUsingInjectedUniversalProvider(Boolean((_q = this.options) == null ? void 0 : _q.universalProvider));
    this.universalProvider = this.options.universalProvider ?? await Z$1.init(universalProviderOptions);
    this.listenWalletConnect();
  }
  async getUniversalProvider() {
    if (!this.universalProvider) {
      try {
        await this.createUniversalProvider();
      } catch (error) {
        throw new Error("AppKit:getUniversalProvider - Cannot create provider");
      }
    }
    return this.universalProvider;
  }
  createAuthProvider() {
    var _a3, _b2, _c3, _d, _e4, _f, _g, _h, _i2, _j, _k;
    const isEmailEnabled = ((_b2 = (_a3 = this.options) == null ? void 0 : _a3.features) == null ? void 0 : _b2.email) === void 0 ? ConstantsUtil$3.DEFAULT_FEATURES.email : (_d = (_c3 = this.options) == null ? void 0 : _c3.features) == null ? void 0 : _d.email;
    const isSocialsEnabled = ((_f = (_e4 = this.options) == null ? void 0 : _e4.features) == null ? void 0 : _f.socials) ? ((_i2 = (_h = (_g = this.options) == null ? void 0 : _g.features) == null ? void 0 : _h.socials) == null ? void 0 : _i2.length) > 0 : ConstantsUtil$3.DEFAULT_FEATURES.socials;
    const isAuthEnabled = isEmailEnabled || isSocialsEnabled;
    if (!this.authProvider && ((_j = this.options) == null ? void 0 : _j.projectId) && isAuthEnabled) {
      this.authProvider = W3mFrameProviderSingleton.getInstance({
        projectId: this.options.projectId,
        enableLogger: this.options.enableAuthLogger,
        chainId: (_k = this.getCaipNetwork()) == null ? void 0 : _k.caipNetworkId,
        onTimeout: () => {
          AlertController.open(ErrorUtil.ALERT_ERRORS.SOCIALS_TIMEOUT, "error");
        }
      });
      this.subscribeState((val) => {
        var _a4;
        if (!val.open) {
          (_a4 = this.authProvider) == null ? void 0 : _a4.rejectRpcRequests();
        }
      });
      this.syncAuthConnector(this.authProvider);
      this.checkExistingSocialConnection();
    }
  }
  async createUniversalProviderForAdapter(chainNamespace) {
    var _a3, _b2, _c3;
    await this.getUniversalProvider();
    if (this.universalProvider) {
      (_c3 = (_b2 = (_a3 = this.chainAdapters) == null ? void 0 : _a3[chainNamespace]) == null ? void 0 : _b2.setUniversalProvider) == null ? void 0 : _c3.call(_b2, this.universalProvider);
    }
  }
  createAuthProviderForAdapter(chainNamespace) {
    var _a3, _b2, _c3;
    this.createAuthProvider();
    if (this.authProvider) {
      (_c3 = (_b2 = (_a3 = this.chainAdapters) == null ? void 0 : _a3[chainNamespace]) == null ? void 0 : _b2.setAuthProvider) == null ? void 0 : _c3.call(_b2, this.authProvider);
    }
  }
  createAdapter(blueprint) {
    var _a3;
    if (!blueprint) {
      return;
    }
    const namespace = blueprint.namespace;
    if (!namespace) {
      return;
    }
    this.createClients();
    const adapterBlueprint = blueprint;
    adapterBlueprint.namespace = namespace;
    adapterBlueprint.construct({
      namespace,
      projectId: (_a3 = this.options) == null ? void 0 : _a3.projectId,
      networks: this.caipNetworks
    });
    if (!this.chainNamespaces.includes(namespace)) {
      this.chainNamespaces.push(namespace);
    }
    if (this.chainAdapters) {
      this.chainAdapters[namespace] = adapterBlueprint;
    }
  }
  createAdapters(blueprints) {
    this.createClients();
    return this.chainNamespaces.reduce((adapters, namespace) => {
      var _a3;
      const blueprint = blueprints == null ? void 0 : blueprints.find((b2) => b2.namespace === namespace);
      if (blueprint) {
        adapters[namespace] = blueprint;
        adapters[namespace].namespace = namespace;
        adapters[namespace].construct({
          namespace,
          projectId: (_a3 = this.options) == null ? void 0 : _a3.projectId,
          networks: this.caipNetworks
        });
      } else {
        adapters[namespace] = new UniversalAdapter({
          namespace,
          networks: this.caipNetworks
        });
      }
      return adapters;
    }, {});
  }
  onConnectors(chainNamespace) {
    const adapter = this.getAdapter(chainNamespace);
    adapter == null ? void 0 : adapter.on("connectors", this.setConnectors.bind(this));
  }
  async initChainAdapter(namespace) {
    var _a3;
    this.onConnectors(namespace);
    this.listenAdapter(namespace);
    (_a3 = this.chainAdapters) == null ? void 0 : _a3[namespace].syncConnectors(this.options, this);
    await this.createUniversalProviderForAdapter(namespace);
    this.createAuthProviderForAdapter(namespace);
  }
  async initChainAdapters() {
    await Promise.all(this.chainNamespaces.map(async (namespace) => {
      await this.initChainAdapter(namespace);
    }));
  }
  getUnsupportedNetwork(caipNetworkId) {
    return {
      id: caipNetworkId.split(":")[1],
      caipNetworkId,
      name: ConstantsUtil$4.UNSUPPORTED_NETWORK_NAME,
      chainNamespace: caipNetworkId.split(":")[0],
      nativeCurrency: {
        name: "",
        decimals: 0,
        symbol: ""
      },
      rpcUrls: {
        default: {
          http: []
        }
      }
    };
  }
  getDefaultNetwork() {
    var _a3, _b2;
    const caipNetworkIdFromStorage = StorageUtil.getActiveCaipNetworkId();
    if (caipNetworkIdFromStorage) {
      const caipNetwork = (_a3 = this.caipNetworks) == null ? void 0 : _a3.find((n5) => n5.caipNetworkId === caipNetworkIdFromStorage);
      if (caipNetwork) {
        return caipNetwork;
      }
      if (this.defaultCaipNetwork) {
        return this.defaultCaipNetwork;
      }
      return this.getUnsupportedNetwork(caipNetworkIdFromStorage);
    }
    if (this.defaultCaipNetwork) {
      return this.defaultCaipNetwork;
    }
    return (_b2 = this.caipNetworks) == null ? void 0 : _b2[0];
  }
  async injectModalUi() {
    if (!this.initPromise && !isInitialized && CoreHelperUtil.isClient()) {
      isInitialized = true;
      this.initPromise = new Promise(async (resolve) => {
        await Promise.all([
          Promise.resolve().then(() => index),
          import("./w3m-modal-BMYzmiT1.js")
        ]);
        const modal = document.createElement("cross-w3m-modal");
        if (!OptionsController.state.disableAppend && !OptionsController.state.enableEmbedded) {
          document.body.insertAdjacentElement("beforeend", modal);
        }
        resolve();
      });
    }
    return this.initPromise;
  }
  async checkExistingSocialConnection() {
    var _a3;
    try {
      if (!CoreHelperUtil.isTelegram()) {
        return;
      }
      const socialProviderToConnect = SafeLocalStorage.getItem(SafeLocalStorageKeys.SOCIAL_PROVIDER);
      if (!socialProviderToConnect) {
        return;
      }
      if (typeof window === "undefined" || typeof document === "undefined") {
        return;
      }
      const url = new URL(window.location.href);
      const resultUri = url.searchParams.get("result_uri");
      if (!resultUri) {
        return;
      }
      AccountController.setSocialProvider(socialProviderToConnect, ChainController.state.activeChain);
      await ((_a3 = this.authProvider) == null ? void 0 : _a3.init());
      const authConnector = ConnectorController.getAuthConnector();
      if (socialProviderToConnect && authConnector) {
        this.setLoading(true);
        await authConnector.provider.connectSocial(resultUri);
        await ConnectionController.connectExternal(authConnector, authConnector.chain);
        StorageUtil.setConnectedSocialProvider(socialProviderToConnect);
        SafeLocalStorage.removeItem(SafeLocalStorageKeys.SOCIAL_PROVIDER);
        EventsController.sendEvent({
          type: "track",
          event: "SOCIAL_LOGIN_SUCCESS",
          properties: { provider: socialProviderToConnect }
        });
      }
    } catch (error) {
      this.setLoading(false);
      console.error("checkExistingSocialConnection error", error);
    }
    try {
      const url = new URL(window.location.href);
      url.searchParams.delete("result_uri");
      window.history.replaceState({}, document.title, url.toString());
    } catch (error) {
      console.error("tma social login failed", error);
    }
  }
}
var __decorate$1M = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
class W3mAccountButtonBase extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.disabled = false;
    this.balance = "show";
    this.charsStart = 4;
    this.charsEnd = 6;
    this.caipAddress = ChainController.state.activeCaipAddress;
    this.balanceVal = AccountController.state.balance;
    this.balanceSymbol = AccountController.state.balanceSymbol;
    this.profileName = AccountController.state.profileName;
    this.profileImage = AccountController.state.profileImage;
    this.network = ChainController.state.activeCaipNetwork;
    this.networkImage = AssetUtil.getNetworkImage(this.network);
    this.isSupported = OptionsController.state.allowUnsupportedChain ? true : ChainController.state.activeChain ? ChainController.checkIfSupportedNetwork(ChainController.state.activeChain) : true;
    this.unsubscribe.push(...[
      AssetController.subscribeNetworkImages(() => {
        this.networkImage = AssetUtil.getNetworkImage(this.network);
      }),
      ChainController.subscribeKey("activeCaipAddress", (val) => {
        this.caipAddress = val;
      }),
      AccountController.subscribeKey("balance", (val) => this.balanceVal = val),
      AccountController.subscribeKey("balanceSymbol", (val) => this.balanceSymbol = val),
      AccountController.subscribeKey("profileName", (val) => this.profileName = val),
      AccountController.subscribeKey("profileImage", (val) => this.profileImage = val),
      ChainController.subscribeKey("activeCaipNetwork", (val) => {
        this.network = val;
        this.networkImage = AssetUtil.getNetworkImage(val);
        this.isSupported = (val == null ? void 0 : val.chainNamespace) ? ChainController.checkIfSupportedNetwork(val == null ? void 0 : val.chainNamespace) : true;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    if (!ChainController.state.activeChain) {
      return null;
    }
    const shouldShowBalance = this.balance === "show";
    const shouldShowLoading = typeof this.balanceVal !== "string";
    return x$3`
      <cross-wui-account-button
        .disabled=${Boolean(this.disabled)}
        .isUnsupportedChain=${OptionsController.state.allowUnsupportedChain ? false : !this.isSupported}
        address=${o$2(CoreHelperUtil.getPlainAddress(this.caipAddress))}
        profileName=${o$2(this.profileName)}
        networkSrc=${o$2(this.networkImage)}
        avatarSrc=${o$2(this.profileImage)}
        balance=${shouldShowBalance ? CoreHelperUtil.formatBalance(this.balanceVal, this.balanceSymbol) : ""}
        @click=${this.onClick.bind(this)}
        data-testid="account-button"
        .charsStart=${this.charsStart}
        .charsEnd=${this.charsEnd}
        ?loading=${shouldShowLoading}
      >
      </cross-wui-account-button>
    `;
  }
  onClick() {
    if (this.isSupported || OptionsController.state.allowUnsupportedChain) {
      ModalController.open();
    } else {
      ModalController.open({ view: "UnsupportedChain" });
    }
  }
}
__decorate$1M([
  n$3({ type: Boolean })
], W3mAccountButtonBase.prototype, "disabled", void 0);
__decorate$1M([
  n$3()
], W3mAccountButtonBase.prototype, "balance", void 0);
__decorate$1M([
  n$3()
], W3mAccountButtonBase.prototype, "charsStart", void 0);
__decorate$1M([
  n$3()
], W3mAccountButtonBase.prototype, "charsEnd", void 0);
__decorate$1M([
  r$1()
], W3mAccountButtonBase.prototype, "caipAddress", void 0);
__decorate$1M([
  r$1()
], W3mAccountButtonBase.prototype, "balanceVal", void 0);
__decorate$1M([
  r$1()
], W3mAccountButtonBase.prototype, "balanceSymbol", void 0);
__decorate$1M([
  r$1()
], W3mAccountButtonBase.prototype, "profileName", void 0);
__decorate$1M([
  r$1()
], W3mAccountButtonBase.prototype, "profileImage", void 0);
__decorate$1M([
  r$1()
], W3mAccountButtonBase.prototype, "network", void 0);
__decorate$1M([
  r$1()
], W3mAccountButtonBase.prototype, "networkImage", void 0);
__decorate$1M([
  r$1()
], W3mAccountButtonBase.prototype, "isSupported", void 0);
let W3mAccountButton = class W3mAccountButton2 extends W3mAccountButtonBase {
};
W3mAccountButton = __decorate$1M([
  customElement("cross-w3m-account-button")
], W3mAccountButton);
let AppKitAccountButton = class AppKitAccountButton2 extends W3mAccountButtonBase {
};
AppKitAccountButton = __decorate$1M([
  customElement("appkit-account-button")
], AppKitAccountButton);
const styles$18 = i$4`
  :host {
    display: block;
    width: max-content;
  }
`;
var __decorate$1L = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
class W3mButtonBase extends i$1 {
  constructor() {
    super(...arguments);
    this.unsubscribe = [];
    this.disabled = false;
    this.balance = void 0;
    this.size = void 0;
    this.label = void 0;
    this.loadingLabel = void 0;
    this.charsStart = 4;
    this.charsEnd = 6;
    this.caipAddress = ChainController.state.activeCaipAddress;
    this.isLoading = ModalController.state.loading;
  }
  firstUpdated() {
    this.unsubscribe.push(ChainController.subscribeKey("activeCaipAddress", (val) => this.caipAddress = val), ModalController.subscribeKey("loading", (val) => this.isLoading = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return this.caipAddress && !this.isLoading ? x$3`
          <appkit-account-button
            .disabled=${Boolean(this.disabled)}
            balance=${o$2(this.balance)}
            .charsStart=${o$2(this.charsStart)}
            .charsEnd=${o$2(this.charsEnd)}
          >
          </appkit-account-button>
        ` : x$3`
          <appkit-connect-button
            size=${o$2(this.size)}
            label=${o$2(this.label)}
            loadingLabel=${o$2(this.loadingLabel)}
          ></appkit-connect-button>
        `;
  }
}
W3mButtonBase.styles = styles$18;
__decorate$1L([
  n$3({ type: Boolean })
], W3mButtonBase.prototype, "disabled", void 0);
__decorate$1L([
  n$3()
], W3mButtonBase.prototype, "balance", void 0);
__decorate$1L([
  n$3()
], W3mButtonBase.prototype, "size", void 0);
__decorate$1L([
  n$3()
], W3mButtonBase.prototype, "label", void 0);
__decorate$1L([
  n$3()
], W3mButtonBase.prototype, "loadingLabel", void 0);
__decorate$1L([
  n$3()
], W3mButtonBase.prototype, "charsStart", void 0);
__decorate$1L([
  n$3()
], W3mButtonBase.prototype, "charsEnd", void 0);
__decorate$1L([
  r$1()
], W3mButtonBase.prototype, "caipAddress", void 0);
__decorate$1L([
  r$1()
], W3mButtonBase.prototype, "isLoading", void 0);
let W3mButton = class W3mButton2 extends W3mButtonBase {
};
W3mButton = __decorate$1L([
  customElement("cross-w3m-button")
], W3mButton);
let AppKitButton = class AppKitButton2 extends W3mButtonBase {
};
AppKitButton = __decorate$1L([
  customElement("appkit-button")
], AppKitButton);
var __decorate$1K = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
class W3mConnectButtonBase extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.size = "md";
    this.label = "Connect Wallet";
    this.loadingLabel = "Connecting...";
    this.open = ModalController.state.open;
    this.loading = ModalController.state.loading;
    this.unsubscribe.push(ModalController.subscribe((val) => {
      this.open = val.open;
      this.loading = val.loading;
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const isLoading = this.loading || this.open;
    return x$3`
      <cross-wui-connect-button
        size=${o$2(this.size)}
        .loading=${isLoading}
        @click=${this.onClick.bind(this)}
        data-testid="connect-button"
      >
        ${isLoading ? this.loadingLabel : this.label}
      </cross-wui-connect-button>
    `;
  }
  onClick() {
    if (this.open) {
      ModalController.close();
    } else if (!this.loading) {
      ModalController.open();
    }
  }
}
__decorate$1K([
  n$3()
], W3mConnectButtonBase.prototype, "size", void 0);
__decorate$1K([
  n$3()
], W3mConnectButtonBase.prototype, "label", void 0);
__decorate$1K([
  n$3()
], W3mConnectButtonBase.prototype, "loadingLabel", void 0);
__decorate$1K([
  r$1()
], W3mConnectButtonBase.prototype, "open", void 0);
__decorate$1K([
  r$1()
], W3mConnectButtonBase.prototype, "loading", void 0);
let W3mConnectButton = class W3mConnectButton2 extends W3mConnectButtonBase {
};
W3mConnectButton = __decorate$1K([
  customElement("cross-w3m-connect-button")
], W3mConnectButton);
let AppKitConnectButton = class AppKitConnectButton2 extends W3mConnectButtonBase {
};
AppKitConnectButton = __decorate$1K([
  customElement("appkit-connect-button")
], AppKitConnectButton);
const styles$17 = i$4`
  :host {
    display: block;
    width: max-content;
  }
`;
var __decorate$1J = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
class W3mNetworkButtonBase extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.disabled = false;
    this.network = ChainController.state.activeCaipNetwork;
    this.networkImage = AssetUtil.getNetworkImage(this.network);
    this.caipAddress = ChainController.state.activeCaipAddress;
    this.loading = ModalController.state.loading;
    this.isSupported = OptionsController.state.allowUnsupportedChain ? true : ChainController.state.activeChain ? ChainController.checkIfSupportedNetwork(ChainController.state.activeChain) : true;
    this.unsubscribe.push(...[
      AssetController.subscribeNetworkImages(() => {
        this.networkImage = AssetUtil.getNetworkImage(this.network);
      }),
      ChainController.subscribeKey("activeCaipAddress", (val) => {
        this.caipAddress = val;
      }),
      ChainController.subscribeKey("activeCaipNetwork", (val) => {
        this.network = val;
        this.networkImage = AssetUtil.getNetworkImage(val);
        this.isSupported = (val == null ? void 0 : val.chainNamespace) ? ChainController.checkIfSupportedNetwork(val.chainNamespace) : true;
      }),
      ModalController.subscribeKey("loading", (val) => this.loading = val)
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const isSupported = this.network ? ChainController.checkIfSupportedNetwork(this.network.chainNamespace) : true;
    return x$3`
      <cross-wui-network-button
        .disabled=${Boolean(this.disabled || this.loading)}
        .isUnsupportedChain=${OptionsController.state.allowUnsupportedChain ? false : !isSupported}
        imageSrc=${o$2(this.networkImage)}
        @click=${this.onClick.bind(this)}
        data-testid="cross-w3m-network-button"
      >
        ${this.getLabel()}
        <slot></slot>
      </cross-wui-network-button>
    `;
  }
  getLabel() {
    if (this.network) {
      if (!this.isSupported && !OptionsController.state.allowUnsupportedChain) {
        return "Switch Network";
      }
      return this.network.name;
    }
    if (this.label) {
      return this.label;
    }
    if (this.caipAddress) {
      return "Unknown Network";
    }
    return "Select Network";
  }
  onClick() {
    if (!this.loading) {
      EventsController.sendEvent({ type: "track", event: "CLICK_NETWORKS" });
      ModalController.open({ view: "Networks" });
    }
  }
}
W3mNetworkButtonBase.styles = styles$17;
__decorate$1J([
  n$3({ type: Boolean })
], W3mNetworkButtonBase.prototype, "disabled", void 0);
__decorate$1J([
  n$3({ type: String })
], W3mNetworkButtonBase.prototype, "label", void 0);
__decorate$1J([
  r$1()
], W3mNetworkButtonBase.prototype, "network", void 0);
__decorate$1J([
  r$1()
], W3mNetworkButtonBase.prototype, "networkImage", void 0);
__decorate$1J([
  r$1()
], W3mNetworkButtonBase.prototype, "caipAddress", void 0);
__decorate$1J([
  r$1()
], W3mNetworkButtonBase.prototype, "loading", void 0);
__decorate$1J([
  r$1()
], W3mNetworkButtonBase.prototype, "isSupported", void 0);
let W3mNetworkButton = class W3mNetworkButton2 extends W3mNetworkButtonBase {
};
W3mNetworkButton = __decorate$1J([
  customElement("cross-w3m-network-button")
], W3mNetworkButton);
let AppKitNetworkButton = class AppKitNetworkButton2 extends W3mNetworkButtonBase {
};
AppKitNetworkButton = __decorate$1J([
  customElement("appkit-network-button")
], AppKitNetworkButton);
const styles$16 = i$4`
  :host {
    --prev-height: 0px;
    --new-height: 0px;
    display: block;
  }

  div.w3m-router-container {
    transform: translateY(0);
    opacity: 1;
  }

  div.w3m-router-container[view-direction='prev'] {
    animation:
      slide-left-out 150ms forwards ease,
      slide-left-in 150ms forwards ease;
    animation-delay: 0ms, 200ms;
  }

  div.w3m-router-container[view-direction='next'] {
    animation:
      slide-right-out 150ms forwards ease,
      slide-right-in 150ms forwards ease;
    animation-delay: 0ms, 200ms;
  }

  @keyframes slide-left-out {
    from {
      transform: translateX(0px);
      opacity: 1;
    }
    to {
      transform: translateX(10px);
      opacity: 0;
    }
  }

  @keyframes slide-left-in {
    from {
      transform: translateX(-10px);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }

  @keyframes slide-right-out {
    from {
      transform: translateX(0px);
      opacity: 1;
    }
    to {
      transform: translateX(-10px);
      opacity: 0;
    }
  }

  @keyframes slide-right-in {
    from {
      transform: translateX(10px);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }
`;
var __decorate$1I = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mRouter = class W3mRouter2 extends i$1 {
  constructor() {
    super();
    this.resizeObserver = void 0;
    this.prevHeight = "0px";
    this.prevHistoryLength = 1;
    this.unsubscribe = [];
    this.view = RouterController.state.view;
    this.viewDirection = "";
    this.unsubscribe.push(RouterController.subscribeKey("view", (val) => this.onViewChange(val)));
  }
  firstUpdated() {
    this.resizeObserver = new ResizeObserver(([content]) => {
      const height = `${content == null ? void 0 : content.contentRect.height}px`;
      if (this.prevHeight !== "0px") {
        this.style.setProperty("--prev-height", this.prevHeight);
        this.style.setProperty("--new-height", height);
        this.style.animation = "w3m-view-height 150ms forwards ease";
        this.style.height = "auto";
      }
      setTimeout(() => {
        this.prevHeight = height;
        this.style.animation = "unset";
      }, ConstantsUtil$2.ANIMATION_DURATIONS.ModalHeight);
    });
    this.resizeObserver.observe(this.getWrapper());
  }
  disconnectedCallback() {
    var _a3;
    (_a3 = this.resizeObserver) == null ? void 0 : _a3.unobserve(this.getWrapper());
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x$3`<div class="w3m-router-container" view-direction="${this.viewDirection}">
      ${this.viewTemplate()}
    </div>`;
  }
  viewTemplate() {
    switch (this.view) {
      case "AccountSettings":
        return x$3`<cross-w3m-account-settings-view></cross-w3m-account-settings-view>`;
      case "Account":
        return x$3`<cross-w3m-account-view></cross-w3m-account-view>`;
      case "AllWallets":
        return x$3`<cross-w3m-all-wallets-view></cross-w3m-all-wallets-view>`;
      case "ApproveTransaction":
        return x$3`<cross-w3m-approve-transaction-view></cross-w3m-approve-transaction-view>`;
      case "BuyInProgress":
        return x$3`<cross-w3m-buy-in-progress-view></cross-w3m-buy-in-progress-view>`;
      case "ChooseAccountName":
        return x$3`<cross-w3m-choose-account-name-view></cross-w3m-choose-account-name-view>`;
      case "Connect":
        return x$3`<cross-w3m-connect-view></cross-w3m-connect-view>`;
      case "Create":
        return x$3`<cross-w3m-connect-view walletGuide="explore"></cross-w3m-connect-view>`;
      case "ConnectingWalletConnect": {
        const isMini = CoreHelperUtil.isMiniWindow();
        const isLandscape = CoreHelperUtil.isMobileLandscape();
        console.log(" [Router] ConnectingWalletConnect:", {
          isMini,
          isLandscape,
          selectedView: isMini ? "mini" : isLandscape ? "landscape" : "default"
        });
        return isMini ? x$3`<cross-w3m-connecting-wc-mini-view></cross-w3m-connecting-wc-mini-view>` : isLandscape ? x$3`<cross-w3m-connecting-wc-landscape-view></cross-w3m-connecting-wc-landscape-view>` : x$3`<cross-w3m-connecting-wc-view></cross-w3m-connecting-wc-view>`;
      }
      case "ConnectingWalletConnectBasic":
        return x$3`<cross-w3m-connecting-wc-basic-view></cross-w3m-connecting-wc-basic-view>`;
      case "ConnectingExternal":
        return x$3`<cross-w3m-connecting-external-view></cross-w3m-connecting-external-view>`;
      case "ConnectingSiwe":
        return x$3`<cross-w3m-connecting-siwe-view></cross-w3m-connecting-siwe-view>`;
      case "ConnectWallets":
        return x$3`<cross-w3m-connect-wallets-view></cross-w3m-connect-wallets-view>`;
      case "ConnectSocials":
        return x$3`<cross-w3m-connect-socials-view></cross-w3m-connect-socials-view>`;
      case "ConnectingSocial":
        return x$3`<cross-w3m-connecting-social-view></cross-w3m-connecting-social-view>`;
      case "Downloads":
        return x$3`<cross-w3m-downloads-view></cross-w3m-downloads-view>`;
      case "EmailVerifyOtp":
        return x$3`<cross-w3m-email-verify-otp-view></cross-w3m-email-verify-otp-view>`;
      case "EmailVerifyDevice":
        return x$3`<cross-w3m-email-verify-device-view></cross-w3m-email-verify-device-view>`;
      case "GetWallet":
        return x$3`<cross-w3m-get-wallet-view></cross-w3m-get-wallet-view>`;
      case "Networks":
        return x$3`<cross-w3m-networks-view></cross-w3m-networks-view>`;
      case "SwitchNetwork":
        return x$3`<cross-w3m-network-switch-view></cross-w3m-network-switch-view>`;
      case "Profile":
        return x$3`<cross-w3m-profile-view></cross-w3m-profile-view>`;
      case "SwitchAddress":
        return x$3`<cross-w3m-switch-address-view></cross-w3m-switch-address-view>`;
      case "Transactions":
        return x$3`<cross-w3m-transactions-view></cross-w3m-transactions-view>`;
      case "OnRampProviders":
        return x$3`<w3m-onramp-providers-view></w3m-onramp-providers-view>`;
      case "OnRampActivity":
        return x$3`<cross-w3m-onramp-activity-view></cross-w3m-onramp-activity-view>`;
      case "OnRampTokenSelect":
        return x$3`<cross-w3m-onramp-token-select-view></cross-w3m-onramp-token-select-view>`;
      case "OnRampFiatSelect":
        return x$3`<cross-w3m-onramp-fiat-select-view></cross-w3m-onramp-fiat-select-view>`;
      case "UpgradeEmailWallet":
        return x$3`<cross-w3m-upgrade-wallet-view></cross-w3m-upgrade-wallet-view>`;
      case "UpdateEmailWallet":
        return x$3`<cross-w3m-update-email-wallet-view></cross-w3m-update-email-wallet-view>`;
      case "UpdateEmailPrimaryOtp":
        return x$3`<cross-w3m-update-email-primary-otp-view></cross-w3m-update-email-primary-otp-view>`;
      case "UpdateEmailSecondaryOtp":
        return x$3`<cross-w3m-update-email-secondary-otp-view></cross-w3m-update-email-secondary-otp-view>`;
      case "UnsupportedChain":
        return x$3`<cross-w3m-unsupported-chain-view></cross-w3m-unsupported-chain-view>`;
      case "Swap":
        return x$3`<cross-w3m-swap-view></cross-w3m-swap-view>`;
      case "SwapSelectToken":
        return x$3`<cross-w3m-swap-select-token-view></cross-w3m-swap-select-token-view>`;
      case "SwapPreview":
        return x$3`<cross-w3m-swap-preview-view></cross-w3m-swap-preview-view>`;
      case "WalletSend":
        return x$3`<cross-w3m-wallet-send-view></cross-w3m-wallet-send-view>`;
      case "WalletSendSelectToken":
        return x$3`<cross-w3m-wallet-send-select-token-view></cross-w3m-wallet-send-select-token-view>`;
      case "WalletSendPreview":
        return x$3`<cross-w3m-wallet-send-preview-view></cross-w3m-wallet-send-preview-view>`;
      case "WhatIsABuy":
        return x$3`<cross-w3m-what-is-a-buy-view></cross-w3m-what-is-a-buy-view>`;
      case "WalletReceive":
        return x$3`<cross-w3m-wallet-receive-view></cross-w3m-wallet-receive-view>`;
      case "WalletCompatibleNetworks":
        return x$3`<cross-w3m-wallet-compatible-networks-view></cross-w3m-wallet-compatible-networks-view>`;
      case "WhatIsAWallet":
        return x$3`<cross-w3m-what-is-a-wallet-view></cross-w3m-what-is-a-wallet-view>`;
      case "ConnectingMultiChain":
        return x$3`<cross-w3m-connecting-multi-chain-view></cross-w3m-connecting-multi-chain-view>`;
      case "WhatIsANetwork":
        return x$3`<cross-w3m-what-is-a-network-view></cross-w3m-what-is-a-network-view>`;
      case "ConnectingFarcaster":
        return x$3`<cross-w3m-connecting-farcaster-view></cross-w3m-connecting-farcaster-view>`;
      case "SwitchActiveChain":
        return x$3`<cross-w3m-switch-active-chain-view></cross-w3m-switch-active-chain-view>`;
      case "RegisterAccountName":
        return x$3`<cross-w3m-register-account-name-view></cross-w3m-register-account-name-view>`;
      case "RegisterAccountNameSuccess":
        return x$3`<cross-w3m-register-account-name-success-view></cross-w3m-register-account-name-success-view>`;
      case "SmartSessionCreated":
        return x$3`<cross-w3m-smart-session-created-view></cross-w3m-smart-session-created-view>`;
      case "SmartSessionList":
        return x$3`<cross-w3m-smart-session-list-view></cross-w3m-smart-session-list-view>`;
      case "SIWXSignMessage":
        return x$3`<cross-w3m-siwx-sign-message-view></cross-w3m-siwx-sign-message-view>`;
      default:
        return x$3`<cross-w3m-connect-view></cross-w3m-connect-view>`;
    }
  }
  onViewChange(newView) {
    TooltipController.hide();
    let direction = ConstantsUtil$2.VIEW_DIRECTION.Next;
    const { history } = RouterController.state;
    if (history.length < this.prevHistoryLength) {
      direction = ConstantsUtil$2.VIEW_DIRECTION.Prev;
    }
    this.prevHistoryLength = history.length;
    this.viewDirection = direction;
    setTimeout(() => {
      this.view = newView;
    }, ConstantsUtil$2.ANIMATION_DURATIONS.ViewTransition);
  }
  getWrapper() {
    var _a3;
    return (_a3 = this.shadowRoot) == null ? void 0 : _a3.querySelector("div");
  }
};
W3mRouter.styles = styles$16;
__decorate$1I([
  r$1()
], W3mRouter.prototype, "view", void 0);
__decorate$1I([
  r$1()
], W3mRouter.prototype, "viewDirection", void 0);
W3mRouter = __decorate$1I([
  customElement("cross-w3m-router")
], W3mRouter);
const styles$15 = i$4`
  :host > cross-wui-flex {
    width: 100%;
    max-width: 360px;
  }

  :host > wui-flex > cross-wui-flex {
    border-radius: var(--wui-border-radius-l);
    width: 100%;
  }

  .amounts-container {
    width: 100%;
  }
`;
var __decorate$1H = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
const PAYMENT_CURRENCY_SYMBOLS = {
  USD: "$",
  EUR: "",
  GBP: ""
};
const BUY_PRESET_AMOUNTS = [100, 250, 500, 1e3];
let W3mOnrampWidget = class W3mOnrampWidget2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.disabled = false;
    this.caipAddress = ChainController.state.activeCaipAddress;
    this.loading = ModalController.state.loading;
    this.paymentCurrency = OnRampController.state.paymentCurrency;
    this.paymentAmount = OnRampController.state.paymentAmount;
    this.purchaseAmount = OnRampController.state.purchaseAmount;
    this.quoteLoading = OnRampController.state.quotesLoading;
    this.unsubscribe.push(...[
      ChainController.subscribeKey("activeCaipAddress", (val) => this.caipAddress = val),
      ModalController.subscribeKey("loading", (val) => {
        this.loading = val;
      }),
      OnRampController.subscribe((val) => {
        this.paymentCurrency = val.paymentCurrency;
        this.paymentAmount = val.paymentAmount;
        this.purchaseAmount = val.purchaseAmount;
        this.quoteLoading = val.quotesLoading;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x$3`
      <cross-wui-flex flexDirection="column" justifyContent="center" alignItems="center">
        <cross-wui-flex flexDirection="column" alignItems="center" gap="xs">
          <cross-w3m-onramp-input
            type="Fiat"
            @inputChange=${this.onPaymentAmountChange.bind(this)}
            .value=${this.paymentAmount || 0}
          ></cross-w3m-onramp-input>
          <cross-w3m-onramp-input
            type="Token"
            .value=${this.purchaseAmount || 0}
            .loading=${this.quoteLoading}
          ></cross-w3m-onramp-input>
          <cross-wui-flex justifyContent="space-evenly" class="amounts-container" gap="xs">
            ${BUY_PRESET_AMOUNTS.map((amount) => {
      var _a3;
      return x$3`<cross-wui-button
                  variant=${this.paymentAmount === amount ? "accent" : "neutral"}
                  size="md"
                  textVariant="paragraph-600"
                  fullWidth
                  @click=${() => this.selectPresetAmount(amount)}
                  >${`${PAYMENT_CURRENCY_SYMBOLS[((_a3 = this.paymentCurrency) == null ? void 0 : _a3.id) || "USD"]} ${amount}`}</wui-button
                >`;
    })}
          </cross-wui-flex>
          ${this.templateButton()}
        </cross-wui-flex>
      </cross-wui-flex>
    `;
  }
  templateButton() {
    return this.caipAddress ? x$3`<cross-wui-button
          @click=${this.getQuotes.bind(this)}
          variant="main"
          fullWidth
          size="lg"
          borderRadius="xs"
        >
          Get quotes
        </cross-wui-button>` : x$3`<cross-wui-button
          @click=${this.openModal.bind(this)}
          variant="accent"
          fullWidth
          size="lg"
          borderRadius="xs"
        >
          Connect wallet
        </cross-wui-button>`;
  }
  getQuotes() {
    if (!this.loading) {
      ModalController.open({ view: "OnRampProviders" });
    }
  }
  openModal() {
    ModalController.open({ view: "Connect" });
  }
  async onPaymentAmountChange(event) {
    OnRampController.setPaymentAmount(Number(event.detail));
    await OnRampController.getQuote();
  }
  async selectPresetAmount(amount) {
    OnRampController.setPaymentAmount(amount);
    await OnRampController.getQuote();
  }
};
W3mOnrampWidget.styles = styles$15;
__decorate$1H([
  n$3({ type: Boolean })
], W3mOnrampWidget.prototype, "disabled", void 0);
__decorate$1H([
  r$1()
], W3mOnrampWidget.prototype, "caipAddress", void 0);
__decorate$1H([
  r$1()
], W3mOnrampWidget.prototype, "loading", void 0);
__decorate$1H([
  r$1()
], W3mOnrampWidget.prototype, "paymentCurrency", void 0);
__decorate$1H([
  r$1()
], W3mOnrampWidget.prototype, "paymentAmount", void 0);
__decorate$1H([
  r$1()
], W3mOnrampWidget.prototype, "purchaseAmount", void 0);
__decorate$1H([
  r$1()
], W3mOnrampWidget.prototype, "quoteLoading", void 0);
W3mOnrampWidget = __decorate$1H([
  customElement("cross-w3m-onramp-widget")
], W3mOnrampWidget);
var __decorate$1G = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mAccountSettingsView = class W3mAccountSettingsView2 extends i$1 {
  constructor() {
    super();
    this.usubscribe = [];
    this.networkImages = AssetController.state.networkImages;
    this.address = AccountController.state.address;
    this.profileImage = AccountController.state.profileImage;
    this.profileName = AccountController.state.profileName;
    this.network = ChainController.state.activeCaipNetwork;
    this.preferredAccountType = AccountController.state.preferredAccountType;
    this.disconnecting = false;
    this.loading = false;
    this.switched = false;
    this.text = "";
    this.usubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.address) {
          this.address = val.address;
          this.profileImage = val.profileImage;
          this.profileName = val.profileName;
          this.preferredAccountType = val.preferredAccountType;
        } else {
          ModalController.close();
        }
      }),
      AccountController.subscribeKey("preferredAccountType", (val) => this.preferredAccountType = val),
      ChainController.subscribeKey("activeCaipNetwork", (val) => {
        if (val == null ? void 0 : val.id) {
          this.network = val;
        }
      })
    ]);
  }
  disconnectedCallback() {
    this.usubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a3, _b2, _c3;
    if (!this.address) {
      throw new Error("cross-w3m-account-settings-view: No account provided");
    }
    const networkImage = this.networkImages[((_b2 = (_a3 = this.network) == null ? void 0 : _a3.assets) == null ? void 0 : _b2.imageId) ?? ""];
    return x$3`
      <cross-wui-flex
        flexDirection="column"
        alignItems="center"
        gap="l"
        .padding=${["0", "xl", "m", "xl"]}
      >
        <cross-wui-avatar
          alt=${this.address}
          address=${this.address}
          imageSrc=${o$2(this.profileImage)}
          size="2lg"
        ></cross-wui-avatar>
        <cross-wui-flex flexDirection="column" alignItems="center">
          <cross-wui-flex gap="3xs" alignItems="center" justifyContent="center">
            <cross-wui-text variant="title-6-600" color="fg-100" data-testid="account-settings-address">
              ${UiHelperUtil.getTruncateString({
      string: this.address,
      charsStart: 4,
      charsEnd: 6,
      truncate: "middle"
    })}
            </cross-wui-text>
            <cross-wui-icon-link
              size="md"
              icon="copy"
              iconColor="fg-200"
              @click=${this.onCopyAddress}
            ></cross-wui-icon-link>
          </cross-wui-flex>
        </cross-wui-flex>
      </cross-wui-flex>
      <cross-wui-flex flexDirection="column" gap="m">
        <cross-wui-flex flexDirection="column" gap="xs" .padding=${["0", "l", "m", "l"]}>
          ${this.authCardTemplate()}
          <cross-w3m-account-auth-button></cross-w3m-account-auth-button>
          <cross-wui-list-item
            .variant=${networkImage ? "image" : "icon"}
            iconVariant="overlay"
            icon="networkPlaceholder"
            imageSrc=${o$2(networkImage)}
            ?chevron=${this.isAllowedNetworkSwitch()}
            @click=${this.onNetworks.bind(this)}
            data-testid="account-switch-network-button"
          >
            <cross-wui-text variant="paragraph-500" color="fg-100">
              ${((_c3 = this.network) == null ? void 0 : _c3.name) ?? "Unknown"}
            </cross-wui-text>
          </cross-wui-list-item>
          ${this.togglePreferredAccountBtnTemplate()} ${this.chooseNameButtonTemplate()}
          <cross-wui-list-item
            variant="icon"
            iconVariant="overlay"
            icon="disconnect"
            ?chevron=${false}
            .loading=${this.disconnecting}
            @click=${this.onDisconnect.bind(this)}
            data-testid="disconnect-button"
          >
            <cross-wui-text variant="paragraph-500" color="fg-200">Disconnect</cross-wui-text>
          </cross-wui-list-item>
        </cross-wui-flex>
      </cross-wui-flex>
    `;
  }
  chooseNameButtonTemplate() {
    var _a3;
    const namespace = (_a3 = this.network) == null ? void 0 : _a3.chainNamespace;
    const connectorId = StorageUtil.getConnectedConnectorId(namespace);
    const authConnector = ConnectorController.getAuthConnector();
    const hasNetworkSupport = ChainController.checkIfNamesSupported();
    if (!hasNetworkSupport || !authConnector || connectorId !== ConstantsUtil$4.CONNECTOR_ID.AUTH || this.profileName) {
      return null;
    }
    return x$3`
      <cross-wui-list-item
        variant="icon"
        iconVariant="overlay"
        icon="id"
        iconSize="sm"
        ?chevron=${true}
        @click=${this.onChooseName.bind(this)}
        data-testid="account-choose-name-button"
      >
        <cross-wui-text variant="paragraph-500" color="fg-100">Choose account name </cross-wui-text>
      </cross-wui-list-item>
    `;
  }
  authCardTemplate() {
    var _a3;
    const namespace = (_a3 = this.network) == null ? void 0 : _a3.chainNamespace;
    const connectorId = StorageUtil.getConnectedConnectorId(namespace);
    const authConnector = ConnectorController.getAuthConnector();
    const { origin } = location;
    if (!authConnector || connectorId !== ConstantsUtil$4.CONNECTOR_ID.AUTH || origin.includes(ConstantsUtil$3.SECURE_SITE)) {
      return null;
    }
    return x$3`
      <cross-wui-notice-card
        @click=${this.onGoToUpgradeView.bind(this)}
        label="Upgrade your wallet"
        description="Transition to a self-custodial wallet"
        icon="wallet"
        data-testid="cross-w3m-wallet-upgrade-card"
      ></cross-wui-notice-card>
    `;
  }
  isAllowedNetworkSwitch() {
    const requestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
    const isMultiNetwork = requestedCaipNetworks ? requestedCaipNetworks.length > 1 : false;
    const isValidNetwork = requestedCaipNetworks == null ? void 0 : requestedCaipNetworks.find(({ id: id2 }) => {
      var _a3;
      return id2 === ((_a3 = this.network) == null ? void 0 : _a3.id);
    });
    return isMultiNetwork || !isValidNetwork;
  }
  onCopyAddress() {
    try {
      if (this.address) {
        CoreHelperUtil.copyToClopboard(this.address);
        SnackController.showSuccess("Address copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
  togglePreferredAccountBtnTemplate() {
    var _a3;
    const namespace = (_a3 = this.network) == null ? void 0 : _a3.chainNamespace;
    const isNetworkEnabled = ChainController.checkIfSmartAccountEnabled();
    const connectorId = StorageUtil.getConnectedConnectorId(namespace);
    const authConnector = ConnectorController.getAuthConnector();
    if (!authConnector || connectorId !== ConstantsUtil$4.CONNECTOR_ID.AUTH || !isNetworkEnabled) {
      return null;
    }
    if (!this.switched) {
      this.text = this.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT ? "Switch to your EOA" : "Switch to your smart account";
    }
    return x$3`
      <cross-wui-list-item
        variant="icon"
        iconVariant="overlay"
        icon="swapHorizontalBold"
        iconSize="sm"
        ?chevron=${true}
        ?loading=${this.loading}
        @click=${this.changePreferredAccountType.bind(this)}
        data-testid="account-toggle-preferred-account-type"
      >
        <cross-wui-text variant="paragraph-500" color="fg-100">${this.text}</cross-wui-text>
      </cross-wui-list-item>
    `;
  }
  onChooseName() {
    RouterController.push("ChooseAccountName");
  }
  async changePreferredAccountType() {
    const isSmartAccountEnabled = ChainController.checkIfSmartAccountEnabled();
    const accountTypeTarget = this.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT || !isSmartAccountEnabled ? W3mFrameRpcConstants.ACCOUNT_TYPES.EOA : W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT;
    const authConnector = ConnectorController.getAuthConnector();
    if (!authConnector) {
      return;
    }
    this.loading = true;
    await ConnectionController.setPreferredAccountType(accountTypeTarget);
    this.text = accountTypeTarget === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT ? "Switch to your EOA" : "Switch to your smart account";
    this.switched = true;
    SendController.resetSend();
    this.loading = false;
    this.requestUpdate();
  }
  onNetworks() {
    if (this.isAllowedNetworkSwitch()) {
      RouterController.push("Networks");
    }
  }
  async onDisconnect() {
    try {
      this.disconnecting = true;
      await ConnectionController.disconnect();
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_SUCCESS" });
      ModalController.close();
    } catch {
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_ERROR" });
      SnackController.showError("Failed to disconnect");
    } finally {
      this.disconnecting = false;
    }
  }
  onGoToUpgradeView() {
    EventsController.sendEvent({ type: "track", event: "EMAIL_UPGRADE_FROM_MODAL" });
    RouterController.push("UpgradeEmailWallet");
  }
};
__decorate$1G([
  r$1()
], W3mAccountSettingsView.prototype, "address", void 0);
__decorate$1G([
  r$1()
], W3mAccountSettingsView.prototype, "profileImage", void 0);
__decorate$1G([
  r$1()
], W3mAccountSettingsView.prototype, "profileName", void 0);
__decorate$1G([
  r$1()
], W3mAccountSettingsView.prototype, "network", void 0);
__decorate$1G([
  r$1()
], W3mAccountSettingsView.prototype, "preferredAccountType", void 0);
__decorate$1G([
  r$1()
], W3mAccountSettingsView.prototype, "disconnecting", void 0);
__decorate$1G([
  r$1()
], W3mAccountSettingsView.prototype, "loading", void 0);
__decorate$1G([
  r$1()
], W3mAccountSettingsView.prototype, "switched", void 0);
__decorate$1G([
  r$1()
], W3mAccountSettingsView.prototype, "text", void 0);
W3mAccountSettingsView = __decorate$1G([
  customElement("cross-w3m-account-settings-view")
], W3mAccountSettingsView);
var __decorate$1F = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mAccountView = class W3mAccountView2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.namespace = ChainController.state.activeChain;
    this.unsubscribe.push(ChainController.subscribeKey("activeChain", (namespace) => {
      this.namespace = namespace;
    }));
  }
  render() {
    if (!this.namespace) {
      return null;
    }
    const connectorId = StorageUtil.getConnectedConnectorId(this.namespace);
    const authConnector = ConnectorController.getAuthConnector();
    return x$3`
      ${authConnector && connectorId === ConstantsUtil$4.CONNECTOR_ID.AUTH ? this.walletFeaturesTemplate() : this.defaultTemplate()}
    `;
  }
  walletFeaturesTemplate() {
    return x$3`<cross-w3m-account-wallet-features-widget></cross-w3m-account-wallet-features-widget>`;
  }
  defaultTemplate() {
    return x$3`<cross-w3m-account-default-widget></cross-w3m-account-default-widget>`;
  }
};
__decorate$1F([
  r$1()
], W3mAccountView.prototype, "namespace", void 0);
W3mAccountView = __decorate$1F([
  customElement("cross-w3m-account-view")
], W3mAccountView);
var __decorate$1E = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mAllWalletsView = class W3mAllWalletsView2 extends i$1 {
  constructor() {
    super(...arguments);
    this.search = "";
    this.onDebouncedSearch = CoreHelperUtil.debounce((value) => {
      this.search = value;
    });
  }
  render() {
    const isSearch = this.search.length >= 2;
    return x$3`
      <cross-wui-flex .padding=${["0", "s", "s", "s"]} gap="xs">
        <cross-wui-search-bar @inputChange=${this.onInputChange.bind(this)}></cross-wui-search-bar>
        <cross-wui-certified-switch
          ?checked=${this.badge}
          @click=${this.onClick.bind(this)}
          data-testid="wui-certified-switch"
        ></cross-wui-certified-switch>
        ${this.qrButtonTemplate()}
      </cross-wui-flex>
      ${isSearch || this.badge ? x$3`<w3m-all-wallets-search
            query=${this.search}
            badge=${o$2(this.badge)}
          ></w3m-all-wallets-search>` : x$3`<cross-w3m-all-wallets-list
            badge=${o$2(this.badge)}
          ></cross-w3m-all-wallets-list>`}
    `;
  }
  onInputChange(event) {
    this.onDebouncedSearch(event.detail);
  }
  onClick() {
    if (this.badge === "certified") {
      this.badge = void 0;
      return;
    }
    this.badge = "certified";
    SnackController.showSvg("Only WalletConnect certified", {
      icon: "walletConnectBrown",
      iconColor: "accent-100"
    });
  }
  qrButtonTemplate() {
    if (CoreHelperUtil.isMobile()) {
      return x$3`
        <cross-wui-icon-box
          size="lg"
          iconSize="xl"
          iconColor="accent-100"
          backgroundColor="accent-100"
          icon="qrCode"
          background="transparent"
          border
          borderColor="wui-accent-glass-010"
          @click=${this.onWalletConnectQr.bind(this)}
        ></cross-wui-icon-box>
      `;
    }
    return null;
  }
  onWalletConnectQr() {
    RouterController.push("ConnectingWalletConnect");
  }
};
__decorate$1E([
  r$1()
], W3mAllWalletsView.prototype, "search", void 0);
__decorate$1E([
  r$1()
], W3mAllWalletsView.prototype, "badge", void 0);
W3mAllWalletsView = __decorate$1E([
  customElement("cross-w3m-all-wallets-view")
], W3mAllWalletsView);
const styles$14 = i$4`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  cross-wui-loading-thumbnail {
    position: absolute;
  }

  cross-wui-visual {
    width: var(--wui-wallet-image-size-lg);
    height: var(--wui-wallet-image-size-lg);
    border-radius: calc(var(--wui-border-radius-5xs) * 9 - var(--wui-border-radius-xxs));
    position: relative;
    overflow: hidden;
  }

  wui-visual::after {
    content: '';
    display: block;
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
    border-radius: calc(var(--wui-border-radius-5xs) * 9 - var(--wui-border-radius-xxs));
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  cross-wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition:
      opacity var(--wui-ease-out-power-2) var(--wui-duration-lg),
      transform var(--wui-ease-out-power-2) var(--wui-duration-lg);
    will-change: opacity, transform;
  }

  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }

  [data-error='true'] cross-wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  [data-retry='false'] cross-wui-link {
    display: none;
  }

  [data-retry='true'] cross-wui-link {
    display: block;
    opacity: 1;
  }

  cross-wui-link {
    padding: var(--wui-spacing-4xs) var(--wui-spacing-xxs);
  }
`;
var __decorate$1D = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mBuyInProgressView = class W3mBuyInProgressView2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.selectedOnRampProvider = OnRampController.state.selectedProvider;
    this.uri = ConnectionController.state.wcUri;
    this.ready = false;
    this.showRetry = false;
    this.buffering = false;
    this.error = false;
    this.startTime = null;
    this.isMobile = false;
    this.onRetry = void 0;
    this.unsubscribe.push(...[
      OnRampController.subscribeKey("selectedProvider", (val) => {
        this.selectedOnRampProvider = val;
      })
    ]);
    this.watchTransactions();
  }
  disconnectedCallback() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
    }
  }
  render() {
    var _a3, _b2;
    let label = "Continue in external window";
    if (this.error) {
      label = "Buy failed";
    } else if (this.selectedOnRampProvider) {
      label = `Buy in ${(_a3 = this.selectedOnRampProvider) == null ? void 0 : _a3.label}`;
    }
    const subLabel = this.error ? "Buy can be declined from your side or due to and error on the provider app" : `Well notify you once your Buy is processed`;
    return x$3`
      <cross-wui-flex
        data-error=${o$2(this.error)}
        data-retry=${this.showRetry}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <cross-wui-flex justifyContent="center" alignItems="center">
          <cross-wui-visual
            name=${o$2((_b2 = this.selectedOnRampProvider) == null ? void 0 : _b2.name)}
            size="lg"
            class="provider-image"
          >
          </cross-wui-visual>

          ${this.error ? null : this.loaderTemplate()}

          <cross-wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></cross-wui-icon-box>
        </cross-wui-flex>

        <cross-wui-flex flexDirection="column" alignItems="center" gap="xs">
          <cross-wui-text variant="paragraph-500" color=${this.error ? "error-100" : "fg-100"}>
            ${label}
          </cross-wui-text>
          <cross-wui-text align="center" variant="small-500" color="fg-200">${subLabel}</cross-wui-text>
        </cross-wui-flex>

        ${this.error ? this.tryAgainTemplate() : null}
      </cross-wui-flex>

      <cross-wui-flex .padding=${["0", "xl", "xl", "xl"]} justifyContent="center">
        <cross-wui-link @click=${this.onCopyUri} color="fg-200">
          <cross-wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></cross-wui-icon>
          Copy link
        </cross-wui-link>
      </cross-wui-flex>
    `;
  }
  watchTransactions() {
    if (!this.selectedOnRampProvider) {
      return;
    }
    switch (this.selectedOnRampProvider.name) {
      case "coinbase":
        this.startTime = Date.now();
        this.initializeCoinbaseTransactions();
        break;
    }
  }
  async initializeCoinbaseTransactions() {
    await this.watchCoinbaseTransactions();
    this.intervalId = setInterval(() => this.watchCoinbaseTransactions(), 4e3);
  }
  async watchCoinbaseTransactions() {
    try {
      const address = AccountController.state.address;
      if (!address) {
        throw new Error("No address found");
      }
      const coinbaseResponse = await BlockchainApiController.fetchTransactions({
        account: address,
        onramp: "coinbase"
      });
      const newTransactions = coinbaseResponse.data.filter((tx) => new Date(tx.metadata.minedAt) > new Date(this.startTime) || tx.metadata.status === "ONRAMP_TRANSACTION_STATUS_IN_PROGRESS");
      if (newTransactions.length) {
        clearInterval(this.intervalId);
        RouterController.replace("OnRampActivity");
      } else if (this.startTime && Date.now() - this.startTime >= 18e4) {
        clearInterval(this.intervalId);
        this.error = true;
      }
    } catch (error) {
      SnackController.showError(error);
    }
  }
  onTryAgain() {
    if (!this.selectedOnRampProvider) {
      return;
    }
    this.error = false;
    CoreHelperUtil.openHref(this.selectedOnRampProvider.url, "popupWindow", "width=600,height=800,scrollbars=yes");
  }
  tryAgainTemplate() {
    var _a3;
    if (!((_a3 = this.selectedOnRampProvider) == null ? void 0 : _a3.url)) {
      return null;
    }
    return x$3`<cross-wui-button size="md" variant="accent" @click=${this.onTryAgain.bind(this)}>
      <cross-wui-icon color="inherit" slot="iconLeft" name="refresh"></cross-wui-icon>
      Try again
    </cross-wui-button>`;
  }
  loaderTemplate() {
    const borderRadiusMaster = ThemeController.state.themeVariables["--w3m-border-radius-master"];
    const radius = borderRadiusMaster ? parseInt(borderRadiusMaster.replace("px", ""), 10) : 4;
    return x$3`<cross-wui-loading-thumbnail radius=${radius * 9}></cross-wui-loading-thumbnail>`;
  }
  onCopyUri() {
    var _a3;
    if (!((_a3 = this.selectedOnRampProvider) == null ? void 0 : _a3.url)) {
      SnackController.showError("No link found");
      RouterController.goBack();
      return;
    }
    try {
      CoreHelperUtil.copyToClopboard(this.selectedOnRampProvider.url);
      SnackController.showSuccess("Link copied");
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
};
W3mBuyInProgressView.styles = styles$14;
__decorate$1D([
  r$1()
], W3mBuyInProgressView.prototype, "intervalId", void 0);
__decorate$1D([
  r$1()
], W3mBuyInProgressView.prototype, "selectedOnRampProvider", void 0);
__decorate$1D([
  r$1()
], W3mBuyInProgressView.prototype, "uri", void 0);
__decorate$1D([
  r$1()
], W3mBuyInProgressView.prototype, "ready", void 0);
__decorate$1D([
  r$1()
], W3mBuyInProgressView.prototype, "showRetry", void 0);
__decorate$1D([
  r$1()
], W3mBuyInProgressView.prototype, "buffering", void 0);
__decorate$1D([
  r$1()
], W3mBuyInProgressView.prototype, "error", void 0);
__decorate$1D([
  r$1()
], W3mBuyInProgressView.prototype, "startTime", void 0);
__decorate$1D([
  n$3({ type: Boolean })
], W3mBuyInProgressView.prototype, "isMobile", void 0);
__decorate$1D([
  n$3()
], W3mBuyInProgressView.prototype, "onRetry", void 0);
W3mBuyInProgressView = __decorate$1D([
  customElement("cross-w3m-buy-in-progress-view")
], W3mBuyInProgressView);
const styles$13 = i$4`
  :host {
    --connect-scroll--top-opacity: 0;
    --connect-scroll--bottom-opacity: 0;
    --connect-mask-image: none;
  }

  .connect {
    max-height: clamp(360px, 470px, 80vh);
    scrollbar-width: none;
    overflow-y: scroll;
    overflow-x: hidden;
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
    mask-image: var(--connect-mask-image);
  }

  .guide {
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
  }

  .connect::-webkit-scrollbar {
    display: none;
  }

  .all-wallets {
    flex-flow: column;
  }

  .connect.disabled,
  .guide.disabled {
    opacity: 0.3;
    pointer-events: none;
    user-select: none;
  }

  cross-wui-separator {
    margin: var(--wui-spacing-s) calc(var(--wui-spacing-s) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }
`;
var __decorate$1C = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
const SCROLL_THRESHOLD = 470;
let W3mConnectView = class W3mConnectView2 extends i$1 {
  constructor() {
    var _a3, _b2;
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.authConnector = this.connectors.find((c2) => c2.type === "AUTH");
    this.features = OptionsController.state.features;
    this.enableWallets = OptionsController.state.enableWallets;
    this.noAdapters = ChainController.state.noAdapters;
    this.walletGuide = "get-started";
    this.checked = false;
    this.isEmailEnabled = ((_a3 = this.features) == null ? void 0 : _a3.email) && !ChainController.state.noAdapters;
    this.isSocialEnabled = ((_b2 = this.features) == null ? void 0 : _b2.socials) && this.features.socials.length > 0 && !ChainController.state.noAdapters;
    this.isAuthEnabled = this.checkIfAuthEnabled(this.connectors);
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => {
      this.connectors = val;
      this.authConnector = this.connectors.find((c2) => c2.type === "AUTH");
      this.isAuthEnabled = this.checkIfAuthEnabled(this.connectors);
    }), OptionsController.subscribeKey("features", (val) => this.setEmailAndSocialEnableCheck(val, this.noAdapters)), OptionsController.subscribeKey("enableWallets", (val) => this.enableWallets = val), ChainController.subscribeKey("noAdapters", (val) => this.setEmailAndSocialEnableCheck(this.features, val)));
  }
  disconnectedCallback() {
    var _a3, _b2;
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    (_a3 = this.resizeObserver) == null ? void 0 : _a3.disconnect();
    const connectEl = (_b2 = this.shadowRoot) == null ? void 0 : _b2.querySelector(".connect");
    connectEl == null ? void 0 : connectEl.removeEventListener("scroll", this.handleConnectListScroll.bind(this));
  }
  firstUpdated() {
    var _a3;
    const connectEl = (_a3 = this.shadowRoot) == null ? void 0 : _a3.querySelector(".connect");
    if (connectEl) {
      requestAnimationFrame(this.handleConnectListScroll.bind(this));
      connectEl == null ? void 0 : connectEl.addEventListener("scroll", this.handleConnectListScroll.bind(this));
      this.resizeObserver = new ResizeObserver(() => {
        this.handleConnectListScroll();
      });
      this.resizeObserver.observe(connectEl);
      this.handleConnectListScroll();
    }
  }
  render() {
    var _a3;
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    const isLegalCheckbox = (_a3 = OptionsController.state.features) == null ? void 0 : _a3.legalCheckbox;
    const legalUrl = termsConditionsUrl || privacyPolicyUrl;
    const isShowLegalCheckbox = Boolean(legalUrl) && Boolean(isLegalCheckbox) && this.walletGuide === "get-started";
    const isDisabled = isShowLegalCheckbox && !this.checked;
    const classes = {
      connect: true,
      disabled: isDisabled
    };
    const isEnableWalletGuide = OptionsController.state.enableWalletGuide;
    const isEnableWallets = this.enableWallets;
    const socialOrEmailLoginEnabled = this.isSocialEnabled || this.authConnector;
    const tabIndex = isDisabled ? -1 : void 0;
    return x$3`
      <cross-wui-flex flexDirection="column">
        ${this.legalCheckboxTemplate()}
        <cross-wui-flex
          data-testid="cross-w3m-connect-scroll-view"
          flexDirection="column"
          class=${e$1(classes)}
        >
          <cross-wui-flex
            class="connect-methods"
            flexDirection="column"
            gap="s"
            .padding=${socialOrEmailLoginEnabled && isEnableWallets && isEnableWalletGuide && this.walletGuide === "get-started" ? ["3xs", "s", "0", "s"] : ["3xs", "s", "s", "s"]}
          >
            ${this.renderConnectMethod(tabIndex)}
          </cross-wui-flex>
        </cross-wui-flex>
        <cross-w3m-legal-footer></cross-w3m-legal-footer>
      </cross-wui-flex>
    `;
  }
  setEmailAndSocialEnableCheck(features, noAdapters) {
    this.isEmailEnabled = (features == null ? void 0 : features.email) && !noAdapters;
    this.isSocialEnabled = (features == null ? void 0 : features.socials) && features.socials.length > 0 && !noAdapters;
    this.features = features;
    this.noAdapters = noAdapters;
  }
  checkIfAuthEnabled(connectors) {
    const namespacesWithAuthConnector = connectors.filter((c2) => c2.type === ConstantsUtil$1.CONNECTOR_TYPE_AUTH).map((i4) => i4.chain);
    const authSupportedNamespaces = ConstantsUtil$4.AUTH_CONNECTOR_SUPPORTED_CHAINS;
    return authSupportedNamespaces.some((ns2) => namespacesWithAuthConnector.includes(ns2));
  }
  renderConnectMethod(tabIndex) {
    const connectMethodsOrder = WalletUtil$1.getConnectOrderMethod(this.features, this.connectors);
    return x$3`${connectMethodsOrder.map((method, index2) => {
      switch (method) {
        case "email":
          return x$3`${this.emailTemplate(tabIndex)} ${this.separatorTemplate(index2, "email")}`;
        case "social":
          return x$3`${this.socialListTemplate(tabIndex)}
          ${this.separatorTemplate(index2, "social")}`;
        case "wallet":
          return x$3`${this.walletListTemplate(tabIndex)}
          ${this.separatorTemplate(index2, "wallet")}`;
        default:
          return null;
      }
    })}`;
  }
  checkMethodEnabled(name) {
    switch (name) {
      case "wallet":
        return this.enableWallets;
      case "social":
        return this.isSocialEnabled && this.isAuthEnabled;
      case "email":
        return this.isEmailEnabled && this.isAuthEnabled;
      default:
        return null;
    }
  }
  checkIsThereNextMethod(currentIndex) {
    const connectMethodsOrder = WalletUtil$1.getConnectOrderMethod(this.features, this.connectors);
    const nextMethod = connectMethodsOrder[currentIndex + 1];
    if (!nextMethod) {
      return void 0;
    }
    const isNextMethodEnabled = this.checkMethodEnabled(nextMethod);
    if (isNextMethodEnabled) {
      return nextMethod;
    }
    return this.checkIsThereNextMethod(currentIndex + 1);
  }
  separatorTemplate(index2, type2) {
    const nextEnabledMethod = this.checkIsThereNextMethod(index2);
    const isExplore = this.walletGuide === "explore";
    switch (type2) {
      case "wallet": {
        const isWalletEnable = this.enableWallets;
        return isWalletEnable && nextEnabledMethod && !isExplore ? x$3`<cross-wui-separator data-testid="wui-separator" text="or"></cross-wui-separator>` : null;
      }
      case "email": {
        const isNextMethodSocial = nextEnabledMethod === "social";
        return this.isAuthEnabled && this.isEmailEnabled && !isNextMethodSocial && nextEnabledMethod ? x$3`<cross-wui-separator
              data-testid="cross-w3m-email-login-or-separator"
              text="or"
            ></cross-wui-separator>` : null;
      }
      case "social": {
        const isNextMethodEmail = nextEnabledMethod === "email";
        return this.isAuthEnabled && this.isSocialEnabled && !isNextMethodEmail && nextEnabledMethod ? x$3`<cross-wui-separator data-testid="wui-separator" text="or"></cross-wui-separator>` : null;
      }
      default:
        return null;
    }
  }
  emailTemplate(tabIndex) {
    if (!this.isEmailEnabled || !this.isAuthEnabled) {
      return null;
    }
    return x$3`<cross-w3m-email-login-widget
      walletGuide=${this.walletGuide}
      tabIdx=${o$2(tabIndex)}
    ></cross-w3m-email-login-widget>`;
  }
  socialListTemplate(tabIndex) {
    if (!this.isSocialEnabled || !this.isAuthEnabled) {
      return null;
    }
    return x$3`<cross-w3m-social-login-widget
      walletGuide=${this.walletGuide}
      tabIdx=${o$2(tabIndex)}
    ></cross-w3m-social-login-widget>`;
  }
  walletListTemplate(tabIndex) {
    var _a3, _b2;
    const isEnableWallets = this.enableWallets;
    const isCollapseWalletsOldProp = ((_a3 = this.features) == null ? void 0 : _a3.emailShowWallets) === false;
    const isCollapseWallets = (_b2 = this.features) == null ? void 0 : _b2.collapseWallets;
    const shouldCollapseWallets = isCollapseWalletsOldProp || isCollapseWallets;
    console.log(" walletListTemplate Debug:", {
      isEnableWallets,
      enableWallets: this.enableWallets,
      features: this.features,
      walletGuide: this.walletGuide,
      isCollapseWalletsOldProp,
      isCollapseWallets,
      shouldCollapseWallets
    });
    if (!isEnableWallets) {
      console.log("  ");
      return null;
    }
    if ((CoreHelperUtil.isTelegram() || CoreHelperUtil.isSafari()) && CoreHelperUtil.isIos()) {
      ConnectionController.connectWalletConnect().catch((_e4) => ({}));
    }
    if (this.walletGuide === "explore") {
      return null;
    }
    this.isAuthEnabled && (this.isEmailEnabled || this.isSocialEnabled);
    return x$3`<cross-w3m-wallet-login-list
      tabIdx=${o$2(tabIndex)}
    ></cross-w3m-wallet-login-list>`;
  }
  guideTemplate(disabled = false) {
    const isEnableWalletGuide = OptionsController.state.enableWalletGuide;
    if (!isEnableWalletGuide) {
      return null;
    }
    const classes = {
      guide: true,
      disabled
    };
    const tabIndex = disabled ? -1 : void 0;
    if (!this.authConnector && !this.isSocialEnabled) {
      return null;
    }
    return x$3`
      ${this.walletGuide === "explore" && !ChainController.state.noAdapters ? x$3`<cross-wui-separator data-testid="wui-separator" id="explore" text="or"></cross-wui-separator>` : null}
      <cross-wui-flex flexDirection="column" .padding=${["s", "0", "xl", "0"]} class=${e$1(classes)}>
        <cross-w3m-wallet-guide
          tabIdx=${o$2(tabIndex)}
          walletGuide=${this.walletGuide}
        ></cross-w3m-wallet-guide>
      </cross-wui-flex>
    `;
  }
  legalCheckboxTemplate() {
    if (this.walletGuide === "explore") {
      return null;
    }
    return x$3`<cross-w3m-legal-checkbox
      @checkboxChange=${this.onCheckboxChange.bind(this)}
      data-testid="cross-w3m-legal-checkbox"
    ></cross-w3m-legal-checkbox>`;
  }
  handleConnectListScroll() {
    var _a3;
    const connectEl = (_a3 = this.shadowRoot) == null ? void 0 : _a3.querySelector(".connect");
    if (!connectEl) {
      return;
    }
    const shouldApplyMask = connectEl.scrollHeight > SCROLL_THRESHOLD;
    if (shouldApplyMask) {
      connectEl.style.setProperty("--connect-mask-image", `linear-gradient(
          to bottom,
          rgba(0, 0, 0, calc(1 - var(--connect-scroll--top-opacity))) 0px,
          rgba(200, 200, 200, calc(1 - var(--connect-scroll--top-opacity))) 1px,
          black 40px,
          black calc(100% - 40px),
          rgba(155, 155, 155, calc(1 - var(--connect-scroll--bottom-opacity))) calc(100% - 1px),
          rgba(0, 0, 0, calc(1 - var(--connect-scroll--bottom-opacity))) 100%
        )`);
      connectEl.style.setProperty("--connect-scroll--top-opacity", MathUtil.interpolate([0, 50], [0, 1], connectEl.scrollTop).toString());
      connectEl.style.setProperty("--connect-scroll--bottom-opacity", MathUtil.interpolate([0, 50], [0, 1], connectEl.scrollHeight - connectEl.scrollTop - connectEl.offsetHeight).toString());
    } else {
      connectEl.style.setProperty("--connect-mask-image", "none");
      connectEl.style.setProperty("--connect-scroll--top-opacity", "0");
      connectEl.style.setProperty("--connect-scroll--bottom-opacity", "0");
    }
  }
  onContinueWalletClick() {
    RouterController.push("ConnectWallets");
  }
  onCheckboxChange(event) {
    this.checked = Boolean(event.detail);
  }
};
W3mConnectView.styles = styles$13;
__decorate$1C([
  r$1()
], W3mConnectView.prototype, "connectors", void 0);
__decorate$1C([
  r$1()
], W3mConnectView.prototype, "authConnector", void 0);
__decorate$1C([
  r$1()
], W3mConnectView.prototype, "features", void 0);
__decorate$1C([
  r$1()
], W3mConnectView.prototype, "enableWallets", void 0);
__decorate$1C([
  r$1()
], W3mConnectView.prototype, "noAdapters", void 0);
__decorate$1C([
  n$3()
], W3mConnectView.prototype, "walletGuide", void 0);
__decorate$1C([
  r$1()
], W3mConnectView.prototype, "checked", void 0);
__decorate$1C([
  r$1()
], W3mConnectView.prototype, "isEmailEnabled", void 0);
__decorate$1C([
  r$1()
], W3mConnectView.prototype, "isSocialEnabled", void 0);
__decorate$1C([
  r$1()
], W3mConnectView.prototype, "isAuthEnabled", void 0);
W3mConnectView = __decorate$1C([
  customElement("cross-w3m-connect-view")
], W3mConnectView);
const styles$12 = i$4`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  cross-wui-loading-thumbnail {
    position: absolute;
  }

  cross-wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition-property: opacity, transform;
    transition-duration: var(--wui-duration-lg);
    transition-timing-function: var(--wui-ease-out-power-2);
    will-change: opacity, transform;
  }

  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }

  [data-error='true'] cross-wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  [data-retry='false'] cross-wui-link {
    display: none;
  }

  [data-retry='true'] cross-wui-link {
    display: block;
    opacity: 1;
  }
`;
var __decorate$1B = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
class W3mConnectingWidget extends i$1 {
  constructor() {
    var _a3, _b2, _c3, _d, _e4;
    super();
    this.wallet = (_a3 = RouterController.state.data) == null ? void 0 : _a3.wallet;
    this.connector = (_b2 = RouterController.state.data) == null ? void 0 : _b2.connector;
    this.timeout = void 0;
    this.secondaryBtnIcon = "refresh";
    this.onConnect = void 0;
    this.onRender = void 0;
    this.onAutoConnect = void 0;
    this.isWalletConnect = true;
    this.unsubscribe = [];
    this.imageSrc = AssetUtil.getWalletImage(this.wallet) ?? AssetUtil.getConnectorImage(this.connector);
    this.name = ((_c3 = this.wallet) == null ? void 0 : _c3.name) ?? ((_d = this.connector) == null ? void 0 : _d.name) ?? "Wallet";
    this.isRetrying = false;
    this.uri = ConnectionController.state.wcUri;
    this.error = ConnectionController.state.wcError;
    this.ready = false;
    this.showRetry = false;
    this.secondaryBtnLabel = "Try again";
    this.secondaryLabel = "Accept connection request in the wallet";
    this.buffering = false;
    this.isMobile = false;
    this.onRetry = void 0;
    this.unsubscribe.push(...[
      ConnectionController.subscribeKey("wcUri", (val) => {
        var _a4;
        this.uri = val;
        if (this.isRetrying && this.onRetry) {
          this.isRetrying = false;
          (_a4 = this.onConnect) == null ? void 0 : _a4.call(this);
        }
      }),
      ConnectionController.subscribeKey("wcError", (val) => {
        this.error = val;
      }),
      ConnectionController.subscribeKey("buffering", (val) => {
        this.buffering = val;
      })
    ]);
    if ((CoreHelperUtil.isTelegram() || CoreHelperUtil.isSafari()) && CoreHelperUtil.isIos() && ConnectionController.state.wcUri) {
      (_e4 = this.onConnect) == null ? void 0 : _e4.call(this);
    }
  }
  firstUpdated() {
    var _a3;
    if (this.onAutoConnect) {
      (_a3 = this.onAutoConnect) == null ? void 0 : _a3.call(this);
    }
    this.showRetry = !this.onAutoConnect;
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    clearTimeout(this.timeout);
  }
  render() {
    var _a3;
    (_a3 = this.onRender) == null ? void 0 : _a3.call(this);
    this.onShowRetry();
    const subLabel = this.error ? "Connection can be declined if a previous request is still active" : this.secondaryLabel;
    let label = `Continue in ${this.name}`;
    if (this.buffering) {
      label = "Connecting...";
    }
    if (this.error) {
      label = "Connection declined";
    }
    return x$3`
      <cross-wui-flex
        data-error=${o$2(this.error)}
        data-retry=${this.showRetry}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <cross-wui-flex justifyContent="center" alignItems="center">
          <cross-wui-wallet-image size="lg" imageSrc=${o$2(this.imageSrc)}></cross-wui-wallet-image>

          ${this.error ? null : this.loaderTemplate()}

          <cross-wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></cross-wui-icon-box>
        </cross-wui-flex>

        <cross-wui-flex flexDirection="column" alignItems="center" gap="xs">
          <cross-wui-text variant="paragraph-500" color=${this.error ? "error-100" : "fg-100"}>
            ${label}
          </cross-wui-text>
          <cross-wui-text align="center" variant="small-500" color="fg-200">${subLabel}</cross-wui-text>
        </cross-wui-flex>

        ${this.secondaryBtnLabel ? x$3`
              <cross-wui-button
                variant="accent"
                size="md"
                ?disabled=${this.isRetrying || !this.error && this.buffering}
                @click=${this.onTryAgain.bind(this)}
                data-testid="cross-w3m-connecting-widget-secondary-button"
              >
                <cross-wui-icon color="inherit" slot="iconLeft" name=${this.secondaryBtnIcon}></cross-wui-icon>
                ${this.secondaryBtnLabel}
              </cross-wui-button>
            ` : null}
      </cross-wui-flex>

      ${this.isWalletConnect && !CoreHelperUtil.isMobileLandscape() ? x$3`
            <cross-wui-flex .padding=${["0", "xl", "xl", "xl"]} justifyContent="center">
              <cross-wui-link @click=${this.onCopyUri} color="fg-200" data-testid="wui-link-copy">
                <cross-wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></cross-wui-icon>
                Copy link
              </cross-wui-link>
            </cross-wui-flex>
          ` : null}
      ${CoreHelperUtil.isMobileLandscape() ? null : x$3`<cross-w3m-mobile-download-links
            .wallet=${this.wallet}
          ></cross-w3m-mobile-download-links>`}
    `;
  }
  onShowRetry() {
    var _a3;
    if (this.error && !this.showRetry) {
      this.showRetry = true;
      const retryButton = (_a3 = this.shadowRoot) == null ? void 0 : _a3.querySelector("cross-wui-button");
      retryButton == null ? void 0 : retryButton.animate([{ opacity: 0 }, { opacity: 1 }], {
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  onTryAgain() {
    var _a3, _b2;
    if (!this.buffering) {
      ConnectionController.setWcError(false);
      if (this.onRetry) {
        this.isRetrying = true;
        (_a3 = this.onRetry) == null ? void 0 : _a3.call(this);
      } else {
        (_b2 = this.onConnect) == null ? void 0 : _b2.call(this);
      }
    }
  }
  loaderTemplate() {
    const borderRadiusMaster = ThemeController.state.themeVariables["--w3m-border-radius-master"];
    const radius = borderRadiusMaster ? parseInt(borderRadiusMaster.replace("px", ""), 10) : 4;
    return x$3`<cross-wui-loading-thumbnail radius=${radius * 9}></cross-wui-loading-thumbnail>`;
  }
  onCopyUri() {
    try {
      if (this.uri) {
        CoreHelperUtil.copyToClopboard(this.uri);
        SnackController.showSuccess("Link copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
}
W3mConnectingWidget.styles = styles$12;
__decorate$1B([
  r$1()
], W3mConnectingWidget.prototype, "isRetrying", void 0);
__decorate$1B([
  r$1()
], W3mConnectingWidget.prototype, "uri", void 0);
__decorate$1B([
  r$1()
], W3mConnectingWidget.prototype, "error", void 0);
__decorate$1B([
  r$1()
], W3mConnectingWidget.prototype, "ready", void 0);
__decorate$1B([
  r$1()
], W3mConnectingWidget.prototype, "showRetry", void 0);
__decorate$1B([
  r$1()
], W3mConnectingWidget.prototype, "secondaryBtnLabel", void 0);
__decorate$1B([
  r$1()
], W3mConnectingWidget.prototype, "secondaryLabel", void 0);
__decorate$1B([
  r$1()
], W3mConnectingWidget.prototype, "buffering", void 0);
__decorate$1B([
  n$3({ type: Boolean })
], W3mConnectingWidget.prototype, "isMobile", void 0);
__decorate$1B([
  n$3()
], W3mConnectingWidget.prototype, "onRetry", void 0);
var __decorate$1A = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mConnectingExternalView = class W3mConnectingExternalView2 extends W3mConnectingWidget {
  constructor() {
    super();
    this.externalViewUnsubscribe = [];
    if (!this.connector) {
      throw new Error("w3m-connecting-view: No connector provided");
    }
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: {
        name: this.connector.name ?? "Unknown",
        platform: "browser"
      }
    });
    this.onConnect = this.onConnectProxy.bind(this);
    this.onAutoConnect = this.onConnectProxy.bind(this);
    this.isWalletConnect = false;
    this.externalViewUnsubscribe.push(ChainController.subscribeKey("activeCaipAddress", (val) => {
      if (val) {
        ModalController.close();
      }
    }));
  }
  disconnectedCallback() {
    this.externalViewUnsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  async onConnectProxy() {
    try {
      this.error = false;
      if (this.connector) {
        if (this.connector.id !== ConstantsUtil$4.CONNECTOR_ID.COINBASE_SDK || !this.error) {
          await ConnectionController.connectExternal(this.connector, this.connector.chain);
          EventsController.sendEvent({
            type: "track",
            event: "CONNECT_SUCCESS",
            properties: { method: "browser", name: this.connector.name || "Unknown" }
          });
        }
      }
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: (error == null ? void 0 : error.message) ?? "Unknown" }
      });
      this.error = true;
    }
  }
};
W3mConnectingExternalView = __decorate$1A([
  customElement("cross-w3m-connecting-external-view")
], W3mConnectingExternalView);
const styles$11 = i$4`
  cross-wui-flex,
  cross-wui-list-wallet {
    width: 100%;
  }
`;
var __decorate$1z = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mConnectingMultiChainView = class W3mConnectingMultiChainView2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.activeConnector = ConnectorController.state.activeConnector;
    this.unsubscribe.push(...[ConnectorController.subscribeKey("activeConnector", (val) => this.activeConnector = val)]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a3;
    return x$3`
      <cross-wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["m", "xl", "xl", "xl"]}
        gap="xl"
      >
        <cross-wui-flex justifyContent="center" alignItems="center">
          <cross-wui-wallet-image
            size="lg"
            imageSrc=${o$2(AssetUtil.getConnectorImage(this.activeConnector))}
          ></cross-wui-wallet-image>
        </cross-wui-flex>
        <cross-wui-flex
          flexDirection="column"
          alignItems="center"
          gap="xs"
          .padding=${["0", "s", "0", "s"]}
        >
          <cross-wui-text variant="paragraph-500" color="fg-100">
            Select Chain for ${(_a3 = this.activeConnector) == null ? void 0 : _a3.name}
          </cross-wui-text>
          <cross-wui-text align="center" variant="small-500" color="fg-200"
            >Select which chain to connect to your multi chain wallet</wui-text
          >
        </cross-wui-flex>
        <cross-wui-flex
          flexGrow="1"
          flexDirection="column"
          alignItems="center"
          gap="xs"
          .padding=${["xs", "0", "xs", "0"]}
        >
          ${this.networksTemplate()}
        </cross-wui-flex>
      </cross-wui-flex>
    `;
  }
  networksTemplate() {
    var _a3, _b2;
    return (_b2 = (_a3 = this.activeConnector) == null ? void 0 : _a3.connectors) == null ? void 0 : _b2.map((connector) => connector.name ? x$3`
            <cross-wui-list-wallet
              imageSrc=${o$2(AssetUtil.getChainImage(connector.chain))}
              name=${ConstantsUtil$4.CHAIN_NAME_MAP[connector.chain]}
              @click=${() => this.onConnector(connector)}
              data-testid="wui-list-chain-${connector.chain}"
            ></cross-wui-list-wallet>
          ` : null);
  }
  onConnector(provider) {
    var _a3, _b2;
    const connector = (_b2 = (_a3 = this.activeConnector) == null ? void 0 : _a3.connectors) == null ? void 0 : _b2.find((p2) => p2.chain === provider.chain);
    if (!connector) {
      SnackController.showError("Failed to find connector");
      return;
    }
    if (connector.id === "walletConnect") {
      if (CoreHelperUtil.isMobile()) {
        RouterController.push("AllWallets");
      } else {
        RouterController.push("ConnectingWalletConnect");
      }
    } else {
      RouterController.push("ConnectingExternal", {
        connector
      });
    }
  }
};
W3mConnectingMultiChainView.styles = styles$11;
__decorate$1z([
  r$1()
], W3mConnectingMultiChainView.prototype, "activeConnector", void 0);
W3mConnectingMultiChainView = __decorate$1z([
  customElement("cross-w3m-connecting-multi-chain-view")
], W3mConnectingMultiChainView);
var __decorate$1y = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mConnectingWcView = class W3mConnectingWcView2 extends i$1 {
  constructor() {
    var _a3;
    super();
    this.interval = void 0;
    this.lastRetry = Date.now();
    this.wallet = (_a3 = RouterController.state.data) == null ? void 0 : _a3.wallet;
    this.platform = void 0;
    this.platforms = [];
    this.isSiwxEnabled = Boolean(OptionsController.state.siwx);
    this.determinePlatforms();
    this.initializeConnection();
    this.interval = setInterval(this.initializeConnection.bind(this), ConstantsUtil$3.TEN_SEC_MS);
  }
  disconnectedCallback() {
    clearTimeout(this.interval);
  }
  render() {
    return x$3`
      ${this.headerTemplate()}
      <div>${this.platformTemplate()}</div>
    `;
  }
  async initializeConnection(retry = false) {
    if (this.platform === "browser") {
      return;
    }
    try {
      const { wcPairingExpiry, status } = ConnectionController.state;
      if (retry || CoreHelperUtil.isPairingExpired(wcPairingExpiry) || status === "connecting") {
        await ConnectionController.connectWalletConnect();
        this.finalizeConnection();
        if (!this.isSiwxEnabled) {
          ModalController.close();
        }
      }
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: (error == null ? void 0 : error.message) ?? "Unknown" }
      });
      ConnectionController.setWcError(true);
      if (CoreHelperUtil.isAllowedRetry(this.lastRetry)) {
        SnackController.showError(error.message ?? "Declined");
        this.lastRetry = Date.now();
        this.initializeConnection(true);
      } else {
        SnackController.showError(error.message ?? "Connection error");
      }
    }
  }
  finalizeConnection() {
    var _a3;
    const { wcLinking, recentWallet } = ConnectionController.state;
    if (wcLinking) {
      StorageUtil.setWalletConnectDeepLink(wcLinking);
    }
    if (recentWallet) {
      StorageUtil.setAppKitRecent(recentWallet);
    }
    EventsController.sendEvent({
      type: "track",
      event: "CONNECT_SUCCESS",
      properties: {
        method: wcLinking ? "mobile" : "qrcode",
        name: ((_a3 = this.wallet) == null ? void 0 : _a3.name) || "Unknown"
      }
    });
  }
  isCrossWalletInstalled(rdns) {
    const currentConnectors = ConnectorController.state.connectors;
    const crossWalletExtensionConnectors = currentConnectors.filter((c2) => (c2.type === "ANNOUNCED" || c2.type === "INJECTED") && c2.id === rdns);
    if (crossWalletExtensionConnectors && crossWalletExtensionConnectors.length > 0) {
      return true;
    }
    const isCrossWalletInWindow = typeof window !== "undefined" && window.crossWallet;
    return Boolean(isCrossWalletInWindow);
  }
  determinePlatformsForCross(params) {
    const { mobile_link, rdns, isBrowser } = params;
    const isMobile = CoreHelperUtil.isMobile();
    if (isMobile) {
      if (mobile_link) {
        this.platforms.push("mobile");
        this.platforms.push("qrcode");
        this.platform = "mobile";
      } else {
        this.platforms.push("qrcode");
        this.platform = "qrcode";
      }
      return true;
    }
    if (isBrowser && !ChainController.state.noAdapters && rdns) {
      const isChrome = CoreHelperUtil.isChrome();
      const isCrossWalletFound = this.isCrossWalletInstalled(rdns);
      if (isCrossWalletFound) {
        if (isChrome) {
          this.platforms.push("qrcode");
          this.platforms.push("browser");
          this.platform = "qrcode";
        } else {
          this.platforms.push("qrcode");
          this.platform = "qrcode";
        }
      } else {
        this.platforms.push("qrcode");
        this.platform = "qrcode";
      }
      return true;
    }
    this.platforms.push("qrcode");
    this.platform = "qrcode";
    return true;
  }
  determinePlatforms() {
    var _a3;
    if (!this.wallet) {
      this.platforms.push("qrcode");
      this.platform = "qrcode";
      return;
    }
    if (this.platform) {
      return;
    }
    const { mobile_link, desktop_link, webapp_link, injected: injected2, rdns } = this.wallet;
    const injectedIds = injected2 == null ? void 0 : injected2.map(({ injected_id }) => injected_id).filter(Boolean);
    const browserIds = [...rdns ? [rdns] : injectedIds ?? []];
    const isBrowser = OptionsController.state.isUniversalProvider ? false : browserIds.length;
    const isMobileWc = mobile_link;
    const isWebWc = webapp_link;
    const isBrowserInstalled = ConnectionController.checkInstalled(browserIds);
    const isBrowserWc = isBrowser && isBrowserInstalled;
    const isDesktopWc = desktop_link && !CoreHelperUtil.isMobile();
    const isCrossWallet = ((_a3 = this.wallet.name) == null ? void 0 : _a3.includes("CROSSx Wallet")) || rdns === "nexus.to.crosswallet.desktop";
    if (isCrossWallet && rdns) {
      this.determinePlatformsForCross({ mobile_link, rdns, isBrowser: Boolean(isBrowser) });
      return;
    }
    if (isBrowserWc && !ChainController.state.noAdapters) {
      this.platforms.push("browser");
    }
    if (isMobileWc) {
      this.platforms.push(CoreHelperUtil.isMobile() ? "mobile" : "qrcode");
    }
    if (isWebWc) {
      this.platforms.push("web");
    }
    if (isDesktopWc) {
      this.platforms.push("desktop");
    }
    if (!isBrowserWc && isBrowser && !ChainController.state.noAdapters) {
      this.platforms.push("unsupported");
    }
    this.platform = this.platforms[0];
  }
  platformTemplate() {
    switch (this.platform) {
      case "browser":
        return x$3`<cross-w3m-connecting-wc-browser></cross-w3m-connecting-wc-browser>`;
      case "web":
        return x$3`<cross-w3m-connecting-wc-web></cross-w3m-connecting-wc-web>`;
      case "desktop":
        return x$3`
          <cross-w3m-connecting-wc-desktop .onRetry=${() => this.initializeConnection(true)}>
          </cross-w3m-connecting-wc-desktop>
        `;
      case "mobile":
        return x$3`
          <cross-w3m-connecting-wc-mobile
            isMobile
            .onRetry=${() => this.initializeConnection(true)}
          >
          </cross-w3m-connecting-wc-mobile>
        `;
      case "qrcode":
        return x$3`<cross-w3m-connecting-wc-qrcode></cross-w3m-connecting-wc-qrcode>`;
      default:
        return x$3`<cross-w3m-connecting-wc-unsupported></cross-w3m-connecting-wc-unsupported>`;
    }
  }
  headerTemplate() {
    const multiPlatform = this.platforms.length > 1;
    if (!multiPlatform) {
      return null;
    }
    return x$3`
      <cross-w3m-connecting-header
        .platforms=${this.platforms}
        .onSelectPlatfrom=${this.onSelectPlatform.bind(this)}
      >
      </cross-w3m-connecting-header>
    `;
  }
  async onSelectPlatform(platform) {
    var _a3;
    const container = (_a3 = this.shadowRoot) == null ? void 0 : _a3.querySelector("div");
    if (container) {
      await container.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.platform = platform;
      container.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
};
__decorate$1y([
  r$1()
], W3mConnectingWcView.prototype, "platform", void 0);
__decorate$1y([
  r$1()
], W3mConnectingWcView.prototype, "platforms", void 0);
__decorate$1y([
  r$1()
], W3mConnectingWcView.prototype, "isSiwxEnabled", void 0);
W3mConnectingWcView = __decorate$1y([
  customElement("cross-w3m-connecting-wc-view")
], W3mConnectingWcView);
var __decorate$1x = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mConnectingHeader = class W3mConnectingHeader2 extends i$1 {
  constructor() {
    super();
    this.platformTabs = [];
    this.unsubscribe = [];
    this.platforms = [];
    this.onSelectPlatfrom = void 0;
    this.buffering = false;
    this.style.setProperty("--wui-tabs-active-bg", "#ffffff");
    this.style.setProperty("--wui-tabs-active-text-color", "#222222");
    this.style.setProperty("--wui-tabs-active-icon-color", "#222222");
    this.style.setProperty("--wui-tabs-disabled-opacity", "1");
    this.style.setProperty("--wui-tabs-active-disabled-text-color", "#222222");
    this.style.setProperty("--wui-tabs-active-disabled-icon-color", "#222222");
    this.unsubscribe.push(ConnectionController.subscribeKey("buffering", (val) => this.buffering = val));
  }
  disconnectCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const tabs = this.generateTabs();
    return x$3`
      <cross-wui-flex justifyContent="center" .padding=${["0", "0", "l", "0"]}>
        <cross-wui-tabs
          style="--wui-tabs-active-bg:#fff;--wui-tabs-active-text-color:#222;--wui-tabs-active-icon-color:#222;--wui-tabs-disabled-opacity:1;--wui-tabs-active-disabled-text-color:#222;--wui-tabs-active-disabled-icon-color:#222"
          ?disabled=${this.buffering}
          .tabs=${tabs}
          .onTabChange=${this.onTabChange.bind(this)}
        ></cross-wui-tabs>
      </cross-wui-flex>
    `;
  }
  generateTabs() {
    const tabs = this.platforms.map((platform) => {
      if (platform === "browser") {
        return { label: "Extension", icon: "extension", platform: "browser" };
      } else if (platform === "mobile") {
        return { label: "Mobile", icon: "mobile", platform: "mobile" };
      } else if (platform === "qrcode") {
        return { label: "QR Code", icon: "mobile", platform: "qrcode" };
      } else if (platform === "web") {
        return { label: "Webapp", icon: "browser", platform: "web" };
      } else if (platform === "desktop") {
        return { label: "Extension", icon: "desktop", platform: "desktop" };
      }
      return { label: "Browser", icon: "extension", platform: "unsupported" };
    });
    this.platformTabs = tabs.map(({ platform }) => platform);
    return tabs;
  }
  onTabChange(index2) {
    var _a3;
    const tab = this.platformTabs[index2];
    if (tab) {
      (_a3 = this.onSelectPlatfrom) == null ? void 0 : _a3.call(this, tab);
    }
  }
};
__decorate$1x([
  n$3({ type: Array })
], W3mConnectingHeader.prototype, "platforms", void 0);
__decorate$1x([
  n$3()
], W3mConnectingHeader.prototype, "onSelectPlatfrom", void 0);
__decorate$1x([
  r$1()
], W3mConnectingHeader.prototype, "buffering", void 0);
W3mConnectingHeader = __decorate$1x([
  customElement("cross-w3m-connecting-header")
], W3mConnectingHeader);
var __decorate$1w = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mConnectingWcMobile = class W3mConnectingWcMobile2 extends W3mConnectingWidget {
  constructor() {
    var _a3;
    super();
    this.btnLabelTimeout = void 0;
    this.labelTimeout = void 0;
    this.onRender = () => {
      var _a4, _b2, _c3;
      if (!this.ready && this.uri) {
        this.ready = true;
        const isIos2 = CoreHelperUtil.isIos();
        const isUniversalLink2 = (_b2 = (_a4 = this.wallet) == null ? void 0 : _a4.mobile_link) == null ? void 0 : _b2.startsWith("https://");
        const shouldShowButton2 = isIos2 && isUniversalLink2;
        if (!shouldShowButton2) {
          (_c3 = this.onConnect) == null ? void 0 : _c3.call(this);
        }
      }
    };
    this.onConnect = () => {
      var _a4;
      if (((_a4 = this.wallet) == null ? void 0 : _a4.mobile_link) && this.uri) {
        try {
          this.error = false;
          const { mobile_link, name } = this.wallet;
          const { redirect, href } = CoreHelperUtil.formatNativeUrl(mobile_link, this.uri);
          ConnectionController.setWcLinking({ name, href });
          ConnectionController.setRecentWallet(this.wallet);
          const target = CoreHelperUtil.isIframe() ? "_top" : "_self";
          CoreHelperUtil.openHref(redirect, target);
          clearTimeout(this.labelTimeout);
          const isMiniWindow2 = CoreHelperUtil.isMiniWindow();
          this.secondaryLabel = isMiniWindow2 ? "Tap to switch connection method" : ConstantsUtil$3.CONNECT_LABELS.MOBILE;
        } catch (e3) {
          EventsController.sendEvent({
            type: "track",
            event: "CONNECT_PROXY_ERROR",
            properties: {
              message: e3 instanceof Error ? e3.message : "Error parsing the deeplink",
              uri: this.uri,
              mobile_link: this.wallet.mobile_link,
              name: this.wallet.name
            }
          });
          this.error = true;
        }
      }
    };
    if (!this.wallet) {
      throw new Error("cross-w3m-connecting-wc-mobile: No wallet provided");
    }
    const isIos = CoreHelperUtil.isIos();
    const isUniversalLink = (_a3 = this.wallet.mobile_link) == null ? void 0 : _a3.startsWith("https://");
    const shouldShowButton = isIos && isUniversalLink;
    this.secondaryBtnLabel = shouldShowButton ? "Open CrossX App" : void 0;
    this.secondaryBtnIcon = shouldShowButton ? "externalLink" : "refresh";
    const isMiniWindow = CoreHelperUtil.isMiniWindow();
    this.secondaryLabel = isMiniWindow ? "Tap to switch connection method" : ConstantsUtil$3.CONNECT_LABELS.MOBILE;
    document.addEventListener("visibilitychange", this.onBuffering.bind(this));
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "mobile" }
    });
    if (!shouldShowButton) {
      this.btnLabelTimeout = setTimeout(() => {
        this.secondaryBtnLabel = "Try again";
        this.secondaryLabel = isMiniWindow ? "Tap to switch connection method" : ConstantsUtil$3.CONNECT_LABELS.MOBILE;
      }, ConstantsUtil$3.FIVE_SEC_MS);
      this.labelTimeout = setTimeout(() => {
        this.secondaryLabel = `Hold tight... it's taking longer than expected`;
      }, ConstantsUtil$3.THREE_SEC_MS);
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    document.removeEventListener("visibilitychange", this.onBuffering.bind(this));
    clearTimeout(this.btnLabelTimeout);
    clearTimeout(this.labelTimeout);
  }
  onBuffering() {
    const isIos = CoreHelperUtil.isIos();
    if ((document == null ? void 0 : document.visibilityState) === "visible" && !this.error && isIos) {
      ConnectionController.setBuffering(true);
      setTimeout(() => {
        ConnectionController.setBuffering(false);
      }, 5e3);
    }
  }
  onTryAgain() {
    if (!this.buffering) {
      ConnectionController.setWcError(false);
      this.onConnect();
    }
  }
};
W3mConnectingWcMobile = __decorate$1w([
  customElement("cross-w3m-connecting-wc-mobile")
], W3mConnectingWcMobile);
const styles$10 = i$4`
  @keyframes fadein {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  cross-wui-shimmer {
    width: 100%;
    aspect-ratio: 1 / 1;
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px) !important;
  }

  cross-wui-qr-code {
    opacity: 0;
    animation-duration: 200ms;
    animation-timing-function: ease;
    animation-name: fadein;
    animation-fill-mode: forwards;
  }
`;
var __decorate$1v = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mConnectingWcQrcode = class W3mConnectingWcQrcode2 extends W3mConnectingWidget {
  constructor() {
    var _a3;
    super();
    this.forceUpdate = () => {
      this.requestUpdate();
    };
    window.addEventListener("resize", this.forceUpdate);
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: ((_a3 = this.wallet) == null ? void 0 : _a3.name) ?? "CROSSx Wallet", platform: "qrcode" }
    });
  }
  disconnectedCallback() {
    var _a3;
    super.disconnectedCallback();
    (_a3 = this.unsubscribe) == null ? void 0 : _a3.forEach((unsub) => unsub());
    window.removeEventListener("resize", this.forceUpdate);
  }
  render() {
    this.onRenderProxy();
    if (CoreHelperUtil.isMobileLandscape()) {
      return x$3`
        <cross-wui-flex
          flexDirection="column"
          alignItems="center"
          justifyContent="center"
          .padding=${["0", "0", "0", "0"]}
          gap="0"
          style="width: 100%; height: 100%;"
        >
          ${this.ready && this.uri ? x$3` ${this.qrCodeTemplate()} ` : x$3`
                <cross-wui-shimmer
                  borderRadius="l"
                  width="270px"
                  height="270px"
                  style="width: 270px; height: 270px; max-width: 270px; max-height: 270px;"
                >
                </cross-wui-shimmer>
              `}
        </cross-wui-flex>
      `;
    }
    return x$3`
      <cross-wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["0", "xl", "xl", "xl"]}
        gap="xl"
      >
        <cross-wui-shimmer borderRadius="l" width="100%" style="max-width:300px;">
          ${this.qrCodeTemplate()}
        </cross-wui-shimmer>

        <cross-wui-text variant="paragraph-500" color="fg-100">
          Scan this QR Code with your phone
        </cross-wui-text>
        ${this.copyTemplate()}
      </cross-wui-flex>
      <cross-w3m-mobile-download-links .wallet=${this.wallet}></cross-w3m-mobile-download-links>
    `;
  }
  onRenderProxy() {
    if (!this.ready && this.uri) {
      this.timeout = setTimeout(() => {
        this.ready = true;
      }, 200);
    }
  }
  qrCodeTemplate() {
    if (!this.uri || !this.ready) {
      return null;
    }
    const size2 = this.getBoundingClientRect().width - 40;
    const alt = this.wallet ? this.wallet.name : "CROSSx Wallet";
    ConnectionController.setWcLinking(void 0);
    ConnectionController.setRecentWallet(this.wallet);
    return x$3` <cross-wui-qr-code
      size=${size2}
      theme=${ThemeController.state.themeMode}
      uri=${this.uri}
      imageSrc=${o$2(AssetUtil.getWalletImage(this.wallet))}
      color=${o$2(ThemeController.state.themeVariables["--w3m-qr-color"])}
      alt=${o$2(alt)}
      data-testid="wui-qr-code"
    ></cross-wui-qr-code>`;
  }
  copyTemplate() {
    const inactive = !this.uri || !this.ready;
    return x$3`<cross-wui-link
      .disabled=${inactive}
      @click=${this.onCopyUri}
      color="fg-200"
      data-testid="copy-wc2-uri"
    >
      <cross-wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></cross-wui-icon>
      Copy link
    </cross-wui-link>`;
  }
};
W3mConnectingWcQrcode.styles = styles$10;
W3mConnectingWcQrcode = __decorate$1v([
  customElement("cross-w3m-connecting-wc-qrcode")
], W3mConnectingWcQrcode);
const styles$$ = i$4`
  :host {
    display: block;
    padding: 0 var(--wui-spacing-xl) var(--wui-spacing-xl);
  }
`;
var __decorate$1u = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mMobileDownloadLinks = class W3mMobileDownloadLinks2 extends i$1 {
  constructor() {
    super(...arguments);
    this.wallet = void 0;
  }
  render() {
    if (!this.wallet) {
      this.style.display = "none";
      return null;
    }
    const { name, app_store, play_store, chrome_store, homepage } = this.wallet;
    const isMobile = CoreHelperUtil.isMobile();
    const isIos = CoreHelperUtil.isIos();
    const isAndroid = CoreHelperUtil.isAndroid();
    const isMultiple = [app_store, play_store, homepage, chrome_store].filter(Boolean).length > 1;
    if (isMultiple && !isMobile) {
      return x$3`
        <cross-wui-cta-button
          label=${`Don't have ${name}?`}
          buttonLabel="Get"
          @click=${() => RouterController.push("Downloads", { wallet: this.wallet })}
        ></cross-wui-cta-button>
      `;
    }
    if (!isMultiple && homepage) {
      return x$3`
        <cross-wui-cta-button
          label=${`Don't have ${name}?`}
          buttonLabel="Get"
          @click=${this.onHomePage.bind(this)}
        ></cross-wui-cta-button>
      `;
    }
    if (app_store && isIos) {
      return x$3`
        <cross-wui-cta-button
          label=${`Don't have ${name}?`}
          buttonLabel="Get"
          @click=${this.onAppStore.bind(this)}
        ></cross-wui-cta-button>
      `;
    }
    if (play_store && isAndroid) {
      return x$3`
        <cross-wui-cta-button
          label=${`Don't have ${name}?`}
          buttonLabel="Get"
          @click=${this.onPlayStore.bind(this)}
        ></cross-wui-cta-button>
      `;
    }
    this.style.display = "none";
    return null;
  }
  onAppStore() {
    var _a3;
    if ((_a3 = this.wallet) == null ? void 0 : _a3.app_store) {
      CoreHelperUtil.openHref(this.wallet.app_store, "_blank");
    }
  }
  onPlayStore() {
    var _a3;
    if ((_a3 = this.wallet) == null ? void 0 : _a3.play_store) {
      CoreHelperUtil.openHref(this.wallet.play_store, "_blank");
    }
  }
  onHomePage() {
    var _a3;
    if ((_a3 = this.wallet) == null ? void 0 : _a3.homepage) {
      CoreHelperUtil.openHref(this.wallet.homepage, "_blank");
    }
  }
};
W3mMobileDownloadLinks.styles = [styles$$];
__decorate$1u([
  n$3({ type: Object })
], W3mMobileDownloadLinks.prototype, "wallet", void 0);
W3mMobileDownloadLinks = __decorate$1u([
  customElement("cross-w3m-mobile-download-links")
], W3mMobileDownloadLinks);
const styles$_ = i$4`
  :host {
    display: block;
    width: 100%;
    min-width: 700px;
  }

  /*  CSS   -    */
  :host {
    --w3m-modal-width: 700px !important;
  }

  /*  wui-card  */
  cross-wui-card {
    max-width: 700px !important;
    width: 700px !important;
    height: 360px !important;
    max-height: 360px !important;
    margin: 0 !important;
  }

  .landscape-container {
    display: flex;
    flex-direction: row;
    width: 100%;
    min-width: 700px;
    height: 100%;
    max-height: 100%;
    background: var(--wui-color-modal-bg);
    position: relative;
    box-sizing: border-box;
  }

  .landscape-left {
    flex: 0 0 300px;
    width: 300px;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    margin: 0;
    background: var(--wui-color-modal-bg);
    overflow: visible;
    position: relative;
  }

  .landscape-right {
    flex: 1;
    min-width: 300px;
    height: 100%;
    display: flex;
    flex-direction: column;
    border-left: 1px solid var(--wui-color-gray-glass-005);
    background: var(--wui-color-modal-bg);
  }

  .landscape-tabs {
    flex: 0 0 auto;
    padding: var(--wui-spacing-l);
    border-bottom: 1px solid var(--wui-color-gray-glass-005);
    background: var(--wui-color-modal-bg);
  }

  .landscape-desc {
    flex: 1;
    padding: var(--wui-spacing-l);
    background: var(--wui-color-modal-bg);
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
  }

  .landscape-store {
    flex: 0 0 auto;
    padding: var(--wui-spacing-l);
    background: var(--wui-color-modal-bg);
    border-top: 1px solid var(--wui-color-gray-glass-005);
  }

  .qr-section {
    width: 280px;
    height: 280px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--wui-color-modal-bg);
    border-radius: var(--wui-border-radius-m);
    overflow: visible;
    margin: 0;
    padding: 0;
    flex-shrink: 0;
  }

  .store-links {
    display: flex;
    flex-direction: column;
    gap: var(--wui-spacing-s);
    height: 100%;
    justify-content: center;
  }

  .store-links cross-w3m-mobile-download-links {
    display: block;
  }

  /*     */
  .landscape-left cross-w3m-connecting-wc-mobile {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: flex-start;
    justify-content: center;
    padding: 0;
    margin: 0;
  }

  .landscape-left cross-w3m-connecting-wc-mobile cross-wui-flex {
    padding: 0 var(--wui-spacing-s) 0 var(--wui-spacing-s) !important;
    margin: 0 !important;
    transform: translateY(0) !important;
    justify-content: flex-start !important;
    align-items: center !important;
  }

  .landscape-left cross-w3m-connecting-wc-mobile cross-wui-wallet-image {
    margin: 0 !important;
  }

  .landscape-left cross-w3m-connecting-wc-mobile cross-wui-text {
    margin: var(--wui-spacing-xs) 0 !important;
  }

  .landscape-left cross-w3m-connecting-wc-mobile cross-wui-button {
    margin: var(--wui-spacing-s) 0 0 0 !important;
  }

  .qr-section cross-w3m-connecting-wc-qrcode {
    width: 100%;
    height: 100%;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
  }

  .qr-section cross-w3m-connecting-wc-qrcode cross-wui-flex {
    width: 100% !important;
    height: 100% !important;
    justify-content: center !important;
    align-items: center !important;
    padding: 0 !important;
  }

  .qr-section cross-w3m-connecting-wc-qrcode cross-wui-shimmer {
    width: 280px !important;
    height: 280px !important;
    max-width: 280px !important;
    max-height: 280px !important;
  }

  .qr-section cross-w3m-connecting-wc-qrcode cross-wui-flex {
    width: 100% !important;
    height: 100% !important;
    justify-content: center !important;
    align-items: center !important;
    padding: 0 !important;
  }

  .qr-section cross-w3m-connecting-wc-qrcode cross-wui-qr-code {
    width: 280px !important;
    height: 280px !important;
    max-width: 280px !important;
    max-height: 280px !important;
  }

  .qr-section cross-w3m-connecting-wc-qrcode cross-wui-text {
    display: none !important;
  }

  /*      */
  cross-w3m-mobile-download-links {
    padding: 0 !important;
  }

  /*      */

  /*     */
  .landscape-tabs cross-w3m-connecting-header {
    width: 100%;
  }
`;
var __decorate$1t = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mConnectingWcLandscapeView = class W3mConnectingWcLandscapeView2 extends i$1 {
  constructor() {
    var _a3;
    super();
    this.interval = void 0;
    this.lastRetry = Date.now();
    this.wallet = (_a3 = RouterController.state.data) == null ? void 0 : _a3.wallet;
    this.selected = "qrcode";
    this.platforms = [];
    this.isSiwxEnabled = Boolean(OptionsController.state.siwx);
    this.determinePlatforms();
    this.initializeConnection();
    this.interval = setInterval(this.initializeConnection.bind(this), 1e4);
  }
  disconnectedCallback() {
    clearTimeout(this.interval);
  }
  render() {
    return x$3`
      <div class="landscape-container">
        <div class="landscape-left">${this.leftContentTemplate()}</div>
        <div class="landscape-right">
          <div class="landscape-tabs">${this.tabsTemplate()}</div>
          <div class="landscape-desc">${this.descriptionTemplate()}</div>
          <div class="landscape-store">${this.storeLinksTemplate()}</div>
        </div>
      </div>
    `;
  }
  async initializeConnection(retry = false) {
    try {
      const { wcPairingExpiry, status } = ConnectionController.state;
      if (retry || CoreHelperUtil.isPairingExpired(wcPairingExpiry) || status === "connecting") {
        await ConnectionController.connectWalletConnect();
        this.finalizeConnection();
        if (!this.isSiwxEnabled) {
          ModalController.close();
        }
      }
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: (error == null ? void 0 : error.message) ?? "Unknown" }
      });
      ConnectionController.setWcError(true);
      if (CoreHelperUtil.isAllowedRetry(this.lastRetry)) {
        SnackController.showError(error.message ?? "Declined");
        this.lastRetry = Date.now();
        this.initializeConnection(true);
      } else {
        SnackController.showError(error.message ?? "Connection error");
      }
    }
  }
  finalizeConnection() {
    var _a3;
    const { wcLinking, recentWallet } = ConnectionController.state;
    if (wcLinking) {
      StorageUtil.setWalletConnectDeepLink(wcLinking);
    }
    if (recentWallet) {
      StorageUtil.setAppKitRecent(recentWallet);
    }
    EventsController.sendEvent({
      type: "track",
      event: "CONNECT_SUCCESS",
      properties: {
        method: this.selected === "mobile" ? "mobile" : "qrcode",
        name: ((_a3 = this.wallet) == null ? void 0 : _a3.name) || "Unknown"
      }
    });
  }
  determinePlatforms() {
    if (!this.wallet) {
      this.platforms = ["mobile", "qrcode"];
      this.selected = "qrcode";
      return;
    }
    const { mobile_link } = this.wallet;
    if (CoreHelperUtil.isMobile()) {
      if (mobile_link) {
        this.platforms = ["mobile", "qrcode"];
        this.selected = "mobile";
      } else {
        this.platforms = ["qrcode"];
        this.selected = "qrcode";
      }
    } else {
      this.platforms = ["qrcode"];
      this.selected = "qrcode";
    }
  }
  leftContentTemplate() {
    const wallet = this.wallet;
    const mobileSupported = Boolean(wallet == null ? void 0 : wallet.mobile_link);
    if (this.selected === "mobile") {
      return mobileSupported && wallet ? x$3`<cross-w3m-connecting-wc-mobile isMobile></cross-w3m-connecting-wc-mobile>` : x$3`<cross-wui-flex
            flexDirection="column"
            alignItems="center"
            justifyContent="center"
            gap="s"
            style="width:210px;height:210px"
          >
            <cross-wui-icon-box size="md" icon="externalLink" background="opaque"></cross-wui-icon-box>
            <cross-wui-text variant="small-500" color="fg-200">  </cross-wui-text>
          </cross-wui-flex>`;
    }
    return x$3`<div class="qr-section">
      <cross-w3m-connecting-wc-qrcode></cross-w3m-connecting-wc-qrcode>
    </div>`;
  }
  tabsTemplate() {
    const platforms = ["mobile", "qrcode"];
    return x$3`<cross-w3m-connecting-header
      .platforms=${platforms}
      .onSelectPlatfrom=${this.onSelectPlatform.bind(this)}
    ></cross-w3m-connecting-header>`;
  }
  descriptionTemplate() {
    const title = this.selected === "mobile" ? "Continue on mobile" : "Scan this QR Code with your phone";
    const desc = this.selected === "mobile" ? "Deep link to your selected wallet app to complete the connection." : "Scan the code with your phone camera or wallet app QR scanner.";
    return x$3`<cross-wui-flex flexDirection="column" gap="xs" style="margin: var(--wui-spacing-m)">
      <cross-wui-text variant="paragraph-500" color="fg-100">${title}</cross-wui-text>
      <cross-wui-text variant="small-500" color="fg-200">${desc}</cross-wui-text>
    </cross-wui-flex>`;
  }
  storeLinksTemplate() {
    return x$3`<div class="store-links">
      <cross-wui-text variant="small-400" color="fg-200" align="center">
        <cross-w3m-mobile-download-links .wallet=${this.wallet}></cross-w3m-mobile-download-links>
      </cross-wui-text>
    </div>`;
  }
  async onSelectPlatform(platform) {
    var _a3;
    const container = (_a3 = this.shadowRoot) == null ? void 0 : _a3.querySelector(".landscape-left");
    if (container) {
      await container.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 150,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.selected = platform;
      container.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 150,
        fill: "forwards",
        easing: "ease"
      });
    } else {
      this.selected = platform;
    }
  }
  onCopyUri() {
    try {
      const uri2 = ConnectionController.state.wcUri;
      if (uri2) {
        CoreHelperUtil.copyToClopboard(uri2);
        SnackController.showSuccess("Link copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
};
W3mConnectingWcLandscapeView.styles = styles$_;
__decorate$1t([
  r$1()
], W3mConnectingWcLandscapeView.prototype, "selected", void 0);
__decorate$1t([
  r$1()
], W3mConnectingWcLandscapeView.prototype, "platforms", void 0);
__decorate$1t([
  r$1()
], W3mConnectingWcLandscapeView.prototype, "isSiwxEnabled", void 0);
W3mConnectingWcLandscapeView = __decorate$1t([
  customElement("cross-w3m-connecting-wc-landscape-view")
], W3mConnectingWcLandscapeView);
var __decorate$1s = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mConnectingWcBrowser = class W3mConnectingWcBrowser2 extends W3mConnectingWidget {
  constructor() {
    super();
    this.isCrossWalletInstalled = false;
    if (!this.wallet) {
      throw new Error("cross-w3m-connecting-wc-browser: No wallet provided");
    }
    this.checkCrossWalletInstallation();
    this.onConnect = this.onConnectProxy.bind(this);
    this.onAutoConnect = this.onConnectProxy.bind(this);
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "browser" }
    });
  }
  render() {
    if (!this.isCrossWalletInstalled && this.isCrossWallet()) {
      return this.renderStoreLinks();
    }
    return super.render();
  }
  isCrossWallet() {
    var _a3, _b2;
    return ((_a3 = this.wallet) == null ? void 0 : _a3.id) === "cross_wallet" || ((_b2 = this.wallet) == null ? void 0 : _b2.rdns) === "nexus.to.crosswallet.desktop";
  }
  checkCrossWalletInstallation() {
    var _a3;
    if (!this.isCrossWallet() || !((_a3 = this.wallet) == null ? void 0 : _a3.rdns)) {
      this.isCrossWalletInstalled = true;
      return;
    }
    const { connectors } = ConnectorController.state;
    const crossWalletConnectors = connectors.filter((c2) => {
      var _a4, _b2;
      return (c2.type === "ANNOUNCED" || c2.type === "INJECTED") && ((_a4 = c2.info) == null ? void 0 : _a4.rdns) === ((_b2 = this.wallet) == null ? void 0 : _b2.rdns);
    });
    if (crossWalletConnectors && crossWalletConnectors.length > 0) {
      this.isCrossWalletInstalled = true;
      return;
    }
    if (typeof window !== "undefined") {
      const rdns = this.wallet.rdns;
      if (rdns === "nexus.to.crosswallet.desktop") {
        const crossWalletProvider = window.crossWallet;
        if (crossWalletProvider) {
          this.isCrossWalletInstalled = true;
          return;
        }
      }
    }
    this.isCrossWalletInstalled = false;
  }
  renderStoreLinks() {
    var _a3, _b2;
    const isChrome = CoreHelperUtil.isChrome();
    const chromeStoreUrl = (_a3 = this.wallet) == null ? void 0 : _a3.chrome_store;
    return x$3`
      <cross-wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <cross-wui-flex justifyContent="center" alignItems="center">
          <cross-wui-wallet-image size="lg" imageSrc=${((_b2 = this.wallet) == null ? void 0 : _b2.image_url) || ""}></cross-wui-wallet-image>
        </cross-wui-flex>

        <cross-wui-flex flexDirection="column" alignItems="center" gap="xs">
          <cross-wui-text variant="paragraph-500" color="fg-100"> Cross Wallet not installed </cross-wui-text>
          <cross-wui-text align="center" variant="small-500" color="fg-200">
            Install Cross Wallet to continue with browser connection
          </cross-wui-text>
        </cross-wui-flex>

        ${isChrome && chromeStoreUrl ? x$3`
              <cross-wui-button
                variant="accent"
                size="md"
                @click=${() => this.openChromeStore()}
                data-testid="cross-w3m-install-wallet-button"
              >
                <cross-wui-icon color="inherit" slot="iconLeft" name="externalLink"></cross-wui-icon>
                Install from Chrome Store
              </cross-wui-button>
            ` : x$3`
              <cross-wui-text align="center" variant="small-500" color="fg-200">
                Please install Cross Wallet extension for your browser
              </cross-wui-text>
            `}
      </cross-wui-flex>
    `;
  }
  openChromeStore() {
    var _a3;
    if ((_a3 = this.wallet) == null ? void 0 : _a3.chrome_store) {
      window.open(this.wallet.chrome_store, "_blank", "noopener,noreferrer");
    }
  }
  async onConnectProxy() {
    var _a3, _b2;
    try {
      this.error = false;
      const { connectors } = ConnectorController.state;
      const isAlreadyConnected = Boolean(AccountController.state.address);
      if (isAlreadyConnected) {
        try {
          await ChainController.disconnect();
        } catch (error) {
        }
      }
      let connector = null;
      if ((_a3 = this.wallet) == null ? void 0 : _a3.rdns) {
        connector = connectors.find((c2) => {
          var _a4, _b3;
          return (c2.type === "ANNOUNCED" || c2.type === "INJECTED") && ((_a4 = c2.info) == null ? void 0 : _a4.rdns) === ((_b3 = this.wallet) == null ? void 0 : _b3.rdns);
        });
      }
      if (!connector) {
        connector = connectors.find((c2) => {
          var _a4;
          return c2.name === ((_a4 = this.wallet) == null ? void 0 : _a4.name);
        });
      }
      if (!connector) {
        connector = connectors.find((c2) => c2.type === "INJECTED");
      }
      if (connector) {
        if (this.isCrossWalletInstalled) {
          await ConnectionController.connectExternal(connector, connector.chain);
          ModalController.close();
          EventsController.sendEvent({
            type: "track",
            event: "CONNECT_SUCCESS",
            properties: { method: "browser", name: ((_b2 = this.wallet) == null ? void 0 : _b2.name) || "Unknown" }
          });
        } else {
          console.log("Cross Wallet not installed - staying on install screen");
          return;
        }
      } else {
        throw new Error("cross-w3m-connecting-wc-browser: No connector found");
      }
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: (error == null ? void 0 : error.message) ?? "Unknown" }
      });
      this.error = true;
    }
  }
};
__decorate$1s([
  r$1()
], W3mConnectingWcBrowser.prototype, "isCrossWalletInstalled", void 0);
W3mConnectingWcBrowser = __decorate$1s([
  customElement("cross-w3m-connecting-wc-browser")
], W3mConnectingWcBrowser);
const styles$Z = i$4`
  :host {
    display: block;
    width: 100%;
    height: 100%;
  }

  .mini-container {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: var(--wui-spacing-xs);
    box-sizing: border-box;
    cursor: pointer;
    position: relative;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
  }

  .mini-container:active {
    opacity: 0.8;
  }

  .platform-indicator {
    position: absolute;
    bottom: var(--wui-spacing-s);
    left: 50%;
    transform: translateX(-50%);
    padding: var(--wui-spacing-xs) var(--wui-spacing-s);
    background: var(--wui-color-gray-glass-005);
    border-radius: var(--wui-border-radius-xs);
    white-space: nowrap;
  }

  /* QR    */
  cross-w3m-connecting-wc-qrcode {
    width: 290px !important;
    height: 290px !important;
    max-width: 290px !important;
    max-height: 290px !important;
    min-width: 290px !important;
    min-height: 290px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    flex-shrink: 0 !important;
    overflow: visible !important;
  }

  cross-w3m-connecting-wc-qrcode * {
    box-sizing: border-box !important;
  }

  cross-w3m-connecting-wc-qrcode cross-wui-flex {
    width: 100% !important;
    height: 100% !important;
    padding: 0 !important;
    gap: 0 !important;
  }

  cross-w3m-connecting-wc-qrcode cross-wui-shimmer {
    width: 280px !important;
    height: 280px !important;
    max-width: 280px !important;
    max-height: 280px !important;
    border-radius: var(--wui-border-radius-l) !important;
  }

  cross-w3m-connecting-wc-qrcode cross-wui-qr-code {
    width: 280px !important;
    height: 280px !important;
    max-width: 280px !important;
    max-height: 280px !important;
  }

  cross-w3m-connecting-wc-qrcode cross-wui-text {
    display: none !important;
  }

  cross-w3m-connecting-wc-qrcode cross-wui-link {
    display: none !important;
  }

  cross-w3m-connecting-wc-qrcode cross-w3m-mobile-download-links {
    display: none !important;
  }

  /* Mobile     */
  cross-w3m-connecting-wc-mobile {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  cross-w3m-connecting-wc-mobile cross-wui-wallet-image {
    width: 60px !important;
    height: 60px !important;
  }

  cross-w3m-connecting-wc-mobile cross-wui-text {
    font-size: 12px !important;
  }

  /* Browser     */
  cross-w3m-connecting-wc-browser {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
  }
`;
var __decorate$1r = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mConnectingWcMiniView = class W3mConnectingWcMiniView2 extends i$1 {
  constructor() {
    var _a3;
    super();
    this.interval = void 0;
    this.lastRetry = Date.now();
    this.wallet = (_a3 = RouterController.state.data) == null ? void 0 : _a3.wallet;
    this.platform = void 0;
    this.platforms = [];
    this.isSiwxEnabled = Boolean(OptionsController.state.siwx);
    this.determinePlatforms();
    this.initializeConnection();
    this.interval = setInterval(this.initializeConnection.bind(this), ConstantsUtil$3.TEN_SEC_MS);
  }
  disconnectedCallback() {
    clearTimeout(this.interval);
  }
  render() {
    var _a3;
    console.log(" [MiniView] Rendering:", {
      platform: this.platform,
      platforms: this.platforms,
      wallet: (_a3 = this.wallet) == null ? void 0 : _a3.name
    });
    return x$3`
      <div class="mini-container" @click=${this.onTogglePlatform.bind(this)}>
        ${this.platformTemplate()}
      </div>
    `;
  }
  async initializeConnection(retry = false) {
    if (this.platform === "browser") {
      return;
    }
    try {
      const { wcPairingExpiry, status } = ConnectionController.state;
      if (retry || CoreHelperUtil.isPairingExpired(wcPairingExpiry) || status === "connecting") {
        await ConnectionController.connectWalletConnect();
        this.finalizeConnection();
        if (!this.isSiwxEnabled) {
          ModalController.close();
        }
      }
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: (error == null ? void 0 : error.message) ?? "Unknown" }
      });
      ConnectionController.setWcError(true);
      if (CoreHelperUtil.isAllowedRetry(this.lastRetry)) {
        SnackController.showError(error.message ?? "Declined");
        this.lastRetry = Date.now();
        this.initializeConnection(true);
      } else {
        SnackController.showError(error.message ?? "Connection error");
      }
    }
  }
  finalizeConnection() {
    var _a3;
    const { wcLinking, recentWallet } = ConnectionController.state;
    if (wcLinking) {
      StorageUtil.setWalletConnectDeepLink(wcLinking);
    }
    if (recentWallet) {
      StorageUtil.setAppKitRecent(recentWallet);
    }
    EventsController.sendEvent({
      type: "track",
      event: "CONNECT_SUCCESS",
      properties: {
        method: wcLinking ? "mobile" : "qrcode",
        name: ((_a3 = this.wallet) == null ? void 0 : _a3.name) || "Unknown"
      }
    });
  }
  isCrossWalletInstalled(rdns) {
    const currentConnectors = ConnectorController.state.connectors;
    const crossWalletExtensionConnectors = currentConnectors.filter((c2) => (c2.type === "ANNOUNCED" || c2.type === "INJECTED") && c2.id === rdns);
    if (crossWalletExtensionConnectors && crossWalletExtensionConnectors.length > 0) {
      return true;
    }
    const isCrossWalletInWindow = typeof window !== "undefined" && window.crossWallet;
    return Boolean(isCrossWalletInWindow);
  }
  determinePlatformsForCross(params) {
    const { mobile_link, rdns, isBrowser } = params;
    const isMobile = CoreHelperUtil.isMobile();
    if (isMobile) {
      if (mobile_link) {
        this.platforms.push("mobile");
        this.platforms.push("qrcode");
        this.platform = "mobile";
      } else {
        this.platforms.push("qrcode");
        this.platform = "qrcode";
      }
      return true;
    }
    if (isBrowser && !ChainController.state.noAdapters && rdns) {
      const isChrome = CoreHelperUtil.isChrome();
      const isCrossWalletFound = this.isCrossWalletInstalled(rdns);
      if (isCrossWalletFound) {
        if (isChrome) {
          this.platforms.push("qrcode");
          this.platforms.push("browser");
          this.platform = "qrcode";
        } else {
          this.platforms.push("qrcode");
          this.platform = "qrcode";
        }
      } else {
        this.platforms.push("qrcode");
        this.platform = "qrcode";
      }
      return true;
    }
    this.platforms.push("qrcode");
    this.platform = "qrcode";
    return true;
  }
  determinePlatforms() {
    var _a3;
    if (!this.wallet) {
      this.platforms.push("qrcode");
      this.platform = "qrcode";
      return;
    }
    if (this.platform) {
      return;
    }
    const { mobile_link, desktop_link, webapp_link, injected: injected2, rdns } = this.wallet;
    const injectedIds = injected2 == null ? void 0 : injected2.map(({ injected_id }) => injected_id).filter(Boolean);
    const browserIds = [...rdns ? [rdns] : injectedIds ?? []];
    const isBrowser = OptionsController.state.isUniversalProvider ? false : browserIds.length;
    const isMobileWc = mobile_link;
    const isWebWc = webapp_link;
    const isBrowserInstalled = ConnectionController.checkInstalled(browserIds);
    const isBrowserWc = isBrowser && isBrowserInstalled;
    const isDesktopWc = desktop_link && !CoreHelperUtil.isMobile();
    const isCrossWallet = ((_a3 = this.wallet.name) == null ? void 0 : _a3.includes("CROSSx Wallet")) || rdns === "nexus.to.crosswallet.desktop";
    if (isCrossWallet && rdns) {
      this.determinePlatformsForCross({ mobile_link, rdns, isBrowser: Boolean(isBrowser) });
      return;
    }
    if (isBrowserWc && !ChainController.state.noAdapters) {
      this.platforms.push("browser");
    }
    if (isMobileWc) {
      this.platforms.push(CoreHelperUtil.isMobile() ? "mobile" : "qrcode");
    }
    if (isWebWc) {
      this.platforms.push("web");
    }
    if (isDesktopWc) {
      this.platforms.push("desktop");
    }
    if (!isBrowserWc && isBrowser && !ChainController.state.noAdapters) {
      this.platforms.push("unsupported");
    }
    this.platform = this.platforms[0];
  }
  platformTemplate() {
    console.log(" [MiniView] Platform template:", this.platform);
    switch (this.platform) {
      case "browser":
        return x$3`<cross-w3m-connecting-wc-browser></cross-w3m-connecting-wc-browser>`;
      case "mobile":
        return x$3`
          <cross-w3m-connecting-wc-mobile
            isMobile
            .onRetry=${() => this.initializeConnection(true)}
          >
          </cross-w3m-connecting-wc-mobile>
        `;
      case "qrcode":
        return x$3`<cross-w3m-connecting-wc-qrcode></cross-w3m-connecting-wc-qrcode>`;
      default:
        console.warn(" [MiniView] Unknown platform, using qrcode");
        return x$3`<cross-w3m-connecting-wc-qrcode></cross-w3m-connecting-wc-qrcode>`;
    }
  }
  platformIndicatorTemplate() {
    const currentIndex = this.platforms.indexOf(this.platform);
    const platformLabels = {
      browser: "Extension",
      mobile: "Mobile",
      qrcode: "QR Code",
      web: "Web",
      desktop: "Desktop",
      unsupported: "Unsupported"
    };
    return x$3`
      <div class="platform-indicator">
        <cross-wui-text variant="small-400" color="fg-200">
          ${platformLabels[this.platform] || "Unknown"}
          (${currentIndex + 1}/${this.platforms.length})
        </cross-wui-text>
      </div>
    `;
  }
  async onTogglePlatform() {
    var _a3;
    if (this.platforms.length <= 1) {
      return;
    }
    const container = (_a3 = this.shadowRoot) == null ? void 0 : _a3.querySelector(".mini-container");
    if (container) {
      await container.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 150,
        fill: "forwards",
        easing: "ease"
      }).finished;
      const currentIndex = this.platforms.indexOf(this.platform);
      const nextIndex = (currentIndex + 1) % this.platforms.length;
      this.platform = this.platforms[nextIndex];
      container.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 150,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
};
W3mConnectingWcMiniView.styles = styles$Z;
__decorate$1r([
  r$1()
], W3mConnectingWcMiniView.prototype, "platform", void 0);
__decorate$1r([
  r$1()
], W3mConnectingWcMiniView.prototype, "platforms", void 0);
__decorate$1r([
  r$1()
], W3mConnectingWcMiniView.prototype, "isSiwxEnabled", void 0);
W3mConnectingWcMiniView = __decorate$1r([
  customElement("cross-w3m-connecting-wc-mini-view")
], W3mConnectingWcMiniView);
var __decorate$1q = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mConnectingWcBasicView = class W3mConnectingWcBasicView2 extends i$1 {
  constructor() {
    super(...arguments);
    this.isMobile = CoreHelperUtil.isMobile();
  }
  render() {
    if (this.isMobile) {
      const { featured, recommended } = ApiController$1.state;
      const { customWallets } = OptionsController.state;
      const recent = StorageUtil.getRecentWallets();
      const showConnectors = featured.length || recommended.length || (customWallets == null ? void 0 : customWallets.length) || recent.length;
      return x$3`<cross-wui-flex
        flexDirection="column"
        gap="xs"
        .margin=${["3xs", "s", "s", "s"]}
      >
        ${showConnectors ? x$3`<cross-w3m-connector-list></cross-w3m-connector-list>` : null}
        <cross-w3m-all-wallets-widget></cross-w3m-all-wallets-widget>
      </cross-wui-flex>`;
    }
    return x$3`<cross-wui-flex flexDirection="column" .padding=${["0", "0", "l", "0"]}>
      <cross-w3m-connecting-wc-view></cross-w3m-connecting-wc-view>
      <cross-wui-flex flexDirection="column" .padding=${["0", "m", "0", "m"]}>
        <cross-w3m-all-wallets-widget></cross-w3m-all-wallets-widget> </wui-flex
    ></cross-wui-flex>`;
  }
};
__decorate$1q([
  r$1()
], W3mConnectingWcBasicView.prototype, "isMobile", void 0);
W3mConnectingWcBasicView = __decorate$1q([
  customElement("cross-w3m-connecting-wc-basic-view")
], W3mConnectingWcBasicView);
const styles$Y = i$4`
  .continue-button-container {
    width: 100%;
  }
`;
var __decorate$1p = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mChooseAccountNameView = class W3mChooseAccountNameView2 extends i$1 {
  constructor() {
    super(...arguments);
    this.loading = false;
  }
  render() {
    return x$3`
      <cross-wui-flex
        flexDirection="column"
        alignItems="center"
        gap="xxl"
        .padding=${["0", "0", "l", "0"]}
      >
        ${this.onboardingTemplate()} ${this.buttonsTemplate()}
        <cross-wui-link
          @click=${() => {
      CoreHelperUtil.openHref(NavigationUtil.URLS.FAQ, "_blank");
    }}
        >
          Learn more about names
          <cross-wui-icon color="inherit" slot="iconRight" name="externalLink"></cross-wui-icon>
        </cross-wui-link>
      </cross-wui-flex>
    `;
  }
  onboardingTemplate() {
    return x$3` <cross-wui-flex
      flexDirection="column"
      gap="xxl"
      alignItems="center"
      .padding=${["0", "xxl", "0", "xxl"]}
    >
      <cross-wui-flex gap="s" alignItems="center" justifyContent="center">
        <cross-wui-icon-box
          icon="id"
          size="xl"
          iconSize="xxl"
          iconColor="fg-200"
          backgroundColor="fg-200"
        ></cross-wui-icon-box>
      </cross-wui-flex>
      <cross-wui-flex flexDirection="column" alignItems="center" gap="s">
        <cross-wui-text align="center" variant="medium-600" color="fg-100">
          Choose your account name
        </cross-wui-text>
        <cross-wui-text align="center" variant="paragraph-400" color="fg-100">
          Finally say goodbye to 0x addresses, name your account to make it easier to exchange
          assets
        </cross-wui-text>
      </cross-wui-flex>
    </cross-wui-flex>`;
  }
  buttonsTemplate() {
    return x$3`<cross-wui-flex
      .padding=${["0", "2l", "0", "2l"]}
      gap="s"
      class="continue-button-container"
    >
      <cross-wui-button
        fullWidth
        .loading=${this.loading}
        size="lg"
        borderRadius="xs"
        @click=${this.handleContinue.bind(this)}
        >Choose name
      </cross-wui-button>
    </cross-wui-flex>`;
  }
  handleContinue() {
    RouterController.push("RegisterAccountName");
    EventsController.sendEvent({
      type: "track",
      event: "OPEN_ENS_FLOW",
      properties: {
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
  }
};
W3mChooseAccountNameView.styles = styles$Y;
__decorate$1p([
  r$1()
], W3mChooseAccountNameView.prototype, "loading", void 0);
W3mChooseAccountNameView = __decorate$1p([
  customElement("cross-w3m-choose-account-name-view")
], W3mChooseAccountNameView);
var __decorate$1o = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mDownloadsView = class W3mDownloadsView2 extends i$1 {
  constructor() {
    var _a3;
    super(...arguments);
    this.wallet = (_a3 = RouterController.state.data) == null ? void 0 : _a3.wallet;
  }
  render() {
    if (!this.wallet) {
      throw new Error("cross-w3m-downloads-view");
    }
    return x$3`
      <cross-wui-flex gap="xs" flexDirection="column" .padding=${["s", "s", "l", "s"]}>
        ${this.chromeTemplate()} ${this.iosTemplate()} ${this.androidTemplate()}
        ${this.homepageTemplate()}
      </cross-wui-flex>
    `;
  }
  chromeTemplate() {
    var _a3;
    if (!((_a3 = this.wallet) == null ? void 0 : _a3.chrome_store)) {
      return null;
    }
    return x$3`<cross-wui-list-item
      variant="icon"
      icon="chromeStore"
      iconVariant="square"
      @click=${this.onChromeStore.bind(this)}
      chevron
    >
      <cross-wui-text variant="paragraph-500" color="fg-100">Chrome Extension</cross-wui-text>
    </cross-wui-list-item>`;
  }
  iosTemplate() {
    var _a3;
    if (!((_a3 = this.wallet) == null ? void 0 : _a3.app_store)) {
      return null;
    }
    return x$3`<cross-wui-list-item
      variant="icon"
      icon="appStore"
      iconVariant="square"
      @click=${this.onAppStore.bind(this)}
      chevron
    >
      <cross-wui-text variant="paragraph-500" color="fg-100">iOS App</cross-wui-text>
    </cross-wui-list-item>`;
  }
  androidTemplate() {
    var _a3;
    if (!((_a3 = this.wallet) == null ? void 0 : _a3.play_store)) {
      return null;
    }
    return x$3`<cross-wui-list-item
      variant="icon"
      icon="playStore"
      iconVariant="square"
      @click=${this.onPlayStore.bind(this)}
      chevron
    >
      <cross-wui-text variant="paragraph-500" color="fg-100">Android App</cross-wui-text>
    </cross-wui-list-item>`;
  }
  homepageTemplate() {
    var _a3;
    if (!((_a3 = this.wallet) == null ? void 0 : _a3.homepage)) {
      return null;
    }
    return x$3`
      <cross-wui-list-item
        variant="icon"
        icon="browser"
        iconVariant="square-blue"
        @click=${this.onHomePage.bind(this)}
        chevron
      >
        <cross-wui-text variant="paragraph-500" color="fg-100">Website</cross-wui-text>
      </cross-wui-list-item>
    `;
  }
  onChromeStore() {
    var _a3;
    if ((_a3 = this.wallet) == null ? void 0 : _a3.chrome_store) {
      CoreHelperUtil.openHref(this.wallet.chrome_store, "_blank");
    }
  }
  onAppStore() {
    var _a3;
    if ((_a3 = this.wallet) == null ? void 0 : _a3.app_store) {
      CoreHelperUtil.openHref(this.wallet.app_store, "_blank");
    }
  }
  onPlayStore() {
    var _a3;
    if ((_a3 = this.wallet) == null ? void 0 : _a3.play_store) {
      CoreHelperUtil.openHref(this.wallet.play_store, "_blank");
    }
  }
  onHomePage() {
    var _a3;
    if ((_a3 = this.wallet) == null ? void 0 : _a3.homepage) {
      CoreHelperUtil.openHref(this.wallet.homepage, "_blank");
    }
  }
};
W3mDownloadsView = __decorate$1o([
  customElement("cross-w3m-downloads-view")
], W3mDownloadsView);
var __decorate$1n = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
const EXPLORER = "https://walletconnect.com/explorer";
let W3mGetWalletView = class W3mGetWalletView2 extends i$1 {
  render() {
    return x$3`
      <cross-wui-flex flexDirection="column" .padding=${["0", "s", "s", "s"]} gap="xs">
        ${this.recommendedWalletsTemplate()}
        <cross-wui-list-wallet
          name="Explore all"
          showAllWallets
          walletIcon="allWallets"
          icon="externalLink"
          @click=${() => {
      CoreHelperUtil.openHref("https://walletconnect.com/explorer?type=wallet", "_blank");
    }}
        ></cross-wui-list-wallet>
      </cross-wui-flex>
    `;
  }
  recommendedWalletsTemplate() {
    const { recommended, featured } = ApiController$1.state;
    const { customWallets } = OptionsController.state;
    const wallets = [...featured, ...customWallets ?? [], ...recommended].slice(0, 4);
    return wallets.map((wallet) => x$3`
        <cross-wui-list-wallet
          name=${wallet.name ?? "Unknown"}
          tagVariant="main"
          imageSrc=${o$2(AssetUtil.getWalletImage(wallet))}
          @click=${() => {
      CoreHelperUtil.openHref(wallet.homepage ?? EXPLORER, "_blank");
    }}
        ></cross-wui-list-wallet>
      `);
  }
};
W3mGetWalletView = __decorate$1n([
  customElement("cross-w3m-get-wallet-view")
], W3mGetWalletView);
const styles$X = i$4`
  cross-wui-flex {
    width: 100%;
  }

  .suggestion {
    background: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }

  .suggestion:hover {
    background-color: var(--wui-color-gray-glass-005);
    cursor: pointer;
  }

  .suggested-name {
    max-width: 75%;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  form {
    width: 100%;
  }

  cross-wui-icon-link {
    position: absolute;
    right: 20px;
    transform: translateY(11px);
  }
`;
var __decorate$1m = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mRegisterAccountNameView = class W3mRegisterAccountNameView2 extends i$1 {
  constructor() {
    super();
    this.formRef = e();
    this.usubscribe = [];
    this.name = "";
    this.error = "";
    this.loading = EnsController.state.loading;
    this.suggestions = EnsController.state.suggestions;
    this.registered = false;
    this.profileName = AccountController.state.profileName;
    this.onDebouncedNameInputChange = CoreHelperUtil.debounce((value) => {
      if (EnsController.validateName(value)) {
        this.error = "";
        this.name = value;
        EnsController.getSuggestions(value);
        EnsController.isNameRegistered(value).then((registered) => {
          this.registered = registered;
        });
      } else if (value.length < 4) {
        this.error = "Name must be at least 4 characters long";
      } else {
        this.error = "Can only contain letters, numbers and - characters";
      }
    });
    this.usubscribe.push(...[
      EnsController.subscribe((val) => {
        this.suggestions = val.suggestions;
        this.loading = val.loading;
      }),
      AccountController.subscribeKey("profileName", (val) => {
        this.profileName = val;
        if (val) {
          this.error = "You already own a name";
        }
      })
    ]);
  }
  firstUpdated() {
    var _a3;
    (_a3 = this.formRef.value) == null ? void 0 : _a3.addEventListener("keydown", this.onEnterKey.bind(this));
  }
  disconnectedCallback() {
    var _a3;
    super.disconnectedCallback();
    this.usubscribe.forEach((unsub) => unsub());
    (_a3 = this.formRef.value) == null ? void 0 : _a3.removeEventListener("keydown", this.onEnterKey.bind(this));
  }
  render() {
    return x$3`
      <cross-wui-flex
        flexDirection="column"
        alignItems="center"
        gap="m"
        .padding=${["0", "s", "m", "s"]}
      >
        <form ${n$1(this.formRef)} @submit=${this.onSubmitName.bind(this)}>
          <cross-wui-ens-input
            @inputChange=${this.onNameInputChange.bind(this)}
            .errorMessage=${this.error}
            .value=${this.name}
          >
          </cross-wui-ens-input>
          ${this.submitButtonTemplate()}
          <input type="submit" hidden />
        </form>
        ${this.templateSuggestions()}
      </cross-wui-flex>
    `;
  }
  submitButtonTemplate() {
    const showSubmit = this.isAllowedToSubmit();
    return showSubmit ? x$3`
          <cross-wui-icon-link
            size="sm"
            icon="chevronRight"
            iconcolor="accent-100"
            @click=${this.onSubmitName.bind(this)}
          >
          </cross-wui-icon-link>
        ` : null;
  }
  onSelectSuggestion(name) {
    return () => {
      this.name = name;
      this.registered = false;
      this.requestUpdate();
    };
  }
  onNameInputChange(event) {
    this.onDebouncedNameInputChange(event.detail);
  }
  nameSuggestionTagTemplate() {
    if (this.loading) {
      return x$3`<cross-wui-loading-spinner size="lg" color="fg-100"></cross-wui-loading-spinner>`;
    }
    return this.registered ? x$3`<cross-wui-tag variant="shade" size="lg">Registered</cross-wui-tag>` : x$3`<cross-wui-tag variant="success" size="lg">Available</cross-wui-tag>`;
  }
  templateSuggestions() {
    if (!this.name || this.name.length < 4 || this.error) {
      return null;
    }
    const suggestions = this.registered ? this.suggestions.filter((s2) => s2.name !== this.name) : [];
    return x$3`<cross-wui-flex flexDirection="column" gap="xxs" alignItems="center">
      <cross-wui-flex
        data-testid="account-name-suggestion"
        .padding=${["m", "m", "m", "m"]}
        justifyContent="space-between"
        class="suggestion"
        @click=${this.onSubmitName.bind(this)}
      >
        <cross-wui-text color="fg-100" variant="paragraph-400" class="suggested-name">
          ${this.name}</wui-text
        >${this.nameSuggestionTagTemplate()}
      </cross-wui-flex>
      ${suggestions.map((suggestion) => this.availableNameTemplate(suggestion.name))}
    </cross-wui-flex>`;
  }
  availableNameTemplate(suggestion) {
    return x$3` <cross-wui-flex
      data-testid="account-name-suggestion"
      .padding=${["m", "m", "m", "m"]}
      justifyContent="space-between"
      class="suggestion"
      @click=${this.onSelectSuggestion(suggestion)}
    >
      <cross-wui-text color="fg-100" variant="paragraph-400" class="suggested-name">
        ${suggestion}
      </cross-wui-text>
      <cross-wui-tag variant="success" size="lg">Available</cross-wui-tag>
    </cross-wui-flex>`;
  }
  isAllowedToSubmit() {
    return !this.loading && !this.registered && !this.error && !this.profileName && EnsController.validateName(this.name);
  }
  async onSubmitName() {
    try {
      if (!this.isAllowedToSubmit()) {
        return;
      }
      const ensName = `${this.name}${ConstantsUtil$4.WC_NAME_SUFFIX}`;
      EventsController.sendEvent({
        type: "track",
        event: "REGISTER_NAME_INITIATED",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          ensName
        }
      });
      await EnsController.registerName(ensName);
      EventsController.sendEvent({
        type: "track",
        event: "REGISTER_NAME_SUCCESS",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          ensName
        }
      });
    } catch (error) {
      SnackController.showError(error.message);
      EventsController.sendEvent({
        type: "track",
        event: "REGISTER_NAME_ERROR",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          ensName: `${this.name}${ConstantsUtil$4.WC_NAME_SUFFIX}`,
          error: (error == null ? void 0 : error.message) || "Unknown error"
        }
      });
    }
  }
  onEnterKey(event) {
    if (event.key === "Enter" && this.isAllowedToSubmit()) {
      this.onSubmitName();
    }
  }
};
W3mRegisterAccountNameView.styles = styles$X;
__decorate$1m([
  n$3()
], W3mRegisterAccountNameView.prototype, "errorMessage", void 0);
__decorate$1m([
  r$1()
], W3mRegisterAccountNameView.prototype, "name", void 0);
__decorate$1m([
  r$1()
], W3mRegisterAccountNameView.prototype, "error", void 0);
__decorate$1m([
  r$1()
], W3mRegisterAccountNameView.prototype, "loading", void 0);
__decorate$1m([
  r$1()
], W3mRegisterAccountNameView.prototype, "suggestions", void 0);
__decorate$1m([
  r$1()
], W3mRegisterAccountNameView.prototype, "registered", void 0);
__decorate$1m([
  r$1()
], W3mRegisterAccountNameView.prototype, "profileName", void 0);
W3mRegisterAccountNameView = __decorate$1m([
  customElement("cross-w3m-register-account-name-view")
], W3mRegisterAccountNameView);
const styles$W = i$4`
  .continue-button-container {
    width: 100%;
  }
`;
var __decorate$1l = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mRegisterAccountNameSuccess = class W3mRegisterAccountNameSuccess2 extends i$1 {
  render() {
    return x$3`
      <cross-wui-flex
        flexDirection="column"
        alignItems="center"
        gap="xxl"
        .padding=${["0", "0", "l", "0"]}
      >
        ${this.onboardingTemplate()} ${this.buttonsTemplate()}
        <cross-wui-link
          @click=${() => {
      CoreHelperUtil.openHref(NavigationUtil.URLS.FAQ, "_blank");
    }}
        >
          Learn more
          <cross-wui-icon color="inherit" slot="iconRight" name="externalLink"></cross-wui-icon>
        </cross-wui-link>
      </cross-wui-flex>
    `;
  }
  onboardingTemplate() {
    return x$3` <cross-wui-flex
      flexDirection="column"
      gap="xxl"
      alignItems="center"
      .padding=${["0", "xxl", "0", "xxl"]}
    >
      <cross-wui-flex gap="s" alignItems="center" justifyContent="center">
        <cross-wui-icon-box
          size="xl"
          iconcolor="success-100"
          backgroundcolor="success-100"
          icon="checkmark"
          background="opaque"
        ></cross-wui-icon-box>
      </cross-wui-flex>
      <cross-wui-flex flexDirection="column" alignItems="center" gap="s">
        <cross-wui-text align="center" variant="medium-600" color="fg-100">
          Account name chosen successfully
        </cross-wui-text>
        <cross-wui-text align="center" variant="paragraph-400" color="fg-100">
          You can now fund your account and trade crypto
        </cross-wui-text>
      </cross-wui-flex>
    </cross-wui-flex>`;
  }
  buttonsTemplate() {
    return x$3`<cross-wui-flex
      .padding=${["0", "2l", "0", "2l"]}
      gap="s"
      class="continue-button-container"
    >
      <cross-wui-button fullWidth size="lg" borderRadius="xs" @click=${this.redirectToAccount.bind(this)}
        >Let's Go!
      </cross-wui-button>
    </cross-wui-flex>`;
  }
  redirectToAccount() {
    RouterController.replace("Account");
  }
};
W3mRegisterAccountNameSuccess.styles = styles$W;
W3mRegisterAccountNameSuccess = __decorate$1l([
  customElement("cross-w3m-register-account-name-success-view")
], W3mRegisterAccountNameSuccess);
const styles$V = i$4`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  cross-wui-loading-hexagon {
    position: absolute;
  }

  cross-wui-icon-box {
    position: absolute;
    right: 4px;
    bottom: 0;
    opacity: 0;
    transform: scale(0.5);
    z-index: 1;
  }

  cross-wui-button {
    display: none;
  }

  [data-error='true'] cross-wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  wui-button[data-retry='true'] {
    display: block;
    opacity: 1;
  }
`;
var __decorate$1k = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mNetworkSwitchView = class W3mNetworkSwitchView2 extends i$1 {
  constructor() {
    var _a3;
    super();
    this.network = (_a3 = RouterController.state.data) == null ? void 0 : _a3.network;
    this.unsubscribe = [];
    this.showRetry = false;
    this.error = false;
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  firstUpdated() {
    this.onSwitchNetwork();
  }
  render() {
    if (!this.network) {
      throw new Error("cross-w3m-network-switch-view: No network provided");
    }
    this.onShowRetry();
    const label = this.getLabel();
    const subLabel = this.getSubLabel();
    return x$3`
      <cross-wui-flex
        data-error=${this.error}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "3xl", "xl"]}
        gap="xl"
      >
        <cross-wui-flex justifyContent="center" alignItems="center">
          <cross-wui-network-image
            size="lg"
            imageSrc=${o$2(AssetUtil.getNetworkImage(this.network))}
          ></cross-wui-network-image>

          ${this.error ? null : x$3`<cross-wui-loading-hexagon></cross-wui-loading-hexagon>`}

          <cross-wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            ?border=${true}
            borderColor="wui-color-bg-125"
          ></cross-wui-icon-box>
        </cross-wui-flex>

        <cross-wui-flex flexDirection="column" alignItems="center" gap="xs">
          <cross-wui-text align="center" variant="paragraph-500" color="fg-100">${label}</cross-wui-text>
          <cross-wui-text align="center" variant="small-500" color="fg-200">${subLabel}</cross-wui-text>
        </cross-wui-flex>

        <cross-wui-button
          data-retry=${this.showRetry}
          variant="accent"
          size="md"
          .disabled=${!this.error}
          @click=${this.onSwitchNetwork.bind(this)}
        >
          <cross-wui-icon color="inherit" slot="iconLeft" name="refresh"></cross-wui-icon>
          Try again
        </cross-wui-button>
      </cross-wui-flex>
    `;
  }
  getSubLabel() {
    const namespace = ChainController.state.activeChain;
    const connectorId = StorageUtil.getConnectedConnectorId(namespace);
    const authConnector = ConnectorController.getAuthConnector();
    if (authConnector && connectorId === ConstantsUtil$4.CONNECTOR_ID.AUTH) {
      return "";
    }
    return this.error ? "Switch can be declined if chain is not supported by a wallet or previous request is still active" : "Accept connection request in your wallet";
  }
  getLabel() {
    var _a3;
    const namespace = ChainController.state.activeChain;
    const connectorId = StorageUtil.getConnectedConnectorId(namespace);
    const authConnector = ConnectorController.getAuthConnector();
    if (authConnector && connectorId === ConstantsUtil$4.CONNECTOR_ID.AUTH) {
      return `Switching to ${((_a3 = this.network) == null ? void 0 : _a3.name) ?? "Unknown"} network...`;
    }
    return this.error ? "Switch declined" : "Approve in wallet";
  }
  onShowRetry() {
    var _a3;
    if (this.error && !this.showRetry) {
      this.showRetry = true;
      const retryButton = (_a3 = this.shadowRoot) == null ? void 0 : _a3.querySelector("cross-wui-button");
      retryButton == null ? void 0 : retryButton.animate([{ opacity: 0 }, { opacity: 1 }], {
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  async onSwitchNetwork() {
    try {
      this.error = false;
      if (this.network) {
        await ChainController.switchActiveNetwork(this.network);
      }
    } catch (error) {
      this.error = true;
    }
  }
};
W3mNetworkSwitchView.styles = styles$V;
__decorate$1k([
  r$1()
], W3mNetworkSwitchView.prototype, "showRetry", void 0);
__decorate$1k([
  r$1()
], W3mNetworkSwitchView.prototype, "error", void 0);
W3mNetworkSwitchView = __decorate$1k([
  customElement("cross-w3m-network-switch-view")
], W3mNetworkSwitchView);
const styles$U = i$4`
  .container {
    max-height: 360px;
    overflow: auto;
  }

  .container::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$1j = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mNetworksView = class W3mNetworksView2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.network = ChainController.state.activeCaipNetwork;
    this.requestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
    this.search = "";
    this.onDebouncedSearch = CoreHelperUtil.debounce((value) => {
      this.search = value;
    }, 100);
    this.unsubscribe.push(AssetController.subscribeNetworkImages(() => this.requestUpdate()), ChainController.subscribeKey("activeCaipNetwork", (val) => this.network = val), ChainController.subscribeKey("chains", () => this.requestedCaipNetworks = ChainController.getAllRequestedCaipNetworks()));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x$3`
      ${this.templateSearchInput()}
      <cross-wui-flex
        class="container"
        .padding=${["0", "s", "s", "s"]}
        flexDirection="column"
        gap="xs"
      >
        ${this.networksTemplate()}
      </cross-wui-flex>

      <cross-wui-separator></cross-wui-separator>

      <cross-wui-flex padding="s" flexDirection="column" gap="m" alignItems="center">
        <cross-wui-text variant="small-400" color="fg-300" align="center">
          Your connected wallet may not support some of the networks available for this dApp
        </cross-wui-text>
        <cross-wui-link @click=${this.onNetworkHelp.bind(this)}>
          <cross-wui-icon size="xs" color="accent-100" slot="iconLeft" name="helpCircle"></cross-wui-icon>
          What is a network
        </cross-wui-link>
      </cross-wui-flex>
    `;
  }
  templateSearchInput() {
    return x$3`
      <cross-wui-flex gap="xs" .padding=${["0", "s", "s", "s"]}>
        <cross-wui-input-text
          @inputChange=${this.onInputChange.bind(this)}
          class="network-search-input"
          size="md"
          placeholder="Search network"
          icon="search"
        ></cross-wui-input-text>
      </cross-wui-flex>
    `;
  }
  onInputChange(event) {
    this.onDebouncedSearch(event.detail);
  }
  onNetworkHelp() {
    EventsController.sendEvent({ type: "track", event: "CLICK_NETWORK_HELP" });
    RouterController.push("WhatIsANetwork");
  }
  networksTemplate() {
    var _a3;
    const requestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
    const approvedCaipNetworkIds = ChainController.getAllApprovedCaipNetworkIds();
    const sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedCaipNetworkIds, requestedCaipNetworks);
    if (this.search) {
      this.filteredNetworks = sortedNetworks == null ? void 0 : sortedNetworks.filter((network) => {
        var _a4;
        return (_a4 = network == null ? void 0 : network.name) == null ? void 0 : _a4.toLowerCase().includes(this.search.toLowerCase());
      });
    } else {
      this.filteredNetworks = sortedNetworks;
    }
    return (_a3 = this.filteredNetworks) == null ? void 0 : _a3.map((network) => {
      var _a4;
      return x$3`
        <cross-wui-list-network
          .selected=${((_a4 = this.network) == null ? void 0 : _a4.id) === network.id}
          imageSrc=${o$2(AssetUtil.getNetworkImage(network))}
          type="network"
          name=${network.name ?? network.id}
          @click=${() => this.onSwitchNetwork(network)}
          .disabled=${this.getNetworkDisabled(network)}
          data-testid=${`w3m-network-switch-${network.name ?? network.id}`}
        ></cross-wui-list-network>
      `;
    });
  }
  getNetworkDisabled(network) {
    const networkNamespace = network.chainNamespace;
    const isNextNamespaceConnected = AccountController.getCaipAddress(networkNamespace);
    const approvedCaipNetworkIds = ChainController.getAllApprovedCaipNetworkIds();
    const supportsAllNetworks = ChainController.getNetworkProp("supportsAllNetworks", networkNamespace) !== false;
    const connectorId = StorageUtil.getConnectedConnectorId(networkNamespace);
    const authConnector = ConnectorController.getAuthConnector();
    const isConnectedWithAuth = connectorId === ConstantsUtil$4.CONNECTOR_ID.AUTH && authConnector;
    if (!isNextNamespaceConnected || supportsAllNetworks || isConnectedWithAuth) {
      return false;
    }
    return !(approvedCaipNetworkIds == null ? void 0 : approvedCaipNetworkIds.includes(network.caipNetworkId));
  }
  onSwitchNetwork(network) {
    var _a3;
    const routerData = RouterController.state.data;
    const isSameNetwork = network.id === ((_a3 = this.network) == null ? void 0 : _a3.id);
    if (isSameNetwork) {
      return;
    }
    const isDifferentNamespace = network.chainNamespace !== ChainController.state.activeChain;
    const isCurrentNamespaceConnected = AccountController.state.caipAddress;
    const isNextNamespaceConnected = AccountController.getCaipAddress(network.chainNamespace);
    const connectorId = StorageUtil.getConnectedConnectorId(ChainController.state.activeChain);
    const isConnectedWithAuth = connectorId === ConstantsUtil$4.CONNECTOR_ID.AUTH;
    const isSupportedForAuthConnector = ConstantsUtil$4.AUTH_CONNECTOR_SUPPORTED_CHAINS.find((c2) => c2 === network.chainNamespace);
    if (isCurrentNamespaceConnected) {
      if (isConnectedWithAuth && isSupportedForAuthConnector) {
        RouterController.push("SwitchNetwork", { ...routerData, network });
      } else if (isConnectedWithAuth && !isSupportedForAuthConnector || isDifferentNamespace && !isNextNamespaceConnected) {
        RouterController.push("SwitchActiveChain", {
          switchToChain: network.chainNamespace,
          navigateTo: "Connect",
          navigateWithReplace: true,
          network
        });
      } else {
        RouterController.push("SwitchNetwork", { ...routerData, network });
      }
    } else {
      RouterController.push("SwitchNetwork", { ...routerData, network });
    }
  }
};
W3mNetworksView.styles = styles$U;
__decorate$1j([
  r$1()
], W3mNetworksView.prototype, "network", void 0);
__decorate$1j([
  r$1()
], W3mNetworksView.prototype, "requestedCaipNetworks", void 0);
__decorate$1j([
  r$1()
], W3mNetworksView.prototype, "filteredNetworks", void 0);
__decorate$1j([
  r$1()
], W3mNetworksView.prototype, "search", void 0);
W3mNetworksView = __decorate$1j([
  customElement("cross-w3m-networks-view")
], W3mNetworksView);
const styles$T = i$4`
  :host > cross-wui-flex {
    height: 500px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
    padding: var(--wui-spacing-m);
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: flex-start;
  }

  :host > wui-flex::-webkit-scrollbar {
    display: none;
  }

  :host > wui-flex > cross-wui-flex {
    width: 100%;
  }

  cross-wui-transaction-list-item-loader {
    width: 100%;
  }
`;
var __decorate$1i = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
const LOADING_ITEM_COUNT$1 = 7;
let W3mOnRampActivityView = class W3mOnRampActivityView2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.selectedOnRampProvider = OnRampController.state.selectedProvider;
    this.loading = false;
    this.coinbaseTransactions = TransactionsController.state.coinbaseTransactions;
    this.tokenImages = AssetController.state.tokenImages;
    this.unsubscribe.push(...[
      OnRampController.subscribeKey("selectedProvider", (val) => {
        this.selectedOnRampProvider = val;
      }),
      AssetController.subscribeKey("tokenImages", (val) => this.tokenImages = val),
      () => {
        clearTimeout(this.refetchTimeout);
      },
      TransactionsController.subscribe((val) => {
        this.coinbaseTransactions = { ...val.coinbaseTransactions };
      })
    ]);
    TransactionsController.clearCursor();
    this.fetchTransactions();
  }
  render() {
    return x$3`
      <cross-wui-flex flexDirection="column" .padding=${["0", "s", "s", "s"]} gap="xs">
        ${this.loading ? this.templateLoading() : this.templateTransactionsByYear()}
      </cross-wui-flex>
    `;
  }
  templateTransactions(transactions) {
    return transactions == null ? void 0 : transactions.map((transaction) => {
      var _a3, _b2, _c3;
      const date = DateUtil.formatDate((_a3 = transaction == null ? void 0 : transaction.metadata) == null ? void 0 : _a3.minedAt);
      const transfer = transaction.transfers[0];
      const fungibleInfo = transfer == null ? void 0 : transfer.fungible_info;
      if (!fungibleInfo) {
        return null;
      }
      const icon = ((_b2 = fungibleInfo == null ? void 0 : fungibleInfo.icon) == null ? void 0 : _b2.url) || ((_c3 = this.tokenImages) == null ? void 0 : _c3[fungibleInfo.symbol || ""]);
      return x$3`
        <cross-w3m-onramp-activity-item
          label="Bought"
          .completed=${transaction.metadata.status === "ONRAMP_TRANSACTION_STATUS_SUCCESS"}
          .inProgress=${transaction.metadata.status === "ONRAMP_TRANSACTION_STATUS_IN_PROGRESS"}
          .failed=${transaction.metadata.status === "ONRAMP_TRANSACTION_STATUS_FAILED"}
          purchaseCurrency=${o$2(fungibleInfo.symbol)}
          purchaseValue=${transfer.quantity.numeric}
          date=${date}
          icon=${o$2(icon)}
          symbol=${o$2(fungibleInfo.symbol)}
        ></cross-w3m-onramp-activity-item>
      `;
    });
  }
  templateTransactionsByYear() {
    const sortedYearKeys = Object.keys(this.coinbaseTransactions).sort().reverse();
    return sortedYearKeys.map((year) => {
      const yearInt = parseInt(year, 10);
      const sortedMonthIndexes = new Array(12).fill(null).map((_3, idx) => idx).reverse();
      return sortedMonthIndexes.map((month) => {
        var _a3;
        const groupTitle = TransactionUtil.getTransactionGroupTitle(yearInt, month);
        const transactions = (_a3 = this.coinbaseTransactions[yearInt]) == null ? void 0 : _a3[month];
        if (!transactions) {
          return null;
        }
        return x$3`
          <cross-wui-flex flexDirection="column">
            <cross-wui-flex
              alignItems="center"
              flexDirection="row"
              .padding=${["xs", "s", "s", "s"]}
            >
              <cross-wui-text variant="paragraph-500" color="fg-200">${groupTitle}</cross-wui-text>
            </cross-wui-flex>
            <cross-wui-flex flexDirection="column" gap="xs">
              ${this.templateTransactions(transactions)}
            </cross-wui-flex>
          </cross-wui-flex>
        `;
      });
    });
  }
  async fetchTransactions() {
    {
      await this.fetchCoinbaseTransactions();
    }
  }
  async fetchCoinbaseTransactions() {
    const address = AccountController.state.address;
    const projectId = OptionsController.state.projectId;
    if (!address) {
      throw new Error("No address found");
    }
    if (!projectId) {
      throw new Error("No projectId found");
    }
    this.loading = true;
    await TransactionsController.fetchTransactions(address, "coinbase");
    this.loading = false;
    this.refetchLoadingTransactions();
  }
  refetchLoadingTransactions() {
    var _a3;
    const today = /* @__PURE__ */ new Date();
    const currentMonthTxs = ((_a3 = this.coinbaseTransactions[today.getFullYear()]) == null ? void 0 : _a3[today.getMonth()]) || [];
    const loadingTransactions = currentMonthTxs.filter((transaction) => transaction.metadata.status === "ONRAMP_TRANSACTION_STATUS_IN_PROGRESS");
    if (loadingTransactions.length === 0) {
      clearTimeout(this.refetchTimeout);
      return;
    }
    this.refetchTimeout = setTimeout(async () => {
      const address = AccountController.state.address;
      await TransactionsController.fetchTransactions(address, "coinbase");
      this.refetchLoadingTransactions();
    }, 3e3);
  }
  templateLoading() {
    return Array(LOADING_ITEM_COUNT$1).fill(x$3` <cross-wui-transaction-list-item-loader></cross-wui-transaction-list-item-loader> `).map((item) => item);
  }
};
W3mOnRampActivityView.styles = styles$T;
__decorate$1i([
  r$1()
], W3mOnRampActivityView.prototype, "selectedOnRampProvider", void 0);
__decorate$1i([
  r$1()
], W3mOnRampActivityView.prototype, "loading", void 0);
__decorate$1i([
  r$1()
], W3mOnRampActivityView.prototype, "coinbaseTransactions", void 0);
__decorate$1i([
  r$1()
], W3mOnRampActivityView.prototype, "tokenImages", void 0);
W3mOnRampActivityView = __decorate$1i([
  customElement("cross-w3m-onramp-activity-view")
], W3mOnRampActivityView);
const styles$S = i$4`
  :host > cross-wui-grid {
    max-height: 360px;
    overflow: auto;
  }

  cross-wui-flex {
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-flex.disabled {
    opacity: 0.3;
    pointer-events: none;
    user-select: none;
  }
`;
var __decorate$1h = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mOnrampFiatSelectView = class W3mOnrampFiatSelectView2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.selectedCurrency = OnRampController.state.paymentCurrency;
    this.currencies = OnRampController.state.paymentCurrencies;
    this.currencyImages = AssetController.state.currencyImages;
    this.checked = false;
    this.unsubscribe.push(...[
      OnRampController.subscribe((val) => {
        this.selectedCurrency = val.paymentCurrency;
        this.currencies = val.paymentCurrencies;
      }),
      AssetController.subscribeKey("currencyImages", (val) => this.currencyImages = val)
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a3;
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    const legalCheckbox = (_a3 = OptionsController.state.features) == null ? void 0 : _a3.legalCheckbox;
    const legalUrl = termsConditionsUrl || privacyPolicyUrl;
    const showLegalCheckbox = Boolean(legalUrl) && Boolean(legalCheckbox);
    const disabled = showLegalCheckbox && !this.checked;
    return x$3`
      <cross-w3m-legal-checkbox
        @checkboxChange=${this.onCheckboxChange.bind(this)}
      ></cross-w3m-legal-checkbox>
      <cross-wui-flex
        flexDirection="column"
        .padding=${["0", "s", "s", "s"]}
        gap="xs"
        class=${o$2(disabled ? "disabled" : void 0)}
      >
        ${this.currenciesTemplate(disabled)}
      </cross-wui-flex>
      <cross-w3m-legal-footer></cross-w3m-legal-footer>
    `;
  }
  currenciesTemplate(disabled = false) {
    return this.currencies.map((currency) => {
      var _a3;
      return x$3`
        <cross-wui-list-item
          imageSrc=${o$2((_a3 = this.currencyImages) == null ? void 0 : _a3[currency.id])}
          @click=${() => this.selectCurrency(currency)}
          variant="image"
          tabIdx=${o$2(disabled ? -1 : void 0)}
        >
          <cross-wui-text variant="paragraph-500" color="fg-100">${currency.id}</cross-wui-text>
        </cross-wui-list-item>
      `;
    });
  }
  selectCurrency(currency) {
    if (!currency) {
      return;
    }
    OnRampController.setPaymentCurrency(currency);
    ModalController.close();
  }
  onCheckboxChange(event) {
    this.checked = Boolean(event.detail);
  }
};
W3mOnrampFiatSelectView.styles = styles$S;
__decorate$1h([
  r$1()
], W3mOnrampFiatSelectView.prototype, "selectedCurrency", void 0);
__decorate$1h([
  r$1()
], W3mOnrampFiatSelectView.prototype, "currencies", void 0);
__decorate$1h([
  r$1()
], W3mOnrampFiatSelectView.prototype, "currencyImages", void 0);
__decorate$1h([
  r$1()
], W3mOnrampFiatSelectView.prototype, "checked", void 0);
W3mOnrampFiatSelectView = __decorate$1h([
  customElement("cross-w3m-onramp-fiat-select-view")
], W3mOnrampFiatSelectView);
var __decorate$1g = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mOnRampProvidersView = class W3mOnRampProvidersView2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.providers = OnRampController.state.providers;
    this.unsubscribe.push(...[
      OnRampController.subscribeKey("providers", (val) => {
        this.providers = val;
      })
    ]);
  }
  firstUpdated() {
    const urlPromises = this.providers.map(async (provider) => {
      if (provider.name === "coinbase") {
        return await this.getCoinbaseOnRampURL();
      }
      return Promise.resolve(provider == null ? void 0 : provider.url);
    });
    Promise.all(urlPromises).then((urls) => {
      this.providers = this.providers.map((provider, index2) => ({
        ...provider,
        url: urls[index2] || ""
      }));
    });
  }
  render() {
    return x$3`
      <cross-wui-flex flexDirection="column" .padding=${["0", "s", "s", "s"]} gap="xs">
        ${this.onRampProvidersTemplate()}
      </cross-wui-flex>
      <cross-w3m-onramp-providers-footer></cross-w3m-onramp-providers-footer>
    `;
  }
  onRampProvidersTemplate() {
    return this.providers.filter((provider) => provider.supportedChains.includes(ChainController.state.activeChain ?? "eip155")).map((provider) => x$3`
          <cross-w3m-onramp-provider-item
            label=${provider.label}
            name=${provider.name}
            feeRange=${provider.feeRange}
            @click=${() => {
      this.onClickProvider(provider);
    }}
            ?disabled=${!provider.url}
          ></cross-w3m-onramp-provider-item>
        `);
  }
  onClickProvider(provider) {
    OnRampController.setSelectedProvider(provider);
    RouterController.push("BuyInProgress");
    CoreHelperUtil.openHref(provider.url, "popupWindow", "width=600,height=800,scrollbars=yes");
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_BUY_PROVIDER",
      properties: {
        provider: provider.name,
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
  }
  async getCoinbaseOnRampURL() {
    const address = AccountController.state.address;
    const network = ChainController.state.activeCaipNetwork;
    if (!address) {
      throw new Error("No address found");
    }
    if (!(network == null ? void 0 : network.name)) {
      throw new Error("No network found");
    }
    const defaultNetwork = ConstantsUtil$3.WC_COINBASE_PAY_SDK_CHAIN_NAME_MAP[network.name] ?? ConstantsUtil$3.WC_COINBASE_PAY_SDK_FALLBACK_CHAIN;
    const purchaseCurrency = OnRampController.state.purchaseCurrency;
    const assets = purchaseCurrency ? [purchaseCurrency.symbol] : OnRampController.state.purchaseCurrencies.map((currency) => currency.symbol);
    return await BlockchainApiController.generateOnRampURL({
      defaultNetwork,
      destinationWallets: [
        { address, blockchains: ConstantsUtil$3.WC_COINBASE_PAY_SDK_CHAINS, assets }
      ],
      partnerUserId: address,
      purchaseAmount: OnRampController.state.purchaseAmount
    });
  }
};
__decorate$1g([
  r$1()
], W3mOnRampProvidersView.prototype, "providers", void 0);
W3mOnRampProvidersView = __decorate$1g([
  customElement("w3m-onramp-providers-view")
], W3mOnRampProvidersView);
const styles$R = i$4`
  :host > cross-wui-grid {
    max-height: 360px;
    overflow: auto;
  }

  cross-wui-flex {
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-flex.disabled {
    opacity: 0.3;
    pointer-events: none;
    user-select: none;
  }
`;
var __decorate$1f = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mOnrampTokensView = class W3mOnrampTokensView2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.selectedCurrency = OnRampController.state.purchaseCurrencies;
    this.tokens = OnRampController.state.purchaseCurrencies;
    this.tokenImages = AssetController.state.tokenImages;
    this.checked = false;
    this.unsubscribe.push(...[
      OnRampController.subscribe((val) => {
        this.selectedCurrency = val.purchaseCurrencies;
        this.tokens = val.purchaseCurrencies;
      }),
      AssetController.subscribeKey("tokenImages", (val) => this.tokenImages = val)
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a3;
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    const legalCheckbox = (_a3 = OptionsController.state.features) == null ? void 0 : _a3.legalCheckbox;
    const legalUrl = termsConditionsUrl || privacyPolicyUrl;
    const showLegalCheckbox = Boolean(legalUrl) && Boolean(legalCheckbox);
    const disabled = showLegalCheckbox && !this.checked;
    return x$3`
      <cross-w3m-legal-checkbox
        @checkboxChange=${this.onCheckboxChange.bind(this)}
      ></cross-w3m-legal-checkbox>
      <cross-wui-flex
        flexDirection="column"
        .padding=${["0", "s", "s", "s"]}
        gap="xs"
        class=${o$2(disabled ? "disabled" : void 0)}
      >
        ${this.currenciesTemplate(disabled)}
      </cross-wui-flex>
      <cross-w3m-legal-footer></cross-w3m-legal-footer>
    `;
  }
  currenciesTemplate(disabled = false) {
    return this.tokens.map((token) => {
      var _a3;
      return x$3`
        <cross-wui-list-item
          imageSrc=${o$2((_a3 = this.tokenImages) == null ? void 0 : _a3[token.symbol])}
          @click=${() => this.selectToken(token)}
          variant="image"
          tabIdx=${o$2(disabled ? -1 : void 0)}
        >
          <cross-wui-flex gap="3xs" alignItems="center">
            <cross-wui-text variant="paragraph-500" color="fg-100">${token.name}</cross-wui-text>
            <cross-wui-text variant="small-400" color="fg-200">${token.symbol}</cross-wui-text>
          </cross-wui-flex>
        </cross-wui-list-item>
      `;
    });
  }
  selectToken(currency) {
    if (!currency) {
      return;
    }
    OnRampController.setPurchaseCurrency(currency);
    ModalController.close();
  }
  onCheckboxChange(event) {
    this.checked = Boolean(event.detail);
  }
};
W3mOnrampTokensView.styles = styles$R;
__decorate$1f([
  r$1()
], W3mOnrampTokensView.prototype, "selectedCurrency", void 0);
__decorate$1f([
  r$1()
], W3mOnrampTokensView.prototype, "tokens", void 0);
__decorate$1f([
  r$1()
], W3mOnrampTokensView.prototype, "tokenImages", void 0);
__decorate$1f([
  r$1()
], W3mOnrampTokensView.prototype, "checked", void 0);
W3mOnrampTokensView = __decorate$1f([
  customElement("cross-w3m-onramp-token-select-view")
], W3mOnrampTokensView);
const styles$Q = i$4`
  :host > wui-flex:first-child {
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }

  :host > wui-flex:first-child::-webkit-scrollbar {
    display: none;
  }

  cross-wui-loading-hexagon {
    position: absolute;
  }

  .action-button {
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
  }

  .action-button:disabled {
    border-color: 1px solid var(--wui-color-gray-glass-005);
  }

  .swap-inputs-container {
    position: relative;
  }

  .replace-tokens-button-container {
    display: flex;
    justify-content: center;
    align-items: center;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    gap: var(--wui-spacing-1xs);
    border-radius: var(--wui-border-radius-xs);
    background-color: var(--wui-color-modal-bg-base);
    padding: var(--wui-spacing-xxs);
  }

  .replace-tokens-button-container > button {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 40px;
    width: 40px;
    padding: var(--wui-spacing-xs);
    border: none;
    border-radius: var(--wui-border-radius-xxs);
    background: var(--wui-color-gray-glass-002);
    transition: background-color var(--wui-duration-md) var(--wui-ease-out-power-1);
    will-change: background-color;
    z-index: 20;
  }

  .replace-tokens-button-container > button:hover {
    background: var(--wui-color-gray-glass-005);
  }

  .details-container > cross-wui-flex {
    background: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xxs);
    width: 100%;
  }

  .details-container > wui-flex > button {
    border: none;
    background: none;
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);
    transition: background 0.2s linear;
  }

  .details-container > wui-flex > button:hover {
    background: var(--wui-color-gray-glass-002);
  }

  .details-content-container {
    padding: var(--wui-spacing-1xs);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .details-content-container > cross-wui-flex {
    width: 100%;
  }

  .details-row {
    width: 100%;
    padding: var(--wui-spacing-s) var(--wui-spacing-xl);
    border-radius: var(--wui-border-radius-xxs);
    background: var(--wui-color-gray-glass-002);
  }
`;
var __decorate$1e = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mSwapView = class W3mSwapView2 extends i$1 {
  constructor() {
    var _a3;
    super();
    this.unsubscribe = [];
    this.detailsOpen = false;
    this.caipNetworkId = (_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.caipNetworkId;
    this.initialized = SwapController.state.initialized;
    this.loadingQuote = SwapController.state.loadingQuote;
    this.loadingPrices = SwapController.state.loadingPrices;
    this.loadingTransaction = SwapController.state.loadingTransaction;
    this.sourceToken = SwapController.state.sourceToken;
    this.sourceTokenAmount = SwapController.state.sourceTokenAmount;
    this.sourceTokenPriceInUSD = SwapController.state.sourceTokenPriceInUSD;
    this.toToken = SwapController.state.toToken;
    this.toTokenAmount = SwapController.state.toTokenAmount;
    this.toTokenPriceInUSD = SwapController.state.toTokenPriceInUSD;
    this.inputError = SwapController.state.inputError;
    this.gasPriceInUSD = SwapController.state.gasPriceInUSD;
    this.fetchError = SwapController.state.fetchError;
    this.onDebouncedGetSwapCalldata = CoreHelperUtil.debounce(async () => {
      await SwapController.swapTokens();
    }, 200);
    ChainController.subscribeKey("activeCaipNetwork", (newCaipNetwork) => {
      if (this.caipNetworkId !== (newCaipNetwork == null ? void 0 : newCaipNetwork.caipNetworkId)) {
        this.caipNetworkId = newCaipNetwork == null ? void 0 : newCaipNetwork.caipNetworkId;
        SwapController.resetState();
        SwapController.initializeState();
      }
    });
    this.unsubscribe.push(...[
      ModalController.subscribeKey("open", (isOpen) => {
        if (!isOpen) {
          SwapController.resetState();
        }
      }),
      RouterController.subscribeKey("view", (newRoute) => {
        if (!newRoute.includes("Swap")) {
          SwapController.resetValues();
        }
      }),
      SwapController.subscribe((newState) => {
        this.initialized = newState.initialized;
        this.loadingQuote = newState.loadingQuote;
        this.loadingPrices = newState.loadingPrices;
        this.loadingTransaction = newState.loadingTransaction;
        this.sourceToken = newState.sourceToken;
        this.sourceTokenAmount = newState.sourceTokenAmount;
        this.sourceTokenPriceInUSD = newState.sourceTokenPriceInUSD;
        this.toToken = newState.toToken;
        this.toTokenAmount = newState.toTokenAmount;
        this.toTokenPriceInUSD = newState.toTokenPriceInUSD;
        this.inputError = newState.inputError;
        this.gasPriceInUSD = newState.gasPriceInUSD;
        this.fetchError = newState.fetchError;
      })
    ]);
  }
  firstUpdated() {
    SwapController.initializeState();
    this.watchTokensAndValues();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe == null ? void 0 : unsubscribe());
    clearInterval(this.interval);
  }
  render() {
    return x$3`
      <cross-wui-flex flexDirection="column" .padding=${["0", "l", "l", "l"]} gap="s">
        ${this.initialized ? this.templateSwap() : this.templateLoading()}
      </cross-wui-flex>
    `;
  }
  watchTokensAndValues() {
    this.interval = setInterval(() => {
      SwapController.getNetworkTokenPrice();
      SwapController.getMyTokensWithBalance();
      SwapController.swapTokens();
    }, 1e4);
  }
  templateSwap() {
    return x$3`
      <cross-wui-flex flexDirection="column" gap="s">
        <cross-wui-flex flexDirection="column" alignItems="center" gap="xs" class="swap-inputs-container">
          ${this.templateTokenInput("sourceToken", this.sourceToken)}
          ${this.templateTokenInput("toToken", this.toToken)} ${this.templateReplaceTokensButton()}
        </cross-wui-flex>
        ${this.templateDetails()} ${this.templateActionButton()}
      </cross-wui-flex>
    `;
  }
  actionButtonLabel() {
    if (this.fetchError) {
      return "Swap";
    }
    if (!this.sourceToken || !this.toToken) {
      return "Select token";
    }
    if (!this.sourceTokenAmount) {
      return "Enter amount";
    }
    if (this.inputError) {
      return this.inputError;
    }
    return "Review swap";
  }
  templateReplaceTokensButton() {
    return x$3`
      <cross-wui-flex class="replace-tokens-button-container">
        <button @click=${this.onSwitchTokens.bind(this)}>
          <cross-wui-icon name="recycleHorizontal" color="fg-250" size="lg"></cross-wui-icon>
        </button>
      </cross-wui-flex>
    `;
  }
  templateLoading() {
    return x$3`
      <cross-wui-flex flexDirection="column" gap="l">
        <cross-wui-flex flexDirection="column" alignItems="center" gap="xs" class="swap-inputs-container">
          <cross-w3m-swap-input-skeleton target="sourceToken"></cross-w3m-swap-input-skeleton>
          <cross-w3m-swap-input-skeleton target="toToken"></cross-w3m-swap-input-skeleton>
          ${this.templateReplaceTokensButton()}
        </cross-wui-flex>
        ${this.templateActionButton()}
      </cross-wui-flex>
    `;
  }
  templateTokenInput(target, token) {
    var _a3, _b2;
    const myToken = (_a3 = SwapController.state.myTokensWithBalance) == null ? void 0 : _a3.find((ct2) => (ct2 == null ? void 0 : ct2.address) === (token == null ? void 0 : token.address));
    const amount = target === "toToken" ? this.toTokenAmount : this.sourceTokenAmount;
    const price = target === "toToken" ? this.toTokenPriceInUSD : this.sourceTokenPriceInUSD;
    const marketValue = NumberUtil.parseLocalStringToNumber(amount) * price;
    return x$3`<cross-w3m-swap-input
      .value=${target === "toToken" ? this.toTokenAmount : this.sourceTokenAmount}
      .disabled=${target === "toToken"}
      .onSetAmount=${this.handleChangeAmount.bind(this)}
      target=${target}
      .token=${token}
      .balance=${(_b2 = myToken == null ? void 0 : myToken.quantity) == null ? void 0 : _b2.numeric}
      .price=${myToken == null ? void 0 : myToken.price}
      .marketValue=${marketValue}
      .onSetMaxValue=${this.onSetMaxValue.bind(this)}
    ></cross-w3m-swap-input>`;
  }
  onSetMaxValue(target, balance) {
    const token = target === "sourceToken" ? this.sourceToken : this.toToken;
    const isNetworkToken = (token == null ? void 0 : token.address) === ChainController.getActiveNetworkTokenAddress();
    let value = "0";
    if (!balance) {
      value = "0";
      this.handleChangeAmount(target, value);
      return;
    }
    if (!this.gasPriceInUSD) {
      value = balance;
      this.handleChangeAmount(target, value);
      return;
    }
    const amountOfTokenGasRequires = NumberUtil.bigNumber(this.gasPriceInUSD.toFixed(5)).div(this.sourceTokenPriceInUSD);
    const maxValue2 = isNetworkToken ? NumberUtil.bigNumber(balance).minus(amountOfTokenGasRequires) : NumberUtil.bigNumber(balance);
    this.handleChangeAmount(target, maxValue2.gt(0) ? maxValue2.toFixed(20) : "0");
  }
  templateDetails() {
    if (!this.sourceToken || !this.toToken || this.inputError) {
      return null;
    }
    return x$3`<cross-w3m-swap-details .detailsOpen=${this.detailsOpen}></cross-w3m-swap-details>`;
  }
  handleChangeAmount(target, value) {
    SwapController.clearError();
    if (target === "sourceToken") {
      SwapController.setSourceTokenAmount(value);
    } else {
      SwapController.setToTokenAmount(value);
    }
    this.onDebouncedGetSwapCalldata();
  }
  templateActionButton() {
    const haveNoTokenSelected = !this.toToken || !this.sourceToken;
    const haveNoAmount = !this.sourceTokenAmount;
    const loading = this.loadingQuote || this.loadingPrices || this.loadingTransaction;
    const disabled = loading || haveNoTokenSelected || haveNoAmount || this.inputError;
    return x$3` <cross-wui-flex gap="xs">
      <cross-wui-button
        data-testid="swap-action-button"
        class="action-button"
        fullWidth
        size="lg"
        borderRadius="xs"
        variant=${haveNoTokenSelected ? "neutral" : "main"}
        .loading=${loading}
        .disabled=${disabled}
        @click=${this.onSwapPreview.bind(this)}
      >
        ${this.actionButtonLabel()}
      </cross-wui-button>
    </cross-wui-flex>`;
  }
  onSwitchTokens() {
    SwapController.switchTokens();
  }
  onSwapPreview() {
    var _a3, _b2;
    if (this.fetchError) {
      SwapController.swapTokens();
      return;
    }
    EventsController.sendEvent({
      type: "track",
      event: "INITIATE_SWAP",
      properties: {
        network: this.caipNetworkId || "",
        swapFromToken: ((_a3 = this.sourceToken) == null ? void 0 : _a3.symbol) || "",
        swapToToken: ((_b2 = this.toToken) == null ? void 0 : _b2.symbol) || "",
        swapFromAmount: this.sourceTokenAmount || "",
        swapToAmount: this.toTokenAmount || "",
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
    RouterController.push("SwapPreview");
  }
};
W3mSwapView.styles = styles$Q;
__decorate$1e([
  r$1()
], W3mSwapView.prototype, "interval", void 0);
__decorate$1e([
  r$1()
], W3mSwapView.prototype, "detailsOpen", void 0);
__decorate$1e([
  r$1()
], W3mSwapView.prototype, "caipNetworkId", void 0);
__decorate$1e([
  r$1()
], W3mSwapView.prototype, "initialized", void 0);
__decorate$1e([
  r$1()
], W3mSwapView.prototype, "loadingQuote", void 0);
__decorate$1e([
  r$1()
], W3mSwapView.prototype, "loadingPrices", void 0);
__decorate$1e([
  r$1()
], W3mSwapView.prototype, "loadingTransaction", void 0);
__decorate$1e([
  r$1()
], W3mSwapView.prototype, "sourceToken", void 0);
__decorate$1e([
  r$1()
], W3mSwapView.prototype, "sourceTokenAmount", void 0);
__decorate$1e([
  r$1()
], W3mSwapView.prototype, "sourceTokenPriceInUSD", void 0);
__decorate$1e([
  r$1()
], W3mSwapView.prototype, "toToken", void 0);
__decorate$1e([
  r$1()
], W3mSwapView.prototype, "toTokenAmount", void 0);
__decorate$1e([
  r$1()
], W3mSwapView.prototype, "toTokenPriceInUSD", void 0);
__decorate$1e([
  r$1()
], W3mSwapView.prototype, "inputError", void 0);
__decorate$1e([
  r$1()
], W3mSwapView.prototype, "gasPriceInUSD", void 0);
__decorate$1e([
  r$1()
], W3mSwapView.prototype, "fetchError", void 0);
W3mSwapView = __decorate$1e([
  customElement("cross-w3m-swap-view")
], W3mSwapView);
const styles$P = i$4`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  cross-wui-loading-thumbnail {
    position: absolute;
  }

  cross-wui-visual {
    width: var(--wui-wallet-image-size-lg);
    height: var(--wui-wallet-image-size-lg);
    border-radius: calc(var(--wui-border-radius-5xs) * 9 - var(--wui-border-radius-xxs));
    position: relative;
    overflow: hidden;
  }

  wui-visual::after {
    content: '';
    display: block;
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
    border-radius: calc(var(--wui-border-radius-5xs) * 9 - var(--wui-border-radius-xxs));
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  cross-wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition:
      opacity var(--wui-ease-out-power-2) var(--wui-duration-lg),
      transform var(--wui-ease-out-power-2) var(--wui-duration-lg);
    will-change: opacity, transform;
  }

  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }

  [data-error='true'] cross-wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  [data-retry='false'] cross-wui-link {
    display: none;
  }

  [data-retry='true'] cross-wui-link {
    display: block;
    opacity: 1;
  }

  cross-wui-link {
    padding: var(--wui-spacing-4xs) var(--wui-spacing-xxs);
  }

  .capitalize {
    text-transform: capitalize;
  }
`;
var __decorate$1d = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mSwitchActiveChainView = class W3mSwitchActiveChainView2 extends i$1 {
  constructor() {
    var _a3, _b2, _c3, _d;
    super(...arguments);
    this.unsubscribe = [];
    this.switchToChain = (_a3 = RouterController.state.data) == null ? void 0 : _a3.switchToChain;
    this.navigateTo = (_b2 = RouterController.state.data) == null ? void 0 : _b2.navigateTo;
    this.navigateWithReplace = (_c3 = RouterController.state.data) == null ? void 0 : _c3.navigateWithReplace;
    this.caipNetwork = (_d = RouterController.state.data) == null ? void 0 : _d.network;
    this.activeChain = ChainController.state.activeChain;
  }
  firstUpdated() {
    this.unsubscribe.push(ChainController.subscribeKey("activeChain", (val) => this.activeChain = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const switchedChainNameString = this.switchToChain ? ConstantsUtil$4.CHAIN_NAME_MAP[this.switchToChain] : "supported";
    if (!this.switchToChain) {
      return null;
    }
    const nextChainName = this.switchToChain === "eip155" ? "Ethereum" : this.switchToChain;
    return x$3`
      <cross-wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <cross-wui-flex justifyContent="center" flexDirection="column" alignItems="center" gap="xl">
          <cross-wui-visual
            name=${this.switchToChain === "eip155" ? "eth" : this.switchToChain}
          ></cross-wui-visual>
          <cross-wui-text
            data-testid=${`w3m-switch-active-chain-to-${nextChainName}`}
            variant="paragraph-500"
            color="fg-100"
            align="center"
            >Switch to <span class="capitalize">${nextChainName}</span></wui-text
          >
          <cross-wui-text variant="small-400" color="fg-200" align="center">
            Connected wallet doesn't support connecting to ${switchedChainNameString} chain. You
            need to connect with a different wallet.
          </cross-wui-text>
          <cross-wui-button
            data-testid="cross-w3m-switch-active-chain-button"
            size="md"
            @click=${this.switchActiveChain.bind(this)}
            >Switch</wui-button
          >
        </cross-wui-flex>
      </cross-wui-flex>
    `;
  }
  async switchActiveChain() {
    if (!this.switchToChain) {
      return;
    }
    ChainController.setIsSwitchingNamespace(true);
    ConnectorController.setFilterByNamespace(this.switchToChain);
    if (this.caipNetwork) {
      await ChainController.switchActiveNetwork(this.caipNetwork);
    } else {
      ChainController.setActiveNamespace(this.switchToChain);
    }
    RouterController.reset("Connect");
  }
};
W3mSwitchActiveChainView.styles = styles$P;
__decorate$1d([
  n$3()
], W3mSwitchActiveChainView.prototype, "activeChain", void 0);
W3mSwitchActiveChainView = __decorate$1d([
  customElement("cross-w3m-switch-active-chain-view")
], W3mSwitchActiveChainView);
const styles$O = i$4`
  :host > wui-flex:first-child {
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }

  :host > wui-flex:first-child::-webkit-scrollbar {
    display: none;
  }

  .preview-container,
  .details-container {
    width: 100%;
  }

  .token-image {
    width: 24px;
    height: 24px;
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
    border-radius: 12px;
  }

  cross-wui-loading-hexagon {
    position: absolute;
  }

  .token-item {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--wui-spacing-xxs);
    padding: var(--wui-spacing-xs);
    height: 40px;
    border: none;
    border-radius: 80px;
    background: var(--wui-color-gray-glass-002);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    cursor: pointer;
    transition: background 0.2s linear;
  }

  .token-item:hover {
    background: var(--wui-color-gray-glass-005);
  }

  .preview-token-details-container {
    width: 100%;
  }

  .details-row {
    width: 100%;
    padding: var(--wui-spacing-s) var(--wui-spacing-xl);
    border-radius: var(--wui-border-radius-xxs);
    background: var(--wui-color-gray-glass-002);
  }

  .action-buttons-container {
    width: 100%;
    gap: var(--wui-spacing-xs);
  }

  .action-buttons-container > button {
    display: flex;
    align-items: center;
    justify-content: center;
    background: transparent;
    height: 48px;
    border-radius: var(--wui-border-radius-xs);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  .action-buttons-container > button:disabled {
    opacity: 0.8;
    cursor: not-allowed;
  }

  .action-button > cross-wui-loading-spinner {
    display: inline-block;
  }

  .cancel-button:hover,
  .action-button:hover {
    cursor: pointer;
  }

  .action-buttons-container > wui-button.cancel-button {
    flex: 2;
  }

  .action-buttons-container > wui-button.action-button {
    flex: 4;
  }

  .action-buttons-container > button.action-button > cross-wui-text {
    color: white;
  }

  .details-container > cross-wui-flex {
    background: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xxs);
    width: 100%;
  }

  .details-container > wui-flex > button {
    border: none;
    background: none;
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);
    transition: background 0.2s linear;
  }

  .details-container > wui-flex > button:hover {
    background: var(--wui-color-gray-glass-002);
  }

  .details-content-container {
    padding: var(--wui-spacing-1xs);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .details-content-container > cross-wui-flex {
    width: 100%;
  }

  .details-row {
    width: 100%;
    padding: var(--wui-spacing-s) var(--wui-spacing-xl);
    border-radius: var(--wui-border-radius-xxs);
    background: var(--wui-color-gray-glass-002);
  }
`;
var __decorate$1c = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mSwapPreviewView = class W3mSwapPreviewView2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.detailsOpen = true;
    this.approvalTransaction = SwapController.state.approvalTransaction;
    this.swapTransaction = SwapController.state.swapTransaction;
    this.sourceToken = SwapController.state.sourceToken;
    this.sourceTokenAmount = SwapController.state.sourceTokenAmount ?? "";
    this.sourceTokenPriceInUSD = SwapController.state.sourceTokenPriceInUSD;
    this.toToken = SwapController.state.toToken;
    this.toTokenAmount = SwapController.state.toTokenAmount ?? "";
    this.toTokenPriceInUSD = SwapController.state.toTokenPriceInUSD;
    this.caipNetwork = ChainController.state.activeCaipNetwork;
    this.balanceSymbol = AccountController.state.balanceSymbol;
    this.gasPriceInUSD = SwapController.state.gasPriceInUSD;
    this.inputError = SwapController.state.inputError;
    this.loadingQuote = SwapController.state.loadingQuote;
    this.loadingApprovalTransaction = SwapController.state.loadingApprovalTransaction;
    this.loadingBuildTransaction = SwapController.state.loadingBuildTransaction;
    this.loadingTransaction = SwapController.state.loadingTransaction;
    this.unsubscribe.push(...[
      AccountController.subscribeKey("balanceSymbol", (newBalanceSymbol) => {
        if (this.balanceSymbol !== newBalanceSymbol) {
          RouterController.goBack();
        }
      }),
      ChainController.subscribeKey("activeCaipNetwork", (newCaipNetwork) => {
        if (this.caipNetwork !== newCaipNetwork) {
          this.caipNetwork = newCaipNetwork;
        }
      }),
      SwapController.subscribe((newState) => {
        this.approvalTransaction = newState.approvalTransaction;
        this.swapTransaction = newState.swapTransaction;
        this.sourceToken = newState.sourceToken;
        this.gasPriceInUSD = newState.gasPriceInUSD;
        this.toToken = newState.toToken;
        this.gasPriceInUSD = newState.gasPriceInUSD;
        this.toTokenPriceInUSD = newState.toTokenPriceInUSD;
        this.sourceTokenAmount = newState.sourceTokenAmount ?? "";
        this.toTokenAmount = newState.toTokenAmount ?? "";
        this.inputError = newState.inputError;
        if (newState.inputError) {
          RouterController.goBack();
        }
        this.loadingQuote = newState.loadingQuote;
        this.loadingApprovalTransaction = newState.loadingApprovalTransaction;
        this.loadingBuildTransaction = newState.loadingBuildTransaction;
        this.loadingTransaction = newState.loadingTransaction;
      })
    ]);
  }
  firstUpdated() {
    SwapController.getTransaction();
    this.refreshTransaction();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe == null ? void 0 : unsubscribe());
    clearInterval(this.interval);
  }
  render() {
    return x$3`
      <cross-wui-flex flexDirection="column" .padding=${["0", "l", "l", "l"]} gap="s">
        ${this.templateSwap()}
      </cross-wui-flex>
    `;
  }
  refreshTransaction() {
    this.interval = setInterval(() => {
      if (!SwapController.getApprovalLoadingState()) {
        SwapController.getTransaction();
      }
    }, 1e4);
  }
  templateSwap() {
    var _a3, _b2, _c3, _d;
    const sourceTokenText = `${UiHelperUtil.formatNumberToLocalString(parseFloat(this.sourceTokenAmount))} ${(_a3 = this.sourceToken) == null ? void 0 : _a3.symbol}`;
    const toTokenText = `${UiHelperUtil.formatNumberToLocalString(parseFloat(this.toTokenAmount))} ${(_b2 = this.toToken) == null ? void 0 : _b2.symbol}`;
    const sourceTokenValue = parseFloat(this.sourceTokenAmount) * this.sourceTokenPriceInUSD;
    const toTokenValue = parseFloat(this.toTokenAmount) * this.toTokenPriceInUSD - (this.gasPriceInUSD || 0);
    const sentPrice = UiHelperUtil.formatNumberToLocalString(sourceTokenValue);
    const receivePrice = UiHelperUtil.formatNumberToLocalString(toTokenValue);
    const loading = this.loadingQuote || this.loadingBuildTransaction || this.loadingTransaction || this.loadingApprovalTransaction;
    return x$3`
      <cross-wui-flex flexDirection="column" alignItems="center" gap="l">
        <cross-wui-flex class="preview-container" flexDirection="column" alignItems="flex-start" gap="l">
          <cross-wui-flex
            class="preview-token-details-container"
            alignItems="center"
            justifyContent="space-between"
            gap="l"
          >
            <cross-wui-flex flexDirection="column" alignItems="flex-start" gap="4xs">
              <cross-wui-text variant="small-400" color="fg-150">Send</cross-wui-text>
              <cross-wui-text variant="paragraph-400" color="fg-100">$${sentPrice}</cross-wui-text>
            </cross-wui-flex>
            <cross-wui-token-button
              flexDirection="row-reverse"
              text=${sourceTokenText}
              imageSrc=${(_c3 = this.sourceToken) == null ? void 0 : _c3.logoUri}
            >
            </cross-wui-token-button>
          </cross-wui-flex>
          <cross-wui-icon name="recycleHorizontal" color="fg-200" size="md"></cross-wui-icon>
          <cross-wui-flex
            class="preview-token-details-container"
            alignItems="center"
            justifyContent="space-between"
            gap="l"
          >
            <cross-wui-flex flexDirection="column" alignItems="flex-start" gap="4xs">
              <cross-wui-text variant="small-400" color="fg-150">Receive</cross-wui-text>
              <cross-wui-text variant="paragraph-400" color="fg-100">$${receivePrice}</cross-wui-text>
            </cross-wui-flex>
            <cross-wui-token-button
              flexDirection="row-reverse"
              text=${toTokenText}
              imageSrc=${(_d = this.toToken) == null ? void 0 : _d.logoUri}
            >
            </cross-wui-token-button>
          </cross-wui-flex>
        </cross-wui-flex>

        ${this.templateDetails()}

        <cross-wui-flex flexDirection="row" alignItems="center" justifyContent="center" gap="xs">
          <cross-wui-icon size="sm" color="fg-200" name="infoCircle"></cross-wui-icon>
          <cross-wui-text variant="small-400" color="fg-200">Review transaction carefully</cross-wui-text>
        </cross-wui-flex>

        <cross-wui-flex
          class="action-buttons-container"
          flexDirection="row"
          alignItems="center"
          justifyContent="space-between"
          gap="xs"
        >
          <cross-wui-button
            class="cancel-button"
            fullWidth
            size="lg"
            borderRadius="xs"
            variant="neutral"
            @click=${this.onCancelTransaction.bind(this)}
          >
            <cross-wui-text variant="paragraph-600" color="fg-200">Cancel</cross-wui-text>
          </cross-wui-button>
          <cross-wui-button
            class="action-button"
            fullWidth
            size="lg"
            borderRadius="xs"
            variant="main"
            ?loading=${loading}
            ?disabled=${loading}
            @click=${this.onSendTransaction.bind(this)}
          >
            <cross-wui-text variant="paragraph-600" color="inverse-100">
              ${this.actionButtonLabel()}
            </cross-wui-text>
          </cross-wui-button>
        </cross-wui-flex>
      </cross-wui-flex>
    `;
  }
  templateDetails() {
    if (!this.sourceToken || !this.toToken || this.inputError) {
      return null;
    }
    return x$3`<cross-w3m-swap-details .detailsOpen=${this.detailsOpen}></cross-w3m-swap-details>`;
  }
  actionButtonLabel() {
    if (this.loadingApprovalTransaction) {
      return "Approving...";
    }
    if (this.approvalTransaction) {
      return "Approve";
    }
    return "Swap";
  }
  onCancelTransaction() {
    RouterController.goBack();
  }
  onSendTransaction() {
    if (this.approvalTransaction) {
      SwapController.sendTransactionForApproval(this.approvalTransaction);
    } else {
      SwapController.sendTransactionForSwap(this.swapTransaction);
    }
  }
};
W3mSwapPreviewView.styles = styles$O;
__decorate$1c([
  r$1()
], W3mSwapPreviewView.prototype, "interval", void 0);
__decorate$1c([
  r$1()
], W3mSwapPreviewView.prototype, "detailsOpen", void 0);
__decorate$1c([
  r$1()
], W3mSwapPreviewView.prototype, "approvalTransaction", void 0);
__decorate$1c([
  r$1()
], W3mSwapPreviewView.prototype, "swapTransaction", void 0);
__decorate$1c([
  r$1()
], W3mSwapPreviewView.prototype, "sourceToken", void 0);
__decorate$1c([
  r$1()
], W3mSwapPreviewView.prototype, "sourceTokenAmount", void 0);
__decorate$1c([
  r$1()
], W3mSwapPreviewView.prototype, "sourceTokenPriceInUSD", void 0);
__decorate$1c([
  r$1()
], W3mSwapPreviewView.prototype, "toToken", void 0);
__decorate$1c([
  r$1()
], W3mSwapPreviewView.prototype, "toTokenAmount", void 0);
__decorate$1c([
  r$1()
], W3mSwapPreviewView.prototype, "toTokenPriceInUSD", void 0);
__decorate$1c([
  r$1()
], W3mSwapPreviewView.prototype, "caipNetwork", void 0);
__decorate$1c([
  r$1()
], W3mSwapPreviewView.prototype, "balanceSymbol", void 0);
__decorate$1c([
  r$1()
], W3mSwapPreviewView.prototype, "gasPriceInUSD", void 0);
__decorate$1c([
  r$1()
], W3mSwapPreviewView.prototype, "inputError", void 0);
__decorate$1c([
  r$1()
], W3mSwapPreviewView.prototype, "loadingQuote", void 0);
__decorate$1c([
  r$1()
], W3mSwapPreviewView.prototype, "loadingApprovalTransaction", void 0);
__decorate$1c([
  r$1()
], W3mSwapPreviewView.prototype, "loadingBuildTransaction", void 0);
__decorate$1c([
  r$1()
], W3mSwapPreviewView.prototype, "loadingTransaction", void 0);
W3mSwapPreviewView = __decorate$1c([
  customElement("cross-w3m-swap-preview-view")
], W3mSwapPreviewView);
const styles$N = i$4`
  :host {
    --tokens-scroll--top-opacity: 0;
    --tokens-scroll--bottom-opacity: 1;
    --suggested-tokens-scroll--left-opacity: 0;
    --suggested-tokens-scroll--right-opacity: 1;
  }

  :host > wui-flex:first-child {
    overflow-y: hidden;
    overflow-x: hidden;
    scrollbar-width: none;
    scrollbar-height: none;
  }

  :host > wui-flex:first-child::-webkit-scrollbar {
    display: none;
  }

  cross-wui-loading-hexagon {
    position: absolute;
  }

  .suggested-tokens-container {
    overflow-x: auto;
    mask-image: linear-gradient(
      to right,
      rgba(0, 0, 0, calc(1 - var(--suggested-tokens-scroll--left-opacity))) 0px,
      rgba(200, 200, 200, calc(1 - var(--suggested-tokens-scroll--left-opacity))) 1px,
      black 50px,
      black 90px,
      black calc(100% - 90px),
      black calc(100% - 50px),
      rgba(155, 155, 155, calc(1 - var(--suggested-tokens-scroll--right-opacity))) calc(100% - 1px),
      rgba(0, 0, 0, calc(1 - var(--suggested-tokens-scroll--right-opacity))) 100%
    );
  }

  .suggested-tokens-container::-webkit-scrollbar {
    display: none;
  }

  .tokens-container {
    border-top: 1px solid var(--wui-color-gray-glass-005);
    height: 100%;
    max-height: 390px;
  }

  .tokens {
    width: 100%;
    overflow-y: auto;
    mask-image: linear-gradient(
      to bottom,
      rgba(0, 0, 0, calc(1 - var(--tokens-scroll--top-opacity))) 0px,
      rgba(200, 200, 200, calc(1 - var(--tokens-scroll--top-opacity))) 1px,
      black 50px,
      black 90px,
      black calc(100% - 90px),
      black calc(100% - 50px),
      rgba(155, 155, 155, calc(1 - var(--tokens-scroll--bottom-opacity))) calc(100% - 1px),
      rgba(0, 0, 0, calc(1 - var(--tokens-scroll--bottom-opacity))) 100%
    );
  }

  .network-search-input,
  .select-network-button {
    height: 40px;
  }

  .select-network-button {
    border: none;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    gap: var(--wui-spacing-xs);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
    background-color: transparent;
    border-radius: var(--wui-border-radius-xxs);
    padding: var(--wui-spacing-xs);
    align-items: center;
    transition: background-color 0.2s linear;
  }

  .select-network-button:hover {
    background-color: var(--wui-color-gray-glass-002);
  }

  .select-network-button > cross-wui-image {
    width: 26px;
    height: 26px;
    border-radius: var(--wui-border-radius-xs);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }
`;
var __decorate$1b = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mSwapSelectTokenView = class W3mSwapSelectTokenView2 extends i$1 {
  constructor() {
    var _a3;
    super();
    this.unsubscribe = [];
    this.targetToken = (_a3 = RouterController.state.data) == null ? void 0 : _a3.target;
    this.sourceToken = SwapController.state.sourceToken;
    this.sourceTokenAmount = SwapController.state.sourceTokenAmount;
    this.toToken = SwapController.state.toToken;
    this.myTokensWithBalance = SwapController.state.myTokensWithBalance;
    this.popularTokens = SwapController.state.popularTokens;
    this.searchValue = "";
    this.unsubscribe.push(...[
      SwapController.subscribe((newState) => {
        this.sourceToken = newState.sourceToken;
        this.toToken = newState.toToken;
        this.myTokensWithBalance = newState.myTokensWithBalance;
      })
    ]);
  }
  updated() {
    var _a3, _b2;
    const suggestedTokensContainer = (_a3 = this.renderRoot) == null ? void 0 : _a3.querySelector(".suggested-tokens-container");
    suggestedTokensContainer == null ? void 0 : suggestedTokensContainer.addEventListener("scroll", this.handleSuggestedTokensScroll.bind(this));
    const tokensList = (_b2 = this.renderRoot) == null ? void 0 : _b2.querySelector(".tokens");
    tokensList == null ? void 0 : tokensList.addEventListener("scroll", this.handleTokenListScroll.bind(this));
  }
  disconnectedCallback() {
    var _a3, _b2;
    super.disconnectedCallback();
    const suggestedTokensContainer = (_a3 = this.renderRoot) == null ? void 0 : _a3.querySelector(".suggested-tokens-container");
    const tokensList = (_b2 = this.renderRoot) == null ? void 0 : _b2.querySelector(".tokens");
    suggestedTokensContainer == null ? void 0 : suggestedTokensContainer.removeEventListener("scroll", this.handleSuggestedTokensScroll.bind(this));
    tokensList == null ? void 0 : tokensList.removeEventListener("scroll", this.handleTokenListScroll.bind(this));
    clearInterval(this.interval);
  }
  render() {
    return x$3`
      <cross-wui-flex flexDirection="column" gap="s">
        ${this.templateSearchInput()} ${this.templateSuggestedTokens()} ${this.templateTokens()}
      </cross-wui-flex>
    `;
  }
  onSelectToken(token) {
    if (this.targetToken === "sourceToken") {
      SwapController.setSourceToken(token);
    } else {
      SwapController.setToToken(token);
      if (this.sourceToken && this.sourceTokenAmount) {
        SwapController.swapTokens();
      }
    }
    RouterController.goBack();
  }
  templateSearchInput() {
    return x$3`
      <cross-wui-flex .padding=${["3xs", "s", "0", "s"]} gap="xs">
        <cross-wui-input-text
          data-testid="swap-select-token-search-input"
          class="network-search-input"
          size="sm"
          placeholder="Search token"
          icon="search"
          .value=${this.searchValue}
          @inputChange=${this.onSearchInputChange.bind(this)}
        ></cross-wui-input-text>
      </cross-wui-flex>
    `;
  }
  templateTokens() {
    const yourTokens = this.myTokensWithBalance ? Object.values(this.myTokensWithBalance) : [];
    const tokens = this.popularTokens ? this.popularTokens : [];
    const filteredYourTokens = this.filterTokensWithText(yourTokens, this.searchValue);
    const filteredTokens = this.filterTokensWithText(tokens, this.searchValue);
    return x$3`
      <cross-wui-flex class="tokens-container">
        <cross-wui-flex class="tokens" .padding=${["0", "s", "s", "s"]} flexDirection="column">
          ${(filteredYourTokens == null ? void 0 : filteredYourTokens.length) > 0 ? x$3`
                <cross-wui-flex justifyContent="flex-start" padding="s">
                  <cross-wui-text variant="paragraph-500" color="fg-200">Your tokens</cross-wui-text>
                </cross-wui-flex>
                ${filteredYourTokens.map((token) => {
      var _a3, _b2, _c3;
      const selected = token.symbol === ((_a3 = this.sourceToken) == null ? void 0 : _a3.symbol) || token.symbol === ((_b2 = this.toToken) == null ? void 0 : _b2.symbol);
      return x$3`
                    <cross-wui-token-list-item
                      data-testid="swap-select-token-item-${token.symbol}"
                      name=${token.name}
                      ?disabled=${selected}
                      symbol=${token.symbol}
                      price=${token == null ? void 0 : token.price}
                      amount=${(_c3 = token == null ? void 0 : token.quantity) == null ? void 0 : _c3.numeric}
                      imageSrc=${token.logoUri}
                      @click=${() => {
        if (!selected) {
          this.onSelectToken(token);
        }
      }}
                    >
                    </cross-wui-token-list-item>
                  `;
    })}
              ` : null}

          <cross-wui-flex justifyContent="flex-start" padding="s">
            <cross-wui-text variant="paragraph-500" color="fg-200">Tokens</cross-wui-text>
          </cross-wui-flex>
          ${(filteredTokens == null ? void 0 : filteredTokens.length) > 0 ? filteredTokens.map((token) => x$3`
                  <cross-wui-token-list-item
                    data-testid="swap-select-token-item-${token.symbol}"
                    name=${token.name}
                    symbol=${token.symbol}
                    imageSrc=${token.logoUri}
                    @click=${() => this.onSelectToken(token)}
                  >
                  </cross-wui-token-list-item>
                `) : null}
        </cross-wui-flex>
      </cross-wui-flex>
    `;
  }
  templateSuggestedTokens() {
    const tokens = SwapController.state.suggestedTokens ? SwapController.state.suggestedTokens.slice(0, 8) : null;
    if (!tokens) {
      return null;
    }
    return x$3`
      <cross-wui-flex class="suggested-tokens-container" .padding=${["0", "s", "0", "s"]} gap="xs">
        ${tokens.map((token) => x$3`
            <cross-wui-token-button
              text=${token.symbol}
              imageSrc=${token.logoUri}
              @click=${() => this.onSelectToken(token)}
            >
            </cross-wui-token-button>
          `)}
      </cross-wui-flex>
    `;
  }
  onSearchInputChange(event) {
    this.searchValue = event.detail;
  }
  handleSuggestedTokensScroll() {
    var _a3;
    const container = (_a3 = this.renderRoot) == null ? void 0 : _a3.querySelector(".suggested-tokens-container");
    if (!container) {
      return;
    }
    container.style.setProperty("--suggested-tokens-scroll--left-opacity", MathUtil.interpolate([0, 100], [0, 1], container.scrollLeft).toString());
    container.style.setProperty("--suggested-tokens-scroll--right-opacity", MathUtil.interpolate([0, 100], [0, 1], container.scrollWidth - container.scrollLeft - container.offsetWidth).toString());
  }
  handleTokenListScroll() {
    var _a3;
    const container = (_a3 = this.renderRoot) == null ? void 0 : _a3.querySelector(".tokens");
    if (!container) {
      return;
    }
    container.style.setProperty("--tokens-scroll--top-opacity", MathUtil.interpolate([0, 100], [0, 1], container.scrollTop).toString());
    container.style.setProperty("--tokens-scroll--bottom-opacity", MathUtil.interpolate([0, 100], [0, 1], container.scrollHeight - container.scrollTop - container.offsetHeight).toString());
  }
  filterTokensWithText(tokens, text) {
    return tokens.filter((token) => `${token.symbol} ${token.name} ${token.address}`.toLowerCase().includes(text.toLowerCase()));
  }
};
W3mSwapSelectTokenView.styles = styles$N;
__decorate$1b([
  r$1()
], W3mSwapSelectTokenView.prototype, "interval", void 0);
__decorate$1b([
  r$1()
], W3mSwapSelectTokenView.prototype, "targetToken", void 0);
__decorate$1b([
  r$1()
], W3mSwapSelectTokenView.prototype, "sourceToken", void 0);
__decorate$1b([
  r$1()
], W3mSwapSelectTokenView.prototype, "sourceTokenAmount", void 0);
__decorate$1b([
  r$1()
], W3mSwapSelectTokenView.prototype, "toToken", void 0);
__decorate$1b([
  r$1()
], W3mSwapSelectTokenView.prototype, "myTokensWithBalance", void 0);
__decorate$1b([
  r$1()
], W3mSwapSelectTokenView.prototype, "popularTokens", void 0);
__decorate$1b([
  r$1()
], W3mSwapSelectTokenView.prototype, "searchValue", void 0);
W3mSwapSelectTokenView = __decorate$1b([
  customElement("cross-w3m-swap-select-token-view")
], W3mSwapSelectTokenView);
const styles$M = i$4`
  :host > wui-flex:first-child {
    height: 500px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }

  :host > wui-flex:first-child::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$1a = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mTransactionsView = class W3mTransactionsView2 extends i$1 {
  render() {
    return x$3`
      <cross-wui-flex flexDirection="column" .padding=${["0", "m", "m", "m"]} gap="s">
        <cross-w3m-activity-list page="activity"></cross-w3m-activity-list>
      </cross-wui-flex>
    `;
  }
};
W3mTransactionsView.styles = styles$M;
W3mTransactionsView = __decorate$1a([
  customElement("cross-w3m-transactions-view")
], W3mTransactionsView);
var __decorate$19 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
const data$1 = [
  {
    images: ["network", "layers", "system"],
    title: "The systems nuts and bolts",
    text: "A network is what brings the blockchain to life, as this technical infrastructure allows apps to access the ledger and smart contract services."
  },
  {
    images: ["noun", "defiAlt", "dao"],
    title: "Designed for different uses",
    text: "Each network is designed differently, and may therefore suit certain apps and experiences."
  }
];
let W3mWhatIsANetworkView = class W3mWhatIsANetworkView2 extends i$1 {
  render() {
    return x$3`
      <cross-wui-flex
        flexDirection="column"
        .padding=${["xxl", "xl", "xl", "xl"]}
        alignItems="center"
        gap="xl"
      >
        <cross-w3m-help-widget .data=${data$1}></cross-w3m-help-widget>
        <cross-wui-button
          variant="main"
          size="md"
          @click=${() => {
      CoreHelperUtil.openHref("https://ethereum.org/en/developers/docs/networks/", "_blank");
    }}
        >
          Learn more
          <cross-wui-icon color="inherit" slot="iconRight" name="externalLink"></cross-wui-icon>
        </cross-wui-button>
      </cross-wui-flex>
    `;
  }
};
W3mWhatIsANetworkView = __decorate$19([
  customElement("cross-w3m-what-is-a-network-view")
], W3mWhatIsANetworkView);
var __decorate$18 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
const data = [
  {
    images: ["login", "profile", "lock"],
    title: "One login for all of web3",
    text: "Log in to any app by connecting your wallet. Say goodbye to countless passwords!"
  },
  {
    images: ["defi", "nft", "eth"],
    title: "A home for your digital assets",
    text: "A wallet lets you store, send and receive digital assets like cryptocurrencies and NFTs."
  },
  {
    images: ["browser", "noun", "dao"],
    title: "Your gateway to a new web",
    text: "With your wallet, you can explore and interact with DeFi, NFTs, DAOs, and much more."
  }
];
let W3mWhatIsAWalletView = class W3mWhatIsAWalletView2 extends i$1 {
  render() {
    return x$3`
      <cross-wui-flex
        flexDirection="column"
        .padding=${["xxl", "xl", "xl", "xl"]}
        alignItems="center"
        gap="xl"
      >
        <cross-w3m-help-widget .data=${data}></cross-w3m-help-widget>
        <cross-wui-button variant="main" size="md" @click=${this.onGetWallet.bind(this)}>
          <cross-wui-icon color="inherit" slot="iconLeft" name="wallet"></cross-wui-icon>
          Get a wallet
        </cross-wui-button>
      </cross-wui-flex>
    `;
  }
  onGetWallet() {
    EventsController.sendEvent({ type: "track", event: "CLICK_GET_WALLET" });
    RouterController.push("GetWallet");
  }
};
W3mWhatIsAWalletView = __decorate$18([
  customElement("cross-w3m-what-is-a-wallet-view")
], W3mWhatIsAWalletView);
var __decorate$17 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mWhatIsABuyView = class W3mWhatIsABuyView2 extends i$1 {
  render() {
    return x$3`
      <cross-wui-flex
        flexDirection="column"
        .padding=${["xxl", "3xl", "xl", "3xl"]}
        alignItems="center"
        gap="xl"
      >
        <cross-wui-visual name="onrampCard"></cross-wui-visual>
        <cross-wui-flex flexDirection="column" gap="xs" alignItems="center">
          <cross-wui-text align="center" variant="paragraph-500" color="fg-100">
            Quickly and easily buy digital assets!
          </cross-wui-text>
          <cross-wui-text align="center" variant="small-400" color="fg-200">
            Simply select your preferred onramp provider and add digital assets to your account
            using your credit card or bank transfer
          </cross-wui-text>
        </cross-wui-flex>
        <cross-wui-button @click=${RouterController.goBack}>
          <cross-wui-icon size="sm" color="inherit" name="add" slot="iconLeft"></cross-wui-icon>
          Buy
        </cross-wui-button>
      </cross-wui-flex>
    `;
  }
};
W3mWhatIsABuyView = __decorate$17([
  customElement("cross-w3m-what-is-a-buy-view")
], W3mWhatIsABuyView);
const styles$L = i$4`
  cross-wui-loading-spinner {
    margin: 9px auto;
  }

  .email-display,
  .email-display cross-wui-text {
    max-width: 100%;
  }
`;
var __decorate$16 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
const OTP_LENGTH = 6;
let W3mEmailOtpWidget = class W3mEmailOtpWidget2 extends i$1 {
  firstUpdated() {
    this.startOTPTimeout();
  }
  disconnectedCallback() {
    clearTimeout(this.OTPTimeout);
  }
  constructor() {
    var _a3;
    super();
    this.loading = false;
    this.timeoutTimeLeft = W3mFrameHelpers.getTimeToNextEmailLogin();
    this.error = "";
    this.otp = "";
    this.email = (_a3 = RouterController.state.data) == null ? void 0 : _a3.email;
    this.authConnector = ConnectorController.getAuthConnector();
  }
  render() {
    if (!this.email) {
      throw new Error("cross-w3m-email-otp-widget: No email provided");
    }
    const isResendDisabled = Boolean(this.timeoutTimeLeft);
    const footerLabels = this.getFooterLabels(isResendDisabled);
    return x$3`
      <cross-wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["l", "0", "l", "0"]}
        gap="l"
      >
        <cross-wui-flex
          class="email-display"
          flexDirection="column"
          alignItems="center"
          .padding=${["0", "xl", "0", "xl"]}
        >
          <cross-wui-text variant="paragraph-400" color="fg-100" align="center">
            Enter the code we sent to
          </cross-wui-text>
          <cross-wui-text variant="paragraph-500" color="fg-100" lineClamp="1" align="center">
            ${this.email}
          </cross-wui-text>
        </cross-wui-flex>

        <cross-wui-text variant="small-400" color="fg-200">The code expires in 20 minutes</cross-wui-text>

        ${this.loading ? x$3`<cross-wui-loading-spinner size="xl" color="accent-100"></cross-wui-loading-spinner>` : x$3` <cross-wui-flex flexDirection="column" alignItems="center" gap="xs">
              <cross-wui-otp
                dissabled
                length="6"
                @inputChange=${this.onOtpInputChange.bind(this)}
                .otp=${this.otp}
              ></cross-wui-otp>
              ${this.error ? x$3`
                    <cross-wui-text variant="small-400" align="center" color="error-100">
                      ${this.error}. Try Again
                    </cross-wui-text>
                  ` : null}
            </cross-wui-flex>`}

        <cross-wui-flex alignItems="center" gap="xs">
          <cross-wui-text variant="small-400" color="fg-200">${footerLabels.title}</cross-wui-text>
          <cross-wui-link @click=${this.onResendCode.bind(this)} .disabled=${isResendDisabled}>
            ${footerLabels.action}
          </cross-wui-link>
        </cross-wui-flex>
      </cross-wui-flex>
    `;
  }
  startOTPTimeout() {
    this.timeoutTimeLeft = W3mFrameHelpers.getTimeToNextEmailLogin();
    this.OTPTimeout = setInterval(() => {
      if (this.timeoutTimeLeft > 0) {
        this.timeoutTimeLeft = W3mFrameHelpers.getTimeToNextEmailLogin();
      } else {
        clearInterval(this.OTPTimeout);
      }
    }, 1e3);
  }
  async onOtpInputChange(event) {
    var _a3;
    try {
      if (!this.loading) {
        this.otp = event.detail;
        if (this.authConnector && this.otp.length === OTP_LENGTH) {
          this.loading = true;
          await ((_a3 = this.onOtpSubmit) == null ? void 0 : _a3.call(this, this.otp));
        }
      }
    } catch (error) {
      this.error = CoreHelperUtil.parseError(error);
      this.loading = false;
    }
  }
  async onResendCode() {
    try {
      if (this.onOtpResend) {
        if (!this.loading && !this.timeoutTimeLeft) {
          this.error = "";
          this.otp = "";
          const authConnector = ConnectorController.getAuthConnector();
          if (!authConnector || !this.email) {
            throw new Error("cross-w3m-email-otp-widget: Unable to resend email");
          }
          this.loading = true;
          await this.onOtpResend(this.email);
          this.startOTPTimeout();
          SnackController.showSuccess("Code email resent");
        }
      } else if (this.onStartOver) {
        this.onStartOver();
      }
    } catch (error) {
      SnackController.showError(error);
    } finally {
      this.loading = false;
    }
  }
  getFooterLabels(isResendDisabled) {
    if (this.onStartOver) {
      return {
        title: "Something wrong?",
        action: `Try again ${isResendDisabled ? `in ${this.timeoutTimeLeft}s` : ""}`
      };
    }
    return {
      title: `Didn't receive it?`,
      action: `Resend ${isResendDisabled ? `in ${this.timeoutTimeLeft}s` : "Code"}`
    };
  }
};
W3mEmailOtpWidget.styles = styles$L;
__decorate$16([
  r$1()
], W3mEmailOtpWidget.prototype, "loading", void 0);
__decorate$16([
  r$1()
], W3mEmailOtpWidget.prototype, "timeoutTimeLeft", void 0);
__decorate$16([
  r$1()
], W3mEmailOtpWidget.prototype, "error", void 0);
W3mEmailOtpWidget = __decorate$16([
  customElement("cross-w3m-email-otp-widget")
], W3mEmailOtpWidget);
var __decorate$15 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mEmailVerifyOtpView = class W3mEmailVerifyOtpView2 extends W3mEmailOtpWidget {
  constructor() {
    super(...arguments);
    this.onOtpSubmit = async (otp) => {
      try {
        if (this.authConnector) {
          await this.authConnector.provider.connectOtp({ otp });
          EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_PASS" });
          if (ChainController.state.activeChain) {
            await ConnectionController.connectExternal(this.authConnector, ChainController.state.activeChain);
          } else {
            throw new Error("Active chain is not set on ChainControll");
          }
          EventsController.sendEvent({
            type: "track",
            event: "CONNECT_SUCCESS",
            properties: { method: "email", name: this.authConnector.name || "Unknown" }
          });
          if (!OptionsController.state.siwx) {
            ModalController.close();
          }
        }
      } catch (error) {
        EventsController.sendEvent({
          type: "track",
          event: "EMAIL_VERIFICATION_CODE_FAIL",
          properties: { message: CoreHelperUtil.parseError(error) }
        });
        throw error;
      }
    };
    this.onOtpResend = async (email) => {
      if (this.authConnector) {
        await this.authConnector.provider.connectEmail({ email });
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_SENT" });
      }
    };
  }
};
W3mEmailVerifyOtpView = __decorate$15([
  customElement("cross-w3m-email-verify-otp-view")
], W3mEmailVerifyOtpView);
const styles$K = i$4`
  cross-wui-icon-box {
    height: var(--wui-icon-box-size-xl);
    width: var(--wui-icon-box-size-xl);
  }
`;
var __decorate$14 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mEmailVerifyDeviceView = class W3mEmailVerifyDeviceView2 extends i$1 {
  constructor() {
    var _a3;
    super();
    this.email = (_a3 = RouterController.state.data) == null ? void 0 : _a3.email;
    this.authConnector = ConnectorController.getAuthConnector();
    this.loading = false;
    this.listenForDeviceApproval();
  }
  render() {
    if (!this.email) {
      throw new Error("cross-w3m-email-verify-device-view: No email provided");
    }
    if (!this.authConnector) {
      throw new Error("cross-w3m-email-verify-device-view: No auth connector provided");
    }
    return x$3`
      <cross-wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["xxl", "s", "xxl", "s"]}
        gap="l"
      >
        <cross-wui-icon-box
          size="xl"
          iconcolor="accent-100"
          backgroundcolor="accent-100"
          icon="verify"
          background="opaque"
        ></cross-wui-icon-box>

        <cross-wui-flex flexDirection="column" alignItems="center" gap="s">
          <cross-wui-flex flexDirection="column" alignItems="center">
            <cross-wui-text variant="paragraph-400" color="fg-100">
              Approve the login link we sent to
            </cross-wui-text>
            <cross-wui-text variant="paragraph-400" color="fg-100"><b>${this.email}</b></cross-wui-text>
          </cross-wui-flex>

          <cross-wui-text variant="small-400" color="fg-200" align="center">
            The code expires in 20 minutes
          </cross-wui-text>

          <cross-wui-flex alignItems="center" id="w3m-resend-section" gap="xs">
            <cross-wui-text variant="small-400" color="fg-100" align="center">
              Didn't receive it?
            </cross-wui-text>
            <cross-wui-link @click=${this.onResendCode.bind(this)} .disabled=${this.loading}>
              Resend email
            </cross-wui-link>
          </cross-wui-flex>
        </cross-wui-flex>
      </cross-wui-flex>
    `;
  }
  async listenForDeviceApproval() {
    if (this.authConnector) {
      try {
        await this.authConnector.provider.connectDevice();
        EventsController.sendEvent({ type: "track", event: "DEVICE_REGISTERED_FOR_EMAIL" });
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_SENT" });
        RouterController.replace("EmailVerifyOtp", { email: this.email });
      } catch (error) {
        RouterController.goBack();
      }
    }
  }
  async onResendCode() {
    try {
      if (!this.loading) {
        if (!this.authConnector || !this.email) {
          throw new Error("cross-w3m-email-login-widget: Unable to resend email");
        }
        this.loading = true;
        await this.authConnector.provider.connectEmail({ email: this.email });
        this.listenForDeviceApproval();
        SnackController.showSuccess("Code email resent");
      }
    } catch (error) {
      SnackController.showError(error);
    } finally {
      this.loading = false;
    }
  }
};
W3mEmailVerifyDeviceView.styles = styles$K;
__decorate$14([
  r$1()
], W3mEmailVerifyDeviceView.prototype, "loading", void 0);
W3mEmailVerifyDeviceView = __decorate$14([
  customElement("cross-w3m-email-verify-device-view")
], W3mEmailVerifyDeviceView);
const styles$J = i$4`
  div {
    width: 100%;
  }

  [data-ready='false'] {
    transform: scale(1.05);
  }

  @media (max-width: 430px) {
    [data-ready='false'] {
      transform: translateY(-50px);
    }
  }
`;
var __decorate$13 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
const PAGE_HEIGHT = 600;
const PAGE_WIDTH = 360;
const HEADER_HEIGHT = 64;
let W3mApproveTransactionView = class W3mApproveTransactionView2 extends i$1 {
  constructor() {
    super();
    this.bodyObserver = void 0;
    this.unsubscribe = [];
    this.iframe = document.getElementById("w3m-iframe");
    this.ready = false;
    this.unsubscribe.push(...[
      ModalController.subscribeKey("open", (isOpen) => {
        if (!isOpen) {
          this.onHideIframe();
          RouterController.popTransactionStack();
        }
      }),
      ModalController.subscribeKey("shake", (val) => {
        if (val) {
          this.iframe.style.animation = `w3m-shake 500ms var(--wui-ease-out-power-2)`;
        } else {
          this.iframe.style.animation = "none";
        }
      })
    ]);
  }
  disconnectedCallback() {
    var _a3;
    this.onHideIframe();
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    (_a3 = this.bodyObserver) == null ? void 0 : _a3.unobserve(window.document.body);
  }
  async firstUpdated() {
    var _a3;
    await this.syncTheme();
    this.iframe.style.display = "block";
    const container = (_a3 = this == null ? void 0 : this.renderRoot) == null ? void 0 : _a3.querySelector("div");
    this.bodyObserver = new ResizeObserver((entries) => {
      var _a4, _b2;
      const contentBoxSize = (_a4 = entries == null ? void 0 : entries[0]) == null ? void 0 : _a4.contentBoxSize;
      const width = (_b2 = contentBoxSize == null ? void 0 : contentBoxSize[0]) == null ? void 0 : _b2.inlineSize;
      this.iframe.style.height = `${PAGE_HEIGHT}px`;
      container.style.height = `${PAGE_HEIGHT}px`;
      if (width && width <= 430) {
        this.iframe.style.width = "100%";
        this.iframe.style.left = "0px";
        this.iframe.style.bottom = "0px";
        this.iframe.style.top = "unset";
      } else {
        this.iframe.style.width = `${PAGE_WIDTH}px`;
        this.iframe.style.left = `calc(50% - ${PAGE_WIDTH / 2}px)`;
        this.iframe.style.top = `calc(50% - ${PAGE_HEIGHT / 2}px + ${HEADER_HEIGHT / 2}px)`;
        this.iframe.style.bottom = "unset";
      }
      this.ready = true;
      this.onShowIframe();
    });
    this.bodyObserver.observe(window.document.body);
  }
  render() {
    return x$3`<div data-ready=${this.ready} id="w3m-frame-container"></div>`;
  }
  onShowIframe() {
    const isMobile = window.innerWidth <= 430;
    this.iframe.style.animation = isMobile ? "w3m-iframe-zoom-in-mobile 200ms var(--wui-ease-out-power-2)" : "w3m-iframe-zoom-in 200ms var(--wui-ease-out-power-2)";
  }
  onHideIframe() {
    this.iframe.style.display = "none";
    this.iframe.style.animation = "w3m-iframe-fade-out 200ms var(--wui-ease-out-power-2)";
  }
  async syncTheme() {
    const authConnector = ConnectorController.getAuthConnector();
    if (authConnector) {
      const themeMode = ThemeController.getSnapshot().themeMode;
      const themeVariables = ThemeController.getSnapshot().themeVariables;
      await authConnector.provider.syncTheme({
        themeVariables,
        w3mThemeVariables: getW3mThemeVariables(themeVariables, themeMode)
      });
    }
  }
};
W3mApproveTransactionView.styles = styles$J;
__decorate$13([
  r$1()
], W3mApproveTransactionView.prototype, "ready", void 0);
W3mApproveTransactionView = __decorate$13([
  customElement("cross-w3m-approve-transaction-view")
], W3mApproveTransactionView);
var __decorate$12 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mUpgradeWalletView = class W3mUpgradeWalletView2 extends i$1 {
  render() {
    return x$3`
      <cross-wui-flex flexDirection="column" alignItems="center" gap="xl" padding="xl">
        <cross-wui-text variant="paragraph-400" color="fg-100">Follow the instructions on</cross-wui-text>
        <cross-wui-chip
          icon="externalLink"
          variant="fill"
          href=${ConstantsUtil$3.SECURE_SITE_DASHBOARD}
          imageSrc=${ConstantsUtil$3.SECURE_SITE_FAVICON}
          data-testid="cross-w3m-secure-website-button"
        >
        </cross-wui-chip>
        <cross-wui-text variant="small-400" color="fg-200">
          You will have to reconnect for security reasons
        </cross-wui-text>
      </cross-wui-flex>
    `;
  }
};
W3mUpgradeWalletView = __decorate$12([
  customElement("cross-w3m-upgrade-wallet-view")
], W3mUpgradeWalletView);
const styles$I = i$4`
  cross-wui-email-input {
    width: 100%;
  }

  form {
    width: 100%;
    display: block;
    position: relative;
  }
`;
var __decorate$11 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mUpdateEmailWalletView = class W3mUpdateEmailWalletView2 extends i$1 {
  constructor() {
    var _a3;
    super(...arguments);
    this.formRef = e();
    this.initialEmail = ((_a3 = RouterController.state.data) == null ? void 0 : _a3.email) ?? "";
    this.email = "";
    this.loading = false;
  }
  firstUpdated() {
    var _a3;
    (_a3 = this.formRef.value) == null ? void 0 : _a3.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        this.onSubmitEmail(event);
      }
    });
  }
  render() {
    const showSubmit = !this.loading && this.email.length > 3 && this.email !== this.initialEmail;
    return x$3`
      <cross-wui-flex flexDirection="column" padding="m" gap="m">
        <form ${n$1(this.formRef)} @submit=${this.onSubmitEmail.bind(this)}>
          <cross-wui-email-input
            value=${this.initialEmail}
            .disabled=${this.loading}
            @inputChange=${this.onEmailInputChange.bind(this)}
          >
          </cross-wui-email-input>
          <input type="submit" hidden />
        </form>

        <cross-wui-flex gap="s">
          <cross-wui-button size="md" variant="neutral" fullWidth @click=${RouterController.goBack}>
            Cancel
          </cross-wui-button>

          <cross-wui-button
            size="md"
            variant="main"
            fullWidth
            @click=${this.onSubmitEmail.bind(this)}
            .disabled=${!showSubmit}
            .loading=${this.loading}
          >
            Save
          </cross-wui-button>
        </cross-wui-flex>
      </cross-wui-flex>
    `;
  }
  onEmailInputChange(event) {
    this.email = event.detail;
  }
  async onSubmitEmail(event) {
    try {
      if (this.loading) {
        return;
      }
      this.loading = true;
      event.preventDefault();
      const authConnector = ConnectorController.getAuthConnector();
      if (!authConnector) {
        throw new Error("w3m-update-email-wallet: Auth connector not found");
      }
      const response = await authConnector.provider.updateEmail({ email: this.email });
      EventsController.sendEvent({ type: "track", event: "EMAIL_EDIT" });
      if (response.action === "VERIFY_SECONDARY_OTP") {
        RouterController.push("UpdateEmailSecondaryOtp", {
          email: this.initialEmail,
          newEmail: this.email
        });
      } else {
        RouterController.push("UpdateEmailPrimaryOtp", {
          email: this.initialEmail,
          newEmail: this.email
        });
      }
    } catch (error) {
      SnackController.showError(error);
      this.loading = false;
    }
  }
};
W3mUpdateEmailWalletView.styles = styles$I;
__decorate$11([
  r$1()
], W3mUpdateEmailWalletView.prototype, "email", void 0);
__decorate$11([
  r$1()
], W3mUpdateEmailWalletView.prototype, "loading", void 0);
W3mUpdateEmailWalletView = __decorate$11([
  customElement("cross-w3m-update-email-wallet-view")
], W3mUpdateEmailWalletView);
var __decorate$10 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mUpdateEmailPrimaryOtpView = class W3mUpdateEmailPrimaryOtpView2 extends W3mEmailOtpWidget {
  constructor() {
    var _a3;
    super();
    this.email = (_a3 = RouterController.state.data) == null ? void 0 : _a3.email;
    this.onOtpSubmit = async (otp) => {
      try {
        if (this.authConnector) {
          await this.authConnector.provider.updateEmailPrimaryOtp({ otp });
          EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_PASS" });
          RouterController.replace("UpdateEmailSecondaryOtp", RouterController.state.data);
        }
      } catch (error) {
        EventsController.sendEvent({
          type: "track",
          event: "EMAIL_VERIFICATION_CODE_FAIL",
          properties: { message: CoreHelperUtil.parseError(error) }
        });
        throw error;
      }
    };
    this.onStartOver = () => {
      RouterController.replace("UpdateEmailWallet", RouterController.state.data);
    };
  }
};
W3mUpdateEmailPrimaryOtpView = __decorate$10([
  customElement("cross-w3m-update-email-primary-otp-view")
], W3mUpdateEmailPrimaryOtpView);
var __decorate$$ = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mUpdateEmailSecondaryOtpView = class W3mUpdateEmailSecondaryOtpView2 extends W3mEmailOtpWidget {
  constructor() {
    var _a3;
    super();
    this.email = (_a3 = RouterController.state.data) == null ? void 0 : _a3.newEmail;
    this.onOtpSubmit = async (otp) => {
      try {
        if (this.authConnector) {
          await this.authConnector.provider.updateEmailSecondaryOtp({ otp });
          EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_PASS" });
          RouterController.reset("Account");
        }
      } catch (error) {
        EventsController.sendEvent({
          type: "track",
          event: "EMAIL_VERIFICATION_CODE_FAIL",
          properties: { message: CoreHelperUtil.parseError(error) }
        });
        throw error;
      }
    };
    this.onStartOver = () => {
      RouterController.replace("UpdateEmailWallet", RouterController.state.data);
    };
  }
};
W3mUpdateEmailSecondaryOtpView = __decorate$$([
  customElement("cross-w3m-update-email-secondary-otp-view")
], W3mUpdateEmailSecondaryOtpView);
const styles$H = i$4`
  :host > cross-wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }

  :host > wui-flex::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$_ = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mUnsupportedChainView = class W3mUnsupportedChainView2 extends i$1 {
  constructor() {
    var _a3;
    super();
    this.swapUnsupportedChain = (_a3 = RouterController.state.data) == null ? void 0 : _a3.swapUnsupportedChain;
    this.unsubscribe = [];
    this.disconecting = false;
    this.unsubscribe.push(AssetController.subscribeNetworkImages(() => this.requestUpdate()));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x$3`
      <cross-wui-flex class="container" flexDirection="column" gap="0">
        <cross-wui-flex
          class="container"
          flexDirection="column"
          .padding=${["m", "xl", "xs", "xl"]}
          alignItems="center"
          gap="xl"
        >
          ${this.descriptionTemplate()}
        </cross-wui-flex>

        <cross-wui-flex flexDirection="column" padding="s" gap="xs">
          ${this.networksTemplate()}
        </cross-wui-flex>

        <cross-wui-separator text="or"></cross-wui-separator>
        <cross-wui-flex flexDirection="column" padding="s" gap="xs">
          <cross-wui-list-item
            variant="icon"
            iconVariant="overlay"
            icon="disconnect"
            ?chevron=${false}
            .loading=${this.disconecting}
            @click=${this.onDisconnect.bind(this)}
            data-testid="disconnect-button"
          >
            <cross-wui-text variant="paragraph-500" color="fg-200">Disconnect</cross-wui-text>
          </cross-wui-list-item>
        </cross-wui-flex>
      </cross-wui-flex>
    `;
  }
  descriptionTemplate() {
    if (this.swapUnsupportedChain) {
      return x$3`
        <cross-wui-text variant="small-400" color="fg-200" align="center">
          The swap feature doesnt support your current network. Switch to an available option to
          continue.
        </cross-wui-text>
      `;
    }
    return x$3`
      <cross-wui-text variant="small-400" color="fg-200" align="center">
        This app doesnt support your current network. Switch to an available option to continue.
      </cross-wui-text>
    `;
  }
  networksTemplate() {
    const requestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
    const approvedCaipNetworkIds = ChainController.getAllApprovedCaipNetworkIds();
    const sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedCaipNetworkIds, requestedCaipNetworks);
    const filteredNetworks = this.swapUnsupportedChain ? sortedNetworks.filter((network) => ConstantsUtil$3.SWAP_SUPPORTED_NETWORKS.includes(network.caipNetworkId)) : sortedNetworks;
    return filteredNetworks.map((network) => x$3`
        <cross-wui-list-network
          imageSrc=${o$2(AssetUtil.getNetworkImage(network))}
          name=${network.name ?? "Unknown"}
          @click=${() => this.onSwitchNetwork(network)}
        >
        </cross-wui-list-network>
      `);
  }
  async onDisconnect() {
    try {
      this.disconecting = true;
      await ConnectionController.disconnect();
      EventsController.sendEvent({
        type: "track",
        event: "DISCONNECT_SUCCESS"
      });
      ModalController.close();
    } catch {
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_ERROR" });
      SnackController.showError("Failed to disconnect");
    } finally {
      this.disconecting = false;
    }
  }
  async onSwitchNetwork(network) {
    const caipAddress = AccountController.state.caipAddress;
    const approvedCaipNetworkIds = ChainController.getAllApprovedCaipNetworkIds();
    const supportsAllNetworks = ChainController.getNetworkProp("supportsAllNetworks", network.chainNamespace);
    const routerData = RouterController.state.data;
    if (caipAddress) {
      if (approvedCaipNetworkIds == null ? void 0 : approvedCaipNetworkIds.includes(network.caipNetworkId)) {
        await ChainController.switchActiveNetwork(network);
      } else if (supportsAllNetworks) {
        RouterController.push("SwitchNetwork", { ...routerData, network });
      } else {
        RouterController.push("SwitchNetwork", { ...routerData, network });
      }
    } else if (!caipAddress) {
      ChainController.setActiveCaipNetwork(network);
      RouterController.push("Connect");
    }
  }
};
W3mUnsupportedChainView.styles = styles$H;
__decorate$_([
  r$1()
], W3mUnsupportedChainView.prototype, "disconecting", void 0);
W3mUnsupportedChainView = __decorate$_([
  customElement("cross-w3m-unsupported-chain-view")
], W3mUnsupportedChainView);
const styles$G = i$4`
  cross-wui-compatible-network {
    margin-top: var(--wui-spacing-l);
  }
`;
var __decorate$Z = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mWalletReceiveView = class W3mWalletReceiveView2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.address = AccountController.state.address;
    this.profileName = AccountController.state.profileName;
    this.network = ChainController.state.activeCaipNetwork;
    this.preferredAccountType = AccountController.state.preferredAccountType;
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.address) {
          this.address = val.address;
          this.profileName = val.profileName;
          this.preferredAccountType = val.preferredAccountType;
        } else {
          SnackController.showError("Account not found");
        }
      })
    ], ChainController.subscribeKey("activeCaipNetwork", (val) => {
      if (val == null ? void 0 : val.id) {
        this.network = val;
      }
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    if (!this.address) {
      throw new Error("cross-w3m-wallet-receive-view: No account provided");
    }
    const networkImage = AssetUtil.getNetworkImage(this.network);
    return x$3` <cross-wui-flex
      flexDirection="column"
      .padding=${["0", "l", "l", "l"]}
      alignItems="center"
    >
      <cross-wui-chip-button
        data-testid="receive-address-copy-button"
        @click=${this.onCopyClick.bind(this)}
        text=${UiHelperUtil.getTruncateString({
      string: this.profileName || this.address || "",
      charsStart: this.profileName ? 18 : 4,
      charsEnd: this.profileName ? 0 : 4,
      truncate: this.profileName ? "end" : "middle"
    })}
        icon="copy"
        size="sm"
        imageSrc=${networkImage ? networkImage : ""}
        variant="gray"
      ></cross-wui-chip-button>
      <cross-wui-flex
        flexDirection="column"
        .padding=${["l", "0", "0", "0"]}
        alignItems="center"
        gap="s"
      >
        <cross-wui-qr-code
          size=${232}
          theme=${ThemeController.state.themeMode}
          uri=${this.address}
          ?arenaClear=${true}
          color=${o$2(ThemeController.state.themeVariables["--w3m-qr-color"])}
          data-testid="wui-qr-code"
        ></cross-wui-qr-code>
        <cross-wui-text variant="paragraph-500" color="fg-100" align="center">
          Copy your address or scan this QR code
        </cross-wui-text>
      </cross-wui-flex>
      ${this.networkTemplate()}
    </cross-wui-flex>`;
  }
  networkTemplate() {
    var _a3;
    const requestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
    const isNetworkEnabledForSmartAccounts = ChainController.checkIfSmartAccountEnabled();
    const caipNetwork = ChainController.state.activeCaipNetwork;
    if (this.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT && isNetworkEnabledForSmartAccounts) {
      if (!caipNetwork) {
        return null;
      }
      return x$3`<cross-wui-compatible-network
        @click=${this.onReceiveClick.bind(this)}
        text="Only receive assets on this network"
        .networkImages=${[AssetUtil.getNetworkImage(caipNetwork) ?? ""]}
      ></cross-wui-compatible-network>`;
    }
    const slicedNetworks = (_a3 = requestedCaipNetworks == null ? void 0 : requestedCaipNetworks.filter((network) => {
      var _a4;
      return (_a4 = network == null ? void 0 : network.assets) == null ? void 0 : _a4.imageId;
    })) == null ? void 0 : _a3.slice(0, 5);
    const imagesArray = slicedNetworks.map(AssetUtil.getNetworkImage).filter(Boolean);
    return x$3`<cross-wui-compatible-network
      @click=${this.onReceiveClick.bind(this)}
      text="Only receive assets on these networks"
      .networkImages=${imagesArray}
    ></cross-wui-compatible-network>`;
  }
  onReceiveClick() {
    RouterController.push("WalletCompatibleNetworks");
  }
  onCopyClick() {
    try {
      if (this.address) {
        CoreHelperUtil.copyToClopboard(this.address);
        SnackController.showSuccess("Address copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
};
W3mWalletReceiveView.styles = styles$G;
__decorate$Z([
  r$1()
], W3mWalletReceiveView.prototype, "address", void 0);
__decorate$Z([
  r$1()
], W3mWalletReceiveView.prototype, "profileName", void 0);
__decorate$Z([
  r$1()
], W3mWalletReceiveView.prototype, "network", void 0);
__decorate$Z([
  r$1()
], W3mWalletReceiveView.prototype, "preferredAccountType", void 0);
W3mWalletReceiveView = __decorate$Z([
  customElement("cross-w3m-wallet-receive-view")
], W3mWalletReceiveView);
const styles$F = i$4`
  :host > cross-wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }

  :host > wui-flex::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$Y = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mWalletCompatibleNetworksView = class W3mWalletCompatibleNetworksView2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.preferredAccountType = AccountController.state.preferredAccountType;
    this.unsubscribe.push(AccountController.subscribeKey("preferredAccountType", (val) => {
      this.preferredAccountType = val;
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x$3` <cross-wui-flex
      flexDirection="column"
      .padding=${["xs", "s", "m", "s"]}
      gap="xs"
    >
      <cross-wui-banner
        icon="warningCircle"
        text="You can only receive assets on these networks"
      ></cross-wui-banner>
      ${this.networkTemplate()}
    </cross-wui-flex>`;
  }
  networkTemplate() {
    const requestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
    const approvedCaipNetworkIds = ChainController.getAllApprovedCaipNetworkIds();
    const caipNetwork = ChainController.state.activeCaipNetwork;
    const isNetworkEnabledForSmartAccounts = ChainController.checkIfSmartAccountEnabled();
    let sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedCaipNetworkIds, requestedCaipNetworks);
    if (isNetworkEnabledForSmartAccounts && this.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT) {
      if (!caipNetwork) {
        return null;
      }
      sortedNetworks = [caipNetwork];
    }
    return sortedNetworks.map((network) => x$3`
        <cross-wui-list-network
          imageSrc=${o$2(AssetUtil.getNetworkImage(network))}
          name=${network.name ?? "Unknown"}
          ?transparent=${true}
        >
        </cross-wui-list-network>
      `);
  }
};
W3mWalletCompatibleNetworksView.styles = styles$F;
__decorate$Y([
  r$1()
], W3mWalletCompatibleNetworksView.prototype, "preferredAccountType", void 0);
W3mWalletCompatibleNetworksView = __decorate$Y([
  customElement("cross-w3m-wallet-compatible-networks-view")
], W3mWalletCompatibleNetworksView);
const styles$E = i$4`
  :host {
    display: block;
  }

  cross-wui-flex {
    position: relative;
  }

  cross-wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xs) !important;
    border: 5px solid var(--wui-color-bg-125);
    background: var(--wui-color-bg-175);
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 3;
  }

  cross-wui-button {
    --local-border-radius: var(--wui-border-radius-xs) !important;
  }

  .inputContainer {
    height: fit-content;
  }
`;
var __decorate$X = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mWalletSendView = class W3mWalletSendView2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.token = SendController.state.token;
    this.sendTokenAmount = SendController.state.sendTokenAmount;
    this.receiverAddress = SendController.state.receiverAddress;
    this.receiverProfileName = SendController.state.receiverProfileName;
    this.loading = SendController.state.loading;
    this.gasPriceInUSD = SendController.state.gasPriceInUSD;
    this.gasPrice = SendController.state.gasPrice;
    this.message = "Preview Send";
    this.fetchNetworkPrice();
    this.fetchBalances();
    this.unsubscribe.push(...[
      SendController.subscribe((val) => {
        this.token = val.token;
        this.sendTokenAmount = val.sendTokenAmount;
        this.receiverAddress = val.receiverAddress;
        this.gasPriceInUSD = val.gasPriceInUSD;
        this.receiverProfileName = val.receiverProfileName;
        this.loading = val.loading;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    this.getMessage();
    return x$3` <cross-wui-flex flexDirection="column" .padding=${["0", "l", "l", "l"]}>
      <cross-wui-flex class="inputContainer" gap="xs" flexDirection="column">
        <cross-w3m-input-token
          .token=${this.token}
          .sendTokenAmount=${this.sendTokenAmount}
          .gasPriceInUSD=${this.gasPriceInUSD}
          .gasPrice=${this.gasPrice}
        ></cross-w3m-input-token>
        <cross-wui-icon-box
          size="inherit"
          backgroundColor="fg-300"
          iconSize="lg"
          iconColor="fg-250"
          background="opaque"
          icon="arrowBottom"
        ></cross-wui-icon-box>
        <cross-w3m-input-address
          .value=${this.receiverProfileName ? this.receiverProfileName : this.receiverAddress}
        ></cross-w3m-input-address>
      </cross-wui-flex>
      <cross-wui-flex .margin=${["l", "0", "0", "0"]}>
        <cross-wui-button
          @click=${this.onButtonClick.bind(this)}
          ?disabled=${!this.message.startsWith("Preview Send")}
          size="lg"
          variant="main"
          ?loading=${this.loading}
          fullWidth
        >
          ${this.message}
        </cross-wui-button>
      </cross-wui-flex>
    </cross-wui-flex>`;
  }
  async fetchBalances() {
    await SendController.fetchTokenBalance();
    SendController.fetchNetworkBalance();
  }
  async fetchNetworkPrice() {
    await SwapController.getNetworkTokenPrice();
    const gas = await SwapController.getInitialGasPrice();
    if ((gas == null ? void 0 : gas.gasPrice) && (gas == null ? void 0 : gas.gasPriceInUSD)) {
      SendController.setGasPrice(gas.gasPrice);
      SendController.setGasPriceInUsd(gas.gasPriceInUSD);
    }
  }
  onButtonClick() {
    RouterController.push("WalletSendPreview");
  }
  getMessage() {
    var _a3;
    this.message = "Preview Send";
    if (this.receiverAddress && !CoreHelperUtil.isAddress(this.receiverAddress, ChainController.state.activeChain)) {
      this.message = "Invalid Address";
    }
    if (!this.receiverAddress) {
      this.message = "Add Address";
    }
    if (SendController.hasInsufficientGasFunds()) {
      this.message = "Insufficient Gas Funds";
    }
    if (this.sendTokenAmount && this.token && this.sendTokenAmount > Number(this.token.quantity.numeric)) {
      this.message = "Insufficient Funds";
    }
    if (!this.sendTokenAmount) {
      this.message = "Add Amount";
    }
    if (this.sendTokenAmount && ((_a3 = this.token) == null ? void 0 : _a3.price)) {
      const value = this.sendTokenAmount * this.token.price;
      if (!value) {
        this.message = "Incorrect Value";
      }
    }
    if (!this.token) {
      this.message = "Select Token";
    }
  }
};
W3mWalletSendView.styles = styles$E;
__decorate$X([
  r$1()
], W3mWalletSendView.prototype, "token", void 0);
__decorate$X([
  r$1()
], W3mWalletSendView.prototype, "sendTokenAmount", void 0);
__decorate$X([
  r$1()
], W3mWalletSendView.prototype, "receiverAddress", void 0);
__decorate$X([
  r$1()
], W3mWalletSendView.prototype, "receiverProfileName", void 0);
__decorate$X([
  r$1()
], W3mWalletSendView.prototype, "loading", void 0);
__decorate$X([
  r$1()
], W3mWalletSendView.prototype, "gasPriceInUSD", void 0);
__decorate$X([
  r$1()
], W3mWalletSendView.prototype, "gasPrice", void 0);
__decorate$X([
  r$1()
], W3mWalletSendView.prototype, "message", void 0);
W3mWalletSendView = __decorate$X([
  customElement("cross-w3m-wallet-send-view")
], W3mWalletSendView);
const styles$D = i$4`
  .contentContainer {
    height: 440px;
    overflow: scroll;
    scrollbar-width: none;
  }

  .contentContainer::-webkit-scrollbar {
    display: none;
  }

  cross-wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xxs);
  }
`;
var __decorate$W = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mSendSelectTokenView = class W3mSendSelectTokenView2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tokenBalances = SendController.state.tokenBalances;
    this.search = "";
    this.onDebouncedSearch = CoreHelperUtil.debounce((value) => {
      this.search = value;
    });
    this.unsubscribe.push(...[
      SendController.subscribe((val) => {
        this.tokenBalances = val.tokenBalances;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x$3`
      <cross-wui-flex flexDirection="column">
        ${this.templateSearchInput()} <cross-wui-separator></cross-wui-separator> ${this.templateTokens()}
      </cross-wui-flex>
    `;
  }
  templateSearchInput() {
    return x$3`
      <cross-wui-flex gap="xs" padding="s">
        <cross-wui-input-text
          @inputChange=${this.onInputChange.bind(this)}
          class="network-search-input"
          size="sm"
          placeholder="Search token"
          icon="search"
        ></cross-wui-input-text>
      </cross-wui-flex>
    `;
  }
  templateTokens() {
    var _a3, _b2;
    this.tokens = (_a3 = this.tokenBalances) == null ? void 0 : _a3.filter((token) => {
      var _a4;
      return token.chainId === ((_a4 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a4.caipNetworkId);
    });
    if (this.search) {
      this.filteredTokens = (_b2 = this.tokenBalances) == null ? void 0 : _b2.filter((token) => token.name.toLowerCase().includes(this.search.toLowerCase()));
    } else {
      this.filteredTokens = this.tokens;
    }
    return x$3`
      <cross-wui-flex
        class="contentContainer"
        flexDirection="column"
        .padding=${["0", "s", "0", "s"]}
      >
        <cross-wui-flex justifyContent="flex-start" .padding=${["m", "s", "s", "s"]}>
          <cross-wui-text variant="paragraph-500" color="fg-200">Your tokens</cross-wui-text>
        </cross-wui-flex>
        <cross-wui-flex flexDirection="column" gap="xs">
          ${this.filteredTokens && this.filteredTokens.length > 0 ? this.filteredTokens.map((token) => x$3`<cross-wui-list-token
                    @click=${this.handleTokenClick.bind(this, token)}
                    ?clickable=${true}
                    tokenName=${token.name}
                    tokenImageUrl=${token.iconUrl}
                    tokenAmount=${token.quantity.numeric}
                    tokenValue=${token.value}
                    tokenCurrency=${token.symbol}
                  ></cross-wui-list-token>`) : x$3`<cross-wui-flex
                .padding=${["4xl", "0", "0", "0"]}
                alignItems="center"
                flexDirection="column"
                gap="l"
              >
                <cross-wui-icon-box
                  icon="coinPlaceholder"
                  size="inherit"
                  iconColor="fg-200"
                  backgroundColor="fg-200"
                  iconSize="lg"
                ></cross-wui-icon-box>
                <cross-wui-flex
                  class="textContent"
                  gap="xs"
                  flexDirection="column"
                  justifyContent="center"
                  flexDirection="column"
                >
                  <cross-wui-text variant="paragraph-500" align="center" color="fg-100"
                    >No tokens found</wui-text
                  >
                  <cross-wui-text variant="small-400" align="center" color="fg-200"
                    >Your tokens will appear here</wui-text
                  >
                </cross-wui-flex>
                <cross-wui-link @click=${this.onBuyClick.bind(this)}>Buy</cross-wui-link>
              </cross-wui-flex>`}
        </cross-wui-flex>
      </cross-wui-flex>
    `;
  }
  onBuyClick() {
    RouterController.push("OnRampProviders");
  }
  onInputChange(event) {
    this.onDebouncedSearch(event.detail);
  }
  handleTokenClick(token) {
    SendController.setToken(token);
    SendController.setTokenAmount(void 0);
    RouterController.goBack();
  }
};
W3mSendSelectTokenView.styles = styles$D;
__decorate$W([
  r$1()
], W3mSendSelectTokenView.prototype, "tokenBalances", void 0);
__decorate$W([
  r$1()
], W3mSendSelectTokenView.prototype, "tokens", void 0);
__decorate$W([
  r$1()
], W3mSendSelectTokenView.prototype, "filteredTokens", void 0);
__decorate$W([
  r$1()
], W3mSendSelectTokenView.prototype, "search", void 0);
W3mSendSelectTokenView = __decorate$W([
  customElement("cross-w3m-wallet-send-select-token-view")
], W3mSendSelectTokenView);
const styles$C = i$4`
  cross-wui-avatar,
  cross-wui-image {
    display: ruby;
    width: 32px;
    height: 32px;
    border-radius: var(--wui-border-radius-3xl);
  }

  .sendButton {
    width: 70%;
    --local-width: 100% !important;
    --local-border-radius: var(--wui-border-radius-xs) !important;
  }

  .cancelButton {
    width: 30%;
    --local-width: 100% !important;
    --local-border-radius: var(--wui-border-radius-xs) !important;
  }
`;
var __decorate$V = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mWalletSendPreviewView = class W3mWalletSendPreviewView2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.token = SendController.state.token;
    this.sendTokenAmount = SendController.state.sendTokenAmount;
    this.receiverAddress = SendController.state.receiverAddress;
    this.receiverProfileName = SendController.state.receiverProfileName;
    this.receiverProfileImageUrl = SendController.state.receiverProfileImageUrl;
    this.gasPriceInUSD = SendController.state.gasPriceInUSD;
    this.caipNetwork = ChainController.state.activeCaipNetwork;
    this.unsubscribe.push(...[
      SendController.subscribe((val) => {
        this.token = val.token;
        this.sendTokenAmount = val.sendTokenAmount;
        this.receiverAddress = val.receiverAddress;
        this.gasPriceInUSD = val.gasPriceInUSD;
        this.receiverProfileName = val.receiverProfileName;
        this.receiverProfileImageUrl = val.receiverProfileImageUrl;
      }),
      ChainController.subscribeKey("activeCaipNetwork", (val) => this.caipNetwork = val)
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a3, _b2;
    return x$3` <cross-wui-flex flexDirection="column" .padding=${["0", "l", "l", "l"]}>
      <cross-wui-flex gap="xs" flexDirection="column" .padding=${["0", "xs", "0", "xs"]}>
        <cross-wui-flex alignItems="center" justifyContent="space-between">
          <cross-wui-flex flexDirection="column" gap="4xs">
            <cross-wui-text variant="small-400" color="fg-150">Send</cross-wui-text>
            ${this.sendValueTemplate()}
          </cross-wui-flex>
          <cross-wui-preview-item
            text="${this.sendTokenAmount ? UiHelperUtil.roundNumber(this.sendTokenAmount, 6, 5) : "unknown"} ${(_a3 = this.token) == null ? void 0 : _a3.symbol}"
            .imageSrc=${(_b2 = this.token) == null ? void 0 : _b2.iconUrl}
          ></cross-wui-preview-item>
        </cross-wui-flex>
        <cross-wui-flex>
          <cross-wui-icon color="fg-200" size="md" name="arrowBottom"></cross-wui-icon>
        </cross-wui-flex>
        <cross-wui-flex alignItems="center" justifyContent="space-between">
          <cross-wui-text variant="small-400" color="fg-150">To</cross-wui-text>
          <cross-wui-preview-item
            text="${this.receiverProfileName ? UiHelperUtil.getTruncateString({
      string: this.receiverProfileName,
      charsStart: 20,
      charsEnd: 0,
      truncate: "end"
    }) : UiHelperUtil.getTruncateString({
      string: this.receiverAddress ? this.receiverAddress : "",
      charsStart: 4,
      charsEnd: 4,
      truncate: "middle"
    })}"
            address=${this.receiverAddress ?? ""}
            .imageSrc=${this.receiverProfileImageUrl ?? void 0}
            .isAddress=${true}
          ></cross-wui-preview-item>
        </cross-wui-flex>
      </cross-wui-flex>
      <cross-wui-flex flexDirection="column" .padding=${["xxl", "0", "0", "0"]}>
        <cross-w3m-wallet-send-details
          .caipNetwork=${this.caipNetwork}
          .receiverAddress=${this.receiverAddress}
          .networkFee=${this.gasPriceInUSD}
        ></cross-w3m-wallet-send-details>
        <cross-wui-flex justifyContent="center" gap="xxs" .padding=${["s", "0", "0", "0"]}>
          <cross-wui-icon size="sm" color="fg-200" name="warningCircle"></cross-wui-icon>
          <cross-wui-text variant="small-400" color="fg-200">Review transaction carefully</cross-wui-text>
        </cross-wui-flex>
        <cross-wui-flex justifyContent="center" gap="s" .padding=${["l", "0", "0", "0"]}>
          <cross-wui-button
            class="cancelButton"
            @click=${this.onCancelClick.bind(this)}
            size="lg"
            variant="neutral"
          >
            Cancel
          </cross-wui-button>
          <cross-wui-button
            class="sendButton"
            @click=${this.onSendClick.bind(this)}
            size="lg"
            variant="main"
          >
            Send
          </cross-wui-button>
        </cross-wui-flex>
      </cross-wui-flex></wui-flex
    >`;
  }
  sendValueTemplate() {
    if (this.token && this.sendTokenAmount) {
      const price = this.token.price;
      const totalValue = price * this.sendTokenAmount;
      return x$3`<cross-wui-text variant="paragraph-400" color="fg-100"
        >$${totalValue.toFixed(2)}</wui-text
      >`;
    }
    return null;
  }
  onSendClick() {
    SendController.sendToken();
  }
  onCancelClick() {
    RouterController.goBack();
  }
};
W3mWalletSendPreviewView.styles = styles$C;
__decorate$V([
  r$1()
], W3mWalletSendPreviewView.prototype, "token", void 0);
__decorate$V([
  r$1()
], W3mWalletSendPreviewView.prototype, "sendTokenAmount", void 0);
__decorate$V([
  r$1()
], W3mWalletSendPreviewView.prototype, "receiverAddress", void 0);
__decorate$V([
  r$1()
], W3mWalletSendPreviewView.prototype, "receiverProfileName", void 0);
__decorate$V([
  r$1()
], W3mWalletSendPreviewView.prototype, "receiverProfileImageUrl", void 0);
__decorate$V([
  r$1()
], W3mWalletSendPreviewView.prototype, "gasPriceInUSD", void 0);
__decorate$V([
  r$1()
], W3mWalletSendPreviewView.prototype, "caipNetwork", void 0);
W3mWalletSendPreviewView = __decorate$V([
  customElement("cross-w3m-wallet-send-preview-view")
], W3mWalletSendPreviewView);
const styles$B = i$4`
  cross-wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
  }
  wui-flex::-webkit-scrollbar {
    display: none;
  }
  wui-flex.disabled {
    opacity: 0.3;
    pointer-events: none;
    user-select: none;
  }
`;
var __decorate$U = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mConnectWalletsView = class W3mConnectWalletsView2 extends i$1 {
  constructor() {
    super(...arguments);
    this.checked = false;
  }
  render() {
    var _a3;
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    const legalCheckbox = (_a3 = OptionsController.state.features) == null ? void 0 : _a3.legalCheckbox;
    const legalUrl = termsConditionsUrl || privacyPolicyUrl;
    const showLegalCheckbox = Boolean(legalUrl) && Boolean(legalCheckbox);
    const disabled = showLegalCheckbox && !this.checked;
    const tabIndex = disabled ? -1 : void 0;
    return x$3`
      <cross-w3m-legal-checkbox
        @checkboxChange=${this.onCheckboxChange.bind(this)}
      ></cross-w3m-legal-checkbox>
      <cross-wui-flex
        flexDirection="column"
        .padding=${showLegalCheckbox ? ["0", "s", "s", "s"] : "s"}
        gap="xs"
        class=${o$2(disabled ? "disabled" : void 0)}
      >
        <cross-w3m-wallet-login-list tabIdx=${o$2(tabIndex)}></cross-w3m-wallet-login-list>
      </cross-wui-flex>
      <cross-w3m-legal-footer></cross-w3m-legal-footer>
    `;
  }
  onCheckboxChange(event) {
    this.checked = Boolean(event.detail);
  }
};
W3mConnectWalletsView.styles = styles$B;
__decorate$U([
  r$1()
], W3mConnectWalletsView.prototype, "checked", void 0);
W3mConnectWalletsView = __decorate$U([
  customElement("cross-w3m-connect-wallets-view")
], W3mConnectWalletsView);
const styles$A = i$4`
  cross-wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
  }
  wui-flex::-webkit-scrollbar {
    display: none;
  }
  wui-flex.disabled {
    opacity: 0.3;
    pointer-events: none;
    user-select: none;
  }
`;
var __decorate$T = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mConnectSocialsView = class W3mConnectSocialsView2 extends i$1 {
  constructor() {
    super(...arguments);
    this.checked = false;
  }
  render() {
    var _a3;
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    const legalCheckbox = (_a3 = OptionsController.state.features) == null ? void 0 : _a3.legalCheckbox;
    const legalUrl = termsConditionsUrl || privacyPolicyUrl;
    const showLegalCheckbox = Boolean(legalUrl) && Boolean(legalCheckbox);
    const disabled = showLegalCheckbox && !this.checked;
    const tabIndex = disabled ? -1 : void 0;
    return x$3`
      <cross-w3m-legal-checkbox
        @checkboxChange=${this.onCheckboxChange.bind(this)}
      ></cross-w3m-legal-checkbox>
      <cross-wui-flex
        flexDirection="column"
        .padding=${showLegalCheckbox ? ["0", "s", "s", "s"] : "s"}
        gap="xs"
        class=${o$2(disabled ? "disabled" : void 0)}
      >
        <cross-w3m-social-login-list tabIdx=${o$2(tabIndex)}></cross-w3m-social-login-list>
      </cross-wui-flex>
      <cross-w3m-legal-footer></cross-w3m-legal-footer>
    `;
  }
  onCheckboxChange(event) {
    this.checked = Boolean(event.detail);
  }
};
W3mConnectSocialsView.styles = styles$A;
__decorate$T([
  r$1()
], W3mConnectSocialsView.prototype, "checked", void 0);
W3mConnectSocialsView = __decorate$T([
  customElement("cross-w3m-connect-socials-view")
], W3mConnectSocialsView);
const styles$z = i$4`
  cross-wui-logo {
    width: 80px;
    height: 80px;
    border-radius: var(--wui-border-radius-m);
  }
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }
  wui-flex:first-child:not(:only-child) {
    position: relative;
  }
  cross-wui-loading-thumbnail {
    position: absolute;
  }
  cross-wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }
  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }
  [data-error='true'] cross-wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }
  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }
  .capitalize {
    text-transform: capitalize;
  }
`;
var __decorate$S = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mConnectingSocialView = class W3mConnectingSocialView2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.socialProvider = AccountController.state.socialProvider;
    this.socialWindow = AccountController.state.socialWindow;
    this.error = false;
    this.connecting = false;
    this.message = "Connect in the provider window";
    this.authConnector = ConnectorController.getAuthConnector();
    this.handleSocialConnection = async (event) => {
      var _a3;
      if ((_a3 = event.data) == null ? void 0 : _a3.resultUri) {
        if (event.origin === ConstantsUtil$2.SECURE_SITE_ORIGIN) {
          window.removeEventListener("message", this.handleSocialConnection, false);
          try {
            if (this.authConnector && !this.connecting) {
              if (this.socialWindow) {
                this.socialWindow.close();
                AccountController.setSocialWindow(void 0, ChainController.state.activeChain);
              }
              this.connecting = true;
              this.updateMessage();
              const uri2 = event.data.resultUri;
              if (this.socialProvider) {
                EventsController.sendEvent({
                  type: "track",
                  event: "SOCIAL_LOGIN_REQUEST_USER_DATA",
                  properties: { provider: this.socialProvider }
                });
              }
              await this.authConnector.provider.connectSocial(uri2);
              if (this.socialProvider) {
                StorageUtil.setConnectedSocialProvider(this.socialProvider);
                await ConnectionController.connectExternal(this.authConnector, this.authConnector.chain);
                EventsController.sendEvent({
                  type: "track",
                  event: "SOCIAL_LOGIN_SUCCESS",
                  properties: { provider: this.socialProvider }
                });
              }
            }
          } catch (error) {
            this.error = true;
            this.updateMessage();
            if (this.socialProvider) {
              EventsController.sendEvent({
                type: "track",
                event: "SOCIAL_LOGIN_ERROR",
                properties: { provider: this.socialProvider }
              });
            }
          }
        } else {
          RouterController.goBack();
          SnackController.showError("Untrusted Origin");
          if (this.socialProvider) {
            EventsController.sendEvent({
              type: "track",
              event: "SOCIAL_LOGIN_ERROR",
              properties: { provider: this.socialProvider }
            });
          }
        }
      }
    };
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.socialProvider) {
          this.socialProvider = val.socialProvider;
        }
        if (val.socialWindow) {
          this.socialWindow = val.socialWindow;
        }
        if (val.address) {
          if (ModalController.state.open || OptionsController.state.enableEmbedded) {
            ModalController.close();
          }
        }
      })
    ]);
    if (this.authConnector) {
      this.connectSocial();
    }
  }
  disconnectedCallback() {
    var _a3;
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    window.removeEventListener("message", this.handleSocialConnection, false);
    (_a3 = this.socialWindow) == null ? void 0 : _a3.close();
    AccountController.setSocialWindow(void 0, ChainController.state.activeChain);
  }
  render() {
    return x$3`
      <cross-wui-flex
        data-error=${o$2(this.error)}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <cross-wui-flex justifyContent="center" alignItems="center">
          <cross-wui-logo logo=${o$2(this.socialProvider)}></cross-wui-logo>
          ${this.error ? null : this.loaderTemplate()}
          <cross-wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></cross-wui-icon-box>
        </cross-wui-flex>
        <cross-wui-flex flexDirection="column" alignItems="center" gap="xs">
          <cross-wui-text align="center" variant="paragraph-500" color="fg-100"
            >Log in with
            <span class="capitalize">${this.socialProvider ?? "Social"}</span></wui-text
          >
          <cross-wui-text align="center" variant="small-400" color=${this.error ? "error-100" : "fg-200"}
            >${this.message}</wui-text
          ></wui-flex
        >
      </cross-wui-flex>
    `;
  }
  loaderTemplate() {
    const borderRadiusMaster = ThemeController.state.themeVariables["--w3m-border-radius-master"];
    const radius = borderRadiusMaster ? parseInt(borderRadiusMaster.replace("px", ""), 10) : 4;
    return x$3`<cross-wui-loading-thumbnail radius=${radius * 9}></cross-wui-loading-thumbnail>`;
  }
  connectSocial() {
    const interval = setInterval(() => {
      var _a3;
      if ((_a3 = this.socialWindow) == null ? void 0 : _a3.closed) {
        if (!this.connecting && RouterController.state.view === "ConnectingSocial") {
          if (this.socialProvider) {
            EventsController.sendEvent({
              type: "track",
              event: "SOCIAL_LOGIN_CANCELED",
              properties: { provider: this.socialProvider }
            });
          }
          RouterController.goBack();
        }
        clearInterval(interval);
      }
    }, 1e3);
    window.addEventListener("message", this.handleSocialConnection, false);
  }
  updateMessage() {
    if (this.error) {
      this.message = "Something went wrong";
    } else if (this.connecting) {
      this.message = "Retrieving user data";
    } else {
      this.message = "Connect in the provider window";
    }
  }
};
W3mConnectingSocialView.styles = styles$z;
__decorate$S([
  r$1()
], W3mConnectingSocialView.prototype, "socialProvider", void 0);
__decorate$S([
  r$1()
], W3mConnectingSocialView.prototype, "socialWindow", void 0);
__decorate$S([
  r$1()
], W3mConnectingSocialView.prototype, "error", void 0);
__decorate$S([
  r$1()
], W3mConnectingSocialView.prototype, "connecting", void 0);
__decorate$S([
  r$1()
], W3mConnectingSocialView.prototype, "message", void 0);
W3mConnectingSocialView = __decorate$S([
  customElement("cross-w3m-connecting-social-view")
], W3mConnectingSocialView);
const styles$y = i$4`
  cross-wui-flex {
    width: 100%;
  }

  cross-wui-icon-link {
    margin-right: calc(var(--wui-icon-box-size-md) * -1);
  }

  .account-links {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .account-links cross-wui-flex {
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    flex: 1;
    background: red;
    align-items: center;
    justify-content: center;
    height: 48px;
    padding: 10px;
    flex: 1 0 0;

    border-radius: var(--XS, 16px);
    border: 1px solid var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    background: var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color;
  }

  .account-links wui-flex:hover {
    background: var(--dark-accent-glass-015, rgba(71, 161, 255, 0.15));
  }

  .account-links wui-flex cross-wui-icon {
    width: var(--S, 20px);
    height: var(--S, 20px);
  }

  .account-links wui-flex wui-icon svg path {
    stroke: #47a1ff;
  }

  .account-settings-button {
    padding: calc(var(--wui-spacing-m) - 1px) var(--wui-spacing-2l);
    height: 40px;
    border-radius: var(--wui-border-radius-xxs);
    border: 1px solid var(--wui-color-gray-glass-002);
    background: var(--wui-color-gray-glass-002);
    cursor: pointer;
  }

  .account-settings-button:hover {
    background: var(--wui-color-gray-glass-005);
  }
`;
var __decorate$R = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mProfileView = class W3mProfileView2 extends i$1 {
  constructor() {
    super();
    this.usubscribe = [];
    this.address = AccountController.state.address;
    this.profileImage = AccountController.state.profileImage;
    this.profileName = AccountController.state.profileName;
    this.accounts = AccountController.state.allAccounts;
    this.loading = false;
    this.usubscribe.push(AccountController.subscribeKey("address", (address) => {
      if (address) {
        this.address = address;
      } else {
        ModalController.close();
      }
    }));
    this.usubscribe.push(AccountController.subscribeKey("profileImage", (profileImage) => {
      this.profileImage = profileImage;
    }));
    this.usubscribe.push(AccountController.subscribeKey("profileName", (profileName) => {
      this.profileName = profileName;
    }));
  }
  disconnectedCallback() {
    this.usubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    if (!this.address) {
      throw new Error("cross-w3m-profile-view: No account provided");
    }
    return x$3`
      <cross-wui-flex flexDirection="column" gap="l" .padding=${["0", "xl", "m", "xl"]}>
        <cross-wui-flex flexDirection="column" alignItems="center" gap="l">
          <cross-wui-avatar
            alt=${this.address}
            address=${this.address}
            imageSrc=${o$2(this.profileImage)}
            size="2lg"
          ></cross-wui-avatar>
          <cross-wui-flex flexDirection="column" alignItems="center">
            <cross-wui-flex gap="3xs" alignItems="center" justifyContent="center">
              <cross-wui-text variant="title-6-600" color="fg-100" data-testid="account-settings-address">
                ${this.profileName ? UiHelperUtil.getTruncateString({
      string: this.profileName,
      charsStart: 20,
      charsEnd: 0,
      truncate: "end"
    }) : UiHelperUtil.getTruncateString({
      string: this.address,
      charsStart: 4,
      charsEnd: 6,
      truncate: "middle"
    })}
              </cross-wui-text>
              <cross-wui-icon-link
                size="md"
                icon="copy"
                iconColor="fg-200"
                @click=${this.onCopyAddress}
              ></cross-wui-icon-link>
            </cross-wui-flex>
          </cross-wui-flex>
        </cross-wui-flex>
        <cross-wui-flex
          data-testid="account-settings-button"
          justifyContent="center"
          alignItems="center"
          class="account-settings-button"
          @click=${() => RouterController.push("AccountSettings")}
        >
          <cross-wui-text variant="paragraph-500" color="fg-100">Account Settings</cross-wui-text>
        </cross-wui-flex>
        ${this.accountsTemplate()}
      </cross-wui-flex>
    `;
  }
  accountsTemplate() {
    return x$3`<cross-wui-flex flexDirection="column">
      <cross-wui-flex .padding=${["3xs", "m", "s", "s"]}>
        <cross-wui-text color="fg-200" variant="paragraph-400">Your accounts</cross-wui-text>
      </cross-wui-flex>
      <cross-wui-flex flexDirection="column" gap="xxs">
        ${this.accounts.map((account) => this.accountTemplate(account))}
      </cross-wui-flex>
    </cross-wui-flex>`;
  }
  async onSwitchAccount(account) {
    this.loading = true;
    const emailConnector = ConnectorController.getAuthConnector();
    if (emailConnector) {
      const type2 = account.type;
      await ConnectionController.setPreferredAccountType(type2);
    }
    AccountController.setShouldUpdateToAddress(account.address, ChainController.state.activeChain);
    this.loading = false;
  }
  accountTemplate(account) {
    return x$3`<cross-wui-list-account accountAddress=${account.address} accountType=${account.type}>
      ${account.address === this.address ? "" : x$3`<cross-wui-button
            slot="action"
            textVariant="small-600"
            size="md"
            variant="accent"
            @click=${() => this.onSwitchAccount(account)}
            .loading=${this.loading}
            >Switch</wui-button
          >`}
    </cross-wui-list-account>`;
  }
  onCopyAddress() {
    try {
      if (this.address) {
        CoreHelperUtil.copyToClopboard(this.address);
        SnackController.showSuccess("Address copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
};
W3mProfileView.styles = styles$y;
__decorate$R([
  r$1()
], W3mProfileView.prototype, "address", void 0);
__decorate$R([
  r$1()
], W3mProfileView.prototype, "profileImage", void 0);
__decorate$R([
  r$1()
], W3mProfileView.prototype, "profileName", void 0);
__decorate$R([
  r$1()
], W3mProfileView.prototype, "accounts", void 0);
__decorate$R([
  r$1()
], W3mProfileView.prototype, "loading", void 0);
W3mProfileView = __decorate$R([
  customElement("cross-w3m-profile-view")
], W3mProfileView);
const styles$x = i$4`
  cross-wui-avatar {
    width: var(--wui-spacing-3xl);
    height: var(--wui-spacing-3xl);
    box-shadow: 0 0 0 0;
  }

  cross-wui-icon-box {
    position: relative;
    right: 15px;
    top: 15px;
    border: 2px solid var(--wui-color-bg-150);
    background-color: var(--wui-color-bg-125);
  }
`;
var __decorate$Q = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mSwitchAddressView = class W3mSwitchAddressView2 extends i$1 {
  constructor() {
    super();
    this.metadata = OptionsController.state.metadata;
    this.allAccounts = AccountController.state.allAccounts || [];
    this.balances = {};
    this.labels = AccountController.state.addressLabels;
    this.currentAddress = AccountController.state.address || "";
    this.caipNetwork = ChainController.state.activeCaipNetwork;
    AccountController.subscribeKey("allAccounts", (allAccounts) => {
      this.allAccounts = allAccounts;
    });
  }
  connectedCallback() {
    super.connectedCallback();
    this.allAccounts.forEach((account) => {
      var _a3;
      ApiController$1.getBalance(account.address, (_a3 = this.caipNetwork) == null ? void 0 : _a3.caipNetworkId).then((response) => {
        let total = this.balances[account.address] || 0;
        if (response.length > 0) {
          total = response.reduce((acc, balance) => acc + ((balance == null ? void 0 : balance.value) || 0), 0);
        }
        this.balances[account.address] = total;
        this.requestUpdate();
      });
    });
  }
  getAddressIcon(type2) {
    if (type2 === "smartAccount") {
      return "lightbulb";
    }
    return "mail";
  }
  render() {
    var _a3, _b2;
    return x$3`
      <cross-wui-flex justifyContent="center" .padding=${["xl", "0", "xl", "0"]}>
        <cross-wui-banner-img
          imageSrc=${o$2((_a3 = this.metadata) == null ? void 0 : _a3.icons[0])}
          text=${o$2((_b2 = this.metadata) == null ? void 0 : _b2.url)}
          size="sm"
        ></cross-wui-banner-img>
      </cross-wui-flex>
      <cross-wui-flex flexDirection="column" gap="xxl" .padding=${["l", "xl", "xl", "xl"]}>
        ${this.allAccounts.map((account, index2) => this.getAddressTemplate(account, index2))}
      </cross-wui-flex>
    `;
  }
  getAddressTemplate(account, index2) {
    var _a3, _b2, _c3, _d;
    const label = (_a3 = this.labels) == null ? void 0 : _a3.get(account.address);
    const namespace = ChainController.state.activeChain;
    const connectorId = StorageUtil.getConnectedConnectorId(namespace);
    const shouldShowIcon = connectorId === ConstantsUtil$4.CONNECTOR_ID.AUTH;
    return x$3`
      <cross-wui-flex
        flexDirection="row"
        justifyContent="space-between"
        data-testid="switch-address-item"
      >
        <cross-wui-flex alignItems="center">
          <cross-wui-avatar address=${account.address}></cross-wui-avatar>
          ${shouldShowIcon ? x$3`<cross-wui-icon-box
                size="sm"
                iconcolor="fg-200"
                backgroundcolor="glass-002"
                background="gray"
                icon="${this.getAddressIcon(account.type)}"
                ?border=${true}
              ></cross-wui-icon-box>` : x$3`<cross-wui-flex .padding="${["0", "0", "0", "s"]}"></cross-wui-flex>`}
          <cross-wui-flex flexDirection="column">
            <cross-wui-text class="address" variant="paragraph-500" color="fg-100"
              >${label ? label : UiHelperUtil.getTruncateString({
      string: account.address,
      charsStart: 4,
      charsEnd: 6,
      truncate: "middle"
    })}</wui-text
            >
            <cross-wui-text class="address-description" variant="small-400">
              ${typeof this.balances[account.address] === "number" ? `$${(_b2 = this.balances[account.address]) == null ? void 0 : _b2.toFixed(2)}` : x$3`<cross-wui-loading-spinner size="sm" color="accent-100"></cross-wui-loading-spinner>`}
            </cross-wui-text>
          </cross-wui-flex>
        </cross-wui-flex>
        <cross-wui-flex gap="s" alignItems="center">
          ${((_c3 = account.address) == null ? void 0 : _c3.toLowerCase()) === ((_d = this.currentAddress) == null ? void 0 : _d.toLowerCase()) ? "" : x$3`
                <cross-wui-button
                  data-testid=${`w3m-switch-address-button-${index2}`}
                  textVariant="small-600"
                  size="md"
                  variant="accent"
                  @click=${() => this.onSwitchAddress(account.address)}
                  >Switch to</wui-button
                >
              `}
        </cross-wui-flex>
      </cross-wui-flex>
    `;
  }
  onSwitchAddress(address) {
    const caipNetwork = ChainController.state.activeCaipNetwork;
    const activeChainNamespace = caipNetwork == null ? void 0 : caipNetwork.chainNamespace;
    const caipAddress = `${activeChainNamespace}:${caipNetwork == null ? void 0 : caipNetwork.id}:${address}`;
    AccountController.setCaipAddress(caipAddress, activeChainNamespace);
    ModalController.close();
  }
};
W3mSwitchAddressView.styles = styles$x;
__decorate$Q([
  r$1()
], W3mSwitchAddressView.prototype, "allAccounts", void 0);
__decorate$Q([
  r$1()
], W3mSwitchAddressView.prototype, "balances", void 0);
W3mSwitchAddressView = __decorate$Q([
  customElement("cross-w3m-switch-address-view")
], W3mSwitchAddressView);
const styles$w = i$4`
  @keyframes fadein {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  cross-wui-shimmer {
    width: 100%;
    aspect-ratio: 1 / 1;
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px) !important;
  }

  cross-wui-qr-code {
    opacity: 0;
    animation-duration: 200ms;
    animation-timing-function: ease;
    animation-name: fadein;
    animation-fill-mode: forwards;
  }

  cross-wui-logo {
    width: 80px;
    height: 80px;
    border-radius: var(--wui-border-radius-m);
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }
  cross-wui-loading-thumbnail {
    position: absolute;
  }
  cross-wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }
`;
var __decorate$P = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mConnectingFarcasterView = class W3mConnectingFarcasterView2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.timeout = void 0;
    this.socialProvider = AccountController.state.socialProvider;
    this.uri = AccountController.state.farcasterUrl;
    this.ready = false;
    this.loading = false;
    this.authConnector = ConnectorController.getAuthConnector();
    this.forceUpdate = () => {
      this.requestUpdate();
    };
    this.unsubscribe.push(...[
      AccountController.subscribeKey("farcasterUrl", (val) => {
        if (val) {
          this.uri = val;
          this.connectFarcaster();
        }
      }),
      AccountController.subscribeKey("socialProvider", (val) => {
        if (val) {
          this.socialProvider = val;
        }
      })
    ]);
    window.addEventListener("resize", this.forceUpdate);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    clearTimeout(this.timeout);
    window.removeEventListener("resize", this.forceUpdate);
  }
  render() {
    this.onRenderProxy();
    return x$3`${this.platformTemplate()}`;
  }
  platformTemplate() {
    if (CoreHelperUtil.isMobile()) {
      return x$3`${this.mobileTemplate()}`;
    }
    return x$3`${this.desktopTemplate()}`;
  }
  desktopTemplate() {
    if (this.loading) {
      return x$3`${this.loadingTemplate()}`;
    }
    return x$3`${this.qrTemplate()}`;
  }
  qrTemplate() {
    return x$3` <cross-wui-flex
      flexDirection="column"
      alignItems="center"
      .padding=${["0", "xl", "xl", "xl"]}
      gap="xl"
    >
      <cross-wui-shimmer borderRadius="l" width="100%"> ${this.qrCodeTemplate()} </cross-wui-shimmer>

      <cross-wui-text variant="paragraph-500" color="fg-100">
        Scan this QR Code with your phone
      </cross-wui-text>
      ${this.copyTemplate()}
    </cross-wui-flex>`;
  }
  loadingTemplate() {
    return x$3`
      <cross-wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <cross-wui-flex justifyContent="center" alignItems="center">
          <cross-wui-logo logo="farcaster"></cross-wui-logo>
          ${this.loaderTemplate()}
          <cross-wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></cross-wui-icon-box>
        </cross-wui-flex>
        <cross-wui-flex flexDirection="column" alignItems="center" gap="xs">
          <cross-wui-text align="center" variant="paragraph-500" color="fg-100">
            Loading user data
          </cross-wui-text>
          <cross-wui-text align="center" variant="small-400" color="fg-200">
            Please wait a moment while we load your data.
          </cross-wui-text>
        </cross-wui-flex>
      </cross-wui-flex>
    `;
  }
  mobileTemplate() {
    return x$3` <cross-wui-flex
      flexDirection="column"
      alignItems="center"
      .padding=${["3xl", "xl", "xl", "xl"]}
      gap="xl"
    >
      <cross-wui-flex justifyContent="center" alignItems="center">
        <cross-wui-logo logo="farcaster"></cross-wui-logo>
        ${this.loaderTemplate()}
        <cross-wui-icon-box
          backgroundColor="error-100"
          background="opaque"
          iconColor="error-100"
          icon="close"
          size="sm"
          border
          borderColor="wui-color-bg-125"
        ></cross-wui-icon-box>
      </cross-wui-flex>
      <cross-wui-flex flexDirection="column" alignItems="center" gap="xs">
        <cross-wui-text align="center" variant="paragraph-500" color="fg-100"
          >Continue in Farcaster</span></wui-text
        >
        <cross-wui-text align="center" variant="small-400" color="fg-200"
          >Accept connection request in the app</wui-text
        ></wui-flex
      >
      ${this.mobileLinkTemplate()}
    </cross-wui-flex>`;
  }
  loaderTemplate() {
    const borderRadiusMaster = ThemeController.state.themeVariables["--w3m-border-radius-master"];
    const radius = borderRadiusMaster ? parseInt(borderRadiusMaster.replace("px", ""), 10) : 4;
    return x$3`<cross-wui-loading-thumbnail radius=${radius * 9}></cross-wui-loading-thumbnail>`;
  }
  async connectFarcaster() {
    var _a3;
    if (this.authConnector) {
      try {
        await ((_a3 = this.authConnector) == null ? void 0 : _a3.provider.connectFarcaster());
        if (this.socialProvider) {
          StorageUtil.setConnectedSocialProvider(this.socialProvider);
          EventsController.sendEvent({
            type: "track",
            event: "SOCIAL_LOGIN_REQUEST_USER_DATA",
            properties: { provider: this.socialProvider }
          });
        }
        this.loading = true;
        await ConnectionController.connectExternal(this.authConnector, this.authConnector.chain);
        if (this.socialProvider) {
          EventsController.sendEvent({
            type: "track",
            event: "SOCIAL_LOGIN_SUCCESS",
            properties: { provider: this.socialProvider }
          });
        }
        this.loading = false;
        ModalController.close();
      } catch (error) {
        if (this.socialProvider) {
          EventsController.sendEvent({
            type: "track",
            event: "SOCIAL_LOGIN_ERROR",
            properties: { provider: this.socialProvider }
          });
        }
        RouterController.goBack();
        SnackController.showError(error);
      }
    }
  }
  mobileLinkTemplate() {
    return x$3`<cross-wui-button
      size="md"
      ?loading=${this.loading}
      ?disabled=${!this.uri || this.loading}
      @click=${() => {
      if (this.uri) {
        CoreHelperUtil.openHref(this.uri, "_blank");
      }
    }}
    >
      Open farcaster</wui-button
    >`;
  }
  onRenderProxy() {
    if (!this.ready && this.uri) {
      this.timeout = setTimeout(() => {
        this.ready = true;
      }, 200);
    }
  }
  qrCodeTemplate() {
    if (!this.uri || !this.ready) {
      return null;
    }
    const size2 = this.getBoundingClientRect().width - 40;
    return x$3` <cross-wui-qr-code
      size=${size2}
      theme=${ThemeController.state.themeMode}
      uri=${this.uri}
      ?farcaster=${true}
      data-testid="wui-qr-code"
      color=${o$2(ThemeController.state.themeVariables["--w3m-qr-color"])}
    ></cross-wui-qr-code>`;
  }
  copyTemplate() {
    const inactive = !this.uri || !this.ready;
    return x$3`<cross-wui-link
      .disabled=${inactive}
      @click=${this.onCopyUri}
      color="fg-200"
      data-testid="copy-wc2-uri"
    >
      <cross-wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></cross-wui-icon>
      Copy link
    </cross-wui-link>`;
  }
  onCopyUri() {
    try {
      if (this.uri) {
        CoreHelperUtil.copyToClopboard(this.uri);
        SnackController.showSuccess("Link copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
};
W3mConnectingFarcasterView.styles = styles$w;
__decorate$P([
  r$1()
], W3mConnectingFarcasterView.prototype, "socialProvider", void 0);
__decorate$P([
  r$1()
], W3mConnectingFarcasterView.prototype, "uri", void 0);
__decorate$P([
  r$1()
], W3mConnectingFarcasterView.prototype, "ready", void 0);
__decorate$P([
  r$1()
], W3mConnectingFarcasterView.prototype, "loading", void 0);
W3mConnectingFarcasterView = __decorate$P([
  customElement("cross-w3m-connecting-farcaster-view")
], W3mConnectingFarcasterView);
var __decorate$O = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mSIWXSignMessageView = class W3mSIWXSignMessageView2 extends i$1 {
  constructor() {
    var _a3;
    super(...arguments);
    this.dappName = (_a3 = OptionsController.state.metadata) == null ? void 0 : _a3.name;
    this.isCancelling = false;
    this.isSigning = false;
  }
  render() {
    return x$3`
      <cross-wui-flex justifyContent="center" .padding=${["2xl", "0", "xxl", "0"]}>
        <cross-w3m-siwx-sign-message-thumbnails></cross-w3m-siwx-sign-message-thumbnails>
      </cross-wui-flex>
      <cross-wui-flex
        .padding=${["0", "4xl", "l", "4xl"]}
        gap="s"
        justifyContent="space-between"
      >
        <cross-wui-text variant="paragraph-500" align="center" color="fg-100"
          >${this.dappName ?? "Dapp"} needs to connect to your wallet</wui-text
        >
      </cross-wui-flex>
      <cross-wui-flex
        .padding=${["0", "3xl", "l", "3xl"]}
        gap="s"
        justifyContent="space-between"
      >
        <cross-wui-text variant="small-400" align="center" color="fg-200"
          >Sign this message to prove you own this wallet and proceed. Canceling will disconnect
          you.</wui-text
        >
      </cross-wui-flex>
      <cross-wui-flex .padding=${["l", "xl", "xl", "xl"]} gap="s" justifyContent="space-between">
        <cross-wui-button
          size="lg"
          borderRadius="xs"
          fullWidth
          variant="neutral"
          ?loading=${this.isCancelling}
          @click=${this.onCancel.bind(this)}
          data-testid="cross-w3m-connecting-siwe-cancel"
        >
          ${this.isCancelling ? "Cancelling..." : "Cancel"}
        </cross-wui-button>
        <cross-wui-button
          size="lg"
          borderRadius="xs"
          fullWidth
          variant="main"
          @click=${this.onSign.bind(this)}
          ?loading=${this.isSigning}
          data-testid="cross-w3m-connecting-siwe-sign"
        >
          ${this.isSigning ? "Signing..." : "Sign"}
        </cross-wui-button>
      </cross-wui-flex>
    `;
  }
  async onSign() {
    this.isSigning = true;
    await SIWXUtil.requestSignMessage().finally(() => this.isSigning = false);
  }
  async onCancel() {
    this.isCancelling = true;
    await SIWXUtil.cancelSignMessage().finally(() => this.isCancelling = false);
  }
};
__decorate$O([
  r$1()
], W3mSIWXSignMessageView.prototype, "isCancelling", void 0);
__decorate$O([
  r$1()
], W3mSIWXSignMessageView.prototype, "isSigning", void 0);
W3mSIWXSignMessageView = __decorate$O([
  customElement("cross-w3m-siwx-sign-message-view")
], W3mSIWXSignMessageView);
const styles$v = i$4`
  cross-wui-grid {
    max-height: clamp(360px, 400px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
    grid-template-columns: repeat(auto-fill, 104px);
  }

  @media (max-width: 350px) {
    cross-wui-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  cross-wui-loading-spinner {
    padding-top: var(--wui-spacing-l);
    padding-bottom: var(--wui-spacing-l);
    justify-content: center;
    grid-column: 1 / span 4;
  }
`;
var __decorate$N = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
const PAGINATOR_ID$1 = "local-paginator";
let W3mAllWalletsList = class W3mAllWalletsList2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.paginationObserver = void 0;
    this.loading = !ApiController$1.state.wallets.length;
    this.wallets = ApiController$1.state.wallets;
    this.recommended = ApiController$1.state.recommended;
    this.featured = ApiController$1.state.featured;
    this.unsubscribe.push(...[
      ApiController$1.subscribeKey("wallets", (val) => this.wallets = val),
      ApiController$1.subscribeKey("recommended", (val) => this.recommended = val),
      ApiController$1.subscribeKey("featured", (val) => this.featured = val)
    ]);
  }
  firstUpdated() {
    this.initialFetch();
    this.createPaginationObserver();
  }
  disconnectedCallback() {
    var _a3;
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    (_a3 = this.paginationObserver) == null ? void 0 : _a3.disconnect();
  }
  render() {
    return x$3`
      <cross-wui-grid
        data-scroll=${!this.loading}
        .padding=${["0", "s", "s", "s"]}
        columnGap="xxs"
        rowGap="l"
        justifyContent="space-between"
      >
        ${this.loading ? this.shimmerTemplate(16) : this.walletsTemplate()}
        ${this.paginationLoaderTemplate()}
      </cross-wui-grid>
    `;
  }
  async initialFetch() {
    var _a3;
    this.loading = true;
    const gridEl = (_a3 = this.shadowRoot) == null ? void 0 : _a3.querySelector("cross-wui-grid");
    if (gridEl) {
      await ApiController$1.fetchWallets({ page: 1 });
      await gridEl.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.loading = false;
      gridEl.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  shimmerTemplate(items, id2) {
    return [...Array(items)].map(() => x$3`
        <cross-wui-card-select-loader type="wallet" id=${o$2(id2)}></cross-wui-card-select-loader>
      `);
  }
  walletsTemplate() {
    const wallets = [...this.featured, ...this.recommended, ...this.wallets];
    const walletsWithInstalled = WalletUtil$1.markWalletsAsInstalled(wallets);
    return walletsWithInstalled.map((wallet) => x$3`
        <cross-w3m-all-wallets-list-item
          @click=${() => this.onConnectWallet(wallet)}
          .wallet=${wallet}
        ></cross-w3m-all-wallets-list-item>
      `);
  }
  paginationLoaderTemplate() {
    const { wallets, recommended, featured, count } = ApiController$1.state;
    const columns = window.innerWidth < 352 ? 3 : 4;
    const currentWallets = wallets.length + recommended.length;
    const minimumRows = Math.ceil(currentWallets / columns);
    let shimmerCount = minimumRows * columns - currentWallets + columns;
    shimmerCount -= wallets.length ? featured.length % columns : 0;
    if (count === 0 && featured.length > 0) {
      return null;
    }
    if (count === 0 || [...featured, ...wallets, ...recommended].length < count) {
      return this.shimmerTemplate(shimmerCount, PAGINATOR_ID$1);
    }
    return null;
  }
  createPaginationObserver() {
    var _a3;
    const loaderEl = (_a3 = this.shadowRoot) == null ? void 0 : _a3.querySelector(`#${PAGINATOR_ID$1}`);
    if (loaderEl) {
      this.paginationObserver = new IntersectionObserver(([element]) => {
        if ((element == null ? void 0 : element.isIntersecting) && !this.loading) {
          const { page, count, wallets } = ApiController$1.state;
          if (wallets.length < count) {
            ApiController$1.fetchWallets({ page: page + 1 });
          }
        }
      });
      this.paginationObserver.observe(loaderEl);
    }
  }
  onConnectWallet(wallet) {
    ConnectorController.selectWalletConnector(wallet);
  }
};
W3mAllWalletsList.styles = styles$v;
__decorate$N([
  r$1()
], W3mAllWalletsList.prototype, "loading", void 0);
__decorate$N([
  r$1()
], W3mAllWalletsList.prototype, "wallets", void 0);
__decorate$N([
  r$1()
], W3mAllWalletsList.prototype, "recommended", void 0);
__decorate$N([
  r$1()
], W3mAllWalletsList.prototype, "featured", void 0);
W3mAllWalletsList = __decorate$N([
  customElement("cross-w3m-all-wallets-list")
], W3mAllWalletsList);
const styles$u = i$4`
  button {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    width: 104px;
    row-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-s) var(--wui-spacing-0);
    background-color: var(--wui-color-gray-glass-002);
    border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
    transition:
      color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      background-color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: background-color, color, border-radius;
    outline: none;
    border: none;
  }

  button > wui-flex > cross-wui-text {
    color: var(--wui-color-fg-100);
    max-width: 86px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    justify-content: center;
  }

  button > wui-flex > wui-text.certified {
    max-width: 66px;
  }

  button:hover:enabled {
    background-color: var(--wui-color-gray-glass-005);
  }

  button:disabled > wui-flex > cross-wui-text {
    color: var(--wui-color-gray-glass-015);
  }

  [data-selected='true'] {
    background-color: var(--wui-color-accent-glass-020);
  }

  @media (hover: hover) and (pointer: fine) {
    [data-selected='true']:hover:enabled {
      background-color: var(--wui-color-accent-glass-015);
    }
  }

  [data-selected='true']:active:enabled {
    background-color: var(--wui-color-accent-glass-010);
  }

  @media (max-width: 350px) {
    button {
      width: 100%;
    }
  }
`;
var __decorate$M = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mAllWalletsListItem = class W3mAllWalletsListItem2 extends i$1 {
  constructor() {
    super();
    this.observer = new IntersectionObserver(() => void 0);
    this.visible = false;
    this.imageSrc = void 0;
    this.imageLoading = false;
    this.wallet = void 0;
    this.observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          this.visible = true;
          this.fetchImageSrc();
        } else {
          this.visible = false;
        }
      });
    }, { threshold: 0.01 });
  }
  firstUpdated() {
    this.observer.observe(this);
  }
  disconnectedCallback() {
    this.observer.disconnect();
  }
  render() {
    var _a3, _b2;
    const certified = ((_a3 = this.wallet) == null ? void 0 : _a3.badge_type) === "certified";
    return x$3`
      <button>
        ${this.imageTemplate()}
        <cross-wui-flex flexDirection="row" alignItems="center" justifyContent="center" gap="3xs">
          <cross-wui-text
            variant="tiny-500"
            color="inherit"
            class=${o$2(certified ? "certified" : void 0)}
            >${(_b2 = this.wallet) == null ? void 0 : _b2.name}</wui-text
          >
          ${certified ? x$3`<cross-wui-icon size="sm" name="walletConnectBrown"></cross-wui-icon>` : null}
        </cross-wui-flex>
      </button>
    `;
  }
  imageTemplate() {
    var _a3, _b2;
    if (!this.visible && !this.imageSrc || this.imageLoading) {
      return this.shimmerTemplate();
    }
    return x$3`
      <cross-wui-wallet-image
        size="md"
        imageSrc=${o$2(this.imageSrc)}
        name=${(_a3 = this.wallet) == null ? void 0 : _a3.name}
        .installed=${(_b2 = this.wallet) == null ? void 0 : _b2.installed}
        badgeSize="sm"
      >
      </cross-wui-wallet-image>
    `;
  }
  shimmerTemplate() {
    return x$3`<cross-wui-shimmer width="56px" height="56px" borderRadius="xs"></cross-wui-shimmer>`;
  }
  async fetchImageSrc() {
    if (!this.wallet) {
      return;
    }
    this.imageSrc = AssetUtil.getWalletImage(this.wallet);
    if (this.imageSrc) {
      return;
    }
    this.imageLoading = true;
    this.imageSrc = await AssetUtil.fetchWalletImage(this.wallet.image_id);
    this.imageLoading = false;
  }
};
W3mAllWalletsListItem.styles = styles$u;
__decorate$M([
  r$1()
], W3mAllWalletsListItem.prototype, "visible", void 0);
__decorate$M([
  r$1()
], W3mAllWalletsListItem.prototype, "imageSrc", void 0);
__decorate$M([
  r$1()
], W3mAllWalletsListItem.prototype, "imageLoading", void 0);
__decorate$M([
  n$3()
], W3mAllWalletsListItem.prototype, "wallet", void 0);
W3mAllWalletsListItem = __decorate$M([
  customElement("cross-w3m-all-wallets-list-item")
], W3mAllWalletsListItem);
const styles$t = i$4`
  cross-wui-grid,
  cross-wui-loading-spinner,
  cross-wui-flex {
    height: 360px;
  }

  cross-wui-grid {
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
    grid-template-columns: repeat(auto-fill, 104px);
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  cross-wui-loading-spinner {
    justify-content: center;
    align-items: center;
  }

  @media (max-width: 350px) {
    cross-wui-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }
`;
var __decorate$L = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mAllWalletsSearch = class W3mAllWalletsSearch2 extends i$1 {
  constructor() {
    super(...arguments);
    this.prevQuery = "";
    this.prevBadge = void 0;
    this.loading = true;
    this.query = "";
  }
  render() {
    this.onSearch();
    return this.loading ? x$3`<cross-wui-loading-spinner color="accent-100"></cross-wui-loading-spinner>` : this.walletsTemplate();
  }
  async onSearch() {
    if (this.query.trim() !== this.prevQuery.trim() || this.badge !== this.prevBadge) {
      this.prevQuery = this.query;
      this.prevBadge = this.badge;
      this.loading = true;
      await ApiController$1.searchWallet({ search: this.query, badge: this.badge });
      this.loading = false;
    }
  }
  walletsTemplate() {
    const { search } = ApiController$1.state;
    const wallets = WalletUtil$1.markWalletsAsInstalled(search);
    if (!search.length) {
      return x$3`
        <cross-wui-flex
          data-testid="no-wallet-found"
          justifyContent="center"
          alignItems="center"
          gap="s"
          flexDirection="column"
        >
          <cross-wui-icon-box
            size="lg"
            iconColor="fg-200"
            backgroundColor="fg-300"
            icon="wallet"
            background="transparent"
          ></cross-wui-icon-box>
          <cross-wui-text data-testid="no-wallet-found-text" color="fg-200" variant="paragraph-500">
            No Wallet found
          </cross-wui-text>
        </cross-wui-flex>
      `;
    }
    return x$3`
      <cross-wui-grid
        data-testid="wallet-list"
        .padding=${["0", "s", "s", "s"]}
        rowGap="l"
        columnGap="xs"
        justifyContent="space-between"
      >
        ${wallets.map((wallet) => x$3`
            <cross-w3m-all-wallets-list-item
              @click=${() => this.onConnectWallet(wallet)}
              .wallet=${wallet}
              data-testid="wallet-search-item-${wallet.id}"
            ></cross-w3m-all-wallets-list-item>
          `)}
      </cross-wui-grid>
    `;
  }
  onConnectWallet(wallet) {
    ConnectorController.selectWalletConnector(wallet);
  }
};
W3mAllWalletsSearch.styles = styles$t;
__decorate$L([
  r$1()
], W3mAllWalletsSearch.prototype, "loading", void 0);
__decorate$L([
  n$3()
], W3mAllWalletsSearch.prototype, "query", void 0);
__decorate$L([
  n$3()
], W3mAllWalletsSearch.prototype, "badge", void 0);
W3mAllWalletsSearch = __decorate$L([
  customElement("w3m-all-wallets-search")
], W3mAllWalletsSearch);
var __decorate$K = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mConnectingWcDesktop = class W3mConnectingWcDesktop2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("cross-w3m-connecting-wc-desktop: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.onRender = this.onRenderProxy.bind(this);
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "desktop" }
    });
  }
  onRenderProxy() {
    var _a3;
    if (!this.ready && this.uri) {
      this.ready = true;
      (_a3 = this.onConnect) == null ? void 0 : _a3.call(this);
    }
  }
  onConnectProxy() {
    var _a3;
    if (((_a3 = this.wallet) == null ? void 0 : _a3.desktop_link) && this.uri) {
      try {
        this.error = false;
        const { desktop_link, name } = this.wallet;
        const { redirect, href } = CoreHelperUtil.formatNativeUrl(desktop_link, this.uri);
        ConnectionController.setWcLinking({ name, href });
        ConnectionController.setRecentWallet(this.wallet);
        CoreHelperUtil.openHref(redirect, "_blank");
      } catch {
        this.error = true;
      }
    }
  }
};
W3mConnectingWcDesktop = __decorate$K([
  customElement("cross-w3m-connecting-wc-desktop")
], W3mConnectingWcDesktop);
var __decorate$J = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mConnectingWcQrcodeEmbed = class W3mConnectingWcQrcodeEmbed2 extends W3mConnectingWidget {
  constructor() {
    var _a3;
    super();
    this.resizeObserver = void 0;
    this.onResize = () => this.requestUpdate();
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: ((_a3 = this.wallet) == null ? void 0 : _a3.name) ?? "CROSSx Wallet", platform: "qrcode" }
    });
  }
  render() {
    this.onRenderProxy();
    return x$3`${this.qrCodeTemplate()}`;
  }
  onRenderProxy() {
    if (!this.ready && this.uri) {
      this.timeout = setTimeout(() => {
        this.ready = true;
      }, 200);
    }
  }
  firstUpdated() {
    this.resizeObserver = new ResizeObserver(() => this.requestUpdate());
    this.resizeObserver.observe(this);
    window.addEventListener("orientationchange", this.onResize, { passive: true });
    window.addEventListener("resize", this.onResize, { passive: true });
  }
  disconnectedCallback() {
    var _a3;
    super.disconnectedCallback();
    (_a3 = this.resizeObserver) == null ? void 0 : _a3.disconnect();
    window.removeEventListener("orientationchange", this.onResize);
    window.removeEventListener("resize", this.onResize);
  }
  qrCodeTemplate() {
    if (!this.uri || !this.ready) {
      return null;
    }
    const rect = this.getBoundingClientRect();
    let size2 = Math.floor(Math.min(rect.width || 0, rect.height || 0));
    if (!size2 || size2 <= 0) {
      size2 = 200;
    }
    const alt = this.wallet ? this.wallet.name : "CROSSx Wallet";
    ConnectionController.setWcLinking(void 0);
    ConnectionController.setRecentWallet(this.wallet);
    return x$3` <cross-wui-qr-code
      size=${size2}
      theme=${ThemeController.state.themeMode}
      uri=${this.uri}
      imageSrc=${o$2(void 0)}
      color=${o$2(ThemeController.state.themeVariables["--w3m-qr-color"])}
      alt=${o$2(alt)}
      data-testid="wui-qr-code"
    ></cross-wui-qr-code>`;
  }
};
W3mConnectingWcQrcodeEmbed = __decorate$J([
  customElement("cross-w3m-connecting-wc-qrcode-embed")
], W3mConnectingWcQrcodeEmbed);
var __decorate$I = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mConnectingWcUnsupported = class W3mConnectingWcUnsupported2 extends i$1 {
  constructor() {
    var _a3;
    super();
    this.wallet = (_a3 = RouterController.state.data) == null ? void 0 : _a3.wallet;
    if (!this.wallet) {
      throw new Error("cross-w3m-connecting-wc-unsupported: No wallet provided");
    }
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "browser" }
    });
  }
  render() {
    return x$3`
      <cross-wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <cross-wui-wallet-image
          size="lg"
          imageSrc=${o$2(AssetUtil.getWalletImage(this.wallet))}
        ></cross-wui-wallet-image>

        <cross-wui-text variant="paragraph-500" color="fg-100">Not Detected</cross-wui-text>
      </cross-wui-flex>

      <cross-w3m-mobile-download-links .wallet=${this.wallet}></cross-w3m-mobile-download-links>
    `;
  }
};
W3mConnectingWcUnsupported = __decorate$I([
  customElement("cross-w3m-connecting-wc-unsupported")
], W3mConnectingWcUnsupported);
var __decorate$H = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mConnectingWcWeb = class W3mConnectingWcWeb2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("cross-w3m-connecting-wc-web: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.secondaryBtnLabel = "Open";
    this.secondaryLabel = "Open and continue in a new browser tab";
    this.secondaryBtnIcon = "externalLink";
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "web" }
    });
  }
  onConnectProxy() {
    var _a3;
    if (((_a3 = this.wallet) == null ? void 0 : _a3.webapp_link) && this.uri) {
      try {
        this.error = false;
        const { webapp_link, name } = this.wallet;
        const { redirect, href } = CoreHelperUtil.formatUniversalUrl(webapp_link, this.uri);
        ConnectionController.setWcLinking({ name, href });
        ConnectionController.setRecentWallet(this.wallet);
        CoreHelperUtil.openHref(redirect, "_blank");
      } catch {
        this.error = true;
      }
    }
  }
};
W3mConnectingWcWeb = __decorate$H([
  customElement("cross-w3m-connecting-wc-web")
], W3mConnectingWcWeb);
const styles$s = i$4`
  :host {
    width: 100%;
  }

  .details-container > cross-wui-flex {
    background: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xxs);
    width: 100%;
  }

  .details-container > wui-flex > button {
    border: none;
    background: none;
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);
    cursor: pointer;
  }

  .details-content-container {
    padding: var(--wui-spacing-1xs);
    padding-top: 0px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .details-content-container > cross-wui-flex {
    width: 100%;
  }

  .details-row {
    width: 100%;
    padding: var(--wui-spacing-s);
    padding-left: var(--wui-spacing-s);
    padding-right: var(--wui-spacing-1xs);
    border-radius: calc(var(--wui-border-radius-5xs) + var(--wui-border-radius-4xs));
    background: var(--wui-color-gray-glass-002);
  }

  .details-row-title {
    white-space: nowrap;
  }

  .details-row.provider-free-row {
    padding-right: var(--wui-spacing-xs);
  }
`;
var __decorate$G = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
const slippageRate = ConstantsUtil$3.CONVERT_SLIPPAGE_TOLERANCE;
let WuiSwapDetails = class WuiSwapDetails2 extends i$1 {
  constructor() {
    var _a3;
    super();
    this.unsubscribe = [];
    this.networkName = (_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.name;
    this.detailsOpen = false;
    this.sourceToken = SwapController.state.sourceToken;
    this.toToken = SwapController.state.toToken;
    this.toTokenAmount = SwapController.state.toTokenAmount;
    this.sourceTokenPriceInUSD = SwapController.state.sourceTokenPriceInUSD;
    this.toTokenPriceInUSD = SwapController.state.toTokenPriceInUSD;
    this.gasPriceInUSD = SwapController.state.gasPriceInUSD;
    this.priceImpact = SwapController.state.priceImpact;
    this.maxSlippage = SwapController.state.maxSlippage;
    this.networkTokenSymbol = SwapController.state.networkTokenSymbol;
    this.inputError = SwapController.state.inputError;
    this.unsubscribe.push(...[
      SwapController.subscribe((newState) => {
        this.sourceToken = newState.sourceToken;
        this.toToken = newState.toToken;
        this.toTokenAmount = newState.toTokenAmount;
        this.gasPriceInUSD = newState.gasPriceInUSD;
        this.priceImpact = newState.priceImpact;
        this.maxSlippage = newState.maxSlippage;
        this.sourceTokenPriceInUSD = newState.sourceTokenPriceInUSD;
        this.toTokenPriceInUSD = newState.toTokenPriceInUSD;
        this.inputError = newState.inputError;
      })
    ]);
  }
  render() {
    const minReceivedAmount = this.toTokenAmount && this.maxSlippage ? NumberUtil.bigNumber(this.toTokenAmount).minus(this.maxSlippage).toString() : null;
    if (!this.sourceToken || !this.toToken || this.inputError) {
      return null;
    }
    const toTokenSwappedAmount = this.sourceTokenPriceInUSD && this.toTokenPriceInUSD ? 1 / this.toTokenPriceInUSD * this.sourceTokenPriceInUSD : 0;
    return x$3`
      <cross-wui-flex flexDirection="column" alignItems="center" gap="1xs" class="details-container">
        <cross-wui-flex flexDirection="column">
          <button @click=${this.toggleDetails.bind(this)}>
            <cross-wui-flex justifyContent="space-between" .padding=${["0", "xs", "0", "xs"]}>
              <cross-wui-flex justifyContent="flex-start" flexGrow="1" gap="xs">
                <cross-wui-text variant="small-400" color="fg-100">
                  1 ${this.sourceToken.symbol} =
                  ${UiHelperUtil.formatNumberToLocalString(toTokenSwappedAmount, 3)}
                  ${this.toToken.symbol}
                </cross-wui-text>
                <cross-wui-text variant="small-400" color="fg-200">
                  $${UiHelperUtil.formatNumberToLocalString(this.sourceTokenPriceInUSD)}
                </cross-wui-text>
              </cross-wui-flex>
              <cross-wui-icon name="chevronBottom"></cross-wui-icon>
            </cross-wui-flex>
          </button>
          ${this.detailsOpen ? x$3`
                <cross-wui-flex flexDirection="column" gap="xs" class="details-content-container">
                  <cross-wui-flex flexDirection="column" gap="xs">
                    <cross-wui-flex
                      justifyContent="space-between"
                      alignItems="center"
                      class="details-row"
                    >
                      <cross-wui-flex alignItems="center" gap="xs">
                        <cross-wui-text class="details-row-title" variant="small-400" color="fg-150">
                          Network cost
                        </cross-wui-text>
                        <cross-w3m-tooltip-trigger
                          text=${`Network cost is paid in ${this.networkTokenSymbol} on the ${this.networkName} network in order to execute transaction.`}
                        >
                          <cross-wui-icon size="xs" color="fg-250" name="infoCircle"></cross-wui-icon>
                        </cross-w3m-tooltip-trigger>
                      </cross-wui-flex>
                      <cross-wui-text variant="small-400" color="fg-100">
                        $${UiHelperUtil.formatNumberToLocalString(this.gasPriceInUSD, 3)}
                      </cross-wui-text>
                    </cross-wui-flex>
                  </cross-wui-flex>
                  ${this.priceImpact ? x$3` <cross-wui-flex flexDirection="column" gap="xs">
                        <cross-wui-flex
                          justifyContent="space-between"
                          alignItems="center"
                          class="details-row"
                        >
                          <cross-wui-flex alignItems="center" gap="xs">
                            <cross-wui-text class="details-row-title" variant="small-400" color="fg-150">
                              Price impact
                            </cross-wui-text>
                            <cross-w3m-tooltip-trigger
                              text="Price impact reflects the change in market price due to your trade"
                            >
                              <cross-wui-icon size="xs" color="fg-250" name="infoCircle"></cross-wui-icon>
                            </cross-w3m-tooltip-trigger>
                          </cross-wui-flex>
                          <cross-wui-flex>
                            <cross-wui-text variant="small-400" color="fg-200">
                              ${UiHelperUtil.formatNumberToLocalString(this.priceImpact, 3)}%
                            </cross-wui-text>
                          </cross-wui-flex>
                        </cross-wui-flex>
                      </cross-wui-flex>` : null}
                  ${this.maxSlippage && this.sourceToken.symbol ? x$3`<cross-wui-flex flexDirection="column" gap="xs">
                        <cross-wui-flex
                          justifyContent="space-between"
                          alignItems="center"
                          class="details-row"
                        >
                          <cross-wui-flex alignItems="center" gap="xs">
                            <cross-wui-text class="details-row-title" variant="small-400" color="fg-150">
                              Max. slippage
                            </cross-wui-text>
                            <cross-w3m-tooltip-trigger
                              text=${`Max slippage sets the minimum amount you must receive for the transaction to proceed. ${minReceivedAmount ? `Transaction will be reversed if you receive less than ${UiHelperUtil.formatNumberToLocalString(minReceivedAmount, 6)} ${this.toToken.symbol} due to price changes.` : ""}`}
                            >
                              <cross-wui-icon size="xs" color="fg-250" name="infoCircle"></cross-wui-icon>
                            </cross-w3m-tooltip-trigger>
                          </cross-wui-flex>
                          <cross-wui-flex>
                            <cross-wui-text variant="small-400" color="fg-200">
                              ${UiHelperUtil.formatNumberToLocalString(this.maxSlippage, 6)}
                              ${this.toToken.symbol} ${slippageRate}%
                            </cross-wui-text>
                          </cross-wui-flex>
                        </cross-wui-flex>
                      </cross-wui-flex>` : null}
                  <cross-wui-flex flexDirection="column" gap="xs">
                    <cross-wui-flex
                      justifyContent="space-between"
                      alignItems="center"
                      class="details-row provider-free-row"
                    >
                      <cross-wui-flex alignItems="center" gap="xs">
                        <cross-wui-text class="details-row-title" variant="small-400" color="fg-150">
                          Provider fee
                        </cross-wui-text>
                      </cross-wui-flex>
                      <cross-wui-flex>
                        <cross-wui-text variant="small-400" color="fg-200">0.85%</cross-wui-text>
                      </cross-wui-flex>
                    </cross-wui-flex>
                  </cross-wui-flex>
                </cross-wui-flex>
              ` : null}
        </cross-wui-flex>
      </cross-wui-flex>
    `;
  }
  toggleDetails() {
    this.detailsOpen = !this.detailsOpen;
  }
};
WuiSwapDetails.styles = [styles$s];
__decorate$G([
  r$1()
], WuiSwapDetails.prototype, "networkName", void 0);
__decorate$G([
  n$3()
], WuiSwapDetails.prototype, "detailsOpen", void 0);
__decorate$G([
  r$1()
], WuiSwapDetails.prototype, "sourceToken", void 0);
__decorate$G([
  r$1()
], WuiSwapDetails.prototype, "toToken", void 0);
__decorate$G([
  r$1()
], WuiSwapDetails.prototype, "toTokenAmount", void 0);
__decorate$G([
  r$1()
], WuiSwapDetails.prototype, "sourceTokenPriceInUSD", void 0);
__decorate$G([
  r$1()
], WuiSwapDetails.prototype, "toTokenPriceInUSD", void 0);
__decorate$G([
  r$1()
], WuiSwapDetails.prototype, "gasPriceInUSD", void 0);
__decorate$G([
  r$1()
], WuiSwapDetails.prototype, "priceImpact", void 0);
__decorate$G([
  r$1()
], WuiSwapDetails.prototype, "maxSlippage", void 0);
__decorate$G([
  r$1()
], WuiSwapDetails.prototype, "networkTokenSymbol", void 0);
__decorate$G([
  r$1()
], WuiSwapDetails.prototype, "inputError", void 0);
WuiSwapDetails = __decorate$G([
  customElement("cross-w3m-swap-details")
], WuiSwapDetails);
const styles$r = i$4`
  :host > cross-wui-flex {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    border-radius: var(--wui-border-radius-s);
    background-color: var(--wui-color-gray-glass-002);
    padding: var(--wui-spacing-xl);
    padding-right: var(--wui-spacing-s);
    width: 100%;
    height: 100px;
    box-sizing: border-box;
    box-shadow: inset 0px 0px 0px 1px var(--wui-color-gray-glass-002);
    position: relative;
    transition: box-shadow var(--wui-ease-out-power-1) var(--wui-duration-lg);
    will-change: background-color;
  }

  :host wui-flex.focus {
    box-shadow: inset 0px 0px 0px 1px var(--wui-color-gray-glass-005);
  }

  :host > wui-flex .swap-input,
  :host > wui-flex .swap-token-button {
    z-index: 10;
  }

  :host > wui-flex .swap-input {
    -webkit-mask-image: linear-gradient(
      270deg,
      transparent 0px,
      transparent 8px,
      black 24px,
      black 25px,
      black 32px,
      black 100%
    );
    mask-image: linear-gradient(
      270deg,
      transparent 0px,
      transparent 8px,
      black 24px,
      black 25px,
      black 32px,
      black 100%
    );
  }

  :host > wui-flex .swap-input input {
    background: none;
    border: none;
    height: 42px;
    width: 100%;
    font-size: 32px;
    font-style: normal;
    font-weight: 400;
    line-height: 130%;
    letter-spacing: -1.28px;
    outline: none;
    caret-color: var(--wui-color-accent-100);
    color: var(--wui-color-fg-100);
    padding: 0px;
  }

  :host > wui-flex .swap-input input:focus-visible {
    outline: none;
  }

  :host > wui-flex .swap-input input::-webkit-outer-spin-button,
  :host > wui-flex .swap-input input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  .max-value-button {
    background-color: transparent;
    border: none;
    cursor: pointer;
    color: var(--wui-color-gray-glass-020);
    padding-left: 0px;
  }

  .market-value {
    min-height: 18px;
  }
`;
var __decorate$F = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
const MINIMUM_USD_VALUE_TO_CONVERT = 5e-5;
let W3mSwapInput = class W3mSwapInput2 extends i$1 {
  constructor() {
    super(...arguments);
    this.focused = false;
    this.price = 0;
    this.target = "sourceToken";
    this.onSetAmount = null;
    this.onSetMaxValue = null;
  }
  render() {
    const marketValue = this.marketValue || "0";
    const isMarketValueGreaterThanZero = NumberUtil.bigNumber(marketValue).gt("0");
    return x$3`
      <cross-wui-flex class="${this.focused ? "focus" : ""}" justifyContent="space-between">
        <cross-wui-flex
          flex="1"
          flexDirection="column"
          alignItems="flex-start"
          justifyContent="center"
          class="swap-input"
        >
          <input
            data-testid="swap-input-${this.target}"
            @focusin=${() => this.onFocusChange(true)}
            @focusout=${() => this.onFocusChange(false)}
            ?disabled=${this.disabled}
            .value=${this.value}
            @input=${this.dispatchInputChangeEvent}
            @keydown=${this.handleKeydown}
            placeholder="0"
            type="text"
            inputmode="decimal"
          />
          <cross-wui-text class="market-value" variant="small-400" color="fg-200">
            ${isMarketValueGreaterThanZero ? `$${UiHelperUtil.formatNumberToLocalString(this.marketValue, 2)}` : null}
          </cross-wui-text>
        </cross-wui-flex>
        ${this.templateTokenSelectButton()}
      </cross-wui-flex>
    `;
  }
  handleKeydown(event) {
    return InputUtil.numericInputKeyDown(event, this.value, (value) => {
      var _a3;
      return (_a3 = this.onSetAmount) == null ? void 0 : _a3.call(this, this.target, value);
    });
  }
  dispatchInputChangeEvent(event) {
    if (!this.onSetAmount) {
      return;
    }
    const value = event.target.value.replace(/[^0-9.]/gu, "");
    if (value === "," || value === ".") {
      this.onSetAmount(this.target, "0.");
    } else if (value.endsWith(",")) {
      this.onSetAmount(this.target, value.replace(",", "."));
    } else {
      this.onSetAmount(this.target, value);
    }
  }
  setMaxValueToInput() {
    var _a3;
    (_a3 = this.onSetMaxValue) == null ? void 0 : _a3.call(this, this.target, this.balance);
  }
  templateTokenSelectButton() {
    if (!this.token) {
      return x$3` <cross-wui-button
        data-testid="swap-select-token-button-${this.target}"
        class="swap-token-button"
        size="md"
        variant="accent"
        @click=${this.onSelectToken.bind(this)}
      >
        Select token
      </cross-wui-button>`;
    }
    return x$3`
      <cross-wui-flex
        class="swap-token-button"
        flexDirection="column"
        alignItems="flex-end"
        justifyContent="center"
        gap="xxs"
      >
        <cross-wui-token-button
          data-testid="swap-input-token-${this.target}"
          text=${this.token.symbol}
          imageSrc=${this.token.logoUri}
          @click=${this.onSelectToken.bind(this)}
        >
        </cross-wui-token-button>
        <cross-wui-flex alignItems="center" gap="xxs"> ${this.tokenBalanceTemplate()} </cross-wui-flex>
      </cross-wui-flex>
    `;
  }
  tokenBalanceTemplate() {
    const balanceValueInUSD = NumberUtil.multiply(this.balance, this.price);
    const haveBalance = balanceValueInUSD ? balanceValueInUSD == null ? void 0 : balanceValueInUSD.gt(MINIMUM_USD_VALUE_TO_CONVERT) : false;
    return x$3`
      ${haveBalance ? x$3`<cross-wui-text variant="small-400" color="fg-200">
            ${UiHelperUtil.formatNumberToLocalString(this.balance, 2)}
          </cross-wui-text>` : null}
      ${this.target === "sourceToken" ? this.tokenActionButtonTemplate(haveBalance) : null}
    `;
  }
  tokenActionButtonTemplate(haveBalance) {
    if (haveBalance) {
      return x$3` <button class="max-value-button" @click=${this.setMaxValueToInput.bind(this)}>
        <cross-wui-text color="accent-100" variant="small-600">Max</cross-wui-text>
      </button>`;
    }
    return x$3` <button class="max-value-button" @click=${this.onBuyToken.bind(this)}>
      <cross-wui-text color="accent-100" variant="small-600">Buy</cross-wui-text>
    </button>`;
  }
  onFocusChange(state2) {
    this.focused = state2;
  }
  onSelectToken() {
    EventsController.sendEvent({ type: "track", event: "CLICK_SELECT_TOKEN_TO_SWAP" });
    RouterController.push("SwapSelectToken", {
      target: this.target
    });
  }
  onBuyToken() {
    RouterController.push("OnRampProviders");
  }
};
W3mSwapInput.styles = [styles$r];
__decorate$F([
  n$3()
], W3mSwapInput.prototype, "focused", void 0);
__decorate$F([
  n$3()
], W3mSwapInput.prototype, "balance", void 0);
__decorate$F([
  n$3()
], W3mSwapInput.prototype, "value", void 0);
__decorate$F([
  n$3()
], W3mSwapInput.prototype, "price", void 0);
__decorate$F([
  n$3()
], W3mSwapInput.prototype, "marketValue", void 0);
__decorate$F([
  n$3()
], W3mSwapInput.prototype, "disabled", void 0);
__decorate$F([
  n$3()
], W3mSwapInput.prototype, "target", void 0);
__decorate$F([
  n$3()
], W3mSwapInput.prototype, "token", void 0);
__decorate$F([
  n$3()
], W3mSwapInput.prototype, "onSetAmount", void 0);
__decorate$F([
  n$3()
], W3mSwapInput.prototype, "onSetMaxValue", void 0);
W3mSwapInput = __decorate$F([
  customElement("cross-w3m-swap-input")
], W3mSwapInput);
const styles$q = i$4`
  :host {
    width: 100%;
  }

  :host > cross-wui-flex {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    border-radius: var(--wui-border-radius-s);
    padding: var(--wui-spacing-xl);
    padding-right: var(--wui-spacing-s);
    background-color: var(--wui-color-gray-glass-002);
    box-shadow: inset 0px 0px 0px 1px var(--wui-color-gray-glass-002);
    width: 100%;
    height: 100px;
    box-sizing: border-box;
    position: relative;
  }

  wui-shimmer.market-value {
    opacity: 0;
  }

  :host > wui-flex > svg.input_mask {
    position: absolute;
    inset: 0;
    z-index: 5;
  }

  :host wui-flex .input_mask__border,
  :host wui-flex .input_mask__background {
    transition: fill var(--wui-duration-md) var(--wui-ease-out-power-1);
    will-change: fill;
  }

  :host wui-flex .input_mask__border {
    fill: var(--wui-color-gray-glass-020);
  }

  :host wui-flex .input_mask__background {
    fill: var(--wui-color-gray-glass-002);
  }
`;
var __decorate$E = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mSwapInputSkeleton = class W3mSwapInputSkeleton2 extends i$1 {
  constructor() {
    super(...arguments);
    this.target = "sourceToken";
  }
  render() {
    return x$3`
      <cross-wui-flex class justifyContent="space-between">
        <cross-wui-flex
          flex="1"
          flexDirection="column"
          alignItems="flex-start"
          justifyContent="center"
          class="swap-input"
          gap="xxs"
        >
          <cross-wui-shimmer width="80px" height="40px" borderRadius="xxs" variant="light"></cross-wui-shimmer>
        </cross-wui-flex>
        ${this.templateTokenSelectButton()}
      </cross-wui-flex>
    `;
  }
  templateTokenSelectButton() {
    return x$3`
      <cross-wui-flex
        class="swap-token-button"
        flexDirection="column"
        alignItems="flex-end"
        justifyContent="center"
        gap="xxs"
      >
        <cross-wui-shimmer width="80px" height="40px" borderRadius="3xl" variant="light"></cross-wui-shimmer>
      </cross-wui-flex>
    `;
  }
};
W3mSwapInputSkeleton.styles = [styles$q];
__decorate$E([
  n$3()
], W3mSwapInputSkeleton.prototype, "target", void 0);
W3mSwapInputSkeleton = __decorate$E([
  customElement("cross-w3m-swap-input-skeleton")
], W3mSwapInputSkeleton);
const styles$p = i$4`
  :host {
    height: 64px;
  }

  cross-wui-text {
    text-transform: capitalize;
  }

  wui-flex.w3m-header-title {
    transform: translateY(0);
    opacity: 1;
  }

  wui-flex.w3m-header-title[view-direction='prev'] {
    animation:
      slide-down-out 120ms forwards var(--wui-ease-out-power-2),
      slide-down-in 120ms forwards var(--wui-ease-out-power-2);
    animation-delay: 0ms, 200ms;
  }

  wui-flex.w3m-header-title[view-direction='next'] {
    animation:
      slide-up-out 120ms forwards var(--wui-ease-out-power-2),
      slide-up-in 120ms forwards var(--wui-ease-out-power-2);
    animation-delay: 0ms, 200ms;
  }

  wui-icon-link[data-hidden='true'] {
    opacity: 0 !important;
    pointer-events: none;
  }

  @keyframes slide-up-out {
    from {
      transform: translateY(0px);
      opacity: 1;
    }
    to {
      transform: translateY(3px);
      opacity: 0;
    }
  }

  @keyframes slide-up-in {
    from {
      transform: translateY(-3px);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }

  @keyframes slide-down-out {
    from {
      transform: translateY(0px);
      opacity: 1;
    }
    to {
      transform: translateY(-3px);
      opacity: 0;
    }
  }

  @keyframes slide-down-in {
    from {
      transform: translateY(3px);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }
`;
var __decorate$D = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
const BETA_SCREENS = ["SmartSessionList"];
function headings() {
  var _a3, _b2, _c3, _d, _e4, _f, _g;
  const connectorName = (_b2 = (_a3 = RouterController.state.data) == null ? void 0 : _a3.connector) == null ? void 0 : _b2.name;
  const walletName = (_d = (_c3 = RouterController.state.data) == null ? void 0 : _c3.wallet) == null ? void 0 : _d.name;
  const networkName = (_f = (_e4 = RouterController.state.data) == null ? void 0 : _e4.network) == null ? void 0 : _f.name;
  const name = walletName ?? connectorName;
  const connectors = ConnectorController.getConnectors();
  const isEmail = connectors.length === 1 && ((_g = connectors[0]) == null ? void 0 : _g.id) === "w3m-email";
  return {
    Connect: `Connect ${isEmail ? "Email" : ""} Wallet`,
    Create: "Create Wallet",
    ChooseAccountName: void 0,
    Account: void 0,
    AccountSettings: void 0,
    AllWallets: "All Wallets",
    ApproveTransaction: "Approve Transaction",
    BuyInProgress: "Buy",
    ConnectingExternal: name ?? "Connect Wallet",
    ConnectingWalletConnect: name ?? "Cross Connect",
    ConnectingWalletConnectBasic: "Cross Connect",
    ConnectingSiwe: "Sign In",
    Convert: "Convert",
    ConvertSelectToken: "Select token",
    ConvertPreview: "Preview convert",
    Downloads: name ? `Get ${name}` : "Downloads",
    EmailVerifyOtp: "Confirm Email",
    EmailVerifyDevice: "Register Device",
    GetWallet: "Get a wallet",
    Networks: "Choose Network",
    OnRampProviders: "Choose Provider",
    OnRampActivity: "Activity",
    OnRampTokenSelect: "Select Token",
    OnRampFiatSelect: "Select Currency",
    Profile: void 0,
    SwitchNetwork: networkName ?? "Switch Network",
    SwitchAddress: "Switch Address",
    Transactions: "Activity",
    UnsupportedChain: "Switch Network",
    UpgradeEmailWallet: "Upgrade your Wallet",
    UpdateEmailWallet: "Edit Email",
    UpdateEmailPrimaryOtp: "Confirm Current Email",
    UpdateEmailSecondaryOtp: "Confirm New Email",
    WhatIsABuy: "What is Buy?",
    RegisterAccountName: "Choose name",
    RegisterAccountNameSuccess: "",
    WalletReceive: "Receive",
    WalletCompatibleNetworks: "Compatible Networks",
    Swap: "Swap",
    SwapSelectToken: "Select token",
    SwapPreview: "Preview swap",
    WalletSend: "Send",
    WalletSendPreview: "Review send",
    WalletSendSelectToken: "Select Token",
    WhatIsANetwork: "What is a network?",
    WhatIsAWallet: "What is a wallet?",
    ConnectWallets: "Connect wallet",
    ConnectSocials: "All socials",
    ConnectingSocial: AccountController.state.socialProvider ? AccountController.state.socialProvider : "Connect Social",
    ConnectingMultiChain: "Select chain",
    ConnectingFarcaster: "Farcaster",
    SwitchActiveChain: "Switch chain",
    SmartSessionCreated: void 0,
    SmartSessionList: "Smart Sessions",
    SIWXSignMessage: "Sign In"
  };
}
let W3mHeader = class W3mHeader2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.heading = headings()[RouterController.state.view];
    this.network = ChainController.state.activeCaipNetwork;
    this.networkImage = AssetUtil.getNetworkImage(this.network);
    this.buffering = false;
    this.showBack = false;
    this.prevHistoryLength = 1;
    this.view = RouterController.state.view;
    this.viewDirection = "";
    this.headerText = headings()[RouterController.state.view];
    this.unsubscribe.push(AssetController.subscribeNetworkImages(() => {
      this.networkImage = AssetUtil.getNetworkImage(this.network);
    }), RouterController.subscribeKey("view", (val) => {
      setTimeout(() => {
        this.view = val;
        this.headerText = headings()[val];
      }, ConstantsUtil$2.ANIMATION_DURATIONS.HeaderText);
      this.onViewChange();
      this.onHistoryChange();
    }), ConnectionController.subscribeKey("buffering", (val) => this.buffering = val), ChainController.subscribeKey("activeCaipNetwork", (val) => {
      this.network = val;
      this.networkImage = AssetUtil.getNetworkImage(this.network);
    }));
  }
  disconnectCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x$3`
      <cross-wui-flex .padding=${this.getPadding()} justifyContent="space-between" alignItems="center">
        ${this.leftHeaderTemplate()} ${this.titleTemplate()} ${this.rightHeaderTemplate()}
      </cross-wui-flex>
    `;
  }
  onWalletHelp() {
    EventsController.sendEvent({ type: "track", event: "CLICK_WALLET_HELP" });
    RouterController.push("WhatIsAWallet");
  }
  async onClose() {
    const isUnsupportedChain = RouterController.state.view === "UnsupportedChain";
    if (isUnsupportedChain || await SIWXUtil.isSIWXCloseDisabled()) {
      ModalController.shake();
    } else {
      ModalController.close();
    }
  }
  rightHeaderTemplate() {
    var _a3, _b2;
    const isSmartSessionsEnabled = (_b2 = (_a3 = OptionsController == null ? void 0 : OptionsController.state) == null ? void 0 : _a3.features) == null ? void 0 : _b2.smartSessions;
    if (RouterController.state.view !== "Account" || !isSmartSessionsEnabled) {
      return this.closeButtonTemplate();
    }
    return x$3`<cross-wui-flex>
      <cross-wui-icon-link
        icon="clock"
        @click=${() => RouterController.push("SmartSessionList")}
        data-testid="cross-w3m-header-smart-sessions"
      ></cross-wui-icon-link>
      ${this.closeButtonTemplate()}
    </cross-wui-flex> `;
  }
  closeButtonTemplate() {
    return x$3`
      <cross-wui-icon-link
        ?disabled=${this.buffering}
        icon="close"
        @click=${this.onClose.bind(this)}
        data-testid="cross-w3m-header-close"
      ></cross-wui-icon-link>
    `;
  }
  titleTemplate() {
    const isBeta = BETA_SCREENS.includes(this.view);
    return x$3`
      <cross-wui-flex
        view-direction="${this.viewDirection}"
        class="w3m-header-title"
        alignItems="center"
        gap="xs"
      >
        <cross-wui-text variant="paragraph-700" color="fg-100" data-testid="cross-w3m-header-text"
          >${this.headerText}</wui-text
        >
        ${isBeta ? x$3`<cross-wui-tag variant="main">Beta</cross-wui-tag>` : null}
      </cross-wui-flex>
    `;
  }
  leftHeaderTemplate() {
    var _a3;
    const { view } = RouterController.state;
    const isConnectHelp = false;
    OptionsController.state.enableEmbedded;
    const isApproveTransaction = view === "ApproveTransaction";
    const isConnectingSIWEView = view === "ConnectingSiwe";
    const isAccountView = view === "Account";
    const shouldHideBack = isApproveTransaction || isConnectingSIWEView || isConnectHelp;
    if (isAccountView) {
      return x$3`<cross-wui-select
        id="dynamic"
        data-testid="cross-w3m-account-select-network"
        active-network=${o$2((_a3 = this.network) == null ? void 0 : _a3.name)}
        @click=${this.onNetworks.bind(this)}
        imageSrc=${o$2(this.networkImage)}
      ></cross-wui-select>`;
    }
    if (this.showBack && !shouldHideBack) {
      return x$3`<cross-wui-icon-link
        data-testid="header-back"
        id="dynamic"
        icon="chevronLeft"
        ?disabled=${this.buffering}
        @click=${this.onGoBack.bind(this)}
      ></cross-wui-icon-link>`;
    }
    return x$3`<cross-wui-icon-link
      data-hidden=${!isConnectHelp}
      id="dynamic"
      icon="helpCircle"
      @click=${this.onWalletHelp.bind(this)}
    ></cross-wui-icon-link>`;
  }
  onNetworks() {
    if (this.isAllowedNetworkSwitch()) {
      EventsController.sendEvent({ type: "track", event: "CLICK_NETWORKS" });
      RouterController.push("Networks");
    }
  }
  isAllowedNetworkSwitch() {
    const requestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
    const isMultiNetwork = requestedCaipNetworks ? requestedCaipNetworks.length > 1 : false;
    const isValidNetwork = requestedCaipNetworks == null ? void 0 : requestedCaipNetworks.find(({ id: id2 }) => {
      var _a3;
      return id2 === ((_a3 = this.network) == null ? void 0 : _a3.id);
    });
    return isMultiNetwork || !isValidNetwork;
  }
  getPadding() {
    if (this.heading) {
      return ["l", "2l", "l", "2l"];
    }
    return ["0", "2l", "0", "2l"];
  }
  onViewChange() {
    const { history } = RouterController.state;
    let direction = ConstantsUtil$2.VIEW_DIRECTION.Next;
    if (history.length < this.prevHistoryLength) {
      direction = ConstantsUtil$2.VIEW_DIRECTION.Prev;
    }
    this.prevHistoryLength = history.length;
    this.viewDirection = direction;
  }
  async onHistoryChange() {
    var _a3;
    const { history } = RouterController.state;
    const buttonEl = (_a3 = this.shadowRoot) == null ? void 0 : _a3.querySelector("#dynamic");
    if (history.length > 1 && !this.showBack && buttonEl) {
      await buttonEl.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.showBack = true;
      buttonEl.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    } else if (history.length <= 1 && this.showBack && buttonEl) {
      await buttonEl.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.showBack = false;
      buttonEl.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  onGoBack() {
    RouterController.goBack();
  }
};
W3mHeader.styles = styles$p;
__decorate$D([
  r$1()
], W3mHeader.prototype, "heading", void 0);
__decorate$D([
  r$1()
], W3mHeader.prototype, "network", void 0);
__decorate$D([
  r$1()
], W3mHeader.prototype, "networkImage", void 0);
__decorate$D([
  r$1()
], W3mHeader.prototype, "buffering", void 0);
__decorate$D([
  r$1()
], W3mHeader.prototype, "showBack", void 0);
__decorate$D([
  r$1()
], W3mHeader.prototype, "prevHistoryLength", void 0);
__decorate$D([
  r$1()
], W3mHeader.prototype, "view", void 0);
__decorate$D([
  r$1()
], W3mHeader.prototype, "viewDirection", void 0);
__decorate$D([
  r$1()
], W3mHeader.prototype, "headerText", void 0);
W3mHeader = __decorate$D([
  customElement("cross-w3m-header")
], W3mHeader);
var __decorate$C = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mHelpWidget = class W3mHelpWidget2 extends i$1 {
  constructor() {
    super(...arguments);
    this.data = [];
  }
  render() {
    return x$3`
      <cross-wui-flex flexDirection="column" alignItems="center" gap="l">
        ${this.data.map((item) => x$3`
            <cross-wui-flex flexDirection="column" alignItems="center" gap="xl">
              <cross-wui-flex flexDirection="row" justifyContent="center" gap="1xs">
                ${item.images.map((image) => x$3`<cross-wui-visual name=${image}></cross-wui-visual>`)}
              </cross-wui-flex>
            </cross-wui-flex>
            <cross-wui-flex flexDirection="column" alignItems="center" gap="xxs">
              <cross-wui-text variant="paragraph-500" color="fg-100" align="center">
                ${item.title}
              </cross-wui-text>
              <cross-wui-text variant="small-500" color="fg-200" align="center">${item.text}</cross-wui-text>
            </cross-wui-flex>
          `)}
      </cross-wui-flex>
    `;
  }
};
__decorate$C([
  n$3({ type: Array })
], W3mHelpWidget.prototype, "data", void 0);
W3mHelpWidget = __decorate$C([
  customElement("cross-w3m-help-widget")
], W3mHelpWidget);
const styles$o = i$4`
  :host {
    width: 100%;
  }

  :host > cross-wui-flex {
    width: 100%;
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xs);
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: var(--wui-spacing-s);
  }

  :host > wui-flex:hover {
    background-color: var(--wui-color-gray-glass-002);
  }

  .purchase-image-container {
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    width: var(--wui-icon-box-size-lg);
    height: var(--wui-icon-box-size-lg);
  }

  .purchase-image-container cross-wui-image {
    width: 100%;
    height: 100%;
    position: relative;
    border-radius: calc(var(--wui-icon-box-size-lg) / 2);
  }

  .purchase-image-container wui-image::after {
    content: '';
    display: block;
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
    border-radius: calc(var(--wui-icon-box-size-lg) / 2);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  .purchase-image-container cross-wui-icon-box {
    position: absolute;
    right: 0;
    bottom: 0;
    transform: translate(20%, 20%);
  }
`;
var __decorate$B = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mOnRampActivityItem = class W3mOnRampActivityItem2 extends i$1 {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.color = "inherit";
    this.label = "Bought";
    this.purchaseValue = "";
    this.purchaseCurrency = "";
    this.date = "";
    this.completed = false;
    this.inProgress = false;
    this.failed = false;
    this.onClick = null;
    this.symbol = "";
  }
  firstUpdated() {
    if (!this.icon) {
      this.fetchTokenImage();
    }
  }
  render() {
    return x$3`
      <cross-wui-flex>
        ${this.imageTemplate()}
        <cross-wui-flex flexDirection="column" gap="4xs" flexGrow="1">
          <cross-wui-flex gap="xxs" alignItems="center" justifyContent="flex-start">
            ${this.statusIconTemplate()}
            <cross-wui-text variant="paragraph-500" color="fg-100"> ${this.label}</cross-wui-text>
          </cross-wui-flex>
          <cross-wui-text variant="small-400" color="fg-200">
            + ${this.purchaseValue} ${this.purchaseCurrency}
          </cross-wui-text>
        </cross-wui-flex>
        ${this.inProgress ? x$3`<cross-wui-loading-spinner color="fg-200" size="md"></cross-wui-loading-spinner>` : x$3`<cross-wui-text variant="micro-700" color="fg-300"><span>${this.date}</span></cross-wui-text>`}
      </cross-wui-flex>
    `;
  }
  async fetchTokenImage() {
    await ApiController$1._fetchTokenImage(this.purchaseCurrency);
  }
  statusIconTemplate() {
    if (this.inProgress) {
      return null;
    }
    return this.completed ? this.boughtIconTemplate() : this.errorIconTemplate();
  }
  errorIconTemplate() {
    return x$3`<cross-wui-icon-box
      size="xxs"
      iconColor="error-100"
      backgroundColor="error-100"
      background="opaque"
      icon="close"
      borderColor="wui-color-bg-125"
    ></cross-wui-icon-box>`;
  }
  imageTemplate() {
    const icon = this.icon || `https://avatar.vercel.sh/andrew.svg?size=50&text=${this.symbol}`;
    return x$3`<cross-wui-flex class="purchase-image-container">
      <cross-wui-image src=${icon}></cross-wui-image>
    </cross-wui-flex>`;
  }
  boughtIconTemplate() {
    return x$3`<cross-wui-icon-box
      size="xxs"
      iconColor="success-100"
      backgroundColor="success-100"
      background="opaque"
      icon="arrowBottom"
      borderColor="wui-color-bg-125"
    ></cross-wui-icon-box>`;
  }
};
W3mOnRampActivityItem.styles = [styles$o];
__decorate$B([
  n$3({ type: Boolean })
], W3mOnRampActivityItem.prototype, "disabled", void 0);
__decorate$B([
  n$3()
], W3mOnRampActivityItem.prototype, "color", void 0);
__decorate$B([
  n$3()
], W3mOnRampActivityItem.prototype, "label", void 0);
__decorate$B([
  n$3()
], W3mOnRampActivityItem.prototype, "purchaseValue", void 0);
__decorate$B([
  n$3()
], W3mOnRampActivityItem.prototype, "purchaseCurrency", void 0);
__decorate$B([
  n$3()
], W3mOnRampActivityItem.prototype, "date", void 0);
__decorate$B([
  n$3({ type: Boolean })
], W3mOnRampActivityItem.prototype, "completed", void 0);
__decorate$B([
  n$3({ type: Boolean })
], W3mOnRampActivityItem.prototype, "inProgress", void 0);
__decorate$B([
  n$3({ type: Boolean })
], W3mOnRampActivityItem.prototype, "failed", void 0);
__decorate$B([
  n$3()
], W3mOnRampActivityItem.prototype, "onClick", void 0);
__decorate$B([
  n$3()
], W3mOnRampActivityItem.prototype, "symbol", void 0);
__decorate$B([
  n$3()
], W3mOnRampActivityItem.prototype, "icon", void 0);
W3mOnRampActivityItem = __decorate$B([
  customElement("cross-w3m-onramp-activity-item")
], W3mOnRampActivityItem);
const styles$n = i$4`
  :host {
    width: 100%;
  }

  cross-wui-loading-spinner {
    position: absolute;
    top: 50%;
    right: 20px;
    transform: translateY(-50%);
  }

  .currency-container {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    right: var(--wui-spacing-1xs);
    height: 40px;
    padding: var(--wui-spacing-xs) var(--wui-spacing-1xs) var(--wui-spacing-xs)
      var(--wui-spacing-xs);
    min-width: 95px;
    border-radius: var(--FULL, 1000px);
    border: 1px solid var(--wui-color-gray-glass-002);
    background: var(--wui-color-gray-glass-002);
    cursor: pointer;
  }

  .currency-container > cross-wui-image {
    height: 24px;
    width: 24px;
    border-radius: 50%;
  }
`;
var __decorate$A = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mInputCurrency = class W3mInputCurrency2 extends i$1 {
  constructor() {
    var _a3;
    super();
    this.unsubscribe = [];
    this.type = "Token";
    this.value = 0;
    this.currencies = [];
    this.selectedCurrency = (_a3 = this.currencies) == null ? void 0 : _a3[0];
    this.currencyImages = AssetController.state.currencyImages;
    this.tokenImages = AssetController.state.tokenImages;
    this.unsubscribe.push(OnRampController.subscribeKey("purchaseCurrency", (val) => {
      if (!val || this.type === "Fiat") {
        return;
      }
      this.selectedCurrency = this.formatPurchaseCurrency(val);
    }), OnRampController.subscribeKey("paymentCurrency", (val) => {
      if (!val || this.type === "Token") {
        return;
      }
      this.selectedCurrency = this.formatPaymentCurrency(val);
    }), OnRampController.subscribe((val) => {
      if (this.type === "Fiat") {
        this.currencies = val.purchaseCurrencies.map(this.formatPurchaseCurrency);
      } else {
        this.currencies = val.paymentCurrencies.map(this.formatPaymentCurrency);
      }
    }), AssetController.subscribe((val) => {
      this.currencyImages = { ...val.currencyImages };
      this.tokenImages = { ...val.tokenImages };
    }));
  }
  firstUpdated() {
    OnRampController.getAvailableCurrencies();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a3;
    const symbol = ((_a3 = this.selectedCurrency) == null ? void 0 : _a3.symbol) || "";
    const image = this.currencyImages[symbol] || this.tokenImages[symbol];
    return x$3`<cross-wui-input-text type="number" size="lg" value=${this.value}>
      ${this.selectedCurrency ? x$3` <cross-wui-flex
            class="currency-container"
            justifyContent="space-between"
            alignItems="center"
            gap="xxs"
            @click=${() => ModalController.open({ view: `OnRamp${this.type}Select` })}
          >
            <cross-wui-image src=${o$2(image)}></cross-wui-image>
            <cross-wui-text color="fg-100">${this.selectedCurrency.symbol}</cross-wui-text>
          </cross-wui-flex>` : x$3`<cross-wui-loading-spinner></cross-wui-loading-spinner>`}
    </cross-wui-input-text>`;
  }
  formatPaymentCurrency(currency) {
    return {
      name: currency.id,
      symbol: currency.id
    };
  }
  formatPurchaseCurrency(currency) {
    return {
      name: currency.name,
      symbol: currency.symbol
    };
  }
};
W3mInputCurrency.styles = styles$n;
__decorate$A([
  n$3({ type: String })
], W3mInputCurrency.prototype, "type", void 0);
__decorate$A([
  n$3({ type: Number })
], W3mInputCurrency.prototype, "value", void 0);
__decorate$A([
  r$1()
], W3mInputCurrency.prototype, "currencies", void 0);
__decorate$A([
  r$1()
], W3mInputCurrency.prototype, "selectedCurrency", void 0);
__decorate$A([
  r$1()
], W3mInputCurrency.prototype, "currencyImages", void 0);
__decorate$A([
  r$1()
], W3mInputCurrency.prototype, "tokenImages", void 0);
W3mInputCurrency = __decorate$A([
  customElement("cross-w3m-onramp-input")
], W3mInputCurrency);
const styles$m = i$4`
  button {
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xs);
    border: none;
    outline: none;
    background-color: var(--wui-color-gray-glass-002);
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: var(--wui-spacing-s);
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color;
  }

  button:hover {
    background-color: var(--wui-color-gray-glass-005);
  }

  .provider-image {
    width: var(--wui-spacing-3xl);
    min-width: var(--wui-spacing-3xl);
    height: var(--wui-spacing-3xl);
    border-radius: calc(var(--wui-border-radius-xs) - calc(var(--wui-spacing-s) / 2));
    position: relative;
    overflow: hidden;
  }

  .provider-image::after {
    content: '';
    display: block;
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
    border-radius: calc(var(--wui-border-radius-xs) - calc(var(--wui-spacing-s) / 2));
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  .network-icon {
    width: var(--wui-spacing-m);
    height: var(--wui-spacing-m);
    border-radius: calc(var(--wui-spacing-m) / 2);
    overflow: hidden;
    box-shadow:
      0 0 0 3px var(--wui-color-gray-glass-002),
      0 0 0 3px var(--wui-color-modal-bg);
    transition: box-shadow var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: box-shadow;
  }

  button:hover .network-icon {
    box-shadow:
      0 0 0 3px var(--wui-color-gray-glass-005),
      0 0 0 3px var(--wui-color-modal-bg);
  }
`;
var __decorate$z = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mOnRampProviderItem = class W3mOnRampProviderItem2 extends i$1 {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.color = "inherit";
    this.label = "";
    this.feeRange = "";
    this.loading = false;
    this.onClick = null;
  }
  render() {
    return x$3`
      <button ?disabled=${this.disabled}>
        <cross-wui-visual name=${o$2(this.name)} class="provider-image"></cross-wui-visual>
        <cross-wui-flex flexDirection="column" gap="4xs">
          <cross-wui-text variant="paragraph-500" color="fg-100">${this.label}</cross-wui-text>
          <cross-wui-flex alignItems="center" justifyContent="flex-start" gap="l">
            <cross-wui-text variant="tiny-500" color="fg-100">
              <cross-wui-text variant="tiny-400" color="fg-200">Fees</cross-wui-text>
              ${this.feeRange}
            </cross-wui-text>
            <cross-wui-flex gap="xxs">
              <cross-wui-icon name="bank" size="xs" color="fg-150"></cross-wui-icon>
              <cross-wui-icon name="card" size="xs" color="fg-150"></cross-wui-icon>
            </cross-wui-flex>
            ${this.networksTemplate()}
          </cross-wui-flex>
        </cross-wui-flex>
        ${this.loading ? x$3`<cross-wui-loading-spinner color="fg-200" size="md"></cross-wui-loading-spinner>` : x$3`<cross-wui-icon name="chevronRight" color="fg-200" size="sm"></cross-wui-icon>`}
      </button>
    `;
  }
  networksTemplate() {
    var _a3;
    const requestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
    const slicedNetworks = (_a3 = requestedCaipNetworks == null ? void 0 : requestedCaipNetworks.filter((network) => {
      var _a4;
      return (_a4 = network == null ? void 0 : network.assets) == null ? void 0 : _a4.imageId;
    })) == null ? void 0 : _a3.slice(0, 5);
    return x$3`
      <cross-wui-flex class="networks">
        ${slicedNetworks == null ? void 0 : slicedNetworks.map((network) => x$3`
            <cross-wui-flex class="network-icon">
              <cross-wui-image src=${o$2(AssetUtil.getNetworkImage(network))}></cross-wui-image>
            </cross-wui-flex>
          `)}
      </cross-wui-flex>
    `;
  }
};
W3mOnRampProviderItem.styles = [styles$m];
__decorate$z([
  n$3({ type: Boolean })
], W3mOnRampProviderItem.prototype, "disabled", void 0);
__decorate$z([
  n$3()
], W3mOnRampProviderItem.prototype, "color", void 0);
__decorate$z([
  n$3()
], W3mOnRampProviderItem.prototype, "name", void 0);
__decorate$z([
  n$3()
], W3mOnRampProviderItem.prototype, "label", void 0);
__decorate$z([
  n$3()
], W3mOnRampProviderItem.prototype, "feeRange", void 0);
__decorate$z([
  n$3({ type: Boolean })
], W3mOnRampProviderItem.prototype, "loading", void 0);
__decorate$z([
  n$3()
], W3mOnRampProviderItem.prototype, "onClick", void 0);
W3mOnRampProviderItem = __decorate$z([
  customElement("cross-w3m-onramp-provider-item")
], W3mOnRampProviderItem);
const styles$l = i$4`
  cross-wui-flex {
    background-color: var(--wui-color-gray-glass-005);
  }

  a {
    text-decoration: none;
    color: var(--wui-color-fg-175);
    font-weight: 500;
  }
`;
var __decorate$y = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mLegalFooter = class W3mLegalFooter2 extends i$1 {
  render() {
    var _a3;
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    const legalCheckbox = (_a3 = OptionsController.state.features) == null ? void 0 : _a3.legalCheckbox;
    if (!termsConditionsUrl && !privacyPolicyUrl) {
      return null;
    }
    if (legalCheckbox) {
      return null;
    }
    return x$3`
      <cross-wui-flex .padding=${["m", "s", "s", "s"]} justifyContent="center">
        <cross-wui-text color="fg-250" variant="small-400" align="center">
          By connecting your wallet, you agree to our <br />
          ${this.termsTemplate()} ${this.andTemplate()} ${this.privacyTemplate()}
        </cross-wui-text>
      </cross-wui-flex>
    `;
  }
  andTemplate() {
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    return termsConditionsUrl && privacyPolicyUrl ? "and" : "";
  }
  termsTemplate() {
    const { termsConditionsUrl } = OptionsController.state;
    if (!termsConditionsUrl) {
      return null;
    }
    return x$3`<a href=${termsConditionsUrl}>Terms of Service</a>`;
  }
  privacyTemplate() {
    const { privacyPolicyUrl } = OptionsController.state;
    if (!privacyPolicyUrl) {
      return null;
    }
    return x$3`<a href=${privacyPolicyUrl}>Privacy Policy</a>`;
  }
};
W3mLegalFooter.styles = [styles$l];
W3mLegalFooter = __decorate$y([
  customElement("cross-w3m-legal-footer")
], W3mLegalFooter);
const styles$k = i$4`
  :host {
    display: flex;
    align-items: center;
    justify-content: center;
  }
  cross-wui-checkbox {
    padding: var(--wui-spacing-s);
  }
  a {
    text-decoration: none;
    color: var(--wui-color-fg-150);
    font-weight: 500;
  }
`;
var __decorate$x = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mLegalCheckbox = class W3mLegalCheckbox2 extends i$1 {
  render() {
    var _a3;
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    const legalCheckbox = (_a3 = OptionsController.state.features) == null ? void 0 : _a3.legalCheckbox;
    if (!termsConditionsUrl && !privacyPolicyUrl) {
      return null;
    }
    if (!legalCheckbox) {
      return null;
    }
    return x$3`
      <cross-wui-checkbox data-testid="wui-checkbox">
        <cross-wui-text color="fg-250" variant="small-400" align="left">
          I agree to our ${this.termsTemplate()} ${this.andTemplate()} ${this.privacyTemplate()}
        </cross-wui-text>
      </cross-wui-checkbox>
    `;
  }
  andTemplate() {
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    return termsConditionsUrl && privacyPolicyUrl ? "and" : "";
  }
  termsTemplate() {
    const { termsConditionsUrl } = OptionsController.state;
    if (!termsConditionsUrl) {
      return null;
    }
    return x$3`<a rel="noreferrer" target="_blank" href=${termsConditionsUrl}>terms of service</a>`;
  }
  privacyTemplate() {
    const { privacyPolicyUrl } = OptionsController.state;
    if (!privacyPolicyUrl) {
      return null;
    }
    return x$3`<a rel="noreferrer" target="_blank" href=${privacyPolicyUrl}>privacy policy</a>`;
  }
};
W3mLegalCheckbox.styles = [styles$k];
W3mLegalCheckbox = __decorate$x([
  customElement("cross-w3m-legal-checkbox")
], W3mLegalCheckbox);
const styles$j = i$4`
  cross-wui-flex {
    border-top: 1px solid var(--wui-color-gray-glass-005);
  }

  a {
    text-decoration: none;
    color: var(--wui-color-fg-175);
    font-weight: 500;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--wui-spacing-3xs);
  }
`;
var __decorate$w = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mOnRampProvidersFooter = class W3mOnRampProvidersFooter2 extends i$1 {
  render() {
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    if (!termsConditionsUrl && !privacyPolicyUrl) {
      return null;
    }
    return x$3`
      <cross-wui-flex
        .padding=${["m", "s", "s", "s"]}
        flexDirection="column"
        alignItems="center"
        justifyContent="center"
        gap="s"
      >
        <cross-wui-text color="fg-250" variant="small-400" align="center">
          We work with the best providers to give you the lowest fees and best support. More options
          coming soon!
        </cross-wui-text>

        ${this.howDoesItWorkTemplate()}
      </cross-wui-flex>
    `;
  }
  howDoesItWorkTemplate() {
    return x$3` <cross-wui-link @click=${this.onWhatIsBuy.bind(this)}>
      <cross-wui-icon size="xs" color="accent-100" slot="iconLeft" name="helpCircle"></cross-wui-icon>
      How does it work?
    </cross-wui-link>`;
  }
  onWhatIsBuy() {
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WHAT_IS_A_BUY",
      properties: {
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
    RouterController.push("WhatIsABuy");
  }
};
W3mOnRampProvidersFooter.styles = [styles$j];
W3mOnRampProvidersFooter = __decorate$w([
  customElement("cross-w3m-onramp-providers-footer")
], W3mOnRampProvidersFooter);
const styles$i = i$4`
  :host {
    display: block;
    position: absolute;
    opacity: 0;
    pointer-events: none;
    top: 11px;
    left: 50%;
    width: max-content;
  }
`;
var __decorate$v = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
const presets$1 = {
  loading: void 0,
  success: {
    backgroundColor: "success-100",
    iconColor: "success-100",
    icon: "checkmark"
  },
  error: {
    backgroundColor: "error-100",
    iconColor: "error-100",
    icon: "close"
  }
};
let W3mSnackBar = class W3mSnackBar2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.timeout = void 0;
    this.open = SnackController.state.open;
    this.unsubscribe.push(SnackController.subscribeKey("open", (val) => {
      this.open = val;
      this.onOpen();
    }));
  }
  disconnectedCallback() {
    clearTimeout(this.timeout);
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const { message, variant, svg } = SnackController.state;
    const preset = presets$1[variant];
    const { icon, iconColor } = svg ?? preset ?? {};
    return x$3`
      <cross-wui-snackbar
        message=${message}
        backgroundColor=${preset == null ? void 0 : preset.backgroundColor}
        iconColor=${iconColor}
        icon=${icon}
        .loading=${variant === "loading"}
      ></cross-wui-snackbar>
    `;
  }
  onOpen() {
    clearTimeout(this.timeout);
    if (this.open) {
      this.animate([
        { opacity: 0, transform: "translateX(-50%) scale(0.85)" },
        { opacity: 1, transform: "translateX(-50%) scale(1)" }
      ], {
        duration: 150,
        fill: "forwards",
        easing: "ease"
      });
      if (this.timeout) {
        clearTimeout(this.timeout);
      }
      if (SnackController.state.autoClose) {
        this.timeout = setTimeout(() => SnackController.hide(), 2500);
      }
    } else {
      this.animate([
        { opacity: 1, transform: "translateX(-50%) scale(1)" },
        { opacity: 0, transform: "translateX(-50%) scale(0.85)" }
      ], {
        duration: 150,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
};
W3mSnackBar.styles = styles$i;
__decorate$v([
  r$1()
], W3mSnackBar.prototype, "open", void 0);
W3mSnackBar = __decorate$v([
  customElement("cross-w3m-snackbar")
], W3mSnackBar);
const styles$h = i$4`
  :host {
    display: block;
    position: absolute;
    top: var(--wui-spacing-s);
    left: var(--wui-spacing-l);
    right: var(--wui-spacing-l);
    opacity: 0;
    pointer-events: none;
  }
`;
var __decorate$u = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
const presets = {
  info: {
    backgroundColor: "fg-350",
    iconColor: "fg-325",
    icon: "info"
  },
  success: {
    backgroundColor: "success-glass-reown-020",
    iconColor: "success-125",
    icon: "checkmark"
  },
  warning: {
    backgroundColor: "warning-glass-reown-020",
    iconColor: "warning-100",
    icon: "warningCircle"
  },
  error: {
    backgroundColor: "error-glass-reown-020",
    iconColor: "error-125",
    icon: "exclamationTriangle"
  }
};
let W3mAlertBar = class W3mAlertBar2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.open = AlertController.state.open;
    this.onOpen(true);
    this.unsubscribe.push(AlertController.subscribeKey("open", (val) => {
      this.open = val;
      this.onOpen(false);
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const { message, variant } = AlertController.state;
    const preset = presets[variant];
    return x$3`
      <cross-wui-alertbar
        message=${message}
        backgroundColor=${preset == null ? void 0 : preset.backgroundColor}
        iconColor=${preset == null ? void 0 : preset.iconColor}
        icon=${preset == null ? void 0 : preset.icon}
      ></cross-wui-alertbar>
    `;
  }
  onOpen(isMounted) {
    if (this.open) {
      this.animate([
        { opacity: 0, transform: "scale(0.85)" },
        { opacity: 1, transform: "scale(1)" }
      ], {
        duration: 150,
        fill: "forwards",
        easing: "ease"
      });
      this.style.cssText = `pointer-events: auto`;
    } else if (!isMounted) {
      this.animate([
        { opacity: 1, transform: "scale(1)" },
        { opacity: 0, transform: "scale(0.85)" }
      ], {
        duration: 150,
        fill: "forwards",
        easing: "ease"
      });
      this.style.cssText = `pointer-events: none`;
    }
  }
};
W3mAlertBar.styles = styles$h;
__decorate$u([
  r$1()
], W3mAlertBar.prototype, "open", void 0);
W3mAlertBar = __decorate$u([
  customElement("cross-w3m-alertbar")
], W3mAlertBar);
const styles$g = i$4`
  cross-wui-separator {
    margin: var(--wui-spacing-s) calc(var(--wui-spacing-s) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }

  cross-wui-email-input {
    width: 100%;
  }

  form {
    width: 100%;
    display: block;
    position: relative;
  }

  cross-wui-icon-link,
  cross-wui-loading-spinner {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
  }

  cross-wui-icon-link {
    right: var(--wui-spacing-xs);
  }

  cross-wui-loading-spinner {
    right: var(--wui-spacing-m);
  }

  cross-wui-text {
    margin: var(--wui-spacing-xxs) var(--wui-spacing-m) var(--wui-spacing-0) var(--wui-spacing-m);
  }
`;
var __decorate$t = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mEmailLoginWidget = class W3mEmailLoginWidget2 extends i$1 {
  constructor() {
    super(...arguments);
    this.unsubscribe = [];
    this.formRef = e();
    this.email = "";
    this.loading = false;
    this.error = "";
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  firstUpdated() {
    var _a3;
    (_a3 = this.formRef.value) == null ? void 0 : _a3.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        this.onSubmitEmail(event);
      }
    });
  }
  render() {
    return x$3`
      <form ${n$1(this.formRef)} @submit=${this.onSubmitEmail.bind(this)}>
        <cross-wui-email-input
          @focus=${this.onFocusEvent.bind(this)}
          .disabled=${this.loading}
          @inputChange=${this.onEmailInputChange.bind(this)}
          tabIdx=${o$2(this.tabIdx)}
        >
        </cross-wui-email-input>

        ${this.submitButtonTemplate()}${this.loadingTemplate()}
        <input type="submit" hidden />
      </form>
      ${this.templateError()}
    `;
  }
  submitButtonTemplate() {
    const showSubmit = !this.loading && this.email.length > 3;
    return showSubmit ? x$3`
          <cross-wui-icon-link
            size="sm"
            icon="chevronRight"
            iconcolor="accent-100"
            @click=${this.onSubmitEmail.bind(this)}
          >
          </cross-wui-icon-link>
        ` : null;
  }
  loadingTemplate() {
    return this.loading ? x$3`<cross-wui-loading-spinner size="md" color="accent-100"></cross-wui-loading-spinner>` : null;
  }
  templateError() {
    if (this.error) {
      return x$3`<cross-wui-text variant="tiny-500" color="error-100">${this.error}</cross-wui-text>`;
    }
    return null;
  }
  onEmailInputChange(event) {
    this.email = event.detail.trim();
    this.error = "";
  }
  async onSubmitEmail(event) {
    const isAvailableChain = ConstantsUtil$4.AUTH_CONNECTOR_SUPPORTED_CHAINS.find((chain) => chain === ChainController.state.activeChain);
    if (!isAvailableChain) {
      const caipNetwork = ChainController.getFirstCaipNetworkSupportsAuthConnector();
      if (caipNetwork) {
        RouterController.push("SwitchNetwork", { network: caipNetwork });
        return;
      }
    }
    try {
      if (this.loading) {
        return;
      }
      this.loading = true;
      event.preventDefault();
      const authConnector = ConnectorController.getAuthConnector();
      if (!authConnector) {
        throw new Error("cross-w3m-email-login-widget: Auth connector not found");
      }
      const { action } = await authConnector.provider.connectEmail({ email: this.email });
      EventsController.sendEvent({ type: "track", event: "EMAIL_SUBMITTED" });
      if (action === "VERIFY_OTP") {
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_SENT" });
        RouterController.push("EmailVerifyOtp", { email: this.email });
      } else if (action === "VERIFY_DEVICE") {
        RouterController.push("EmailVerifyDevice", { email: this.email });
      } else if (action === "CONNECT") {
        await ConnectionController.connectExternal(authConnector, ChainController.state.activeChain);
        RouterController.replace("Account");
      }
    } catch (error) {
      const parsedError = CoreHelperUtil.parseError(error);
      if (parsedError == null ? void 0 : parsedError.includes("Invalid email")) {
        this.error = "Invalid email. Try again.";
      } else {
        SnackController.showError(error);
      }
    } finally {
      this.loading = false;
    }
  }
  onFocusEvent() {
    EventsController.sendEvent({ type: "track", event: "EMAIL_LOGIN_SELECTED" });
  }
};
W3mEmailLoginWidget.styles = styles$g;
__decorate$t([
  n$3()
], W3mEmailLoginWidget.prototype, "tabIdx", void 0);
__decorate$t([
  r$1()
], W3mEmailLoginWidget.prototype, "email", void 0);
__decorate$t([
  r$1()
], W3mEmailLoginWidget.prototype, "loading", void 0);
__decorate$t([
  r$1()
], W3mEmailLoginWidget.prototype, "error", void 0);
W3mEmailLoginWidget = __decorate$t([
  customElement("cross-w3m-email-login-widget")
], W3mEmailLoginWidget);
const styles$f = i$4`
  cross-wui-flex {
    width: 100%;
  }

  :host > wui-flex:first-child {
    transform: translateY(calc(var(--wui-spacing-xxs) * -1));
  }

  cross-wui-icon-link {
    margin-right: calc(var(--wui-icon-box-size-md) * -1);
  }

  cross-wui-notice-card {
    margin-bottom: var(--wui-spacing-3xs);
  }

  wui-list-item > cross-wui-text {
    flex: 1;
  }

  cro-transactions-view {
    max-height: 200px;
  }

  .tab-content-container {
    height: 300px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }

  .tab-content-container::-webkit-scrollbar {
    display: none;
  }

  .account-button {
    width: auto;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--wui-spacing-s);
    height: 48px;
    padding: var(--wui-spacing-xs);
    padding-right: var(--wui-spacing-s);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    background-color: var(--wui-color-gray-glass-002);
    border-radius: 24px;
    transition: background-color 0.2s linear;
  }

  .account-button:hover {
    background-color: var(--wui-color-gray-glass-005);
  }

  .avatar-container {
    position: relative;
  }

  wui-avatar.avatar {
    width: 32px;
    height: 32px;
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
  }

  wui-avatar.network-avatar {
    width: 16px;
    height: 16px;
    position: absolute;
    left: 100%;
    top: 100%;
    transform: translate(-75%, -75%);
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
  }

  .account-links {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .account-links cross-wui-flex {
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    flex: 1;
    background: red;
    align-items: center;
    justify-content: center;
    height: 48px;
    padding: 10px;
    flex: 1 0 0;
    border-radius: var(--XS, 16px);
    border: 1px solid var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    background: var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    transition:
      background-color var(--wui-ease-out-power-1) var(--wui-duration-md),
      opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color, opacity;
  }

  .account-links wui-flex:hover {
    background: var(--dark-accent-glass-015, rgba(71, 161, 255, 0.15));
  }

  .account-links wui-flex cross-wui-icon {
    width: var(--S, 20px);
    height: var(--S, 20px);
  }

  .account-links wui-flex wui-icon svg path {
    stroke: #667dff;
  }
`;
var __decorate$s = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mAccountDefaultWidget = class W3mAccountDefaultWidget2 extends i$1 {
  constructor() {
    var _a3;
    super();
    this.unsubscribe = [];
    this.caipAddress = AccountController.state.caipAddress;
    this.address = CoreHelperUtil.getPlainAddress(AccountController.state.caipAddress);
    this.allAccounts = AccountController.state.allAccounts;
    this.profileImage = AccountController.state.profileImage;
    this.profileName = AccountController.state.profileName;
    this.disconnecting = false;
    this.balance = AccountController.state.balance;
    this.balanceSymbol = AccountController.state.balanceSymbol;
    this.features = OptionsController.state.features;
    this.namespace = ChainController.state.activeChain;
    this.chainId = (_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.id;
    this.unsubscribe.push(...[
      AccountController.subscribeKey("caipAddress", (val) => {
        this.address = CoreHelperUtil.getPlainAddress(val);
        this.caipAddress = val;
      }),
      AccountController.subscribeKey("balance", (val) => this.balance = val),
      AccountController.subscribeKey("balanceSymbol", (val) => this.balanceSymbol = val),
      AccountController.subscribeKey("profileName", (val) => this.profileName = val),
      AccountController.subscribeKey("profileImage", (val) => this.profileImage = val),
      OptionsController.subscribeKey("features", (val) => this.features = val),
      AccountController.subscribeKey("allAccounts", (allAccounts) => {
        this.allAccounts = allAccounts;
      }),
      ChainController.subscribeKey("activeChain", (val) => this.namespace = val),
      ChainController.subscribeKey("activeCaipNetwork", (val) => {
        var _a4;
        if (val) {
          const [namespace, chainId] = ((_a4 = val == null ? void 0 : val.caipNetworkId) == null ? void 0 : _a4.split(":")) || [];
          if (namespace && chainId) {
            this.namespace = namespace;
            this.chainId = chainId;
          }
        }
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    if (!this.caipAddress) {
      return null;
    }
    const shouldShowMultiAccount = ChainController.state.activeChain !== ConstantsUtil$4.CHAIN.SOLANA && this.allAccounts.length > 1;
    return x$3`<cross-wui-flex
        flexDirection="column"
        .padding=${["0", "xl", "m", "xl"]}
        alignItems="center"
        gap="l"
      >
        ${shouldShowMultiAccount ? this.multiAccountTemplate() : this.singleAccountTemplate()}
        <cross-wui-flex flexDirection="column" alignItems="center">
          <cross-wui-text variant="paragraph-500" color="fg-200">
            ${CoreHelperUtil.formatBalance(this.balance, this.balanceSymbol)}
          </cross-wui-text>
        </cross-wui-flex>
        ${this.explorerBtnTemplate()}
      </cross-wui-flex>

      <cross-wui-flex flexDirection="column" gap="xs" .padding=${["0", "s", "s", "s"]}>
        ${this.authCardTemplate()} <cross-w3m-account-auth-button></cross-w3m-account-auth-button>
        ${this.orderedFeaturesTemplate()} ${this.activityTemplate()}
        <cross-wui-list-item
          variant="icon"
          iconVariant="overlay"
          icon="disconnect"
          ?chevron=${false}
          .loading=${this.disconnecting}
          @click=${this.onDisconnect.bind(this)}
          data-testid="disconnect-button"
        >
          <cross-wui-text variant="paragraph-500" color="fg-200">Disconnect</cross-wui-text>
        </cross-wui-list-item>
      </cross-wui-flex>`;
  }
  onrampTemplate() {
    var _a3;
    if (!this.namespace) {
      return null;
    }
    const onramp = (_a3 = this.features) == null ? void 0 : _a3.onramp;
    const hasNetworkSupport = ConstantsUtil$3.ONRAMP_SUPPORTED_CHAIN_NAMESPACES.includes(this.namespace);
    if (!onramp || !hasNetworkSupport) {
      return null;
    }
    return x$3`
      <cross-wui-list-item
        data-testid="cross-w3m-account-default-onramp-button"
        iconVariant="blue"
        icon="card"
        ?chevron=${true}
        @click=${this.handleClickPay.bind(this)}
      >
        <cross-wui-text variant="paragraph-500" color="fg-100">Buy crypto</cross-wui-text>
      </cross-wui-list-item>
    `;
  }
  orderedFeaturesTemplate() {
    var _a3;
    const featuresOrder = ((_a3 = this.features) == null ? void 0 : _a3.walletFeaturesOrder) || ConstantsUtil$3.DEFAULT_FEATURES.walletFeaturesOrder;
    return featuresOrder.map((feature) => {
      switch (feature) {
        case "onramp":
          return null;
        case "swaps":
          return null;
        case "send":
          return this.sendTemplate();
        default:
          return null;
      }
    });
  }
  activityTemplate() {
    var _a3;
    if (!this.namespace) {
      return null;
    }
    const isSolana = ChainController.state.activeChain === ConstantsUtil$4.CHAIN.SOLANA;
    const isEnabled = ((_a3 = this.features) == null ? void 0 : _a3.history) && ConstantsUtil$3.ACTIVITY_ENABLED_CHAIN_NAMESPACES.includes(this.namespace);
    return isEnabled ? x$3` <cross-wui-list-item
          iconVariant="blue"
          icon="clock"
          iconSize="sm"
          ?chevron=${!isSolana}
          ?disabled=${isSolana}
          @click=${this.onTransactions.bind(this)}
        >
          <cross-wui-text variant="paragraph-500" color="fg-100" ?disabled=${isSolana}>
            Activity
          </cross-wui-text>
          ${isSolana ? x$3`<cross-wui-tag variant="main">Coming soon</cross-wui-tag>` : ""}
        </cross-wui-list-item>` : null;
  }
  swapsTemplate() {
    var _a3;
    const swaps = (_a3 = this.features) == null ? void 0 : _a3.swaps;
    const isEvm = ChainController.state.activeChain === ConstantsUtil$4.CHAIN.EVM;
    if (!swaps || !isEvm) {
      return null;
    }
    return x$3`
      <cross-wui-list-item
        iconVariant="blue"
        icon="recycleHorizontal"
        ?chevron=${true}
        @click=${this.handleClickSwap.bind(this)}
      >
        <cross-wui-text variant="paragraph-500" color="fg-100">Swap</cross-wui-text>
      </cross-wui-list-item>
    `;
  }
  sendTemplate() {
    var _a3;
    const send = (_a3 = this.features) == null ? void 0 : _a3.send;
    const isEvm = ChainController.state.activeChain === ConstantsUtil$4.CHAIN.EVM;
    if (!send || !isEvm) {
      return null;
    }
    return x$3`
      <cross-wui-list-item
        iconVariant="blue"
        icon="send"
        ?chevron=${true}
        @click=${this.handleClickSend.bind(this)}
      >
        <cross-wui-text variant="paragraph-500" color="fg-100">Send</cross-wui-text>
      </cross-wui-list-item>
    `;
  }
  authCardTemplate() {
    const namespace = ChainController.state.activeChain;
    const connectorId = StorageUtil.getConnectedConnectorId(namespace);
    const authConnector = ConnectorController.getAuthConnector();
    const { origin } = location;
    if (!authConnector || connectorId !== ConstantsUtil$4.CONNECTOR_ID.AUTH || origin.includes(ConstantsUtil$3.SECURE_SITE)) {
      return null;
    }
    return x$3`
      <cross-wui-notice-card
        @click=${this.onGoToUpgradeView.bind(this)}
        label="Upgrade your wallet"
        description="Transition to a self-custodial wallet"
        icon="wallet"
        data-testid="cross-w3m-wallet-upgrade-card"
      ></cross-wui-notice-card>
    `;
  }
  handleSwitchAccountsView() {
    RouterController.push("SwitchAddress");
  }
  handleClickPay() {
    RouterController.push("OnRampProviders");
  }
  handleClickSwap() {
    RouterController.push("Swap");
  }
  handleClickSend() {
    RouterController.push("WalletSend");
  }
  explorerBtnTemplate() {
    const addressExplorerUrl = AccountController.state.addressExplorerUrl;
    if (!addressExplorerUrl) {
      return null;
    }
    return x$3`
      <cross-wui-button size="md" variant="neutral" @click=${this.onExplorer.bind(this)}>
        <cross-wui-icon size="sm" color="inherit" slot="iconLeft" name="compass"></cross-wui-icon>
        Block Explorer
        <cross-wui-icon size="sm" color="inherit" slot="iconRight" name="externalLink"></cross-wui-icon>
      </cross-wui-button>
    `;
  }
  singleAccountTemplate() {
    return x$3`
      <cross-wui-avatar
        alt=${o$2(this.caipAddress)}
        address=${o$2(CoreHelperUtil.getPlainAddress(this.caipAddress))}
        imageSrc=${o$2(this.profileImage === null ? void 0 : this.profileImage)}
        data-testid="single-account-avatar"
      ></cross-wui-avatar>
      <cross-wui-flex flexDirection="column" alignItems="center">
        <cross-wui-flex gap="3xs" alignItems="center" justifyContent="center">
          <cross-wui-text variant="large-600" color="fg-100">
            ${this.profileName ? UiHelperUtil.getTruncateString({
      string: this.profileName,
      charsStart: 20,
      charsEnd: 0,
      truncate: "end"
    }) : UiHelperUtil.getTruncateString({
      string: this.address || "",
      charsStart: 4,
      charsEnd: 4,
      truncate: "middle"
    })}
          </cross-wui-text>
          <cross-wui-icon-link
            size="md"
            icon="copy"
            iconColor="fg-200"
            @click=${this.onCopyAddress}
          ></cross-wui-icon-link> </wui-flex
      ></cross-wui-flex>
    `;
  }
  multiAccountTemplate() {
    if (!this.address) {
      throw new Error("cross-w3m-account-view: No account provided");
    }
    const account = this.allAccounts.find((acc) => acc.address === this.address);
    const label = AccountController.state.addressLabels.get(this.address);
    if (this.namespace === "bip122") {
      return this.btcAccountsTemplate();
    }
    return x$3`
      <cross-wui-profile-button-v2
        .onProfileClick=${this.handleSwitchAccountsView.bind(this)}
        address=${o$2(this.address)}
        icon="${(account == null ? void 0 : account.type) === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT && ChainController.state.activeChain === ConstantsUtil$4.CHAIN.EVM ? "lightbulb" : "mail"}"
        avatarSrc=${o$2(this.profileImage ? this.profileImage : void 0)}
        profileName=${o$2(label ? label : this.profileName)}
        .onCopyClick=${this.onCopyAddress.bind(this)}
      ></wui-profile-button-v2>
    `;
  }
  btcAccountsTemplate() {
    return x$3`<cross-wui-flex gap="m" alignItems="center" flexDirection="column">
      <cross-wui-avatar
        .imageSrc=${o$2(this.profileImage ? this.profileImage : void 0)}
        alt=${this.address}
        address=${this.address}
      ></cross-wui-avatar>
      <cross-wui-tabs
        .tabs=${[{ label: "Payment" }, { label: "Ordinals" }]}
        .onTabChange=${(index2) => {
      var _a3;
      return AccountController.setCaipAddress(`bip122:${this.chainId}:${((_a3 = this.allAccounts[index2]) == null ? void 0 : _a3.address) || ""}`, this.namespace);
    }}
      ></cross-wui-tabs>
      <cross-wui-flex gap="xs" alignItems="center" justifyContent="center">
        <cross-wui-text variant="large-600" color="fg-100">
          ${UiHelperUtil.getTruncateString({
      string: this.profileName || this.address || "",
      charsStart: this.profileName ? 18 : 4,
      charsEnd: this.profileName ? 0 : 4,
      truncate: this.profileName ? "end" : "middle"
    })}
        </cross-wui-text>
        <cross-wui-icon-link
          size="md"
          icon="copy"
          iconColor="fg-200"
          @click=${this.onCopyAddress}
        ></cross-wui-icon-link>
      </cross-wui-flex>
    </cross-wui-flex>`;
  }
  onCopyAddress() {
    try {
      if (this.address) {
        CoreHelperUtil.copyToClopboard(this.address);
        SnackController.showSuccess("Address copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
  onTransactions() {
    EventsController.sendEvent({
      type: "track",
      event: "CLICK_TRANSACTIONS",
      properties: {
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
    RouterController.push("Transactions");
  }
  async onDisconnect() {
    try {
      this.disconnecting = true;
      await ConnectionController.disconnect();
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_SUCCESS" });
      ModalController.close();
    } catch {
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_ERROR" });
      SnackController.showError("Failed to disconnect");
    } finally {
      this.disconnecting = false;
    }
  }
  onExplorer() {
    const addressExplorerUrl = AccountController.state.addressExplorerUrl;
    if (addressExplorerUrl) {
      CoreHelperUtil.openHref(addressExplorerUrl, "_blank");
    }
  }
  onGoToUpgradeView() {
    EventsController.sendEvent({ type: "track", event: "EMAIL_UPGRADE_FROM_MODAL" });
    RouterController.push("UpgradeEmailWallet");
  }
};
W3mAccountDefaultWidget.styles = styles$f;
__decorate$s([
  r$1()
], W3mAccountDefaultWidget.prototype, "caipAddress", void 0);
__decorate$s([
  r$1()
], W3mAccountDefaultWidget.prototype, "address", void 0);
__decorate$s([
  r$1()
], W3mAccountDefaultWidget.prototype, "allAccounts", void 0);
__decorate$s([
  r$1()
], W3mAccountDefaultWidget.prototype, "profileImage", void 0);
__decorate$s([
  r$1()
], W3mAccountDefaultWidget.prototype, "profileName", void 0);
__decorate$s([
  r$1()
], W3mAccountDefaultWidget.prototype, "disconnecting", void 0);
__decorate$s([
  r$1()
], W3mAccountDefaultWidget.prototype, "balance", void 0);
__decorate$s([
  r$1()
], W3mAccountDefaultWidget.prototype, "balanceSymbol", void 0);
__decorate$s([
  r$1()
], W3mAccountDefaultWidget.prototype, "features", void 0);
__decorate$s([
  r$1()
], W3mAccountDefaultWidget.prototype, "namespace", void 0);
__decorate$s([
  r$1()
], W3mAccountDefaultWidget.prototype, "chainId", void 0);
W3mAccountDefaultWidget = __decorate$s([
  customElement("cross-w3m-account-default-widget")
], W3mAccountDefaultWidget);
const styles$e = i$4`
  cross-wui-flex {
    width: 100%;
  }

  cross-wui-promo {
    position: absolute;
    top: -32px;
  }

  cross-wui-profile-button {
    margin-top: calc(-1 * var(--wui-spacing-2l));
  }

  wui-promo + cross-wui-profile-button {
    margin-top: var(--wui-spacing-2l);
  }

  cross-wui-tabs {
    width: 100%;
  }

  .contentContainer {
    height: 280px;
  }

  .contentContainer > cross-wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xxs);
  }

  .contentContainer > .textContent {
    width: 65%;
  }
`;
var __decorate$r = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
const TABS = 3;
const TABS_PADDING = 48;
const MODAL_MOBILE_VIEW_PX = 430;
let W3mAccountWalletFeaturesWidget = class W3mAccountWalletFeaturesWidget2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.address = AccountController.state.address;
    this.profileImage = AccountController.state.profileImage;
    this.profileName = AccountController.state.profileName;
    this.network = ChainController.state.activeCaipNetwork;
    this.currentTab = AccountController.state.currentTab;
    this.tokenBalance = AccountController.state.tokenBalance;
    this.features = OptionsController.state.features;
    this.networkImage = AssetUtil.getNetworkImage(this.network);
    this.unsubscribe.push(...[
      AssetController.subscribeNetworkImages(() => {
        this.networkImage = AssetUtil.getNetworkImage(this.network);
      }),
      AccountController.subscribe((val) => {
        if (val.address) {
          this.address = val.address;
          this.profileImage = val.profileImage;
          this.profileName = val.profileName;
          this.currentTab = val.currentTab;
          this.tokenBalance = val.tokenBalance;
        } else {
          ModalController.close();
        }
      })
    ], ChainController.subscribeKey("activeCaipNetwork", (val) => this.network = val), OptionsController.subscribeKey("features", (val) => this.features = val));
    this.watchSwapValues();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    clearInterval(this.watchTokenBalance);
  }
  firstUpdated() {
    AccountController.fetchTokenBalance();
  }
  render() {
    if (!this.address) {
      throw new Error("cross-w3m-account-view: No account provided");
    }
    return x$3`<cross-wui-flex
      flexDirection="column"
      .padding=${["0", "xl", "m", "xl"]}
      alignItems="center"
      gap="m"
      data-testid="cross-w3m-account-wallet-features-widget"
    >
      ${this.network && x$3`<cross-wui-network-icon .network=${this.network}></cross-wui-network-icon>`}
      <cross-wui-profile-button
        @click=${this.onProfileButtonClick.bind(this)}
        address=${o$2(this.address)}
        networkSrc=${o$2(this.networkImage)}
        icon="chevronBottom"
        avatarSrc=${o$2(this.profileImage ? this.profileImage : void 0)}
        profileName=${o$2(this.profileName ?? void 0)}
        data-testid="cross-w3m-profile-button"
      ></cross-wui-profile-button>

      ${this.tokenBalanceTemplate()} ${this.orderedWalletFeatures()}

      <cross-wui-tabs
        .onTabChange=${this.onTabChange.bind(this)}
        .activeTab=${this.currentTab}
        localTabWidth=${CoreHelperUtil.isMobile() && window.innerWidth < MODAL_MOBILE_VIEW_PX ? `${(window.innerWidth - TABS_PADDING) / TABS}px` : "104px"}
        .tabs=${ConstantsUtil$2.ACCOUNT_TABS}
      ></cross-wui-tabs>
      ${this.listContentTemplate()}
    </cross-wui-flex>`;
  }
  orderedWalletFeatures() {
    var _a3;
    const walletFeaturesOrder = ((_a3 = this.features) == null ? void 0 : _a3.walletFeaturesOrder) || ConstantsUtil$3.DEFAULT_FEATURES.walletFeaturesOrder;
    const isAllDisabled = walletFeaturesOrder.every((feature) => {
      var _a4;
      return !((_a4 = this.features) == null ? void 0 : _a4[feature]);
    });
    if (isAllDisabled) {
      return null;
    }
    return x$3`<cross-wui-flex gap="s">
      ${walletFeaturesOrder.map((feature) => {
      switch (feature) {
        case "onramp":
          return this.onrampTemplate();
        case "swaps":
          return this.swapsTemplate();
        case "receive":
          return this.receiveTemplate();
        case "send":
          return this.sendTemplate();
        default:
          return null;
      }
    })}
    </cross-wui-flex>`;
  }
  onrampTemplate() {
    var _a3;
    const onramp = (_a3 = this.features) == null ? void 0 : _a3.onramp;
    if (!onramp) {
      return null;
    }
    return x$3`
      <cross-w3m-tooltip-trigger text="Buy">
        <cross-wui-icon-button
          data-testid="wallet-features-onramp-button"
          @click=${this.onBuyClick.bind(this)}
          icon="card"
        ></cross-wui-icon-button>
      </cross-w3m-tooltip-trigger>
    `;
  }
  swapsTemplate() {
    var _a3;
    const swaps = (_a3 = this.features) == null ? void 0 : _a3.swaps;
    const isEvm = ChainController.state.activeChain === ConstantsUtil$4.CHAIN.EVM;
    if (!swaps || !isEvm) {
      return null;
    }
    return x$3`
      <cross-w3m-tooltip-trigger text="Swap">
        <cross-wui-icon-button
          data-testid="wallet-features-swaps-button"
          @click=${this.onSwapClick.bind(this)}
          icon="recycleHorizontal"
        >
        </cross-wui-icon-button>
      </cross-w3m-tooltip-trigger>
    `;
  }
  receiveTemplate() {
    var _a3;
    const receive = (_a3 = this.features) == null ? void 0 : _a3.receive;
    if (!receive) {
      return null;
    }
    return x$3`
      <cross-w3m-tooltip-trigger text="Receive">
        <cross-wui-icon-button
          data-testid="wallet-features-receive-button"
          @click=${this.onReceiveClick.bind(this)}
          icon="arrowBottomCircle"
        >
        </cross-wui-icon-button>
      </cross-w3m-tooltip-trigger>
    `;
  }
  sendTemplate() {
    var _a3;
    const send = (_a3 = this.features) == null ? void 0 : _a3.send;
    const isEvm = ChainController.state.activeChain === ConstantsUtil$4.CHAIN.EVM;
    if (!send || !isEvm) {
      return null;
    }
    return x$3`
      <cross-w3m-tooltip-trigger text="Send">
        <cross-wui-icon-button
          data-testid="wallet-features-send-button"
          @click=${this.onSendClick.bind(this)}
          icon="send"
        ></cross-wui-icon-button>
      </cross-w3m-tooltip-trigger>
    `;
  }
  watchSwapValues() {
    this.watchTokenBalance = setInterval(() => AccountController.fetchTokenBalance((error) => this.onTokenBalanceError(error)), 1e4);
  }
  onTokenBalanceError(error) {
    if (error instanceof Error && error.cause instanceof Response) {
      const statusCode = error.cause.status;
      if (statusCode === ConstantsUtil$4.HTTP_STATUS_CODES.SERVICE_UNAVAILABLE) {
        clearInterval(this.watchTokenBalance);
      }
    }
  }
  listContentTemplate() {
    if (this.currentTab === 0) {
      return x$3`<cross-w3m-account-tokens-widget></cross-w3m-account-tokens-widget>`;
    }
    if (this.currentTab === 1) {
      return x$3`<cross-w3m-account-nfts-widget></cross-w3m-account-nfts-widget>`;
    }
    if (this.currentTab === 2) {
      return x$3`<cross-w3m-account-activity-widget></cross-w3m-account-activity-widget>`;
    }
    return x$3`<cross-w3m-account-tokens-widget></cross-w3m-account-tokens-widget>`;
  }
  tokenBalanceTemplate() {
    var _a3;
    if (this.tokenBalance && ((_a3 = this.tokenBalance) == null ? void 0 : _a3.length) >= 0) {
      const value = CoreHelperUtil.calculateBalance(this.tokenBalance);
      const { dollars = "0", pennies = "00" } = CoreHelperUtil.formatTokenBalance(value);
      return x$3`<cross-wui-balance dollars=${dollars} pennies=${pennies}></cross-wui-balance>`;
    }
    return x$3`<cross-wui-balance dollars="0" pennies="00"></cross-wui-balance>`;
  }
  onTabChange(index2) {
    AccountController.setCurrentTab(index2);
  }
  onProfileButtonClick() {
    const { allAccounts } = AccountController.state;
    if (allAccounts.length > 1) {
      RouterController.push("Profile");
    } else {
      RouterController.push("AccountSettings");
    }
  }
  onBuyClick() {
    RouterController.push("OnRampProviders");
  }
  onSwapClick() {
    var _a3, _b2, _c3;
    if (((_a3 = this.network) == null ? void 0 : _a3.caipNetworkId) && !ConstantsUtil$3.SWAP_SUPPORTED_NETWORKS.includes((_b2 = this.network) == null ? void 0 : _b2.caipNetworkId)) {
      RouterController.push("UnsupportedChain", {
        swapUnsupportedChain: true
      });
    } else {
      EventsController.sendEvent({
        type: "track",
        event: "OPEN_SWAP",
        properties: {
          network: ((_c3 = this.network) == null ? void 0 : _c3.caipNetworkId) || "",
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
        }
      });
      RouterController.push("Swap");
    }
  }
  onReceiveClick() {
    RouterController.push("WalletReceive");
  }
  onSendClick() {
    var _a3;
    EventsController.sendEvent({
      type: "track",
      event: "OPEN_SEND",
      properties: {
        network: ((_a3 = this.network) == null ? void 0 : _a3.caipNetworkId) || "",
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
    RouterController.push("WalletSend");
  }
};
W3mAccountWalletFeaturesWidget.styles = styles$e;
__decorate$r([
  r$1()
], W3mAccountWalletFeaturesWidget.prototype, "watchTokenBalance", void 0);
__decorate$r([
  r$1()
], W3mAccountWalletFeaturesWidget.prototype, "address", void 0);
__decorate$r([
  r$1()
], W3mAccountWalletFeaturesWidget.prototype, "profileImage", void 0);
__decorate$r([
  r$1()
], W3mAccountWalletFeaturesWidget.prototype, "profileName", void 0);
__decorate$r([
  r$1()
], W3mAccountWalletFeaturesWidget.prototype, "network", void 0);
__decorate$r([
  r$1()
], W3mAccountWalletFeaturesWidget.prototype, "currentTab", void 0);
__decorate$r([
  r$1()
], W3mAccountWalletFeaturesWidget.prototype, "tokenBalance", void 0);
__decorate$r([
  r$1()
], W3mAccountWalletFeaturesWidget.prototype, "features", void 0);
__decorate$r([
  r$1()
], W3mAccountWalletFeaturesWidget.prototype, "networkImage", void 0);
W3mAccountWalletFeaturesWidget = __decorate$r([
  customElement("cross-w3m-account-wallet-features-widget")
], W3mAccountWalletFeaturesWidget);
const styles$d = i$4`
  :host {
    width: 100%;
    max-height: 280px;
    overflow: scroll;
    scrollbar-width: none;
  }

  :host::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$q = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mAccountActivityWidget = class W3mAccountActivityWidget2 extends i$1 {
  render() {
    return x$3`<cross-w3m-activity-list page="account"></cross-w3m-activity-list>`;
  }
};
W3mAccountActivityWidget.styles = styles$d;
W3mAccountActivityWidget = __decorate$q([
  customElement("cross-w3m-account-activity-widget")
], W3mAccountActivityWidget);
const styles$c = i$4`
  .contentContainer {
    height: 280px;
  }

  .contentContainer > cross-wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xxs);
  }

  .contentContainer > .textContent {
    width: 65%;
  }
`;
var __decorate$p = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mAccountNftsWidget = class W3mAccountNftsWidget2 extends i$1 {
  render() {
    return x$3`${this.nftTemplate()}`;
  }
  nftTemplate() {
    return x$3` <cross-wui-flex
      class="contentContainer"
      alignItems="center"
      justifyContent="center"
      flexDirection="column"
      gap="l"
    >
      <cross-wui-icon-box
        icon="wallet"
        size="inherit"
        iconColor="fg-200"
        backgroundColor="fg-200"
        iconSize="lg"
      ></cross-wui-icon-box>
      <cross-wui-flex
        class="textContent"
        gap="xs"
        flexDirection="column"
        justifyContent="center"
        flexDirection="column"
      >
        <cross-wui-text
          variant="paragraph-500"
          align="center"
          color="fg-100"
          data-testid="nft-template-title"
          >Coming soon</wui-text
        >
        <cross-wui-text
          variant="small-400"
          align="center"
          color="fg-200"
          data-testid="nft-template-description"
          >Stay tuned for our upcoming NFT feature</wui-text
        >
      </cross-wui-flex>
      <cross-wui-link @click=${this.onReceiveClick.bind(this)} data-testid="link-receive-funds"
        >Receive funds</wui-link
      >
    </cross-wui-flex>`;
  }
  onReceiveClick() {
    RouterController.push("WalletReceive");
  }
};
W3mAccountNftsWidget.styles = styles$c;
W3mAccountNftsWidget = __decorate$p([
  customElement("cross-w3m-account-nfts-widget")
], W3mAccountNftsWidget);
const styles$b = i$4`
  :host {
    width: 100%;
  }

  cross-wui-flex {
    width: 100%;
  }

  .contentContainer {
    max-height: 280px;
    overflow: scroll;
    scrollbar-width: none;
  }

  .contentContainer::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$o = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mAccountTokensWidget = class W3mAccountTokensWidget2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tokenBalance = AccountController.state.tokenBalance;
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        this.tokenBalance = val.tokenBalance;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x$3`${this.tokenTemplate()}`;
  }
  tokenTemplate() {
    var _a3;
    if (this.tokenBalance && ((_a3 = this.tokenBalance) == null ? void 0 : _a3.length) > 0) {
      return x$3`<cross-wui-flex class="contentContainer" flexDirection="column" gap="xs">
        ${this.tokenItemTemplate()}
      </cross-wui-flex>`;
    }
    return x$3` <cross-wui-flex flexDirection="column" gap="xs"
      ><cross-wui-list-description
        @click=${this.onBuyClick.bind(this)}
        text="Buy Crypto"
        description="Easy with card or bank account"
        icon="card"
        iconColor="success-100"
        iconBackgroundColor="success-100"
        tag="popular"
        data-testid="buy-crypto"
      ></wui-list-description
      ><cross-wui-list-description
        @click=${this.onReceiveClick.bind(this)}
        text="Receive funds"
        description="Transfer tokens on your wallet"
        icon="arrowBottomCircle"
        iconColor="fg-200"
        iconBackgroundColor="fg-200"
        data-testid="receive-funds"
      ></wui-list-description
    ></cross-wui-flex>`;
  }
  tokenItemTemplate() {
    var _a3;
    return (_a3 = this.tokenBalance) == null ? void 0 : _a3.map((token) => x$3`<cross-wui-list-token
          tokenName=${token.name}
          tokenImageUrl=${token.iconUrl}
          tokenAmount=${token.quantity.numeric}
          tokenValue=${token.value}
          tokenCurrency=${token.symbol}
        ></cross-wui-list-token>`);
  }
  onReceiveClick() {
    RouterController.push("WalletReceive");
  }
  onBuyClick() {
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_BUY_CRYPTO",
      properties: {
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
    RouterController.push("OnRampProviders");
  }
};
W3mAccountTokensWidget.styles = styles$b;
__decorate$o([
  r$1()
], W3mAccountTokensWidget.prototype, "tokenBalance", void 0);
W3mAccountTokensWidget = __decorate$o([
  customElement("cross-w3m-account-tokens-widget")
], W3mAccountTokensWidget);
const styles$a = i$4`
  :host {
    min-height: 100%;
  }

  .group-container[last-group='true'] {
    padding-bottom: var(--wui-spacing-m);
  }

  .contentContainer {
    height: 280px;
  }

  .contentContainer > cross-wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xxs);
  }

  .contentContainer > .textContent {
    width: 65%;
  }

  .emptyContainer {
    height: 100%;
  }
`;
var __decorate$n = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
const PAGINATOR_ID = "last-transaction";
const LOADING_ITEM_COUNT = 7;
let W3mActivityList = class W3mActivityList2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.paginationObserver = void 0;
    this.page = "activity";
    this.caipAddress = ChainController.state.activeCaipAddress;
    this.transactionsByYear = TransactionsController.state.transactionsByYear;
    this.loading = TransactionsController.state.loading;
    this.empty = TransactionsController.state.empty;
    this.next = TransactionsController.state.next;
    TransactionsController.clearCursor();
    this.unsubscribe.push(...[
      ChainController.subscribeKey("activeCaipAddress", (val) => {
        if (val) {
          if (this.caipAddress !== val) {
            TransactionsController.resetTransactions();
            TransactionsController.fetchTransactions(val);
          }
        }
        this.caipAddress = val;
      }),
      ChainController.subscribeKey("activeCaipNetwork", () => {
        this.updateTransactionView();
      }),
      TransactionsController.subscribe((val) => {
        this.transactionsByYear = val.transactionsByYear;
        this.loading = val.loading;
        this.empty = val.empty;
        this.next = val.next;
      })
    ]);
  }
  firstUpdated() {
    this.updateTransactionView();
    this.createPaginationObserver();
  }
  updated() {
    this.setPaginationObserver();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x$3` ${this.empty ? null : this.templateTransactionsByYear()}
    ${this.loading ? this.templateLoading() : null}
    ${!this.loading && this.empty ? this.templateEmpty() : null}`;
  }
  updateTransactionView() {
    var _a3;
    const currentNetwork = (_a3 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a3.caipNetworkId;
    const lastNetworkInView = TransactionsController.state.lastNetworkInView;
    if (lastNetworkInView !== currentNetwork) {
      TransactionsController.resetTransactions();
      if (this.caipAddress) {
        TransactionsController.fetchTransactions(CoreHelperUtil.getPlainAddress(this.caipAddress));
      }
    }
    TransactionsController.setLastNetworkInView(currentNetwork);
  }
  templateTransactionsByYear() {
    const sortedYearKeys = Object.keys(this.transactionsByYear).sort().reverse();
    return sortedYearKeys.map((year) => {
      const yearInt = parseInt(year, 10);
      const sortedMonthIndexes = new Array(12).fill(null).map((_3, idx) => {
        var _a3;
        const groupTitle = TransactionUtil.getTransactionGroupTitle(yearInt, idx);
        const transactions = (_a3 = this.transactionsByYear[yearInt]) == null ? void 0 : _a3[idx];
        return {
          groupTitle,
          transactions
        };
      }).filter(({ transactions }) => transactions).reverse();
      return sortedMonthIndexes.map(({ groupTitle, transactions }, index2) => {
        const isLastGroup = index2 === sortedMonthIndexes.length - 1;
        if (!transactions) {
          return null;
        }
        return x$3`
          <cross-wui-flex
            flexDirection="column"
            class="group-container"
            last-group="${isLastGroup ? "true" : "false"}"
            data-testid="month-indexes"
          >
            <cross-wui-flex
              alignItems="center"
              flexDirection="row"
              .padding=${["xs", "s", "s", "s"]}
            >
              <cross-wui-text variant="paragraph-500" color="fg-200" data-testid="group-title"
                >${groupTitle}</wui-text
              >
            </cross-wui-flex>
            <cross-wui-flex flexDirection="column" gap="xs">
              ${this.templateTransactions(transactions, isLastGroup)}
            </cross-wui-flex>
          </cross-wui-flex>
        `;
      });
    });
  }
  templateRenderTransaction(transaction, isLastTransaction) {
    const { date, descriptions, direction, isAllNFT, images, status, transfers, type: type2 } = this.getTransactionListItemProps(transaction);
    const haveMultipleTransfers = (transfers == null ? void 0 : transfers.length) > 1;
    const haveTwoTransfers = (transfers == null ? void 0 : transfers.length) === 2;
    if (haveTwoTransfers && !isAllNFT) {
      return x$3`
        <cross-wui-transaction-list-item
          date=${date}
          .direction=${direction}
          id=${isLastTransaction && this.next ? PAGINATOR_ID : ""}
          status=${status}
          type=${type2}
          .images=${images}
          .descriptions=${descriptions}
        ></cross-wui-transaction-list-item>
      `;
    }
    if (haveMultipleTransfers) {
      return transfers.map((transfer, index2) => {
        const description = TransactionUtil.getTransferDescription(transfer);
        const isLastTransfer = isLastTransaction && index2 === transfers.length - 1;
        return x$3` <cross-wui-transaction-list-item
          date=${date}
          direction=${transfer.direction}
          id=${isLastTransfer && this.next ? PAGINATOR_ID : ""}
          status=${status}
          type=${type2}
          .onlyDirectionIcon=${true}
          .images=${[images[index2]]}
          .descriptions=${[description]}
        ></cross-wui-transaction-list-item>`;
      });
    }
    return x$3`
      <cross-wui-transaction-list-item
        date=${date}
        .direction=${direction}
        id=${isLastTransaction && this.next ? PAGINATOR_ID : ""}
        status=${status}
        type=${type2}
        .images=${images}
        .descriptions=${descriptions}
      ></cross-wui-transaction-list-item>
    `;
  }
  templateTransactions(transactions, isLastGroup) {
    return transactions.map((transaction, index2) => {
      const isLastTransaction = isLastGroup && index2 === transactions.length - 1;
      return x$3`${this.templateRenderTransaction(transaction, isLastTransaction)}`;
    });
  }
  emptyStateActivity() {
    return x$3`<cross-wui-flex
      class="emptyContainer"
      flexGrow="1"
      flexDirection="column"
      justifyContent="center"
      alignItems="center"
      .padding=${["3xl", "xl", "3xl", "xl"]}
      gap="xl"
      data-testid="empty-activity-state"
    >
      <cross-wui-icon-box
        backgroundColor="gray-glass-005"
        background="gray"
        iconColor="fg-200"
        icon="wallet"
        size="lg"
        ?border=${true}
        borderColor="wui-color-bg-125"
      ></cross-wui-icon-box>
      <cross-wui-flex flexDirection="column" alignItems="center" gap="xs">
        <cross-wui-text align="center" variant="paragraph-500" color="fg-100"
          >No Transactions yet</wui-text
        >
        <cross-wui-text align="center" variant="small-500" color="fg-200"
          >Start trading on dApps <br />
          to grow your wallet!</wui-text
        >
      </cross-wui-flex>
    </cross-wui-flex>`;
  }
  emptyStateAccount() {
    return x$3`<cross-wui-flex
      class="contentContainer"
      alignItems="center"
      justifyContent="center"
      flexDirection="column"
      gap="l"
      data-testid="empty-account-state"
    >
      <cross-wui-icon-box
        icon="swapHorizontal"
        size="inherit"
        iconColor="fg-200"
        backgroundColor="fg-200"
        iconSize="lg"
      ></cross-wui-icon-box>
      <cross-wui-flex
        class="textContent"
        gap="xs"
        flexDirection="column"
        justifyContent="center"
        flexDirection="column"
      >
        <cross-wui-text variant="paragraph-500" align="center" color="fg-100">No activity yet</cross-wui-text>
        <cross-wui-text variant="small-400" align="center" color="fg-200"
          >Your next transactions will appear here</wui-text
        >
      </cross-wui-flex>
      <cross-wui-link @click=${this.onReceiveClick.bind(this)}>Trade</cross-wui-link>
    </cross-wui-flex>`;
  }
  templateEmpty() {
    if (this.page === "account") {
      return x$3`${this.emptyStateAccount()}`;
    }
    return x$3`${this.emptyStateActivity()}`;
  }
  templateLoading() {
    if (this.page === "activity") {
      return Array(LOADING_ITEM_COUNT).fill(x$3` <cross-wui-transaction-list-item-loader></cross-wui-transaction-list-item-loader> `).map((item) => item);
    }
    return null;
  }
  onReceiveClick() {
    RouterController.push("WalletReceive");
  }
  createPaginationObserver() {
    const { projectId } = OptionsController.state;
    this.paginationObserver = new IntersectionObserver(([element]) => {
      if ((element == null ? void 0 : element.isIntersecting) && !this.loading) {
        TransactionsController.fetchTransactions(CoreHelperUtil.getPlainAddress(this.caipAddress));
        EventsController.sendEvent({
          type: "track",
          event: "LOAD_MORE_TRANSACTIONS",
          properties: {
            address: CoreHelperUtil.getPlainAddress(this.caipAddress),
            projectId,
            cursor: this.next,
            isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
          }
        });
      }
    }, {});
    this.setPaginationObserver();
  }
  setPaginationObserver() {
    var _a3, _b2, _c3;
    (_a3 = this.paginationObserver) == null ? void 0 : _a3.disconnect();
    const lastItem = (_b2 = this.shadowRoot) == null ? void 0 : _b2.querySelector(`#${PAGINATOR_ID}`);
    if (lastItem) {
      (_c3 = this.paginationObserver) == null ? void 0 : _c3.observe(lastItem);
    }
  }
  getTransactionListItemProps(transaction) {
    var _a3, _b2, _c3, _d, _e4;
    const date = DateUtil.formatDate((_a3 = transaction == null ? void 0 : transaction.metadata) == null ? void 0 : _a3.minedAt);
    const descriptions = TransactionUtil.getTransactionDescriptions(transaction);
    const transfers = transaction == null ? void 0 : transaction.transfers;
    const transfer = (_b2 = transaction == null ? void 0 : transaction.transfers) == null ? void 0 : _b2[0];
    const isAllNFT = Boolean(transfer) && ((_c3 = transaction == null ? void 0 : transaction.transfers) == null ? void 0 : _c3.every((item) => Boolean(item.nft_info)));
    const images = TransactionUtil.getTransactionImages(transfers);
    return {
      date,
      direction: transfer == null ? void 0 : transfer.direction,
      descriptions,
      isAllNFT,
      images,
      status: (_d = transaction.metadata) == null ? void 0 : _d.status,
      transfers,
      type: (_e4 = transaction.metadata) == null ? void 0 : _e4.operationType
    };
  }
};
W3mActivityList.styles = styles$a;
__decorate$n([
  n$3()
], W3mActivityList.prototype, "page", void 0);
__decorate$n([
  r$1()
], W3mActivityList.prototype, "caipAddress", void 0);
__decorate$n([
  r$1()
], W3mActivityList.prototype, "transactionsByYear", void 0);
__decorate$n([
  r$1()
], W3mActivityList.prototype, "loading", void 0);
__decorate$n([
  r$1()
], W3mActivityList.prototype, "empty", void 0);
__decorate$n([
  r$1()
], W3mActivityList.prototype, "next", void 0);
W3mActivityList = __decorate$n([
  customElement("cross-w3m-activity-list")
], W3mActivityList);
const styles$9 = i$4`
  :host {
    width: 100%;
    height: 100px;
    border-radius: var(--wui-border-radius-s);
    border: 1px solid var(--wui-color-gray-glass-002);
    background-color: var(--wui-color-gray-glass-002);
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-lg);
    will-change: background-color;
  }

  :host(:hover) {
    background-color: var(--wui-color-gray-glass-005);
  }

  cross-wui-flex {
    width: 100%;
    height: fit-content;
  }

  cross-wui-button {
    width: 100%;
    display: flex;
    justify-content: flex-end;
  }

  cross-wui-input-amount {
    mask-image: linear-gradient(
      270deg,
      transparent 0px,
      transparent 8px,
      black 24px,
      black 25px,
      black 32px,
      black 100%
    );
  }

  .totalValue {
    width: 100%;
  }
`;
var __decorate$m = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mInputToken = class W3mInputToken2 extends i$1 {
  render() {
    return x$3` <cross-wui-flex
      flexDirection="column"
      gap="4xs"
      .padding=${["xl", "s", "l", "l"]}
    >
      <cross-wui-flex alignItems="center">
        <cross-wui-input-amount
          @inputChange=${this.onInputChange.bind(this)}
          ?disabled=${!this.token && true}
          .value=${this.sendTokenAmount ? String(this.sendTokenAmount) : ""}
        ></cross-wui-input-amount>
        ${this.buttonTemplate()}
      </cross-wui-flex>
      <cross-wui-flex alignItems="center" justifyContent="space-between">
        ${this.sendValueTemplate()}
        <cross-wui-flex alignItems="center" gap="4xs" justifyContent="flex-end">
          ${this.maxAmountTemplate()} ${this.actionTemplate()}
        </cross-wui-flex>
      </cross-wui-flex>
    </cross-wui-flex>`;
  }
  buttonTemplate() {
    if (this.token) {
      return x$3`<cross-wui-token-button
        text=${this.token.symbol}
        imageSrc=${this.token.iconUrl}
        @click=${this.handleSelectButtonClick.bind(this)}
      >
      </cross-wui-token-button>`;
    }
    return x$3`<cross-wui-button
      size="md"
      variant="accent"
      @click=${this.handleSelectButtonClick.bind(this)}
      >Select token</wui-button
    >`;
  }
  handleSelectButtonClick() {
    RouterController.push("WalletSendSelectToken");
  }
  sendValueTemplate() {
    if (this.token && this.sendTokenAmount) {
      const price = this.token.price;
      const totalValue = price * this.sendTokenAmount;
      return x$3`<cross-wui-text class="totalValue" variant="small-400" color="fg-200"
        >${totalValue ? `$${UiHelperUtil.formatNumberToLocalString(totalValue, 2)}` : "Incorrect value"}</wui-text
      >`;
    }
    return null;
  }
  maxAmountTemplate() {
    if (this.token) {
      if (this.sendTokenAmount && this.sendTokenAmount > Number(this.token.quantity.numeric)) {
        return x$3` <cross-wui-text variant="small-400" color="error-100">
          ${UiHelperUtil.roundNumber(Number(this.token.quantity.numeric), 6, 5)}
        </cross-wui-text>`;
      }
      return x$3` <cross-wui-text variant="small-400" color="fg-200">
        ${UiHelperUtil.roundNumber(Number(this.token.quantity.numeric), 6, 5)}
      </cross-wui-text>`;
    }
    return null;
  }
  actionTemplate() {
    if (this.token) {
      if (this.sendTokenAmount && this.sendTokenAmount > Number(this.token.quantity.numeric)) {
        return x$3`<cross-wui-link @click=${this.onBuyClick.bind(this)}>Buy</cross-wui-link>`;
      }
      return x$3`<cross-wui-link @click=${this.onMaxClick.bind(this)}>Max</cross-wui-link>`;
    }
    return null;
  }
  onInputChange(event) {
    SendController.setTokenAmount(event.detail);
  }
  onMaxClick() {
    if (this.token && typeof this.gasPrice !== "undefined") {
      const isNetworkToken = this.token.address === void 0 || Object.values(ConstantsUtil$3.NATIVE_TOKEN_ADDRESS).some((nativeAddress) => {
        var _a3;
        return ((_a3 = this.token) == null ? void 0 : _a3.address) === nativeAddress;
      });
      const numericGas = NumberUtil.bigNumber(this.gasPrice).div(NumberUtil.bigNumber(10).pow(Number(this.token.quantity.decimals)));
      const maxValue2 = isNetworkToken ? NumberUtil.bigNumber(this.token.quantity.numeric).minus(numericGas) : NumberUtil.bigNumber(this.token.quantity.numeric);
      SendController.setTokenAmount(Number(maxValue2.toFixed(20)));
    }
  }
  onBuyClick() {
    RouterController.push("OnRampProviders");
  }
};
W3mInputToken.styles = styles$9;
__decorate$m([
  n$3({ type: Object })
], W3mInputToken.prototype, "token", void 0);
__decorate$m([
  n$3({ type: Number })
], W3mInputToken.prototype, "sendTokenAmount", void 0);
__decorate$m([
  n$3({ type: Number })
], W3mInputToken.prototype, "gasPriceInUSD", void 0);
__decorate$m([
  n$3({ type: Number })
], W3mInputToken.prototype, "gasPrice", void 0);
W3mInputToken = __decorate$m([
  customElement("cross-w3m-input-token")
], W3mInputToken);
const styles$8 = i$4`
  :host {
    width: 100%;
    height: 100px;
    border-radius: var(--wui-border-radius-s);
    border: 1px solid var(--wui-color-gray-glass-002);
    background-color: var(--wui-color-gray-glass-002);
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-lg);
    will-change: background-color;
    position: relative;
  }

  :host(:hover) {
    background-color: var(--wui-color-gray-glass-005);
  }

  cross-wui-flex {
    width: 100%;
    height: fit-content;
  }

  cross-wui-button {
    display: ruby;
    color: var(--wui-color-fg-100);
    margin: 0 var(--wui-spacing-xs);
  }

  .instruction {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    z-index: 2;
  }

  .paste {
    display: inline-flex;
  }

  textarea {
    background: transparent;
    width: 100%;
    font-family: var(--w3m-font-family);
    font-size: var(--wui-font-size-medium);
    font-style: normal;
    font-weight: var(--wui-font-weight-light);
    line-height: 130%;
    letter-spacing: var(--wui-letter-spacing-medium);
    color: var(--wui-color-fg-100);
    caret-color: var(--wui-color-accent-100);
    box-sizing: border-box;
    -webkit-appearance: none;
    -moz-appearance: textfield;
    padding: 0px;
    border: none;
    outline: none;
    appearance: none;
    resize: none;
    overflow: hidden;
  }
`;
var __decorate$l = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mInputAddress = class W3mInputAddress2 extends i$1 {
  constructor() {
    super(...arguments);
    this.inputElementRef = e();
    this.instructionElementRef = e();
    this.instructionHidden = Boolean(this.value);
    this.pasting = false;
    this.onDebouncedSearch = CoreHelperUtil.debounce(async (value) => {
      const address = await ConnectionController.getEnsAddress(value);
      SendController.setLoading(false);
      if (address) {
        SendController.setReceiverProfileName(value);
        SendController.setReceiverAddress(address);
        const avatar = await ConnectionController.getEnsAvatar(value);
        SendController.setReceiverProfileImageUrl(avatar || void 0);
      } else {
        SendController.setReceiverAddress(value);
        SendController.setReceiverProfileName(void 0);
        SendController.setReceiverProfileImageUrl(void 0);
      }
    });
  }
  firstUpdated() {
    if (this.value) {
      this.instructionHidden = true;
    }
    this.checkHidden();
  }
  render() {
    return x$3` <cross-wui-flex
      @click=${this.onBoxClick.bind(this)}
      flexDirection="column"
      justifyContent="center"
      gap="4xs"
      .padding=${["2xl", "l", "xl", "l"]}
    >
      <cross-wui-text
        ${n$1(this.instructionElementRef)}
        class="instruction"
        color="fg-300"
        variant="medium-400"
      >
        Type or
        <cross-wui-button
          class="paste"
          size="md"
          variant="neutral"
          iconLeft="copy"
          @click=${this.onPasteClick.bind(this)}
        >
          <cross-wui-icon size="sm" color="inherit" slot="iconLeft" name="copy"></cross-wui-icon>
          Paste
        </cross-wui-button>
        address
      </cross-wui-text>
      <textarea
        spellcheck="false"
        ?disabled=${!this.instructionHidden}
        ${n$1(this.inputElementRef)}
        @input=${this.onInputChange.bind(this)}
        @blur=${this.onBlur.bind(this)}
        .value=${this.value ?? ""}
        autocomplete="off"
      >
${this.value ?? ""}</textarea
      >
    </cross-wui-flex>`;
  }
  async focusInput() {
    var _a3;
    if (this.instructionElementRef.value) {
      this.instructionHidden = true;
      await this.toggleInstructionFocus(false);
      this.instructionElementRef.value.style.pointerEvents = "none";
      (_a3 = this.inputElementRef.value) == null ? void 0 : _a3.focus();
      if (this.inputElementRef.value) {
        this.inputElementRef.value.selectionStart = this.inputElementRef.value.selectionEnd = this.inputElementRef.value.value.length;
      }
    }
  }
  async focusInstruction() {
    var _a3;
    if (this.instructionElementRef.value) {
      this.instructionHidden = false;
      await this.toggleInstructionFocus(true);
      this.instructionElementRef.value.style.pointerEvents = "auto";
      (_a3 = this.inputElementRef.value) == null ? void 0 : _a3.blur();
    }
  }
  async toggleInstructionFocus(focus) {
    if (this.instructionElementRef.value) {
      await this.instructionElementRef.value.animate([{ opacity: focus ? 0 : 1 }, { opacity: focus ? 1 : 0 }], {
        duration: 100,
        easing: "ease",
        fill: "forwards"
      }).finished;
    }
  }
  onBoxClick() {
    if (!this.value && !this.instructionHidden) {
      this.focusInput();
    }
  }
  onBlur() {
    if (!this.value && this.instructionHidden && !this.pasting) {
      this.focusInstruction();
    }
  }
  checkHidden() {
    if (this.instructionHidden) {
      this.focusInput();
    }
  }
  async onPasteClick() {
    this.pasting = true;
    const text = await navigator.clipboard.readText();
    SendController.setReceiverAddress(text);
    this.focusInput();
  }
  onInputChange(e3) {
    this.pasting = false;
    const element = e3.target;
    if (element.value && !this.instructionHidden) {
      this.focusInput();
    }
    SendController.setLoading(true);
    this.onDebouncedSearch(element.value);
  }
};
W3mInputAddress.styles = styles$8;
__decorate$l([
  n$3()
], W3mInputAddress.prototype, "value", void 0);
__decorate$l([
  r$1()
], W3mInputAddress.prototype, "instructionHidden", void 0);
__decorate$l([
  r$1()
], W3mInputAddress.prototype, "pasting", void 0);
W3mInputAddress = __decorate$l([
  customElement("cross-w3m-input-address")
], W3mInputAddress);
const styles$7 = i$4`
  :host {
    display: flex;
    width: auto;
    flex-direction: column;
    gap: var(--wui-border-radius-1xs);
    border-radius: var(--wui-border-radius-s);
    background: var(--wui-color-gray-glass-002);
    padding: var(--wui-spacing-s) var(--wui-spacing-1xs) var(--wui-spacing-1xs)
      var(--wui-spacing-1xs);
  }

  cross-wui-text {
    padding: 0 var(--wui-spacing-1xs);
  }

  cross-wui-flex {
    margin-top: var(--wui-spacing-1xs);
  }

  .network {
    cursor: pointer;
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-lg);
    will-change: background-color;
  }

  .network:focus-visible {
    border: 1px solid var(--wui-color-accent-100);
    background-color: var(--wui-color-gray-glass-005);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  .network:hover {
    background-color: var(--wui-color-gray-glass-005);
  }

  .network:active {
    background-color: var(--wui-color-gray-glass-010);
  }
`;
var __decorate$k = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mWalletSendDetails = class W3mWalletSendDetails2 extends i$1 {
  render() {
    return x$3` <cross-wui-text variant="small-400" color="fg-200">Details</cross-wui-text>
      <cross-wui-flex flexDirection="column" gap="xxs">
        <cross-wui-list-content textTitle="Network cost" textValue="$${o$2(UiHelperUtil.formatNumberToLocalString(this.networkFee, 2))}"></cross-wui-list-content></cross-wui-list-content>
        <cross-wui-list-content
          textTitle="Address"
          textValue=${UiHelperUtil.getTruncateString({
      string: this.receiverAddress ?? "",
      charsStart: 4,
      charsEnd: 4,
      truncate: "middle"
    })}
        >
        </cross-wui-list-content>
        ${this.networkTemplate()}
      </cross-wui-flex>`;
  }
  networkTemplate() {
    var _a3;
    if ((_a3 = this.caipNetwork) == null ? void 0 : _a3.name) {
      return x$3` <cross-wui-list-content
        @click=${() => this.onNetworkClick(this.caipNetwork)}
        class="network"
        textTitle="Network"
        imageSrc=${o$2(AssetUtil.getNetworkImage(this.caipNetwork))}
      ></cross-wui-list-content>`;
    }
    return null;
  }
  onNetworkClick(network) {
    if (network) {
      RouterController.push("Networks", { network });
    }
  }
};
W3mWalletSendDetails.styles = styles$7;
__decorate$k([
  n$3()
], W3mWalletSendDetails.prototype, "receiverAddress", void 0);
__decorate$k([
  n$3({ type: Object })
], W3mWalletSendDetails.prototype, "caipNetwork", void 0);
__decorate$k([
  n$3({ type: Number })
], W3mWalletSendDetails.prototype, "networkFee", void 0);
W3mWalletSendDetails = __decorate$k([
  customElement("cross-w3m-wallet-send-details")
], W3mWalletSendDetails);
const styles$6 = i$4`
  :host {
    pointer-events: none;
  }

  :host > cross-wui-flex {
    display: var(--w3m-tooltip-display);
    opacity: var(--w3m-tooltip-opacity);
    padding: 9px var(--wui-spacing-s) 10px var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);
    color: var(--wui-color-bg-100);
    position: fixed;
    top: var(--w3m-tooltip-top);
    left: var(--w3m-tooltip-left);
    transform: translate(calc(-50% + var(--w3m-tooltip-parent-width)), calc(-100% - 8px));
    max-width: calc(var(--w3m-modal-width) - var(--wui-spacing-xl));
    transition: opacity 0.2s var(--wui-ease-out-power-2);
    will-change: opacity;
  }

  :host([data-variant='shade']) > cross-wui-flex {
    background-color: var(--wui-color-bg-150);
    border: 1px solid var(--wui-color-gray-glass-005);
  }

  :host([data-variant='shade']) > wui-flex > cross-wui-text {
    color: var(--wui-color-fg-150);
  }

  :host([data-variant='fill']) > cross-wui-flex {
    background-color: var(--wui-color-fg-100);
    border: none;
  }

  cross-wui-icon {
    position: absolute;
    width: 12px !important;
    height: 4px !important;
    color: var(--wui-color-bg-150);
  }

  wui-icon[data-placement='top'] {
    bottom: 0px;
    left: 50%;
    transform: translate(-50%, 95%);
  }

  wui-icon[data-placement='bottom'] {
    top: 0;
    left: 50%;
    transform: translate(-50%, -95%) rotate(180deg);
  }

  wui-icon[data-placement='right'] {
    top: 50%;
    left: 0;
    transform: translate(-65%, -50%) rotate(90deg);
  }

  wui-icon[data-placement='left'] {
    top: 50%;
    right: 0%;
    transform: translate(65%, -50%) rotate(270deg);
  }
`;
var __decorate$j = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mTooltip = class W3mTooltip2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.open = TooltipController.state.open;
    this.message = TooltipController.state.message;
    this.triggerRect = TooltipController.state.triggerRect;
    this.variant = TooltipController.state.variant;
    this.unsubscribe.push(...[
      TooltipController.subscribe((newState) => {
        this.open = newState.open;
        this.message = newState.message;
        this.triggerRect = newState.triggerRect;
        this.variant = newState.variant;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    this.dataset["variant"] = this.variant;
    const topValue = this.triggerRect.top;
    const leftValue = this.triggerRect.left;
    this.style.cssText = `
    --w3m-tooltip-top: ${topValue}px;
    --w3m-tooltip-left: ${leftValue}px;
    --w3m-tooltip-parent-width: ${this.triggerRect.width / 2}px;
    --w3m-tooltip-display: ${this.open ? "flex" : "none"};
    --w3m-tooltip-opacity: ${this.open ? 1 : 0};
    `;
    return x$3`<cross-wui-flex>
      <cross-wui-icon data-placement="top" color="fg-100" size="inherit" name="cursor"></cross-wui-icon>
      <cross-wui-text color="inherit" variant="small-500">${this.message}</cross-wui-text>
    </cross-wui-flex>`;
  }
};
W3mTooltip.styles = [styles$6];
__decorate$j([
  r$1()
], W3mTooltip.prototype, "open", void 0);
__decorate$j([
  r$1()
], W3mTooltip.prototype, "message", void 0);
__decorate$j([
  r$1()
], W3mTooltip.prototype, "triggerRect", void 0);
__decorate$j([
  r$1()
], W3mTooltip.prototype, "variant", void 0);
W3mTooltip = __decorate$j([
  customElement("cross-w3m-tooltip")
], W3mTooltip);
const styles$5 = i$4`
  :host {
    width: 100%;
    display: block;
  }
`;
var __decorate$i = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let WuiTooltipTrigger = class WuiTooltipTrigger2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.text = "";
    this.open = TooltipController.state.open;
    this.unsubscribe.push(RouterController.subscribeKey("view", () => {
      TooltipController.hide();
    }), ModalController.subscribeKey("open", (modalOpen) => {
      if (!modalOpen) {
        TooltipController.hide();
      }
    }), TooltipController.subscribeKey("open", (tooltipOpen) => {
      this.open = tooltipOpen;
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    TooltipController.hide();
  }
  render() {
    return x$3`
      <div
        @pointermove=${this.onMouseEnter.bind(this)}
        @pointerleave=${this.onMouseLeave.bind(this)}
      >
        ${this.renderChildren()}
      </div>
    `;
  }
  renderChildren() {
    return x$3`<slot></slot> `;
  }
  onMouseEnter() {
    const rect = this.getBoundingClientRect();
    if (!this.open) {
      TooltipController.showTooltip({
        message: this.text,
        triggerRect: {
          width: rect.width,
          height: rect.height,
          left: rect.left,
          top: rect.top
        },
        variant: "shade"
      });
    }
  }
  onMouseLeave(event) {
    if (!this.contains(event.relatedTarget)) {
      TooltipController.hide();
    }
  }
};
WuiTooltipTrigger.styles = [styles$5];
__decorate$i([
  n$3()
], WuiTooltipTrigger.prototype, "text", void 0);
__decorate$i([
  r$1()
], WuiTooltipTrigger.prototype, "open", void 0);
WuiTooltipTrigger = __decorate$i([
  customElement("cross-w3m-tooltip-trigger")
], WuiTooltipTrigger);
const styles$4 = i$4`
  cross-wui-separator {
    margin: var(--wui-spacing-m) calc(var(--wui-spacing-m) * -1) var(--wui-spacing-m)
      calc(var(--wui-spacing-m) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }
`;
var __decorate$h = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
const MAX_TOP_VIEW = 2;
const MAXIMUM_LENGTH = 6;
let W3mSocialLoginWidget = class W3mSocialLoginWidget2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.walletGuide = "get-started";
    this.tabIdx = void 0;
    this.connectors = ConnectorController.state.connectors;
    this.features = OptionsController.state.features;
    this.authConnector = this.connectors.find((c2) => c2.type === "AUTH");
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => {
      this.connectors = val;
      this.authConnector = this.connectors.find((c2) => c2.type === "AUTH");
    }), OptionsController.subscribeKey("features", (val) => this.features = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x$3`
      <cross-wui-flex
        class="container"
        flexDirection="column"
        gap="xs"
        data-testid="cross-w3m-social-login-widget"
      >
        ${this.topViewTemplate()}${this.bottomViewTemplate()}
      </cross-wui-flex>
    `;
  }
  topViewTemplate() {
    var _a3;
    const isCreateWalletPage = this.walletGuide === "explore";
    let socials = (_a3 = this.features) == null ? void 0 : _a3.socials;
    if (!socials && isCreateWalletPage) {
      socials = ConstantsUtil$3.DEFAULT_FEATURES.socials;
      return this.renderTopViewContent(socials);
    }
    if (!socials) {
      return null;
    }
    return this.renderTopViewContent(socials);
  }
  renderTopViewContent(socials) {
    if (socials.length === 2) {
      return x$3` <cross-wui-flex gap="xs">
        ${socials.slice(0, MAX_TOP_VIEW).map((social) => x$3`<cross-wui-logo-select
              data-testid=${`social-selector-${social}`}
              @click=${() => {
        this.onSocialClick(social);
      }}
              logo=${social}
              tabIdx=${o$2(this.tabIdx)}
            ></cross-wui-logo-select>`)}
      </cross-wui-flex>`;
    }
    return x$3` <cross-wui-list-social
      data-testid=${`social-selector-${socials[0]}`}
      @click=${() => {
      this.onSocialClick(socials[0]);
    }}
      logo=${o$2(socials[0])}
      align="center"
      name=${`Continue with ${socials[0]}`}
      tabIdx=${o$2(this.tabIdx)}
    ></cross-wui-list-social>`;
  }
  bottomViewTemplate() {
    var _a3;
    let socials = (_a3 = this.features) == null ? void 0 : _a3.socials;
    const isCreateWalletPage = this.walletGuide === "explore";
    const isSocialDisabled = !this.authConnector || !socials || !(socials == null ? void 0 : socials.length);
    if (isSocialDisabled && isCreateWalletPage) {
      socials = ConstantsUtil$3.DEFAULT_FEATURES.socials;
    }
    if (!socials) {
      return null;
    }
    if (socials.length <= MAX_TOP_VIEW) {
      return null;
    }
    if (socials && socials.length > MAXIMUM_LENGTH) {
      return x$3`<cross-wui-flex gap="xs">
        ${socials.slice(1, MAXIMUM_LENGTH - 1).map((social) => x$3`<cross-wui-logo-select
              data-testid=${`social-selector-${social}`}
              @click=${() => {
        this.onSocialClick(social);
      }}
              logo=${social}
              tabIdx=${o$2(this.tabIdx)}
            ></cross-wui-logo-select>`)}
        <cross-wui-logo-select
          logo="more"
          tabIdx=${o$2(this.tabIdx)}
          @click=${this.onMoreSocialsClick.bind(this)}
        ></cross-wui-logo-select>
      </cross-wui-flex>`;
    }
    if (!socials) {
      return null;
    }
    return x$3`<cross-wui-flex gap="xs">
      ${socials.slice(1, socials.length).map((social) => x$3`<cross-wui-logo-select
            data-testid=${`social-selector-${social}`}
            @click=${() => {
      this.onSocialClick(social);
    }}
            logo=${social}
            tabIdx=${o$2(this.tabIdx)}
          ></cross-wui-logo-select>`)}
    </cross-wui-flex>`;
  }
  onMoreSocialsClick() {
    RouterController.push("ConnectSocials");
  }
  async onSocialClick(socialProvider) {
    var _a3, _b2;
    const isAvailableChain = ConstantsUtil$4.AUTH_CONNECTOR_SUPPORTED_CHAINS.find((chain) => chain === ChainController.state.activeChain);
    if (!isAvailableChain) {
      const caipNetwork = ChainController.getFirstCaipNetworkSupportsAuthConnector();
      if (caipNetwork) {
        RouterController.push("SwitchNetwork", { network: caipNetwork });
        return;
      }
    }
    if (socialProvider) {
      AccountController.setSocialProvider(socialProvider, ChainController.state.activeChain);
      EventsController.sendEvent({
        type: "track",
        event: "SOCIAL_LOGIN_STARTED",
        properties: { provider: socialProvider }
      });
    }
    if (socialProvider === SocialProviderEnum.Farcaster) {
      RouterController.push("ConnectingFarcaster");
      const authConnector = ConnectorController.getAuthConnector();
      if (authConnector) {
        if (!AccountController.state.farcasterUrl) {
          try {
            const { url } = await authConnector.provider.getFarcasterUri();
            AccountController.setFarcasterUrl(url, ChainController.state.activeChain);
          } catch (error) {
            RouterController.goBack();
            SnackController.showError(error);
          }
        }
      }
    } else {
      RouterController.push("ConnectingSocial");
      const authConnector = ConnectorController.getAuthConnector();
      try {
        if (authConnector && socialProvider) {
          if (!CoreHelperUtil.isTelegram()) {
            this.popupWindow = CoreHelperUtil.returnOpenHref("", "popupWindow", "width=600,height=800,scrollbars=yes");
          }
          if (this.popupWindow) {
            AccountController.setSocialWindow(this.popupWindow, ChainController.state.activeChain);
          } else if (!CoreHelperUtil.isTelegram()) {
            throw new Error("Something went wrong");
          }
          const { uri: uri2 } = await authConnector.provider.getSocialRedirectUri({
            provider: socialProvider
          });
          if (!uri2) {
            (_a3 = this.popupWindow) == null ? void 0 : _a3.close();
            throw new Error("Something went wrong");
          }
          if (this.popupWindow) {
            this.popupWindow.location.href = uri2;
          }
          if (CoreHelperUtil.isTelegram()) {
            SafeLocalStorage.setItem(SafeLocalStorageKeys.SOCIAL_PROVIDER, socialProvider);
            const parsedUri = CoreHelperUtil.formatTelegramSocialLoginUrl(uri2);
            return CoreHelperUtil.openHref(parsedUri, "_top");
          }
        }
      } catch (error) {
        (_b2 = this.popupWindow) == null ? void 0 : _b2.close();
        SnackController.showError("Something went wrong");
      }
    }
  }
};
W3mSocialLoginWidget.styles = styles$4;
__decorate$h([
  n$3()
], W3mSocialLoginWidget.prototype, "walletGuide", void 0);
__decorate$h([
  n$3()
], W3mSocialLoginWidget.prototype, "tabIdx", void 0);
__decorate$h([
  r$1()
], W3mSocialLoginWidget.prototype, "connectors", void 0);
__decorate$h([
  r$1()
], W3mSocialLoginWidget.prototype, "features", void 0);
__decorate$h([
  r$1()
], W3mSocialLoginWidget.prototype, "authConnector", void 0);
W3mSocialLoginWidget = __decorate$h([
  customElement("cross-w3m-social-login-widget")
], W3mSocialLoginWidget);
var __decorate$g = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mWalletLoginList = class W3mWalletLoginList2 extends i$1 {
  constructor() {
    super(...arguments);
    this.tabIdx = void 0;
  }
  render() {
    return x$3`
      <cross-wui-flex flexDirection="column" gap="xs">
        <cross-w3m-connector-list tabIdx=${o$2(this.tabIdx)}></cross-w3m-connector-list>
        <cross-w3m-all-wallets-widget
          tabIdx=${o$2(this.tabIdx)}
        ></cross-w3m-all-wallets-widget>
      </cross-wui-flex>
    `;
  }
};
__decorate$g([
  n$3()
], W3mWalletLoginList.prototype, "tabIdx", void 0);
W3mWalletLoginList = __decorate$g([
  customElement("cross-w3m-wallet-login-list")
], W3mWalletLoginList);
const styles$3 = i$4`
  :host {
    margin-top: var(--wui-spacing-3xs);
  }
  cross-wui-separator {
    margin: var(--wui-spacing-m) calc(var(--wui-spacing-m) * -1) var(--wui-spacing-xs)
      calc(var(--wui-spacing-m) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }
`;
var __decorate$f = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mSocialLoginList = class W3mSocialLoginList2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tabIdx = void 0;
    this.connectors = ConnectorController.state.connectors;
    this.authConnector = this.connectors.find((c2) => c2.type === "AUTH");
    this.features = OptionsController.state.features;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => {
      this.connectors = val;
      this.authConnector = this.connectors.find((c2) => c2.type === "AUTH");
    }), OptionsController.subscribeKey("features", (val) => this.features = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a3;
    let socials = ((_a3 = this.features) == null ? void 0 : _a3.socials) || [];
    const isAuthConnectorExist = Boolean(this.authConnector);
    const isSocialsEnabled = socials == null ? void 0 : socials.length;
    const isConnectSocialsView = RouterController.state.view === "ConnectSocials";
    if ((!isAuthConnectorExist || !isSocialsEnabled) && !isConnectSocialsView) {
      return null;
    }
    if (isConnectSocialsView && !isSocialsEnabled) {
      socials = ConstantsUtil$3.DEFAULT_FEATURES.socials;
    }
    return x$3` <cross-wui-flex flexDirection="column" gap="xs">
      ${socials.map((social) => x$3`<cross-wui-list-social
            @click=${() => {
      this.onSocialClick(social);
    }}
            name=${social}
            logo=${social}
            tabIdx=${o$2(this.tabIdx)}
          ></cross-wui-list-social>`)}
    </cross-wui-flex>`;
  }
  async onSocialClick(socialProvider) {
    var _a3, _b2;
    if (socialProvider) {
      AccountController.setSocialProvider(socialProvider, ChainController.state.activeChain);
      EventsController.sendEvent({
        type: "track",
        event: "SOCIAL_LOGIN_STARTED",
        properties: { provider: socialProvider }
      });
    }
    if (socialProvider === SocialProviderEnum.Farcaster) {
      RouterController.push("ConnectingFarcaster");
      const authConnector = ConnectorController.getAuthConnector();
      if (authConnector) {
        if (!AccountController.state.farcasterUrl) {
          try {
            const { url } = await authConnector.provider.getFarcasterUri();
            AccountController.setFarcasterUrl(url, ChainController.state.activeChain);
          } catch (error) {
            RouterController.goBack();
            SnackController.showError(error);
          }
        }
      }
    } else {
      RouterController.push("ConnectingSocial");
      const authConnector = ConnectorController.getAuthConnector();
      this.popupWindow = CoreHelperUtil.returnOpenHref("", "popupWindow", "width=600,height=800,scrollbars=yes");
      try {
        if (authConnector && socialProvider) {
          const { uri: uri2 } = await authConnector.provider.getSocialRedirectUri({
            provider: socialProvider
          });
          if (this.popupWindow && uri2) {
            AccountController.setSocialWindow(this.popupWindow, ChainController.state.activeChain);
            this.popupWindow.location.href = uri2;
          } else {
            (_a3 = this.popupWindow) == null ? void 0 : _a3.close();
            throw new Error("Something went wrong");
          }
        }
      } catch (error) {
        (_b2 = this.popupWindow) == null ? void 0 : _b2.close();
        SnackController.showError("Something went wrong");
      }
    }
  }
};
W3mSocialLoginList.styles = styles$3;
__decorate$f([
  n$3()
], W3mSocialLoginList.prototype, "tabIdx", void 0);
__decorate$f([
  r$1()
], W3mSocialLoginList.prototype, "connectors", void 0);
__decorate$f([
  r$1()
], W3mSocialLoginList.prototype, "authConnector", void 0);
__decorate$f([
  r$1()
], W3mSocialLoginList.prototype, "features", void 0);
W3mSocialLoginList = __decorate$f([
  customElement("cross-w3m-social-login-list")
], W3mSocialLoginList);
var __decorate$e = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mConnectAnnouncedWidget = class W3mConnectAnnouncedWidget2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tabIdx = void 0;
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const announcedConnectors = this.connectors.filter((connector) => connector.type === "ANNOUNCED");
    if (!(announcedConnectors == null ? void 0 : announcedConnectors.length)) {
      this.style.cssText = `display: none`;
      return null;
    }
    return x$3`
      <cross-wui-flex flexDirection="column" gap="xs">
        ${announcedConnectors.map((connector) => {
      var _a3, _b2;
      if (((_a3 = connector.info) == null ? void 0 : _a3.rdns) && ApiController$1.state.excludedRDNS) {
        if (ApiController$1.state.excludedRDNS.includes((_b2 = connector == null ? void 0 : connector.info) == null ? void 0 : _b2.rdns)) {
          return null;
        }
      }
      return x$3`
            <cross-wui-list-wallet
              imageSrc=${o$2(AssetUtil.getConnectorImage(connector))}
              name=${connector.name ?? "Unknown"}
              @click=${() => this.onConnector(connector)}
              tagVariant="success"
              tagLabel="installed"
              data-testid=${`wallet-selector-${connector.id}`}
              .installed=${true}
              tabIdx=${o$2(this.tabIdx)}
            >
            </cross-wui-list-wallet>
          `;
    })}
      </cross-wui-flex>
    `;
  }
  onConnector(connector) {
    if (connector.id === "walletConnect") {
      if (CoreHelperUtil.isMobile()) {
        RouterController.push("AllWallets");
      } else {
        RouterController.push("ConnectingWalletConnect");
      }
    } else {
      RouterController.push("ConnectingExternal", { connector });
    }
  }
};
__decorate$e([
  n$3()
], W3mConnectAnnouncedWidget.prototype, "tabIdx", void 0);
__decorate$e([
  r$1()
], W3mConnectAnnouncedWidget.prototype, "connectors", void 0);
W3mConnectAnnouncedWidget = __decorate$e([
  customElement("cross-w3m-connect-announced-widget")
], W3mConnectAnnouncedWidget);
var __decorate$d = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mConnectCustomWidget = class W3mConnectCustomWidget2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tabIdx = void 0;
    this.connectors = ConnectorController.state.connectors;
    this.loading = false;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
    if (CoreHelperUtil.isTelegram() && CoreHelperUtil.isIos()) {
      this.loading = !ConnectionController.state.wcUri;
      this.unsubscribe.push(ConnectionController.subscribeKey("wcUri", (val) => this.loading = !val));
    }
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const { customWallets } = OptionsController.state;
    console.log(" CustomWidget Debug:", {
      customWallets,
      customWalletsLength: customWallets == null ? void 0 : customWallets.length
    });
    if (!(customWallets == null ? void 0 : customWallets.length)) {
      console.log(" CustomWallets ");
      this.style.cssText = `display: none`;
      return null;
    }
    const wallets = this.filterOutDuplicateWallets(customWallets);
    console.log(" CustomWallets :", wallets);
    return x$3`<cross-wui-flex flexDirection="column" gap="xs">
      ${wallets.map((wallet) => x$3`
          <cross-wui-list-wallet
            imageSrc=${o$2(AssetUtil.getWalletImage(wallet))}
            name=${wallet.name ?? "Unknown"}
            @click=${() => this.onConnectWallet(wallet)}
            data-testid=${`wallet-selector-${wallet.id}`}
            tabIdx=${o$2(this.tabIdx)}
            ?loading=${this.loading}
          >
          </cross-wui-list-wallet>
        `)}
    </cross-wui-flex>`;
  }
  filterOutDuplicateWallets(wallets) {
    const recent = StorageUtil.getRecentWallets();
    const connectorRDNSs = this.connectors.map((connector) => {
      var _a3;
      return (_a3 = connector.info) == null ? void 0 : _a3.rdns;
    }).filter(Boolean);
    const recentRDNSs = recent.map((wallet) => wallet.rdns).filter(Boolean);
    const allRDNSs = connectorRDNSs.concat(recentRDNSs);
    if (allRDNSs.includes("io.metamask.mobile") && CoreHelperUtil.isMobile()) {
      const index2 = allRDNSs.indexOf("io.metamask.mobile");
      allRDNSs[index2] = "io.metamask";
    }
    console.log(" FilterDuplicates Debug:", {
      wallets: wallets.map((w2) => ({ id: w2.id, name: w2.name, rdns: w2.rdns })),
      connectorRDNSs,
      recentRDNSs,
      allRDNSs
    });
    const filtered = wallets;
    console.log(" Filtered Result (no filtering):", filtered.map((w2) => ({ id: w2.id, name: w2.name, rdns: w2.rdns })));
    return filtered;
  }
  onConnectWallet(wallet) {
    if (this.loading) {
      return;
    }
    RouterController.push("ConnectingWalletConnect", { wallet });
  }
};
__decorate$d([
  n$3()
], W3mConnectCustomWidget.prototype, "tabIdx", void 0);
__decorate$d([
  r$1()
], W3mConnectCustomWidget.prototype, "connectors", void 0);
__decorate$d([
  r$1()
], W3mConnectCustomWidget.prototype, "loading", void 0);
W3mConnectCustomWidget = __decorate$d([
  customElement("cross-w3m-connect-custom-widget")
], W3mConnectCustomWidget);
var __decorate$c = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mConnectFeaturedWidget = class W3mConnectFeaturedWidget2 extends i$1 {
  constructor() {
    super(...arguments);
    this.unsubscribe = [];
    this.tabIdx = void 0;
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const { featured } = ApiController$1.state;
    if (!featured.length) {
      this.style.cssText = `display: none`;
      return null;
    }
    const wallets = WalletUtil$1.filterOutDuplicateWallets(featured);
    return x$3`
      <cross-wui-flex flexDirection="column" gap="xs">
        ${wallets.map((wallet) => x$3`
            <cross-wui-list-wallet
              data-testid=${`wallet-selector-featured-${wallet.id}`}
              imageSrc=${o$2(AssetUtil.getWalletImage(wallet))}
              name=${wallet.name ?? "Unknown"}
              @click=${() => this.onConnectWallet(wallet)}
              tabIdx=${o$2(this.tabIdx)}
            >
            </cross-wui-list-wallet>
          `)}
      </cross-wui-flex>
    `;
  }
  onConnectWallet(wallet) {
    ConnectorController.selectWalletConnector(wallet);
  }
};
__decorate$c([
  n$3()
], W3mConnectFeaturedWidget.prototype, "tabIdx", void 0);
W3mConnectFeaturedWidget = __decorate$c([
  customElement("cross-w3m-connect-featured-widget")
], W3mConnectFeaturedWidget);
var __decorate$b = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mConnectInjectedWidget = class W3mConnectInjectedWidget2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tabIdx = void 0;
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a3;
    const injectedConnectors = this.connectors.filter((connector) => connector.type === "INJECTED");
    if (!(injectedConnectors == null ? void 0 : injectedConnectors.length) || injectedConnectors.length === 1 && ((_a3 = injectedConnectors[0]) == null ? void 0 : _a3.name) === "Browser Wallet" && !CoreHelperUtil.isMobile()) {
      this.style.cssText = `display: none`;
      return null;
    }
    return x$3`
      <cross-wui-flex flexDirection="column" gap="xs">
        ${injectedConnectors.map((connector) => {
      var _a4;
      if (!CoreHelperUtil.isMobile() && connector.name === "Browser Wallet") {
        return null;
      }
      const walletRDNS = (_a4 = connector.info) == null ? void 0 : _a4.rdns;
      if (!walletRDNS && !ConnectionController.checkInstalled(void 0)) {
        this.style.cssText = `display: none`;
        return null;
      }
      if (walletRDNS && ApiController$1.state.excludedRDNS) {
        if (ApiController$1.state.excludedRDNS.includes(walletRDNS)) {
          return null;
        }
      }
      return x$3`
            <cross-wui-list-wallet
              imageSrc=${o$2(AssetUtil.getConnectorImage(connector))}
              .installed=${true}
              name=${connector.name ?? "Unknown"}
              tagVariant="success"
              tagLabel="installed"
              data-testid=${`wallet-selector-${connector.id}`}
              @click=${() => this.onConnector(connector)}
              tabIdx=${o$2(this.tabIdx)}
            >
            </cross-wui-list-wallet>
          `;
    })}
      </cross-wui-flex>
    `;
  }
  onConnector(connector) {
    ConnectorController.setActiveConnector(connector);
    RouterController.push("ConnectingExternal", { connector });
  }
};
__decorate$b([
  n$3()
], W3mConnectInjectedWidget.prototype, "tabIdx", void 0);
__decorate$b([
  r$1()
], W3mConnectInjectedWidget.prototype, "connectors", void 0);
W3mConnectInjectedWidget = __decorate$b([
  customElement("cross-w3m-connect-injected-widget")
], W3mConnectInjectedWidget);
var __decorate$a = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mConnectMultiChainWidget = class W3mConnectMultiChainWidget2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tabIdx = void 0;
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const multiChainConnectors = this.connectors.filter((connector) => connector.type === "MULTI_CHAIN" && connector.name !== "WalletConnect");
    if (!(multiChainConnectors == null ? void 0 : multiChainConnectors.length)) {
      this.style.cssText = `display: none`;
      return null;
    }
    return x$3`
      <cross-wui-flex flexDirection="column" gap="xs">
        ${multiChainConnectors.map((connector) => x$3`
            <cross-wui-list-wallet
              imageSrc=${o$2(AssetUtil.getConnectorImage(connector))}
              .installed=${true}
              name=${connector.name ?? "Unknown"}
              tagVariant="shade"
              tagLabel="multichain"
              data-testid=${`wallet-selector-${connector.id}`}
              @click=${() => this.onConnector(connector)}
              tabIdx=${o$2(this.tabIdx)}
            >
            </cross-wui-list-wallet>
          `)}
      </cross-wui-flex>
    `;
  }
  onConnector(connector) {
    ConnectorController.setActiveConnector(connector);
    RouterController.push("ConnectingMultiChain");
  }
};
__decorate$a([
  n$3()
], W3mConnectMultiChainWidget.prototype, "tabIdx", void 0);
__decorate$a([
  r$1()
], W3mConnectMultiChainWidget.prototype, "connectors", void 0);
W3mConnectMultiChainWidget = __decorate$a([
  customElement("cross-w3m-connect-multi-chain-widget")
], W3mConnectMultiChainWidget);
var __decorate$9 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mConnectExternalWidget = class W3mConnectExternalWidget2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tabIdx = void 0;
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const externalConnectors = this.connectors.filter((connector) => connector.type === "EXTERNAL");
    const filteredOutCoinbaseConnectors = externalConnectors.filter((connector) => connector.id !== ConstantsUtil$4.CONNECTOR_ID.COINBASE_SDK);
    if (!(filteredOutCoinbaseConnectors == null ? void 0 : filteredOutCoinbaseConnectors.length)) {
      this.style.cssText = `display: none`;
      return null;
    }
    return x$3`
      <cross-wui-flex flexDirection="column" gap="xs">
        ${filteredOutCoinbaseConnectors.map((connector) => x$3`
            <cross-wui-list-wallet
              imageSrc=${o$2(AssetUtil.getConnectorImage(connector))}
              .installed=${true}
              name=${connector.name ?? "Unknown"}
              data-testid=${`wallet-selector-external-${connector.id}`}
              @click=${() => this.onConnector(connector)}
              tabIdx=${o$2(this.tabIdx)}
            >
            </cross-wui-list-wallet>
          `)}
      </cross-wui-flex>
    `;
  }
  onConnector(connector) {
    RouterController.push("ConnectingExternal", { connector });
  }
};
__decorate$9([
  n$3()
], W3mConnectExternalWidget.prototype, "tabIdx", void 0);
__decorate$9([
  r$1()
], W3mConnectExternalWidget.prototype, "connectors", void 0);
W3mConnectExternalWidget = __decorate$9([
  customElement("cross-w3m-connect-external-widget")
], W3mConnectExternalWidget);
var __decorate$8 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mConnectRecentWidget = class W3mConnectRecentWidget2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tabIdx = void 0;
    this.connectors = ConnectorController.state.connectors;
    this.loading = false;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
    if (CoreHelperUtil.isTelegram() && CoreHelperUtil.isIos()) {
      this.loading = !ConnectionController.state.wcUri;
      this.unsubscribe.push(ConnectionController.subscribeKey("wcUri", (val) => this.loading = !val));
    }
  }
  render() {
    const recentWallets = StorageUtil.getRecentWallets();
    const filteredRecentWallets = recentWallets.filter((wallet) => !this.connectors.some((connector) => connector.id === wallet.id || connector.name === wallet.name));
    if (!filteredRecentWallets.length) {
      this.style.cssText = `display: none`;
      return null;
    }
    return x$3`
      <cross-wui-flex flexDirection="column" gap="xs">
        ${filteredRecentWallets.map((wallet) => x$3`
            <cross-wui-list-wallet
              imageSrc=${o$2(AssetUtil.getWalletImage(wallet))}
              name=${wallet.name ?? "Unknown"}
              @click=${() => this.onConnectWallet(wallet)}
              tagLabel="recent"
              tagVariant="shade"
              tabIdx=${o$2(this.tabIdx)}
              ?loading=${this.loading}
            >
            </cross-wui-list-wallet>
          `)}
      </cross-wui-flex>
    `;
  }
  onConnectWallet(wallet) {
    if (this.loading) {
      return;
    }
    ConnectorController.selectWalletConnector(wallet);
  }
};
__decorate$8([
  n$3()
], W3mConnectRecentWidget.prototype, "tabIdx", void 0);
__decorate$8([
  r$1()
], W3mConnectRecentWidget.prototype, "connectors", void 0);
__decorate$8([
  r$1()
], W3mConnectRecentWidget.prototype, "loading", void 0);
W3mConnectRecentWidget = __decorate$8([
  customElement("cross-w3m-connect-recent-widget")
], W3mConnectRecentWidget);
var __decorate$7 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mConnectRecommendedWidget = class W3mConnectRecommendedWidget2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tabIdx = void 0;
    this.connectors = ConnectorController.state.connectors;
    this.loading = false;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
    if (CoreHelperUtil.isTelegram() && CoreHelperUtil.isIos()) {
      this.loading = !ConnectionController.state.wcUri;
      this.unsubscribe.push(ConnectionController.subscribeKey("wcUri", (val) => this.loading = !val));
    }
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const connector = this.connectors.find((c2) => c2.id === "walletConnect" || c2.type === "WALLET_CONNECT");
    if (!connector) {
      return null;
    }
    const { recommended } = ApiController$1.state;
    const { customWallets, featuredWalletIds } = OptionsController.state;
    const { connectors } = ConnectorController.state;
    const recent = StorageUtil.getRecentWallets();
    const injected2 = connectors.filter((c2) => c2.type === "INJECTED" || c2.type === "ANNOUNCED" || c2.type === "MULTI_CHAIN");
    const injectedWallets = injected2.filter((i4) => i4.name !== "Browser Wallet");
    if (featuredWalletIds || customWallets || !recommended.length) {
      this.style.cssText = `display: none`;
      return null;
    }
    const overrideLength = injectedWallets.length + recent.length;
    const maxRecommended = Math.max(0, 2 - overrideLength);
    const wallets = WalletUtil$1.filterOutDuplicateWallets(recommended).slice(0, maxRecommended);
    if (!wallets.length) {
      this.style.cssText = `display: none`;
      return null;
    }
    return x$3`
      <cross-wui-flex flexDirection="column" gap="xs">
        ${wallets.map((wallet) => x$3`
            <cross-wui-list-wallet
              imageSrc=${o$2(AssetUtil.getWalletImage(wallet))}
              name=${(wallet == null ? void 0 : wallet.name) ?? "Unknown"}
              @click=${() => this.onConnectWallet(wallet)}
              tabIdx=${o$2(this.tabIdx)}
              ?loading=${this.loading}
            >
            </cross-wui-list-wallet>
          `)}
      </cross-wui-flex>
    `;
  }
  onConnectWallet(wallet) {
    if (this.loading) {
      return;
    }
    const connector = ConnectorController.getConnector(wallet.id, wallet.rdns);
    if (connector) {
      RouterController.push("ConnectingExternal", { connector });
    } else {
      RouterController.push("ConnectingWalletConnect", { wallet });
    }
  }
};
__decorate$7([
  n$3()
], W3mConnectRecommendedWidget.prototype, "tabIdx", void 0);
__decorate$7([
  r$1()
], W3mConnectRecommendedWidget.prototype, "connectors", void 0);
__decorate$7([
  r$1()
], W3mConnectRecommendedWidget.prototype, "loading", void 0);
W3mConnectRecommendedWidget = __decorate$7([
  customElement("cross-w3m-connect-recommended-widget")
], W3mConnectRecommendedWidget);
var __decorate$6 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mConnectWalletConnectWidget = class W3mConnectWalletConnectWidget2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tabIdx = void 0;
    this.connectors = ConnectorController.state.connectors;
    this.connectorImages = AssetController.state.connectorImages;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val), AssetController.subscribeKey("connectorImages", (val) => this.connectorImages = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    if (CoreHelperUtil.isMobile()) {
      this.style.cssText = `display: none`;
      return null;
    }
    const connector = this.connectors.find((c2) => c2.id === "walletConnect" || c2.type === "WALLET_CONNECT");
    if (!connector) {
      this.style.cssText = `display: none`;
      return null;
    }
    const connectorImage = connector.imageUrl || this.connectorImages[(connector == null ? void 0 : connector.imageId) ?? ""];
    return x$3`
      <cross-wui-list-wallet
        imageSrc=${o$2(connectorImage)}
        name=${connector.name ?? "Unknown"}
        @click=${() => this.onConnector(connector)}
        tagLabel="qr code"
        tagVariant="main"
        tabIdx=${o$2(this.tabIdx)}
        data-testid="wallet-selector-walletconnect"
      >
      </cross-wui-list-wallet>
    `;
  }
  onConnector(connector) {
    ConnectorController.setActiveConnector(connector);
    RouterController.push("ConnectingWalletConnect");
  }
};
__decorate$6([
  n$3()
], W3mConnectWalletConnectWidget.prototype, "tabIdx", void 0);
__decorate$6([
  r$1()
], W3mConnectWalletConnectWidget.prototype, "connectors", void 0);
__decorate$6([
  r$1()
], W3mConnectWalletConnectWidget.prototype, "connectorImages", void 0);
W3mConnectWalletConnectWidget = __decorate$6([
  customElement("cross-w3m-connect-walletconnect-widget")
], W3mConnectWalletConnectWidget);
const styles$2 = i$4`
  :host {
    margin-top: var(--wui-spacing-3xs);
  }
  cross-wui-separator {
    margin: var(--wui-spacing-m) calc(var(--wui-spacing-m) * -1) var(--wui-spacing-xs)
      calc(var(--wui-spacing-m) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }
`;
var __decorate$5 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mConnectorList = class W3mConnectorList2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tabIdx = void 0;
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const { custom: custom2, announced } = ConnectorUtil$1.getConnectorsByType(this.connectors);
    const hasAnnounced = Boolean(announced && (announced == null ? void 0 : announced.length) > 0);
    const hasCustom = Boolean(custom2 && (custom2 == null ? void 0 : custom2.length) > 0);
    console.log(" ConnectorList Debug:", {
      connectors: this.connectors,
      custom: custom2,
      announced,
      hasAnnounced,
      hasCustom
    });
    return x$3`
      <cross-wui-flex flexDirection="column" gap="xs">
        ${this.renderConnectorWidget(hasAnnounced, hasCustom)}
      </cross-wui-flex>
    `;
  }
  renderConnectorWidget(hasAnnounced, hasCustom) {
    if (hasAnnounced) {
      return x$3`
        <cross-w3m-connect-announced-widget
          tabIdx=${o$2(this.tabIdx)}
        ></cross-w3m-connect-announced-widget>
      `;
    }
    if (!hasAnnounced && hasCustom) {
      return x$3`
        <cross-w3m-connect-custom-widget
          tabIdx=${o$2(this.tabIdx)}
        ></cross-w3m-connect-custom-widget>
      `;
    }
    return null;
  }
};
W3mConnectorList.styles = styles$2;
__decorate$5([
  n$3()
], W3mConnectorList.prototype, "tabIdx", void 0);
__decorate$5([
  r$1()
], W3mConnectorList.prototype, "connectors", void 0);
W3mConnectorList = __decorate$5([
  customElement("cross-w3m-connector-list")
], W3mConnectorList);
var __decorate$4 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mAllWalletsWidget = class W3mAllWalletsWidget2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tabIdx = void 0;
    this.connectors = ConnectorController.state.connectors;
    this.count = ApiController$1.state.count;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val), ApiController$1.subscribeKey("count", (val) => this.count = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const wcConnector = this.connectors.find((c2) => c2.id === "walletConnect" || c2.type === "WALLET_CONNECT");
    const { allWallets } = OptionsController.state;
    console.log(" AllWalletsWidget Debug:", {
      wcConnector,
      allWallets,
      connectors: this.connectors,
      count: this.count,
      connectorsDetail: this.connectors.map((c2) => ({ id: c2.id, name: c2.name, type: c2.type }))
    });
    if (!wcConnector || allWallets === "HIDE") {
      console.log(" All Wallets :", { wcConnector: !!wcConnector, allWallets });
      return null;
    }
    if (allWallets === "ONLY_MOBILE" && !CoreHelperUtil.isMobile()) {
      return null;
    }
    const featuredCount = ApiController$1.state.featured.length;
    const rawCount = this.count + featuredCount;
    const roundedCount = rawCount < 10 ? rawCount : Math.floor(rawCount / 10) * 10;
    const tagLabel = roundedCount < rawCount ? `${roundedCount}+` : `${roundedCount}`;
    return x$3`
      <cross-wui-list-wallet
        name="All Wallets"
        walletIcon="allWallets"
        showAllWallets
        @click=${this.onAllWallets.bind(this)}
        tagLabel=${tagLabel}
        tagVariant="shade"
        data-testid="all-wallets"
        tabIdx=${o$2(this.tabIdx)}
      ></cross-wui-list-wallet>
    `;
  }
  onAllWallets() {
    EventsController.sendEvent({ type: "track", event: "CLICK_ALL_WALLETS" });
    RouterController.push("AllWallets");
  }
};
__decorate$4([
  n$3()
], W3mAllWalletsWidget.prototype, "tabIdx", void 0);
__decorate$4([
  r$1()
], W3mAllWalletsWidget.prototype, "connectors", void 0);
__decorate$4([
  r$1()
], W3mAllWalletsWidget.prototype, "count", void 0);
W3mAllWalletsWidget = __decorate$4([
  customElement("cross-w3m-all-wallets-widget")
], W3mAllWalletsWidget);
var __decorate$3 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mAccountAuthButton = class W3mAccountAuthButton2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.socialProvider = StorageUtil.getConnectedSocialProvider();
    this.socialUsername = StorageUtil.getConnectedSocialUsername();
    this.namespace = ChainController.state.activeChain;
    this.unsubscribe.push(ChainController.subscribeKey("activeChain", (namespace) => {
      this.namespace = namespace;
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsub) => unsub());
  }
  render() {
    const connectorId = StorageUtil.getConnectedConnectorId(this.namespace);
    const authConnector = ConnectorController.getAuthConnector();
    if (!authConnector || connectorId !== ConstantsUtil$4.CONNECTOR_ID.AUTH) {
      this.style.cssText = `display: none`;
      return null;
    }
    const email = authConnector.provider.getEmail() ?? "";
    return x$3`
      <cross-wui-list-item
        variant="icon"
        iconVariant="overlay"
        icon=${this.socialProvider ?? "mail"}
        iconSize=${this.socialProvider ? "xxl" : "sm"}
        data-testid="cross-w3m-account-email-update"
        ?chevron=${!this.socialProvider}
        @click=${() => {
      this.onGoToUpdateEmail(email, this.socialProvider);
    }}
      >
        <cross-wui-text variant="paragraph-500" color="fg-100">${this.getAuthName(email)}</cross-wui-text>
      </cross-wui-list-item>
    `;
  }
  onGoToUpdateEmail(email, socialProvider) {
    if (!socialProvider) {
      RouterController.push("UpdateEmailWallet", { email });
    }
  }
  getAuthName(email) {
    if (this.socialUsername) {
      if (this.socialProvider === "discord" && this.socialUsername.endsWith("0")) {
        return this.socialUsername.slice(0, -1);
      }
      return this.socialUsername;
    }
    return email.length > 30 ? `${email.slice(0, -3)}...` : email;
  }
};
__decorate$3([
  r$1()
], W3mAccountAuthButton.prototype, "namespace", void 0);
W3mAccountAuthButton = __decorate$3([
  customElement("cross-w3m-account-auth-button")
], W3mAccountAuthButton);
const styles$1 = i$4`
  cross-wui-flex {
    width: 100%;
  }

  .wallet-guide {
    width: 100%;
  }

  .chip-box {
    width: fit-content;
    background-color: var(--wui-color-gray-glass-005);
    border-radius: var(--wui-border-radius-3xl);
  }
`;
var __decorate$2 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mWalletGuide = class W3mWalletGuide2 extends i$1 {
  constructor() {
    super(...arguments);
    this.walletGuide = "get-started";
  }
  render() {
    return this.walletGuide === "explore" ? x$3`<cross-wui-flex
          class="wallet-guide"
          flexDirection="column"
          alignItems="center"
          justifyContent="center"
          rowGap="xs"
          data-testid="cross-w3m-wallet-guide-explore"
        >
          <cross-wui-text variant="small-400" color="fg-200" align="center">
            Looking for a self-custody wallet?
          </cross-wui-text>

          <cross-wui-flex class="chip-box">
            <cross-wui-chip
              imageIcon="walletConnectLightBrown"
              icon="externalLink"
              variant="transparent"
              href="https://walletguide.walletconnect.network"
              title="Find one on WalletGuide"
            ></cross-wui-chip>
          </cross-wui-flex>
        </cross-wui-flex>` : x$3`<cross-wui-flex
          columnGap="4xs"
          flexDirection="row"
          alignItems="center"
          justifyContent="center"
        >
          <cross-wui-text variant="small-400" class="title" color="fg-200"
            >Haven't got a wallet?</wui-text
          >
          <cross-wui-link
            data-testid="cross-w3m-wallet-guide-get-started"
            color="blue-100"
            class="get-started-link"
            @click=${this.onGetStarted}
            tabIdx=${o$2(this.tabIdx)}
          >
            Get started
          </cross-wui-link>
        </cross-wui-flex>`;
  }
  onGetStarted() {
    RouterController.push("Create");
  }
};
W3mWalletGuide.styles = styles$1;
__decorate$2([
  n$3()
], W3mWalletGuide.prototype, "tabIdx", void 0);
__decorate$2([
  n$3()
], W3mWalletGuide.prototype, "walletGuide", void 0);
W3mWalletGuide = __decorate$2([
  customElement("cross-w3m-wallet-guide")
], W3mWalletGuide);
const styles = i$4`
  :host {
    display: flex;
    justify-content: center;
    gap: var(--wui-spacing-2xl);
  }

  wui-visual-thumbnail:nth-child(1) {
    z-index: 1;
  }
`;
var __decorate$1 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let W3mSIWXSignMessageThumbnails = class W3mSIWXSignMessageThumbnails2 extends i$1 {
  constructor() {
    var _a3, _b2;
    super(...arguments);
    this.dappImageUrl = (_a3 = OptionsController.state.metadata) == null ? void 0 : _a3.icons;
    this.walletImageUrl = (_b2 = AccountController.state.connectedWalletInfo) == null ? void 0 : _b2.icon;
  }
  firstUpdated() {
    var _a3;
    const visuals = (_a3 = this.shadowRoot) == null ? void 0 : _a3.querySelectorAll("cross-wui-visual-thumbnail");
    if (visuals == null ? void 0 : visuals[0]) {
      this.createAnimation(visuals[0], "translate(18px)");
    }
    if (visuals == null ? void 0 : visuals[1]) {
      this.createAnimation(visuals[1], "translate(-18px)");
    }
  }
  render() {
    var _a3;
    return x$3`
      <cross-wui-visual-thumbnail
        ?borderRadiusFull=${true}
        .imageSrc=${(_a3 = this.dappImageUrl) == null ? void 0 : _a3[0]}
      ></cross-wui-visual-thumbnail>
      <cross-wui-visual-thumbnail .imageSrc=${this.walletImageUrl}></cross-wui-visual-thumbnail>
    `;
  }
  createAnimation(element, translation) {
    element.animate([{ transform: "translateX(0px)" }, { transform: translation }], {
      duration: 1600,
      easing: "cubic-bezier(0.56, 0, 0.48, 1)",
      direction: "alternate",
      iterations: Infinity
    });
  }
};
W3mSIWXSignMessageThumbnails.styles = styles;
W3mSIWXSignMessageThumbnails = __decorate$1([
  customElement("cross-w3m-siwx-sign-message-thumbnails")
], W3mSIWXSignMessageThumbnails);
const EthersHelpersUtil = {
  hexStringToNumber(value) {
    const string2 = value.startsWith("0x") ? value.slice(2) : value;
    const number2 = parseInt(string2, 16);
    return number2;
  },
  numberToHexString(value) {
    return `0x${value.toString(16)}`;
  },
  async getUserInfo(provider) {
    const [addresses, chainId] = await Promise.all([
      EthersHelpersUtil.getAddresses(provider),
      EthersHelpersUtil.getChainId(provider)
    ]);
    return { chainId, addresses };
  },
  async getChainId(provider) {
    const chainId = await provider.request({ method: "eth_chainId" });
    return Number(chainId);
  },
  async getAddress(provider) {
    const [address] = await provider.request({ method: "eth_accounts" });
    return address;
  },
  async getAddresses(provider) {
    const addresses = await provider.request({ method: "eth_accounts" });
    return addresses;
  },
  async addEthereumChain(provider, caipNetwork) {
    var _a3, _b2;
    const rpcUrls = ((_a3 = caipNetwork.rpcUrls["chainDefault"]) == null ? void 0 : _a3.http) || [];
    await provider.request({
      method: "wallet_addEthereumChain",
      params: [
        {
          chainId: EthersHelpersUtil.numberToHexString(caipNetwork.id),
          rpcUrls: [...rpcUrls],
          chainName: caipNetwork.name,
          nativeCurrency: {
            name: caipNetwork.nativeCurrency.name,
            decimals: caipNetwork.nativeCurrency.decimals,
            symbol: caipNetwork.nativeCurrency.symbol
          },
          blockExplorerUrls: [(_b2 = caipNetwork.blockExplorers) == null ? void 0 : _b2.default.url],
          iconUrls: [PresetsUtil.NetworkImageIds[caipNetwork.id]]
        }
      ]
    });
  }
};
var G$2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global$1 < "u" ? global$1 : typeof self < "u" ? self : {};
function At$3() {
  this.__data__ = [], this.size = 0;
}
var jt$2 = At$3;
function Ht$3(r3, e3) {
  return r3 === e3 || r3 !== r3 && e3 !== e3;
}
var z$4 = Ht$3, Et$4 = z$4;
function St$4(r3, e3) {
  for (var t2 = r3.length; t2--; ) if (Et$4(r3[t2][0], e3)) return t2;
  return -1;
}
var k$1 = St$4, Nt$3 = k$1, Tt$3 = Array.prototype, Dt$3 = Tt$3.splice;
function qt$3(r3) {
  var e3 = this.__data__, t2 = Nt$3(e3, r3);
  if (t2 < 0) return false;
  var i4 = e3.length - 1;
  return t2 == i4 ? e3.pop() : Dt$3.call(e3, t2, 1), --this.size, true;
}
var Rt$3 = qt$3, xt$3 = k$1;
function Lt$3(r3) {
  var e3 = this.__data__, t2 = xt$3(e3, r3);
  return t2 < 0 ? void 0 : e3[t2][1];
}
var Ut$3 = Lt$3, Ft$3 = k$1;
function Mt$3(r3) {
  return Ft$3(this.__data__, r3) > -1;
}
var Gt$3 = Mt$3, zt$3 = k$1;
function kt$2(r3, e3) {
  var t2 = this.__data__, i4 = zt$3(t2, r3);
  return i4 < 0 ? (++this.size, t2.push([r3, e3])) : t2[i4][1] = e3, this;
}
var Bt$3 = kt$2, Vt$3 = jt$2, Jt$3 = Rt$3, Kt$3 = Ut$3, Wt$3 = Gt$3, Xt$3 = Bt$3;
function _$3(r3) {
  var e3 = -1, t2 = r3 == null ? 0 : r3.length;
  for (this.clear(); ++e3 < t2; ) {
    var i4 = r3[e3];
    this.set(i4[0], i4[1]);
  }
}
_$3.prototype.clear = Vt$3, _$3.prototype.delete = Jt$3, _$3.prototype.get = Kt$3, _$3.prototype.has = Wt$3, _$3.prototype.set = Xt$3;
var B$2 = _$3, Yt$3 = B$2;
function Zt$3() {
  this.__data__ = new Yt$3(), this.size = 0;
}
var Qt$3 = Zt$3;
function er$3(r3) {
  var e3 = this.__data__, t2 = e3.delete(r3);
  return this.size = e3.size, t2;
}
var tr$3 = er$3;
function rr$3(r3) {
  return this.__data__.get(r3);
}
var ir$3 = rr$3;
function sr$3(r3) {
  return this.__data__.has(r3);
}
var nr$3 = sr$3, ar$3 = typeof G$2 == "object" && G$2 && G$2.Object === Object && G$2, we$3 = ar$3, or$3 = we$3, cr$3 = typeof self == "object" && self && self.Object === Object && self, hr$3 = or$3 || cr$3 || Function("return this")(), C$2 = hr$3, pr$3 = C$2, ur$3 = pr$3.Symbol, _e$4 = ur$3, Ce$2 = _e$4, Ie$2 = Object.prototype, lr$3 = Ie$2.hasOwnProperty, dr$3 = Ie$2.toString, F$3 = Ce$2 ? Ce$2.toStringTag : void 0;
function vr$3(r3) {
  var e3 = lr$3.call(r3, F$3), t2 = r3[F$3];
  try {
    r3[F$3] = void 0;
    var i4 = true;
  } catch {
  }
  var s2 = dr$3.call(r3);
  return i4 && (e3 ? r3[F$3] = t2 : delete r3[F$3]), s2;
}
var fr$3 = vr$3, mr$3 = Object.prototype, gr$3 = mr$3.toString;
function Pr$2(r3) {
  return gr$3.call(r3);
}
var br$3 = Pr$2, Oe$3 = _e$4, $r$3 = fr$3, yr$3 = br$3, wr$3 = "[object Null]", _r$3 = "[object Undefined]", Ae$3 = Oe$3 ? Oe$3.toStringTag : void 0;
function Cr$2(r3) {
  return r3 == null ? r3 === void 0 ? _r$3 : wr$3 : Ae$3 && Ae$3 in Object(r3) ? $r$3(r3) : yr$3(r3);
}
var V$4 = Cr$2;
function Ir$3(r3) {
  var e3 = typeof r3;
  return r3 != null && (e3 == "object" || e3 == "function");
}
var $$3 = Ir$3, Or$3 = V$4, Ar$3 = $$3, jr$1 = "[object AsyncFunction]", Hr$3 = "[object Function]", Er$3 = "[object GeneratorFunction]", Sr$3 = "[object Proxy]";
function Nr$3(r3) {
  if (!Ar$3(r3)) return false;
  var e3 = Or$3(r3);
  return e3 == Hr$3 || e3 == Er$3 || e3 == jr$1 || e3 == Sr$3;
}
var te$2 = Nr$3, Tr$3 = C$2, Dr$2 = Tr$3["__core-js_shared__"], qr$3 = Dr$2, re$3 = qr$3, je$3 = function() {
  var r3 = /[^.]+$/.exec(re$3 && re$3.keys && re$3.keys.IE_PROTO || "");
  return r3 ? "Symbol(src)_1." + r3 : "";
}();
function Rr$3(r3) {
  return !!je$3 && je$3 in r3;
}
var xr$3 = Rr$3, Lr$2 = Function.prototype, Ur$3 = Lr$2.toString;
function Fr$3(r3) {
  if (r3 != null) {
    try {
      return Ur$3.call(r3);
    } catch {
    }
    try {
      return r3 + "";
    } catch {
    }
  }
  return "";
}
var Mr$3 = Fr$3, Gr$3 = te$2, zr$3 = xr$3, kr$2 = $$3, Br$2 = Mr$3, Vr$3 = /[\\^$.*+?()[\]{}|]/g, Jr$3 = /^\[object .+?Constructor\]$/, Kr$3 = Function.prototype, Wr$3 = Object.prototype, Xr$3 = Kr$3.toString, Yr$3 = Wr$3.hasOwnProperty, Zr$3 = RegExp("^" + Xr$3.call(Yr$3).replace(Vr$3, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function Qr$3(r3) {
  if (!kr$2(r3) || zr$3(r3)) return false;
  var e3 = Gr$3(r3) ? Zr$3 : Jr$3;
  return e3.test(Br$2(r3));
}
var ei$3 = Qr$3;
function ti$3(r3, e3) {
  return r3 == null ? void 0 : r3[e3];
}
var ri$3 = ti$3, ii$3 = ei$3, si$3 = ri$3;
function ni$3(r3, e3) {
  var t2 = si$3(r3, e3);
  return ii$3(t2) ? t2 : void 0;
}
var ie$3 = ni$3, ai$3 = ie$3, oi$3 = C$2, ci$3 = ai$3(oi$3, "Map"), He$3 = ci$3, hi$3 = ie$3, pi$3 = hi$3(Object, "create"), J$3 = pi$3, Ee$3 = J$3;
function ui$3() {
  this.__data__ = Ee$3 ? Ee$3(null) : {}, this.size = 0;
}
var li$3 = ui$3;
function di$3(r3) {
  var e3 = this.has(r3) && delete this.__data__[r3];
  return this.size -= e3 ? 1 : 0, e3;
}
var vi$3 = di$3, fi$3 = J$3, mi$3 = "__lodash_hash_undefined__", gi$3 = Object.prototype, Pi$3 = gi$3.hasOwnProperty;
function bi$3(r3) {
  var e3 = this.__data__;
  if (fi$3) {
    var t2 = e3[r3];
    return t2 === mi$3 ? void 0 : t2;
  }
  return Pi$3.call(e3, r3) ? e3[r3] : void 0;
}
var $i$3 = bi$3, yi$3 = J$3, wi$3 = Object.prototype, _i$3 = wi$3.hasOwnProperty;
function Ci$3(r3) {
  var e3 = this.__data__;
  return yi$3 ? e3[r3] !== void 0 : _i$3.call(e3, r3);
}
var Ii$3 = Ci$3, Oi$3 = J$3, Ai$3 = "__lodash_hash_undefined__";
function ji$2(r3, e3) {
  var t2 = this.__data__;
  return this.size += this.has(r3) ? 0 : 1, t2[r3] = Oi$3 && e3 === void 0 ? Ai$3 : e3, this;
}
var Hi$2 = ji$2, Ei$3 = li$3, Si$3 = vi$3, Ni$3 = $i$3, Ti$3 = Ii$3, Di$3 = Hi$2;
function I$1(r3) {
  var e3 = -1, t2 = r3 == null ? 0 : r3.length;
  for (this.clear(); ++e3 < t2; ) {
    var i4 = r3[e3];
    this.set(i4[0], i4[1]);
  }
}
I$1.prototype.clear = Ei$3, I$1.prototype.delete = Si$3, I$1.prototype.get = Ni$3, I$1.prototype.has = Ti$3, I$1.prototype.set = Di$3;
var qi$2 = I$1, Se$3 = qi$2, Ri$3 = B$2, xi$3 = He$3;
function Li$3() {
  this.size = 0, this.__data__ = { hash: new Se$3(), map: new (xi$3 || Ri$3)(), string: new Se$3() };
}
var Ui$2 = Li$3;
function Fi$2(r3) {
  var e3 = typeof r3;
  return e3 == "string" || e3 == "number" || e3 == "symbol" || e3 == "boolean" ? r3 !== "__proto__" : r3 === null;
}
var Mi$2 = Fi$2, Gi$2 = Mi$2;
function zi$3(r3, e3) {
  var t2 = r3.__data__;
  return Gi$2(e3) ? t2[typeof e3 == "string" ? "string" : "hash"] : t2.map;
}
var K$1 = zi$3, ki$2 = K$1;
function Bi$2(r3) {
  var e3 = ki$2(this, r3).delete(r3);
  return this.size -= e3 ? 1 : 0, e3;
}
var Vi$2 = Bi$2, Ji$2 = K$1;
function Ki$2(r3) {
  return Ji$2(this, r3).get(r3);
}
var Wi$2 = Ki$2, Xi$2 = K$1;
function Yi$2(r3) {
  return Xi$2(this, r3).has(r3);
}
var Zi$2 = Yi$2, Qi$1 = K$1;
function es$2(r3, e3) {
  var t2 = Qi$1(this, r3), i4 = t2.size;
  return t2.set(r3, e3), this.size += t2.size == i4 ? 0 : 1, this;
}
var ts$2 = es$2, rs$2 = Ui$2, is$2 = Vi$2, ss$2 = Wi$2, ns$2 = Zi$2, as$2 = ts$2;
function O$1(r3) {
  var e3 = -1, t2 = r3 == null ? 0 : r3.length;
  for (this.clear(); ++e3 < t2; ) {
    var i4 = r3[e3];
    this.set(i4[0], i4[1]);
  }
}
O$1.prototype.clear = rs$2, O$1.prototype.delete = is$2, O$1.prototype.get = ss$2, O$1.prototype.has = ns$2, O$1.prototype.set = as$2;
var os$2 = O$1, cs$2 = B$2, hs$2 = He$3, ps$2 = os$2, us$2 = 200;
function ls$2(r3, e3) {
  var t2 = this.__data__;
  if (t2 instanceof cs$2) {
    var i4 = t2.__data__;
    if (!hs$2 || i4.length < us$2 - 1) return i4.push([r3, e3]), this.size = ++t2.size, this;
    t2 = this.__data__ = new ps$2(i4);
  }
  return t2.set(r3, e3), this.size = t2.size, this;
}
var ds$2 = ls$2, vs$3 = B$2, fs$3 = Qt$3, ms$2 = tr$3, gs$2 = ir$3, Ps$3 = nr$3, bs$3 = ds$2;
function A$1(r3) {
  var e3 = this.__data__ = new vs$3(r3);
  this.size = e3.size;
}
A$1.prototype.clear = fs$3, A$1.prototype.delete = ms$2, A$1.prototype.get = gs$2, A$1.prototype.has = Ps$3, A$1.prototype.set = bs$3;
var $s$2 = A$1, ys$2 = ie$3, ws$2 = function() {
  try {
    var r3 = ys$2(Object, "defineProperty");
    return r3({}, "", {}), r3;
  } catch {
  }
}(), Ne$3 = ws$2, Te$2 = Ne$3;
function _s$2(r3, e3, t2) {
  e3 == "__proto__" && Te$2 ? Te$2(r3, e3, { configurable: true, enumerable: true, value: t2, writable: true }) : r3[e3] = t2;
}
var se$3 = _s$2, Cs$3 = se$3, Is$3 = z$4;
function Os$3(r3, e3, t2) {
  (t2 !== void 0 && !Is$3(r3[e3], t2) || t2 === void 0 && !(e3 in r3)) && Cs$3(r3, e3, t2);
}
var De$3 = Os$3;
function As$3(r3) {
  return function(e3, t2, i4) {
    for (var s2 = -1, n5 = Object(e3), a2 = i4(e3), o3 = a2.length; o3--; ) {
      var c2 = a2[r3 ? o3 : ++s2];
      if (t2(n5[c2], c2, n5) === false) break;
    }
    return e3;
  };
}
var js$3 = As$3, Hs$3 = js$3, Es$2 = Hs$3(), Ss$2 = Es$2, ne$3 = { exports: {} };
(function(r3, e3) {
  var t2 = C$2, i4 = e3 && !e3.nodeType && e3, s2 = i4 && true && r3 && !r3.nodeType && r3, n5 = s2 && s2.exports === i4, a2 = n5 ? t2.Buffer : void 0, o3 = a2 ? a2.allocUnsafe : void 0;
  function c2(u2, l2) {
    if (l2) return u2.slice();
    var P3 = u2.length, d4 = o3 ? o3(P3) : new u2.constructor(P3);
    return u2.copy(d4), d4;
  }
  r3.exports = c2;
})(ne$3, ne$3.exports);
var Ns$3 = C$2, Ts$3 = Ns$3.Uint8Array, Ds$3 = Ts$3, qe$3 = Ds$3;
function qs$4(r3) {
  var e3 = new r3.constructor(r3.byteLength);
  return new qe$3(e3).set(new qe$3(r3)), e3;
}
var Rs$3 = qs$4, xs$3 = Rs$3;
function Ls$3(r3, e3) {
  var t2 = e3 ? xs$3(r3.buffer) : r3.buffer;
  return new r3.constructor(t2, r3.byteOffset, r3.length);
}
var Us$2 = Ls$3;
function Fs$2(r3, e3) {
  var t2 = -1, i4 = r3.length;
  for (e3 || (e3 = Array(i4)); ++t2 < i4; ) e3[t2] = r3[t2];
  return e3;
}
var Ms$2 = Fs$2, Gs$3 = $$3, Re$2 = Object.create, zs$2 = /* @__PURE__ */ function() {
  function r3() {
  }
  return function(e3) {
    if (!Gs$3(e3)) return {};
    if (Re$2) return Re$2(e3);
    r3.prototype = e3;
    var t2 = new r3();
    return r3.prototype = void 0, t2;
  };
}(), ks$2 = zs$2;
function Bs$2(r3, e3) {
  return function(t2) {
    return r3(e3(t2));
  };
}
var Vs$3 = Bs$2, Js$3 = Vs$3, Ks$2 = Js$3(Object.getPrototypeOf, Object), xe$3 = Ks$2, Ws$3 = Object.prototype;
function Xs$3(r3) {
  var e3 = r3 && r3.constructor, t2 = typeof e3 == "function" && e3.prototype || Ws$3;
  return r3 === t2;
}
var Le$4 = Xs$3, Ys$3 = ks$2, Zs$3 = xe$3, Qs$3 = Le$4;
function en$3(r3) {
  return typeof r3.constructor == "function" && !Qs$3(r3) ? Ys$3(Zs$3(r3)) : {};
}
var tn$3 = en$3;
function rn$3(r3) {
  return r3 != null && typeof r3 == "object";
}
var M$3 = rn$3, sn$3 = V$4, nn$3 = M$3, an$3 = "[object Arguments]";
function on$3(r3) {
  return nn$3(r3) && sn$3(r3) == an$3;
}
var cn$3 = on$3, Ue$4 = cn$3, hn$3 = M$3, Fe$4 = Object.prototype, pn$3 = Fe$4.hasOwnProperty, un$3 = Fe$4.propertyIsEnumerable, ln$3 = Ue$4(/* @__PURE__ */ function() {
  return arguments;
}()) ? Ue$4 : function(r3) {
  return hn$3(r3) && pn$3.call(r3, "callee") && !un$3.call(r3, "callee");
}, Me$4 = ln$3, dn$3 = Array.isArray, Ge$3 = dn$3, vn$3 = 9007199254740991;
function fn$3(r3) {
  return typeof r3 == "number" && r3 > -1 && r3 % 1 == 0 && r3 <= vn$3;
}
var ze$2 = fn$3, mn$3 = te$2, gn$3 = ze$2;
function Pn$3(r3) {
  return r3 != null && gn$3(r3.length) && !mn$3(r3);
}
var ae$3 = Pn$3, bn$3 = ae$3, $n$3 = M$3;
function yn$3(r3) {
  return $n$3(r3) && bn$3(r3);
}
var wn$3 = yn$3, W$1 = { exports: {} };
function _n$3() {
  return false;
}
var Cn$3 = _n$3;
(function(r3, e3) {
  var t2 = C$2, i4 = Cn$3, s2 = e3 && !e3.nodeType && e3, n5 = s2 && true && r3 && !r3.nodeType && r3, a2 = n5 && n5.exports === s2, o3 = a2 ? t2.Buffer : void 0, c2 = o3 ? o3.isBuffer : void 0, u2 = c2 || i4;
  r3.exports = u2;
})(W$1, W$1.exports);
var In$3 = V$4, On$3 = xe$3, An$3 = M$3, jn$3 = "[object Object]", Hn$3 = Function.prototype, En$3 = Object.prototype, ke$4 = Hn$3.toString, Sn$3 = En$3.hasOwnProperty, Nn$3 = ke$4.call(Object);
function Tn$3(r3) {
  if (!An$3(r3) || In$3(r3) != jn$3) return false;
  var e3 = On$3(r3);
  if (e3 === null) return true;
  var t2 = Sn$3.call(e3, "constructor") && e3.constructor;
  return typeof t2 == "function" && t2 instanceof t2 && ke$4.call(t2) == Nn$3;
}
var Dn$3 = Tn$3, qn$3 = V$4, Rn$3 = ze$2, xn$3 = M$3, Ln$3 = "[object Arguments]", Un$3 = "[object Array]", Fn$3 = "[object Boolean]", Mn$3 = "[object Date]", Gn$3 = "[object Error]", zn$3 = "[object Function]", kn$3 = "[object Map]", Bn$3 = "[object Number]", Vn$3 = "[object Object]", Jn$3 = "[object RegExp]", Kn$3 = "[object Set]", Wn$3 = "[object String]", Xn$3 = "[object WeakMap]", Yn$3 = "[object ArrayBuffer]", Zn$3 = "[object DataView]", Qn$3 = "[object Float32Array]", ea$1 = "[object Float64Array]", ta$1 = "[object Int8Array]", ra$1 = "[object Int16Array]", ia$1 = "[object Int32Array]", sa$1 = "[object Uint8Array]", na$1 = "[object Uint8ClampedArray]", aa$1 = "[object Uint16Array]", oa$1 = "[object Uint32Array]", p$2 = {};
p$2[Qn$3] = p$2[ea$1] = p$2[ta$1] = p$2[ra$1] = p$2[ia$1] = p$2[sa$1] = p$2[na$1] = p$2[aa$1] = p$2[oa$1] = true, p$2[Ln$3] = p$2[Un$3] = p$2[Yn$3] = p$2[Fn$3] = p$2[Zn$3] = p$2[Mn$3] = p$2[Gn$3] = p$2[zn$3] = p$2[kn$3] = p$2[Bn$3] = p$2[Vn$3] = p$2[Jn$3] = p$2[Kn$3] = p$2[Wn$3] = p$2[Xn$3] = false;
function ca$1(r3) {
  return xn$3(r3) && Rn$3(r3.length) && !!p$2[qn$3(r3)];
}
var ha$1 = ca$1;
function pa$1(r3) {
  return function(e3) {
    return r3(e3);
  };
}
var ua$1 = pa$1, oe$2 = { exports: {} };
(function(r3, e3) {
  var t2 = we$3, i4 = e3 && !e3.nodeType && e3, s2 = i4 && true && r3 && !r3.nodeType && r3, n5 = s2 && s2.exports === i4, a2 = n5 && t2.process, o3 = function() {
    try {
      var c2 = s2 && s2.require && s2.require("util").types;
      return c2 || a2 && a2.binding && a2.binding("util");
    } catch {
    }
  }();
  r3.exports = o3;
})(oe$2, oe$2.exports);
var la$1 = ha$1, da$1 = ua$1, Be$3 = oe$2.exports, Ve$3 = Be$3 && Be$3.isTypedArray, va$1 = Ve$3 ? da$1(Ve$3) : la$1, Je$1 = va$1;
function fa$1(r3, e3) {
  if (!(e3 === "constructor" && typeof r3[e3] == "function") && e3 != "__proto__") return r3[e3];
}
var Ke$4 = fa$1, ma$1 = se$3, ga$1 = z$4, Pa$1 = Object.prototype, ba$1 = Pa$1.hasOwnProperty;
function $a$1(r3, e3, t2) {
  var i4 = r3[e3];
  (!(ba$1.call(r3, e3) && ga$1(i4, t2)) || t2 === void 0 && !(e3 in r3)) && ma$1(r3, e3, t2);
}
var ya$1 = $a$1, wa$1 = ya$1, _a$1 = se$3;
function Ca$1(r3, e3, t2, i4) {
  var s2 = !t2;
  t2 || (t2 = {});
  for (var n5 = -1, a2 = e3.length; ++n5 < a2; ) {
    var o3 = e3[n5], c2 = i4 ? i4(t2[o3], r3[o3], o3, t2, r3) : void 0;
    c2 === void 0 && (c2 = r3[o3]), s2 ? _a$1(t2, o3, c2) : wa$1(t2, o3, c2);
  }
  return t2;
}
var Ia$1 = Ca$1;
function Oa$1(r3, e3) {
  for (var t2 = -1, i4 = Array(r3); ++t2 < r3; ) i4[t2] = e3(t2);
  return i4;
}
var Aa$1 = Oa$1, ja$1 = 9007199254740991, Ha$1 = /^(?:0|[1-9]\d*)$/;
function Ea$1(r3, e3) {
  var t2 = typeof r3;
  return e3 = e3 ?? ja$1, !!e3 && (t2 == "number" || t2 != "symbol" && Ha$1.test(r3)) && r3 > -1 && r3 % 1 == 0 && r3 < e3;
}
var We$1 = Ea$1, Sa$1 = Aa$1, Na$1 = Me$4, Ta$1 = Ge$3, Da$1 = W$1.exports, qa$1 = We$1, Ra$1 = Je$1, xa$1 = Object.prototype, La$1 = xa$1.hasOwnProperty;
function Ua$1(r3, e3) {
  var t2 = Ta$1(r3), i4 = !t2 && Na$1(r3), s2 = !t2 && !i4 && Da$1(r3), n5 = !t2 && !i4 && !s2 && Ra$1(r3), a2 = t2 || i4 || s2 || n5, o3 = a2 ? Sa$1(r3.length, String) : [], c2 = o3.length;
  for (var u2 in r3) (e3 || La$1.call(r3, u2)) && !(a2 && (u2 == "length" || s2 && (u2 == "offset" || u2 == "parent") || n5 && (u2 == "buffer" || u2 == "byteLength" || u2 == "byteOffset") || qa$1(u2, c2))) && o3.push(u2);
  return o3;
}
var Fa$1 = Ua$1;
function Ma$1(r3) {
  var e3 = [];
  if (r3 != null) for (var t2 in Object(r3)) e3.push(t2);
  return e3;
}
var Ga$1 = Ma$1, za$1 = $$3, ka$1 = Le$4, Ba$1 = Ga$1, Va$1 = Object.prototype, Ja$1 = Va$1.hasOwnProperty;
function Ka$1(r3) {
  if (!za$1(r3)) return Ba$1(r3);
  var e3 = ka$1(r3), t2 = [];
  for (var i4 in r3) i4 == "constructor" && (e3 || !Ja$1.call(r3, i4)) || t2.push(i4);
  return t2;
}
var Wa$1 = Ka$1, Xa$1 = Fa$1, Ya$1 = Wa$1, Za$1 = ae$3;
function Qa$1(r3) {
  return Za$1(r3) ? Xa$1(r3, true) : Ya$1(r3);
}
var Xe$2 = Qa$1, eo$3 = Ia$1, to$3 = Xe$2;
function ro$3(r3) {
  return eo$3(r3, to$3(r3));
}
var io$3 = ro$3, Ye$2 = De$3, so$3 = ne$3.exports, no$3 = Us$2, ao$3 = Ms$2, oo$3 = tn$3, Ze$2 = Me$4, Qe$2 = Ge$3, co$2 = wn$3, ho$2 = W$1.exports, po$2 = te$2, uo$2 = $$3, lo$2 = Dn$3, vo$2 = Je$1, et$2 = Ke$4, fo$2 = io$3;
function mo$2(r3, e3, t2, i4, s2, n5, a2) {
  var o3 = et$2(r3, t2), c2 = et$2(e3, t2), u2 = a2.get(c2);
  if (u2) {
    Ye$2(r3, t2, u2);
    return;
  }
  var l2 = n5 ? n5(o3, c2, t2 + "", r3, e3, a2) : void 0, P3 = l2 === void 0;
  if (P3) {
    var d4 = Qe$2(c2), Q2 = !d4 && ho$2(c2), ve2 = !d4 && !Q2 && vo$2(c2);
    l2 = c2, d4 || Q2 || ve2 ? Qe$2(o3) ? l2 = o3 : co$2(o3) ? l2 = ao$3(o3) : Q2 ? (P3 = false, l2 = so$3(c2, true)) : ve2 ? (P3 = false, l2 = no$3(c2, true)) : l2 = [] : lo$2(c2) || Ze$2(c2) ? (l2 = o3, Ze$2(o3) ? l2 = fo$2(o3) : (!uo$2(o3) || po$2(o3)) && (l2 = oo$3(c2))) : P3 = false;
  }
  P3 && (a2.set(c2, l2), s2(l2, c2, i4, n5, a2), a2.delete(c2)), Ye$2(r3, t2, l2);
}
var go$2 = mo$2, Po$2 = $s$2, bo$2 = De$3, $o$2 = Ss$2, yo$2 = go$2, wo$2 = $$3, _o$2 = Xe$2, Co$2 = Ke$4;
function tt$2(r3, e3, t2, i4, s2) {
  r3 !== e3 && $o$2(e3, function(n5, a2) {
    if (s2 || (s2 = new Po$2()), wo$2(n5)) yo$2(r3, e3, a2, t2, tt$2, i4, s2);
    else {
      var o3 = i4 ? i4(Co$2(r3, a2), n5, a2 + "", r3, e3, s2) : void 0;
      o3 === void 0 && (o3 = n5), bo$2(r3, a2, o3);
    }
  }, _o$2);
}
var Io$2 = tt$2;
function Oo$2(r3) {
  return r3;
}
var rt$2 = Oo$2;
function Ao$2(r3, e3, t2) {
  switch (t2.length) {
    case 0:
      return r3.call(e3);
    case 1:
      return r3.call(e3, t2[0]);
    case 2:
      return r3.call(e3, t2[0], t2[1]);
    case 3:
      return r3.call(e3, t2[0], t2[1], t2[2]);
  }
  return r3.apply(e3, t2);
}
var jo$2 = Ao$2, Ho$2 = jo$2, it$2 = Math.max;
function Eo$2(r3, e3, t2) {
  return e3 = it$2(e3 === void 0 ? r3.length - 1 : e3, 0), function() {
    for (var i4 = arguments, s2 = -1, n5 = it$2(i4.length - e3, 0), a2 = Array(n5); ++s2 < n5; ) a2[s2] = i4[e3 + s2];
    s2 = -1;
    for (var o3 = Array(e3 + 1); ++s2 < e3; ) o3[s2] = i4[s2];
    return o3[e3] = t2(a2), Ho$2(r3, this, o3);
  };
}
var So$2 = Eo$2;
function No$2(r3) {
  return function() {
    return r3;
  };
}
var To$2 = No$2, Do$2 = To$2, st$2 = Ne$3, qo$2 = rt$2, Ro$2 = st$2 ? function(r3, e3) {
  return st$2(r3, "toString", { configurable: true, enumerable: false, value: Do$2(e3), writable: true });
} : qo$2, xo$2 = Ro$2, Lo$2 = 800, Uo$2 = 16, Fo$2 = Date.now;
function Mo$2(r3) {
  var e3 = 0, t2 = 0;
  return function() {
    var i4 = Fo$2(), s2 = Uo$2 - (i4 - t2);
    if (t2 = i4, s2 > 0) {
      if (++e3 >= Lo$2) return arguments[0];
    } else e3 = 0;
    return r3.apply(void 0, arguments);
  };
}
var Go$2 = Mo$2, zo$2 = xo$2, ko$2 = Go$2, Bo$2 = ko$2(zo$2), Vo$2 = Bo$2, Jo$2 = rt$2, Ko$2 = So$2, Wo$2 = Vo$2;
function Xo$2(r3, e3) {
  return Wo$2(Ko$2(r3, e3, Jo$2), r3 + "");
}
var Yo$2 = Xo$2, Zo$2 = z$4, Qo$2 = ae$3, ec$1 = We$1, tc$1 = $$3;
function rc$1(r3, e3, t2) {
  if (!tc$1(t2)) return false;
  var i4 = typeof e3;
  return (i4 == "number" ? Qo$2(t2) && ec$1(e3, t2.length) : i4 == "string" && e3 in t2) ? Zo$2(t2[e3], r3) : false;
}
var ic$1 = rc$1, sc$1 = Yo$2, nc$1 = ic$1;
function ac$1(r3) {
  return sc$1(function(e3, t2) {
    var i4 = -1, s2 = t2.length, n5 = s2 > 1 ? t2[s2 - 1] : void 0, a2 = s2 > 2 ? t2[2] : void 0;
    for (n5 = r3.length > 3 && typeof n5 == "function" ? (s2--, n5) : void 0, a2 && nc$1(t2[0], t2[1], a2) && (n5 = s2 < 3 ? void 0 : n5, s2 = 1), e3 = Object(e3); ++i4 < s2; ) {
      var o3 = t2[i4];
      o3 && r3(e3, o3, i4, n5);
    }
    return e3;
  });
}
var oc$1 = ac$1, cc$1 = Io$2, hc$1 = oc$1;
hc$1(function(r3, e3, t2) {
  cc$1(r3, e3, t2);
});
const version$1 = "6.13.2";
function checkType(value, type2, name) {
  const types2 = type2.split("|").map((t2) => t2.trim());
  for (let i4 = 0; i4 < types2.length; i4++) {
    switch (type2) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof value === type2) {
          return;
        }
    }
  }
  const error = new Error(`invalid value for type ${type2}`);
  error.code = "INVALID_ARGUMENT";
  error.argument = `value.${name}`;
  error.value = value;
  throw error;
}
async function resolveProperties(value) {
  const keys2 = Object.keys(value);
  const results = await Promise.all(keys2.map((k3) => Promise.resolve(value[k3])));
  return results.reduce((accum, v2, index2) => {
    accum[keys2[index2]] = v2;
    return accum;
  }, {});
}
function defineProperties(target, values, types2) {
  for (let key2 in values) {
    let value = values[key2];
    const type2 = types2 ? types2[key2] : null;
    if (type2) {
      checkType(value, type2, key2);
    }
    Object.defineProperty(target, key2, { enumerable: true, value, writable: false });
  }
}
function stringify(value) {
  if (value == null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "[ " + value.map(stringify).join(", ") + " ]";
  }
  if (value instanceof Uint8Array) {
    const HEX = "0123456789abcdef";
    let result = "0x";
    for (let i4 = 0; i4 < value.length; i4++) {
      result += HEX[value[i4] >> 4];
      result += HEX[value[i4] & 15];
    }
    return result;
  }
  if (typeof value === "object" && typeof value.toJSON === "function") {
    return stringify(value.toJSON());
  }
  switch (typeof value) {
    case "boolean":
    case "symbol":
      return value.toString();
    case "bigint":
      return BigInt(value).toString();
    case "number":
      return value.toString();
    case "string":
      return JSON.stringify(value);
    case "object": {
      const keys2 = Object.keys(value);
      keys2.sort();
      return "{ " + keys2.map((k3) => `${stringify(k3)}: ${stringify(value[k3])}`).join(", ") + " }";
    }
  }
  return `[ COULD NOT SERIALIZE ]`;
}
function isError(error, code2) {
  return error && error.code === code2;
}
function isCallException(error) {
  return isError(error, "CALL_EXCEPTION");
}
function makeError(message, code2, info) {
  let shortMessage = message;
  {
    const details = [];
    if (info) {
      if ("message" in info || "code" in info || "name" in info) {
        throw new Error(`value will overwrite populated values: ${stringify(info)}`);
      }
      for (const key2 in info) {
        if (key2 === "shortMessage") {
          continue;
        }
        const value = info[key2];
        details.push(key2 + "=" + stringify(value));
      }
    }
    details.push(`code=${code2}`);
    details.push(`version=${version$1}`);
    if (details.length) {
      message += " (" + details.join(", ") + ")";
    }
  }
  let error;
  switch (code2) {
    case "INVALID_ARGUMENT":
      error = new TypeError(message);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      error = new RangeError(message);
      break;
    default:
      error = new Error(message);
  }
  defineProperties(error, { code: code2 });
  if (info) {
    Object.assign(error, info);
  }
  if (error.shortMessage == null) {
    defineProperties(error, { shortMessage });
  }
  return error;
}
function assert(check, message, code2, info) {
  if (!check) {
    throw makeError(message, code2, info);
  }
}
function assertArgument(check, message, name, value) {
  assert(check, message, "INVALID_ARGUMENT", { argument: name, value });
}
function assertArgumentCount(count, expectedCount, message) {
  if (message == null) {
    message = "";
  }
  if (message) {
    message = ": " + message;
  }
  assert(count >= expectedCount, "missing arguemnt" + message, "MISSING_ARGUMENT", {
    count,
    expectedCount
  });
  assert(count <= expectedCount, "too many arguments" + message, "UNEXPECTED_ARGUMENT", {
    count,
    expectedCount
  });
}
["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
  try {
    if ("test".normalize(form) !== "test") {
      throw new Error("bad");
    }
    ;
    if (form === "NFD") {
      const check = String.fromCharCode(233).normalize("NFD");
      const expected = String.fromCharCode(101, 769);
      if (check !== expected) {
        throw new Error("broken");
      }
    }
    accum.push(form);
  } catch (error) {
  }
  return accum;
}, []);
function assertPrivate(givenGuard, guard, className) {
  if (className == null) {
    className = "";
  }
  if (givenGuard !== guard) {
    let method = className, operation = "new";
    if (className) {
      method += ".";
      operation += " " + className;
    }
    assert(false, `private constructor; use ${method}from* methods`, "UNSUPPORTED_OPERATION", {
      operation
    });
  }
}
function _getBytes(value, name, copy2) {
  if (value instanceof Uint8Array) {
    if (copy2) {
      return new Uint8Array(value);
    }
    return value;
  }
  if (typeof value === "string" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    const result = new Uint8Array((value.length - 2) / 2);
    let offset = 2;
    for (let i4 = 0; i4 < result.length; i4++) {
      result[i4] = parseInt(value.substring(offset, offset + 2), 16);
      offset += 2;
    }
    return result;
  }
  assertArgument(false, "invalid BytesLike value", name || "value", value);
}
function getBytes(value, name) {
  return _getBytes(value, name, false);
}
function getBytesCopy(value, name) {
  return _getBytes(value, name, true);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (typeof length === "number" && value.length !== 2 + 2 * length) {
    return false;
  }
  if (length === true && value.length % 2 !== 0) {
    return false;
  }
  return true;
}
function isBytesLike(value) {
  return isHexString(value, true) || value instanceof Uint8Array;
}
const HexCharacters = "0123456789abcdef";
function hexlify(data2) {
  const bytes2 = getBytes(data2);
  let result = "0x";
  for (let i4 = 0; i4 < bytes2.length; i4++) {
    const v2 = bytes2[i4];
    result += HexCharacters[(v2 & 240) >> 4] + HexCharacters[v2 & 15];
  }
  return result;
}
function concat(datas) {
  return "0x" + datas.map((d4) => hexlify(d4).substring(2)).join("");
}
function dataLength(data2) {
  if (isHexString(data2, true)) {
    return (data2.length - 2) / 2;
  }
  return getBytes(data2).length;
}
function dataSlice(data2, start, end) {
  const bytes2 = getBytes(data2);
  if (end != null && end > bytes2.length) {
    assert(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
      buffer: bytes2,
      length: bytes2.length,
      offset: end
    });
  }
  return hexlify(bytes2.slice(start == null ? 0 : start, end == null ? bytes2.length : end));
}
function zeroPad(data2, length, left) {
  const bytes2 = getBytes(data2);
  assert(length >= bytes2.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(bytes2),
    length,
    offset: length + 1
  });
  const result = new Uint8Array(length);
  result.fill(0);
  if (left) {
    result.set(bytes2, length - bytes2.length);
  } else {
    result.set(bytes2, 0);
  }
  return hexlify(result);
}
function zeroPadValue(data2, length) {
  return zeroPad(data2, length, true);
}
function zeroPadBytes(data2, length) {
  return zeroPad(data2, length, false);
}
const BN_0$9 = BigInt(0);
const BN_1$4 = BigInt(1);
const maxValue = 9007199254740991;
function fromTwos(_value2, _width) {
  const value = getUint(_value2, "value");
  const width = BigInt(getNumber(_width, "width"));
  assert(value >> width === BN_0$9, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: _value2
  });
  if (value >> width - BN_1$4) {
    const mask2 = (BN_1$4 << width) - BN_1$4;
    return -((~value & mask2) + BN_1$4);
  }
  return value;
}
function toTwos(_value2, _width) {
  let value = getBigInt(_value2, "value");
  const width = BigInt(getNumber(_width, "width"));
  const limit = BN_1$4 << width - BN_1$4;
  if (value < BN_0$9) {
    value = -value;
    assert(value <= limit, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value2
    });
    const mask2 = (BN_1$4 << width) - BN_1$4;
    return (~value & mask2) + BN_1$4;
  } else {
    assert(value < limit, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value2
    });
  }
  return value;
}
function mask(_value2, _bits) {
  const value = getUint(_value2, "value");
  const bits = BigInt(getNumber(_bits, "bits"));
  return value & (BN_1$4 << bits) - BN_1$4;
}
function getBigInt(value, name) {
  switch (typeof value) {
    case "bigint":
      return value;
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return BigInt(value);
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        if (value[0] === "-" && value[1] !== "-") {
          return -BigInt(value.substring(1));
        }
        return BigInt(value);
      } catch (e3) {
        assertArgument(false, `invalid BigNumberish string: ${e3.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid BigNumberish value", name || "value", value);
}
function getUint(value, name) {
  const result = getBigInt(value, name);
  assert(result >= BN_0$9, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value
  });
  return result;
}
const Nibbles = "0123456789abcdef";
function toBigInt(value) {
  if (value instanceof Uint8Array) {
    let result = "0x0";
    for (const v2 of value) {
      result += Nibbles[v2 >> 4];
      result += Nibbles[v2 & 15];
    }
    return BigInt(result);
  }
  return getBigInt(value);
}
function getNumber(value, name) {
  switch (typeof value) {
    case "bigint":
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return Number(value);
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return value;
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        return getNumber(BigInt(value), name);
      } catch (e3) {
        assertArgument(false, `invalid numeric string: ${e3.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid numeric value", name || "value", value);
}
function toNumber(value) {
  return getNumber(toBigInt(value));
}
function toBeHex(_value2, _width) {
  const value = getUint(_value2, "value");
  let result = value.toString(16);
  if (_width == null) {
    if (result.length % 2) {
      result = "0" + result;
    }
  } else {
    const width = getNumber(_width, "width");
    assert(width * 2 >= result.length, `value exceeds width (${width} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: _value2
    });
    while (result.length < width * 2) {
      result = "0" + result;
    }
  }
  return "0x" + result;
}
function toBeArray(_value2) {
  const value = getUint(_value2, "value");
  if (value === BN_0$9) {
    return new Uint8Array([]);
  }
  let hex = value.toString(16);
  if (hex.length % 2) {
    hex = "0" + hex;
  }
  const result = new Uint8Array(hex.length / 2);
  for (let i4 = 0; i4 < result.length; i4++) {
    const offset = i4 * 2;
    result[i4] = parseInt(hex.substring(offset, offset + 2), 16);
  }
  return result;
}
function toQuantity(value) {
  let result = hexlify(isBytesLike(value) ? value : toBeArray(value)).substring(2);
  while (result.startsWith("0")) {
    result = result.substring(1);
  }
  if (result === "") {
    result = "0";
  }
  return "0x" + result;
}
const Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
BigInt(0);
const BN_58 = BigInt(58);
function encodeBase58(_value2) {
  const bytes2 = getBytes(_value2);
  let value = toBigInt(bytes2);
  let result = "";
  while (value) {
    result = Alphabet[Number(value % BN_58)] + result;
    value /= BN_58;
  }
  for (let i4 = 0; i4 < bytes2.length; i4++) {
    if (bytes2[i4]) {
      break;
    }
    result = Alphabet[0] + result;
  }
  return result;
}
function decodeBase64(textData) {
  textData = atob(textData);
  const data2 = new Uint8Array(textData.length);
  for (let i4 = 0; i4 < textData.length; i4++) {
    data2[i4] = textData.charCodeAt(i4);
  }
  return getBytes(data2);
}
function encodeBase64(_data4) {
  const data2 = getBytes(_data4);
  let textData = "";
  for (let i4 = 0; i4 < data2.length; i4++) {
    textData += String.fromCharCode(data2[i4]);
  }
  return btoa(textData);
}
class EventPayload {
  /**
   *  Create a new **EventPayload** for %%emitter%% with
   *  the %%listener%% and for %%filter%%.
   */
  constructor(emitter, listener, filter) {
    /**
     *  The event filter.
     */
    __publicField(this, "filter");
    /**
     *  The **EventEmitterable**.
     */
    __publicField(this, "emitter");
    __privateAdd(this, _listener);
    __privateSet(this, _listener, listener);
    defineProperties(this, { emitter, filter });
  }
  /**
   *  Unregister the triggered listener for future events.
   */
  async removeListener() {
    if (__privateGet(this, _listener) == null) {
      return;
    }
    await this.emitter.off(this.filter, __privateGet(this, _listener));
  }
}
_listener = new WeakMap();
function errorFunc(reason, offset, bytes2, output2, badCodepoint) {
  assertArgument(false, `invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes2);
}
function ignoreFunc(reason, offset, bytes2, output2, badCodepoint) {
  if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
    let i4 = 0;
    for (let o3 = offset + 1; o3 < bytes2.length; o3++) {
      if (bytes2[o3] >> 6 !== 2) {
        break;
      }
      i4++;
    }
    return i4;
  }
  if (reason === "OVERRUN") {
    return bytes2.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes2, output2, badCodepoint) {
  if (reason === "OVERLONG") {
    assertArgument(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
    output2.push(badCodepoint);
    return 0;
  }
  output2.push(65533);
  return ignoreFunc(reason, offset, bytes2);
}
const Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(_bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  const bytes2 = getBytes(_bytes, "bytes");
  const result = [];
  let i4 = 0;
  while (i4 < bytes2.length) {
    const c2 = bytes2[i4++];
    if (c2 >> 7 === 0) {
      result.push(c2);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c2 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c2 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c2 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c2 & 192) === 128) {
        i4 += onError("UNEXPECTED_CONTINUE", i4 - 1, bytes2, result);
      } else {
        i4 += onError("BAD_PREFIX", i4 - 1, bytes2, result);
      }
      continue;
    }
    if (i4 - 1 + extraLength >= bytes2.length) {
      i4 += onError("OVERRUN", i4 - 1, bytes2, result);
      continue;
    }
    let res = c2 & (1 << 8 - extraLength - 1) - 1;
    for (let j2 = 0; j2 < extraLength; j2++) {
      let nextChar = bytes2[i4];
      if ((nextChar & 192) != 128) {
        i4 += onError("MISSING_CONTINUE", i4, bytes2, result);
        res = null;
        break;
      }
      res = res << 6 | nextChar & 63;
      i4++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i4 += onError("OUT_OF_RANGE", i4 - 1 - extraLength, bytes2, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i4 += onError("UTF16_SURROGATE", i4 - 1 - extraLength, bytes2, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i4 += onError("OVERLONG", i4 - 1 - extraLength, bytes2, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form) {
  assertArgument(typeof str === "string", "invalid string value", "str", str);
  let result = [];
  for (let i4 = 0; i4 < str.length; i4++) {
    const c2 = str.charCodeAt(i4);
    if (c2 < 128) {
      result.push(c2);
    } else if (c2 < 2048) {
      result.push(c2 >> 6 | 192);
      result.push(c2 & 63 | 128);
    } else if ((c2 & 64512) == 55296) {
      i4++;
      const c22 = str.charCodeAt(i4);
      assertArgument(i4 < str.length && (c22 & 64512) === 56320, "invalid surrogate pair", "str", str);
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c2 >> 12 | 224);
      result.push(c2 >> 6 & 63 | 128);
      result.push(c2 & 63 | 128);
    }
  }
  return new Uint8Array(result);
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes2, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes2, onError));
}
function createGetUrl(options) {
  async function getUrl2(req, _signal2) {
    assert(_signal2 == null || !_signal2.cancelled, "request cancelled before sending", "CANCELLED");
    const protocol = req.url.split(":")[0].toLowerCase();
    assert(protocol === "http" || protocol === "https", `unsupported protocol ${protocol}`, "UNSUPPORTED_OPERATION", {
      info: { protocol },
      operation: "request"
    });
    assert(protocol === "https" || !req.credentials || req.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
      operation: "request"
    });
    let error = null;
    const controller = new AbortController();
    const timer = setTimeout(() => {
      error = makeError("request timeout", "TIMEOUT");
      controller.abort();
    }, req.timeout);
    if (_signal2) {
      _signal2.addListener(() => {
        error = makeError("request cancelled", "CANCELLED");
        controller.abort();
      });
    }
    const init4 = {
      method: req.method,
      headers: new Headers(Array.from(req)),
      body: req.body || void 0,
      signal: controller.signal
    };
    let resp;
    try {
      resp = await fetch(req.url, init4);
    } catch (_error2) {
      clearTimeout(timer);
      if (error) {
        throw error;
      }
      throw _error2;
    }
    clearTimeout(timer);
    const headers = {};
    resp.headers.forEach((value, key2) => {
      headers[key2.toLowerCase()] = value;
    });
    const respBody = await resp.arrayBuffer();
    const body = respBody == null ? null : new Uint8Array(respBody);
    return {
      statusCode: resp.status,
      statusMessage: resp.statusText,
      headers,
      body
    };
  }
  return getUrl2;
}
const MAX_ATTEMPTS = 12;
const SLOT_INTERVAL = 250;
let defaultGetUrlFunc = createGetUrl();
const reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
const reIpfs = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
let locked$1 = false;
async function dataGatewayFunc(url, signal) {
  try {
    const match = url.match(reData);
    if (!match) {
      throw new Error("invalid data");
    }
    return new FetchResponse(200, "OK", {
      "content-type": match[1] || "text/plain"
    }, match[2] ? decodeBase64(match[3]) : unpercent(match[3]));
  } catch (error) {
    return new FetchResponse(599, "BAD REQUEST (invalid data: URI)", {}, null, new FetchRequest(url));
  }
}
function getIpfsGatewayFunc(baseUrl2) {
  async function gatewayIpfs(url, signal) {
    try {
      const match = url.match(reIpfs);
      if (!match) {
        throw new Error("invalid link");
      }
      return new FetchRequest(`${baseUrl2}${match[2]}`);
    } catch (error) {
      return new FetchResponse(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new FetchRequest(url));
    }
  }
  return gatewayIpfs;
}
const Gateways = {
  "data": dataGatewayFunc,
  "ipfs": getIpfsGatewayFunc("https://gateway.ipfs.io/ipfs/")
};
const fetchSignals = /* @__PURE__ */ new WeakMap();
class FetchCancelSignal {
  constructor(request) {
    __privateAdd(this, _listeners2);
    __privateAdd(this, _cancelled);
    __privateSet(this, _listeners2, []);
    __privateSet(this, _cancelled, false);
    fetchSignals.set(request, () => {
      if (__privateGet(this, _cancelled)) {
        return;
      }
      __privateSet(this, _cancelled, true);
      for (const listener of __privateGet(this, _listeners2)) {
        setTimeout(() => {
          listener();
        }, 0);
      }
      __privateSet(this, _listeners2, []);
    });
  }
  addListener(listener) {
    assert(!__privateGet(this, _cancelled), "singal already cancelled", "UNSUPPORTED_OPERATION", {
      operation: "fetchCancelSignal.addCancelListener"
    });
    __privateGet(this, _listeners2).push(listener);
  }
  get cancelled() {
    return __privateGet(this, _cancelled);
  }
  checkSignal() {
    assert(!this.cancelled, "cancelled", "CANCELLED", {});
  }
}
_listeners2 = new WeakMap();
_cancelled = new WeakMap();
function checkSignal(signal) {
  if (signal == null) {
    throw new Error("missing signal; should not happen");
  }
  signal.checkSignal();
  return signal;
}
const _FetchRequest = class _FetchRequest {
  /**
   *  Create a new FetchRequest instance with default values.
   *
   *  Once created, each property may be set before issuing a
   *  ``.send()`` to make the request.
   */
  constructor(url) {
    __privateAdd(this, _FetchRequest_instances);
    __privateAdd(this, _allowInsecure);
    __privateAdd(this, _gzip);
    __privateAdd(this, _headers);
    __privateAdd(this, _method);
    __privateAdd(this, _timeout);
    __privateAdd(this, _url);
    __privateAdd(this, _body);
    __privateAdd(this, _bodyType);
    __privateAdd(this, _creds);
    // Hooks
    __privateAdd(this, _preflight);
    __privateAdd(this, _process);
    __privateAdd(this, _retry);
    __privateAdd(this, _signal);
    __privateAdd(this, _throttle);
    __privateAdd(this, _getUrlFunc);
    __privateSet(this, _url, String(url));
    __privateSet(this, _allowInsecure, false);
    __privateSet(this, _gzip, true);
    __privateSet(this, _headers, {});
    __privateSet(this, _method, "");
    __privateSet(this, _timeout, 3e5);
    __privateSet(this, _throttle, {
      slotInterval: SLOT_INTERVAL,
      maxAttempts: MAX_ATTEMPTS
    });
    __privateSet(this, _getUrlFunc, null);
  }
  /**
   *  The fetch URL to request.
   */
  get url() {
    return __privateGet(this, _url);
  }
  set url(url) {
    __privateSet(this, _url, String(url));
  }
  /**
   *  The fetch body, if any, to send as the request body. //(default: null)//
   *
   *  When setting a body, the intrinsic ``Content-Type`` is automatically
   *  set and will be used if **not overridden** by setting a custom
   *  header.
   *
   *  If %%body%% is null, the body is cleared (along with the
   *  intrinsic ``Content-Type``).
   *
   *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to
   *  ``text/plain``.
   *
   *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to
   *  ``application/octet-stream``.
   *
   *  If %%body%% is any other object, the intrinsic ``Content-Type`` is
   *  set to ``application/json``.
   */
  get body() {
    if (__privateGet(this, _body) == null) {
      return null;
    }
    return new Uint8Array(__privateGet(this, _body));
  }
  set body(body) {
    if (body == null) {
      __privateSet(this, _body, void 0);
      __privateSet(this, _bodyType, void 0);
    } else if (typeof body === "string") {
      __privateSet(this, _body, toUtf8Bytes(body));
      __privateSet(this, _bodyType, "text/plain");
    } else if (body instanceof Uint8Array) {
      __privateSet(this, _body, body);
      __privateSet(this, _bodyType, "application/octet-stream");
    } else if (typeof body === "object") {
      __privateSet(this, _body, toUtf8Bytes(JSON.stringify(body)));
      __privateSet(this, _bodyType, "application/json");
    } else {
      throw new Error("invalid body");
    }
  }
  /**
   *  Returns true if the request has a body.
   */
  hasBody() {
    return __privateGet(this, _body) != null;
  }
  /**
   *  The HTTP method to use when requesting the URI. If no method
   *  has been explicitly set, then ``GET`` is used if the body is
   *  null and ``POST`` otherwise.
   */
  get method() {
    if (__privateGet(this, _method)) {
      return __privateGet(this, _method);
    }
    if (this.hasBody()) {
      return "POST";
    }
    return "GET";
  }
  set method(method) {
    if (method == null) {
      method = "";
    }
    __privateSet(this, _method, String(method).toUpperCase());
  }
  /**
   *  The headers that will be used when requesting the URI. All
   *  keys are lower-case.
   *
   *  This object is a copy, so any changes will **NOT** be reflected
   *  in the ``FetchRequest``.
   *
   *  To set a header entry, use the ``setHeader`` method.
   */
  get headers() {
    const headers = Object.assign({}, __privateGet(this, _headers));
    if (__privateGet(this, _creds)) {
      headers["authorization"] = `Basic ${encodeBase64(toUtf8Bytes(__privateGet(this, _creds)))}`;
    }
    if (this.allowGzip) {
      headers["accept-encoding"] = "gzip";
    }
    if (headers["content-type"] == null && __privateGet(this, _bodyType)) {
      headers["content-type"] = __privateGet(this, _bodyType);
    }
    if (this.body) {
      headers["content-length"] = String(this.body.length);
    }
    return headers;
  }
  /**
   *  Get the header for %%key%%, ignoring case.
   */
  getHeader(key2) {
    return this.headers[key2.toLowerCase()];
  }
  /**
   *  Set the header for %%key%% to %%value%%. All values are coerced
   *  to a string.
   */
  setHeader(key2, value) {
    __privateGet(this, _headers)[String(key2).toLowerCase()] = String(value);
  }
  /**
   *  Clear all headers, resetting all intrinsic headers.
   */
  clearHeaders() {
    __privateSet(this, _headers, {});
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys2 = Object.keys(headers);
    let index2 = 0;
    return {
      next: () => {
        if (index2 < keys2.length) {
          const key2 = keys2[index2++];
          return {
            value: [key2, headers[key2]],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The value that will be sent for the ``Authorization`` header.
   *
   *  To set the credentials, use the ``setCredentials`` method.
   */
  get credentials() {
    return __privateGet(this, _creds) || null;
  }
  /**
   *  Sets an ``Authorization`` for %%username%% with %%password%%.
   */
  setCredentials(username, password) {
    assertArgument(!username.match(/:/), "invalid basic authentication username", "username", "[REDACTED]");
    __privateSet(this, _creds, `${username}:${password}`);
  }
  /**
   *  Enable and request gzip-encoded responses. The response will
   *  automatically be decompressed. //(default: true)//
   */
  get allowGzip() {
    return __privateGet(this, _gzip);
  }
  set allowGzip(value) {
    __privateSet(this, _gzip, !!value);
  }
  /**
   *  Allow ``Authentication`` credentials to be sent over insecure
   *  channels. //(default: false)//
   */
  get allowInsecureAuthentication() {
    return !!__privateGet(this, _allowInsecure);
  }
  set allowInsecureAuthentication(value) {
    __privateSet(this, _allowInsecure, !!value);
  }
  /**
   *  The timeout (in milliseconds) to wait for a complete response.
   *  //(default: 5 minutes)//
   */
  get timeout() {
    return __privateGet(this, _timeout);
  }
  set timeout(timeout) {
    assertArgument(timeout >= 0, "timeout must be non-zero", "timeout", timeout);
    __privateSet(this, _timeout, timeout);
  }
  /**
   *  This function is called prior to each request, for example
   *  during a redirection or retry in case of server throttling.
   *
   *  This offers an opportunity to populate headers or update
   *  content before sending a request.
   */
  get preflightFunc() {
    return __privateGet(this, _preflight) || null;
  }
  set preflightFunc(preflight) {
    __privateSet(this, _preflight, preflight);
  }
  /**
   *  This function is called after each response, offering an
   *  opportunity to provide client-level throttling or updating
   *  response data.
   *
   *  Any error thrown in this causes the ``send()`` to throw.
   *
   *  To schedule a retry attempt (assuming the maximum retry limit
   *  has not been reached), use [[response.throwThrottleError]].
   */
  get processFunc() {
    return __privateGet(this, _process) || null;
  }
  set processFunc(process2) {
    __privateSet(this, _process, process2);
  }
  /**
   *  This function is called on each retry attempt.
   */
  get retryFunc() {
    return __privateGet(this, _retry) || null;
  }
  set retryFunc(retry) {
    __privateSet(this, _retry, retry);
  }
  /**
   *  This function is called to fetch content from HTTP and
   *  HTTPS URLs and is platform specific (e.g. nodejs vs
   *  browsers).
   *
   *  This is by default the currently registered global getUrl
   *  function, which can be changed using [[registerGetUrl]].
   *  If this has been set, setting is to ``null`` will cause
   *  this FetchRequest (and any future clones) to revert back to
   *  using the currently registered global getUrl function.
   *
   *  Setting this is generally not necessary, but may be useful
   *  for developers that wish to intercept requests or to
   *  configurege a proxy or other agent.
   */
  get getUrlFunc() {
    return __privateGet(this, _getUrlFunc) || defaultGetUrlFunc;
  }
  set getUrlFunc(value) {
    __privateSet(this, _getUrlFunc, value);
  }
  toString() {
    return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${__privateGet(this, _body) ? hexlify(__privateGet(this, _body)) : "null"}>`;
  }
  /**
   *  Update the throttle parameters used to determine maximum
   *  attempts and exponential-backoff properties.
   */
  setThrottleParams(params) {
    if (params.slotInterval != null) {
      __privateGet(this, _throttle).slotInterval = params.slotInterval;
    }
    if (params.maxAttempts != null) {
      __privateGet(this, _throttle).maxAttempts = params.maxAttempts;
    }
  }
  /**
   *  Resolves to the response by sending the request.
   */
  send() {
    assert(__privateGet(this, _signal) == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" });
    __privateSet(this, _signal, new FetchCancelSignal(this));
    return __privateMethod(this, _FetchRequest_instances, send_fn).call(this, 0, getTime$1() + this.timeout, 0, this, new FetchResponse(0, "", {}, null, this));
  }
  /**
   *  Cancels the inflight response, causing a ``CANCELLED``
   *  error to be rejected from the [[send]].
   */
  cancel() {
    assert(__privateGet(this, _signal) != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
    const signal = fetchSignals.get(this);
    if (!signal) {
      throw new Error("missing signal; should not happen");
    }
    signal();
  }
  /**
   *  Returns a new [[FetchRequest]] that represents the redirection
   *  to %%location%%.
   */
  redirect(location2) {
    const current = this.url.split(":")[0].toLowerCase();
    const target = location2.split(":")[0].toLowerCase();
    assert(this.method === "GET" && (current !== "https" || target !== "http") && location2.match(/^https?:/), `unsupported redirect`, "UNSUPPORTED_OPERATION", {
      operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location2)})`
    });
    const req = new _FetchRequest(location2);
    req.method = "GET";
    req.allowGzip = this.allowGzip;
    req.timeout = this.timeout;
    __privateSet(req, _headers, Object.assign({}, __privateGet(this, _headers)));
    if (__privateGet(this, _body)) {
      __privateSet(req, _body, new Uint8Array(__privateGet(this, _body)));
    }
    __privateSet(req, _bodyType, __privateGet(this, _bodyType));
    return req;
  }
  /**
   *  Create a new copy of this request.
   */
  clone() {
    const clone = new _FetchRequest(this.url);
    __privateSet(clone, _method, __privateGet(this, _method));
    if (__privateGet(this, _body)) {
      __privateSet(clone, _body, __privateGet(this, _body));
    }
    __privateSet(clone, _bodyType, __privateGet(this, _bodyType));
    __privateSet(clone, _headers, Object.assign({}, __privateGet(this, _headers)));
    __privateSet(clone, _creds, __privateGet(this, _creds));
    if (this.allowGzip) {
      clone.allowGzip = true;
    }
    clone.timeout = this.timeout;
    if (this.allowInsecureAuthentication) {
      clone.allowInsecureAuthentication = true;
    }
    __privateSet(clone, _preflight, __privateGet(this, _preflight));
    __privateSet(clone, _process, __privateGet(this, _process));
    __privateSet(clone, _retry, __privateGet(this, _retry));
    __privateSet(clone, _throttle, Object.assign({}, __privateGet(this, _throttle)));
    __privateSet(clone, _getUrlFunc, __privateGet(this, _getUrlFunc));
    return clone;
  }
  /**
   *  Locks all static configuration for gateways and FetchGetUrlFunc
   *  registration.
   */
  static lockConfig() {
    locked$1 = true;
  }
  /**
   *  Get the current Gateway function for %%scheme%%.
   */
  static getGateway(scheme) {
    return Gateways[scheme.toLowerCase()] || null;
  }
  /**
   *  Use the %%func%% when fetching URIs using %%scheme%%.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGateway(scheme, func) {
    scheme = scheme.toLowerCase();
    if (scheme === "http" || scheme === "https") {
      throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);
    }
    if (locked$1) {
      throw new Error("gateways locked");
    }
    Gateways[scheme] = func;
  }
  /**
   *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGetUrl(getUrl2) {
    if (locked$1) {
      throw new Error("gateways locked");
    }
    defaultGetUrlFunc = getUrl2;
  }
  /**
   *  Creates a getUrl function that fetches content from HTTP and
   *  HTTPS URLs.
   *
   *  The available %%options%% are dependent on the platform
   *  implementation of the default getUrl function.
   *
   *  This is not generally something that is needed, but is useful
   *  when trying to customize simple behaviour when fetching HTTP
   *  content.
   */
  static createGetUrlFunc(options) {
    return createGetUrl();
  }
  /**
   *  Creates a function that can "fetch" data URIs.
   *
   *  Note that this is automatically done internally to support
   *  data URIs, so it is not necessary to register it.
   *
   *  This is not generally something that is needed, but may
   *  be useful in a wrapper to perfom custom data URI functionality.
   */
  static createDataGateway() {
    return dataGatewayFunc;
  }
  /**
   *  Creates a function that will fetch IPFS (unvalidated) from
   *  a custom gateway baseUrl.
   *
   *  The default IPFS gateway used internally is
   *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
   */
  static createIpfsGatewayFunc(baseUrl2) {
    return getIpfsGatewayFunc(baseUrl2);
  }
};
_allowInsecure = new WeakMap();
_gzip = new WeakMap();
_headers = new WeakMap();
_method = new WeakMap();
_timeout = new WeakMap();
_url = new WeakMap();
_body = new WeakMap();
_bodyType = new WeakMap();
_creds = new WeakMap();
_preflight = new WeakMap();
_process = new WeakMap();
_retry = new WeakMap();
_signal = new WeakMap();
_throttle = new WeakMap();
_getUrlFunc = new WeakMap();
_FetchRequest_instances = new WeakSet();
send_fn = async function(attempt, expires, delay2, _request3, _response) {
  var _a3, _b2, _c3;
  if (attempt >= __privateGet(this, _throttle).maxAttempts) {
    return _response.makeServerError("exceeded maximum retry limit");
  }
  assert(getTime$1() <= expires, "timeout", "TIMEOUT", {
    operation: "request.send",
    reason: "timeout",
    request: _request3
  });
  if (delay2 > 0) {
    await wait(delay2);
  }
  let req = this.clone();
  const scheme = (req.url.split(":")[0] || "").toLowerCase();
  if (scheme in Gateways) {
    const result = await Gateways[scheme](req.url, checkSignal(__privateGet(_request3, _signal)));
    if (result instanceof FetchResponse) {
      let response2 = result;
      if (this.processFunc) {
        checkSignal(__privateGet(_request3, _signal));
        try {
          response2 = await this.processFunc(req, response2);
        } catch (error) {
          if (error.throttle == null || typeof error.stall !== "number") {
            response2.makeServerError("error in post-processing function", error).assertOk();
          }
        }
      }
      return response2;
    }
    req = result;
  }
  if (this.preflightFunc) {
    req = await this.preflightFunc(req);
  }
  const resp = await this.getUrlFunc(req, checkSignal(__privateGet(_request3, _signal)));
  let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request3);
  if (response.statusCode === 301 || response.statusCode === 302) {
    try {
      const location2 = response.headers.location || "";
      return __privateMethod(_a3 = req.redirect(location2), _FetchRequest_instances, send_fn).call(_a3, attempt + 1, expires, 0, _request3, response);
    } catch (error) {
    }
    return response;
  } else if (response.statusCode === 429) {
    if (this.retryFunc == null || await this.retryFunc(req, response, attempt)) {
      const retryAfter = response.headers["retry-after"];
      let delay3 = __privateGet(this, _throttle).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
      if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
        delay3 = parseInt(retryAfter);
      }
      return __privateMethod(_b2 = req.clone(), _FetchRequest_instances, send_fn).call(_b2, attempt + 1, expires, delay3, _request3, response);
    }
  }
  if (this.processFunc) {
    checkSignal(__privateGet(_request3, _signal));
    try {
      response = await this.processFunc(req, response);
    } catch (error) {
      if (error.throttle == null || typeof error.stall !== "number") {
        response.makeServerError("error in post-processing function", error).assertOk();
      }
      let delay3 = __privateGet(this, _throttle).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
      if (error.stall >= 0) {
        delay3 = error.stall;
      }
      return __privateMethod(_c3 = req.clone(), _FetchRequest_instances, send_fn).call(_c3, attempt + 1, expires, delay3, _request3, response);
    }
  }
  return response;
};
let FetchRequest = _FetchRequest;
const _FetchResponse = class _FetchResponse {
  constructor(statusCode, statusMessage, headers, body, request) {
    __privateAdd(this, _statusCode);
    __privateAdd(this, _statusMessage);
    __privateAdd(this, _headers2);
    __privateAdd(this, _body2);
    __privateAdd(this, _request);
    __privateAdd(this, _error);
    __privateSet(this, _statusCode, statusCode);
    __privateSet(this, _statusMessage, statusMessage);
    __privateSet(this, _headers2, Object.keys(headers).reduce((accum, k3) => {
      accum[k3.toLowerCase()] = String(headers[k3]);
      return accum;
    }, {}));
    __privateSet(this, _body2, body == null ? null : new Uint8Array(body));
    __privateSet(this, _request, request || null);
    __privateSet(this, _error, { message: "" });
  }
  toString() {
    return `<FetchResponse status=${this.statusCode} body=${__privateGet(this, _body2) ? hexlify(__privateGet(this, _body2)) : "null"}>`;
  }
  /**
   *  The response status code.
   */
  get statusCode() {
    return __privateGet(this, _statusCode);
  }
  /**
   *  The response status message.
   */
  get statusMessage() {
    return __privateGet(this, _statusMessage);
  }
  /**
   *  The response headers. All keys are lower-case.
   */
  get headers() {
    return Object.assign({}, __privateGet(this, _headers2));
  }
  /**
   *  The response body, or ``null`` if there was no body.
   */
  get body() {
    return __privateGet(this, _body2) == null ? null : new Uint8Array(__privateGet(this, _body2));
  }
  /**
   *  The response body as a UTF-8 encoded string, or the empty
   *  string (i.e. ``""``) if there was no body.
   *
   *  An error is thrown if the body is invalid UTF-8 data.
   */
  get bodyText() {
    try {
      return __privateGet(this, _body2) == null ? "" : toUtf8String(__privateGet(this, _body2));
    } catch (error) {
      assert(false, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
        operation: "bodyText",
        info: { response: this }
      });
    }
  }
  /**
   *  The response body, decoded as JSON.
   *
   *  An error is thrown if the body is invalid JSON-encoded data
   *  or if there was no body.
   */
  get bodyJson() {
    try {
      return JSON.parse(this.bodyText);
    } catch (error) {
      assert(false, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
        operation: "bodyJson",
        info: { response: this }
      });
    }
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys2 = Object.keys(headers);
    let index2 = 0;
    return {
      next: () => {
        if (index2 < keys2.length) {
          const key2 = keys2[index2++];
          return {
            value: [key2, headers[key2]],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  Return a Response with matching headers and body, but with
   *  an error status code (i.e. 599) and %%message%% with an
   *  optional %%error%%.
   */
  makeServerError(message, error) {
    let statusMessage;
    if (!message) {
      message = `${this.statusCode} ${this.statusMessage}`;
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;
    } else {
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;
    }
    const response = new _FetchResponse(599, statusMessage, this.headers, this.body, __privateGet(this, _request) || void 0);
    __privateSet(response, _error, { message, error });
    return response;
  }
  /**
   *  If called within a [request.processFunc](FetchRequest-processFunc)
   *  call, causes the request to retry as if throttled for %%stall%%
   *  milliseconds.
   */
  throwThrottleError(message, stall2) {
    if (stall2 == null) {
      stall2 = -1;
    } else {
      assertArgument(Number.isInteger(stall2) && stall2 >= 0, "invalid stall timeout", "stall", stall2);
    }
    const error = new Error(message || "throttling requests");
    defineProperties(error, { stall: stall2, throttle: true });
    throw error;
  }
  /**
   *  Get the header value for %%key%%, ignoring case.
   */
  getHeader(key2) {
    return this.headers[key2.toLowerCase()];
  }
  /**
   *  Returns true if the response has a body.
   */
  hasBody() {
    return __privateGet(this, _body2) != null;
  }
  /**
   *  The request made for this response.
   */
  get request() {
    return __privateGet(this, _request);
  }
  /**
   *  Returns true if this response was a success statusCode.
   */
  ok() {
    return __privateGet(this, _error).message === "" && this.statusCode >= 200 && this.statusCode < 300;
  }
  /**
   *  Throws a ``SERVER_ERROR`` if this response is not ok.
   */
  assertOk() {
    if (this.ok()) {
      return;
    }
    let { message, error } = __privateGet(this, _error);
    if (message === "") {
      message = `server response ${this.statusCode} ${this.statusMessage}`;
    }
    let requestUrl = null;
    if (this.request) {
      requestUrl = this.request.url;
    }
    let responseBody = null;
    try {
      if (__privateGet(this, _body2)) {
        responseBody = toUtf8String(__privateGet(this, _body2));
      }
    } catch (e3) {
    }
    assert(false, message, "SERVER_ERROR", {
      request: this.request || "unknown request",
      response: this,
      error,
      info: {
        requestUrl,
        responseBody,
        responseStatus: `${this.statusCode} ${this.statusMessage}`
      }
    });
  }
};
_statusCode = new WeakMap();
_statusMessage = new WeakMap();
_headers2 = new WeakMap();
_body2 = new WeakMap();
_request = new WeakMap();
_error = new WeakMap();
let FetchResponse = _FetchResponse;
function getTime$1() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function unpercent(value) {
  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code2) => {
    return String.fromCharCode(parseInt(code2, 16));
  }));
}
function wait(delay2) {
  return new Promise((resolve) => setTimeout(resolve, delay2));
}
const BN_N1 = BigInt(-1);
const BN_0$8 = BigInt(0);
const BN_1$3 = BigInt(1);
const BN_5 = BigInt(5);
const _guard$3 = {};
let Zeros$1 = "0000";
while (Zeros$1.length < 80) {
  Zeros$1 += Zeros$1;
}
function getTens(decimals) {
  let result = Zeros$1;
  while (result.length < decimals) {
    result += result;
  }
  return BigInt("1" + result.substring(0, decimals));
}
function checkValue(val, format2, safeOp) {
  const width = BigInt(format2.width);
  if (format2.signed) {
    const limit = BN_1$3 << width - BN_1$3;
    assert(safeOp == null || val >= -limit && val < limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    if (val > BN_0$8) {
      val = fromTwos(mask(val, width), width);
    } else {
      val = -fromTwos(mask(-val, width), width);
    }
  } else {
    const limit = BN_1$3 << width;
    assert(safeOp == null || val >= 0 && val < limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    val = (val % limit + limit) % limit & limit - BN_1$3;
  }
  return val;
}
function getFormat(value) {
  if (typeof value === "number") {
    value = `fixed128x${value}`;
  }
  let signed2 = true;
  let width = 128;
  let decimals = 18;
  if (typeof value === "string") {
    if (value === "fixed") ;
    else if (value === "ufixed") {
      signed2 = false;
    } else {
      const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
      assertArgument(match, "invalid fixed format", "format", value);
      signed2 = match[1] !== "u";
      width = parseInt(match[2]);
      decimals = parseInt(match[3]);
    }
  } else if (value) {
    const v2 = value;
    const check = (key2, type2, defaultValue) => {
      if (v2[key2] == null) {
        return defaultValue;
      }
      assertArgument(typeof v2[key2] === type2, "invalid fixed format (" + key2 + " not " + type2 + ")", "format." + key2, v2[key2]);
      return v2[key2];
    };
    signed2 = check("signed", "boolean", signed2);
    width = check("width", "number", width);
    decimals = check("decimals", "number", decimals);
  }
  assertArgument(width % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", width);
  assertArgument(decimals <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", decimals);
  const name = (signed2 ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
  return { signed: signed2, width, decimals, name };
}
function toString(val, decimals) {
  let negative = "";
  if (val < BN_0$8) {
    negative = "-";
    val *= BN_N1;
  }
  let str = val.toString();
  if (decimals === 0) {
    return negative + str;
  }
  while (str.length <= decimals) {
    str = Zeros$1 + str;
  }
  const index2 = str.length - decimals;
  str = str.substring(0, index2) + "." + str.substring(index2);
  while (str[0] === "0" && str[1] !== ".") {
    str = str.substring(1);
  }
  while (str[str.length - 1] === "0" && str[str.length - 2] !== ".") {
    str = str.substring(0, str.length - 1);
  }
  return negative + str;
}
const _FixedNumber = class _FixedNumber {
  // Use this when changing this file to get some typing info,
  // but then switch to any to mask the internal type
  //constructor(guard: any, value: bigint, format: _FixedFormat) {
  /**
   *  @private
   */
  constructor(guard, value, format2) {
    __privateAdd(this, _FixedNumber_instances);
    /**
     *  The specific fixed-point arithmetic field for this value.
     */
    __publicField(this, "format");
    __privateAdd(this, _format);
    // The actual value (accounting for decimals)
    __privateAdd(this, _val);
    // A base-10 value to multiple values by to maintain the magnitude
    __privateAdd(this, _tens);
    /**
     *  This is a property so console.log shows a human-meaningful value.
     *
     *  @private
     */
    __publicField(this, "_value");
    assertPrivate(guard, _guard$3, "FixedNumber");
    __privateSet(this, _val, value);
    __privateSet(this, _format, format2);
    const _value2 = toString(value, format2.decimals);
    defineProperties(this, { format: format2.name, _value: _value2 });
    __privateSet(this, _tens, getTens(format2.decimals));
  }
  /**
   *  If true, negative values are permitted, otherwise only
   *  positive values and zero are allowed.
   */
  get signed() {
    return __privateGet(this, _format).signed;
  }
  /**
   *  The number of bits available to store the value.
   */
  get width() {
    return __privateGet(this, _format).width;
  }
  /**
   *  The number of decimal places in the fixed-point arithment field.
   */
  get decimals() {
    return __privateGet(this, _format).decimals;
  }
  /**
   *  The value as an integer, based on the smallest unit the
   *  [[decimals]] allow.
   */
  get value() {
    return __privateGet(this, _val);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% added
   *  to %%other%%, ignoring overflow.
   */
  addUnsafe(other) {
    return __privateMethod(this, _FixedNumber_instances, add_fn).call(this, other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% added
   *  to %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  add(other) {
    return __privateMethod(this, _FixedNumber_instances, add_fn).call(this, other, "add");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
   *  from %%this%%, ignoring overflow.
   */
  subUnsafe(other) {
    return __privateMethod(this, _FixedNumber_instances, sub_fn).call(this, other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
   *  from %%this%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  sub(other) {
    return __privateMethod(this, _FixedNumber_instances, sub_fn).call(this, other, "sub");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%, ignoring overflow and underflow (precision loss).
   */
  mulUnsafe(other) {
    return __privateMethod(this, _FixedNumber_instances, mul_fn).call(this, other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs.
   */
  mul(other) {
    return __privateMethod(this, _FixedNumber_instances, mul_fn).call(this, other, "mul");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
   *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
   *  occurs or if underflow (precision loss) occurs.
   */
  mulSignal(other) {
    __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, other);
    const value = __privateGet(this, _val) * __privateGet(other, _val);
    assert(value % __privateGet(this, _tens) === BN_0$8, "precision lost during signalling mul", "NUMERIC_FAULT", {
      operation: "mulSignal",
      fault: "underflow",
      value: this
    });
    return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, value / __privateGet(this, _tens), "mulSignal");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%, ignoring underflow (precision loss). A
   *  [[NumericFaultError]] is thrown if overflow occurs.
   */
  divUnsafe(other) {
    return __privateMethod(this, _FixedNumber_instances, div_fn).call(this, other);
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%, ignoring underflow (precision loss). A
   *  [[NumericFaultError]] is thrown if overflow occurs.
   */
  div(other) {
    return __privateMethod(this, _FixedNumber_instances, div_fn).call(this, other, "div");
  }
  /**
   *  Returns a new [[FixedNumber]] with the result of %%this%% divided
   *  by %%other%%. A [[NumericFaultError]] is thrown if underflow
   *  (precision loss) occurs.
   */
  divSignal(other) {
    assert(__privateGet(other, _val) !== BN_0$8, "division by zero", "NUMERIC_FAULT", {
      operation: "div",
      fault: "divide-by-zero",
      value: this
    });
    __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, other);
    const value = __privateGet(this, _val) * __privateGet(this, _tens);
    assert(value % __privateGet(other, _val) === BN_0$8, "precision lost during signalling div", "NUMERIC_FAULT", {
      operation: "divSignal",
      fault: "underflow",
      value: this
    });
    return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, value / __privateGet(other, _val), "divSignal");
  }
  /**
   *  Returns a comparison result between %%this%% and %%other%%.
   *
   *  This is suitable for use in sorting, where ``-1`` implies %%this%%
   *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies
   *  both are equal.
   */
  cmp(other) {
    let a2 = this.value, b2 = other.value;
    const delta = this.decimals - other.decimals;
    if (delta > 0) {
      b2 *= getTens(delta);
    } else if (delta < 0) {
      a2 *= getTens(-delta);
    }
    if (a2 < b2) {
      return -1;
    }
    if (a2 > b2) {
      return 1;
    }
    return 0;
  }
  /**
   *  Returns true if %%other%% is equal to %%this%%.
   */
  eq(other) {
    return this.cmp(other) === 0;
  }
  /**
   *  Returns true if %%other%% is less than to %%this%%.
   */
  lt(other) {
    return this.cmp(other) < 0;
  }
  /**
   *  Returns true if %%other%% is less than or equal to %%this%%.
   */
  lte(other) {
    return this.cmp(other) <= 0;
  }
  /**
   *  Returns true if %%other%% is greater than to %%this%%.
   */
  gt(other) {
    return this.cmp(other) > 0;
  }
  /**
   *  Returns true if %%other%% is greater than or equal to %%this%%.
   */
  gte(other) {
    return this.cmp(other) >= 0;
  }
  /**
   *  Returns a new [[FixedNumber]] which is the largest **integer**
   *  that is less than or equal to %%this%%.
   *
   *  The decimal component of the result will always be ``0``.
   */
  floor() {
    let val = __privateGet(this, _val);
    if (__privateGet(this, _val) < BN_0$8) {
      val -= __privateGet(this, _tens) - BN_1$3;
    }
    val = __privateGet(this, _val) / __privateGet(this, _tens) * __privateGet(this, _tens);
    return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, val, "floor");
  }
  /**
   *  Returns a new [[FixedNumber]] which is the smallest **integer**
   *  that is greater than or equal to %%this%%.
   *
   *  The decimal component of the result will always be ``0``.
   */
  ceiling() {
    let val = __privateGet(this, _val);
    if (__privateGet(this, _val) > BN_0$8) {
      val += __privateGet(this, _tens) - BN_1$3;
    }
    val = __privateGet(this, _val) / __privateGet(this, _tens) * __privateGet(this, _tens);
    return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, val, "ceiling");
  }
  /**
   *  Returns a new [[FixedNumber]] with the decimal component
   *  rounded up on ties at %%decimals%% places.
   */
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    if (decimals >= this.decimals) {
      return this;
    }
    const delta = this.decimals - decimals;
    const bump = BN_5 * getTens(delta - 1);
    let value = this.value + bump;
    const tens = getTens(delta);
    value = value / tens * tens;
    checkValue(value, __privateGet(this, _format), "round");
    return new _FixedNumber(_guard$3, value, __privateGet(this, _format));
  }
  /**
   *  Returns true if %%this%% is equal to ``0``.
   */
  isZero() {
    return __privateGet(this, _val) === BN_0$8;
  }
  /**
   *  Returns true if %%this%% is less than ``0``.
   */
  isNegative() {
    return __privateGet(this, _val) < BN_0$8;
  }
  /**
   *  Returns the string representation of %%this%%.
   */
  toString() {
    return this._value;
  }
  /**
   *  Returns a float approximation.
   *
   *  Due to IEEE 754 precission (or lack thereof), this function
   *  can only return an approximation and most values will contain
   *  rounding errors.
   */
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  /**
   *  Return a new [[FixedNumber]] with the same value but has had
   *  its field set to %%format%%.
   *
   *  This will throw if the value cannot fit into %%format%%.
   */
  toFormat(format2) {
    return _FixedNumber.fromString(this.toString(), format2);
  }
  /**
   *  Creates a new [[FixedNumber]] for %%value%% divided by
   *  %%decimal%% places with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted
   *  for %%decimals%%) cannot fit in %%format%%, either due to overflow
   *  or underflow (precision loss).
   */
  static fromValue(_value2, _decimals, _format2) {
    const decimals = _decimals == null ? 0 : getNumber(_decimals);
    const format2 = getFormat(_format2);
    let value = getBigInt(_value2, "value");
    const delta = decimals - format2.decimals;
    if (delta > 0) {
      const tens = getTens(delta);
      assert(value % tens === BN_0$8, "value loses precision for format", "NUMERIC_FAULT", {
        operation: "fromValue",
        fault: "underflow",
        value: _value2
      });
      value /= tens;
    } else if (delta < 0) {
      value *= getTens(-delta);
    }
    checkValue(value, format2, "fromValue");
    return new _FixedNumber(_guard$3, value, format2);
  }
  /**
   *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
   *  in %%format%%, either due to overflow or underflow (precision loss).
   */
  static fromString(_value2, _format2) {
    const match = _value2.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
    assertArgument(match && match[2].length + match[3].length > 0, "invalid FixedNumber string value", "value", _value2);
    const format2 = getFormat(_format2);
    let whole = match[2] || "0", decimal = match[3] || "";
    while (decimal.length < format2.decimals) {
      decimal += Zeros$1;
    }
    assert(decimal.substring(format2.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
      operation: "fromString",
      fault: "underflow",
      value: _value2
    });
    decimal = decimal.substring(0, format2.decimals);
    const value = BigInt(match[1] + whole + decimal);
    checkValue(value, format2, "fromString");
    return new _FixedNumber(_guard$3, value, format2);
  }
  /**
   *  Creates a new [[FixedNumber]] with the big-endian representation
   *  %%value%% with %%format%%.
   *
   *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
   *  in %%format%% due to overflow.
   */
  static fromBytes(_value2, _format2) {
    let value = toBigInt(getBytes(_value2, "value"));
    const format2 = getFormat(_format2);
    if (format2.signed) {
      value = fromTwos(value, format2.width);
    }
    checkValue(value, format2, "fromBytes");
    return new _FixedNumber(_guard$3, value, format2);
  }
};
_format = new WeakMap();
_val = new WeakMap();
_tens = new WeakMap();
_FixedNumber_instances = new WeakSet();
checkFormat_fn = function(other) {
  assertArgument(this.format === other.format, "incompatible format; use fixedNumber.toFormat", "other", other);
};
checkValue_fn = function(val, safeOp) {
  val = checkValue(val, __privateGet(this, _format), safeOp);
  return new _FixedNumber(_guard$3, val, __privateGet(this, _format));
};
add_fn = function(o3, safeOp) {
  __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, o3);
  return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, __privateGet(this, _val) + __privateGet(o3, _val), safeOp);
};
sub_fn = function(o3, safeOp) {
  __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, o3);
  return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, __privateGet(this, _val) - __privateGet(o3, _val), safeOp);
};
mul_fn = function(o3, safeOp) {
  __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, o3);
  return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, __privateGet(this, _val) * __privateGet(o3, _val) / __privateGet(this, _tens), safeOp);
};
div_fn = function(o3, safeOp) {
  assert(__privateGet(o3, _val) !== BN_0$8, "division by zero", "NUMERIC_FAULT", {
    operation: "div",
    fault: "divide-by-zero",
    value: this
  });
  __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, o3);
  return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, __privateGet(this, _val) * __privateGet(this, _tens) / __privateGet(o3, _val), safeOp);
};
let FixedNumber = _FixedNumber;
function hexlifyByte(value) {
  let result = value.toString(16);
  while (result.length < 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function unarrayifyInteger(data2, offset, length) {
  let result = 0;
  for (let i4 = 0; i4 < length; i4++) {
    result = result * 256 + data2[offset + i4];
  }
  return result;
}
function _decodeChildren(data2, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode(data2, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    assert(childOffset <= offset + 1 + length, "child data too short", "BUFFER_OVERRUN", {
      buffer: data2,
      length,
      offset
    });
  }
  return { consumed: 1 + length, result };
}
function _decode(data2, offset) {
  assert(data2.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: data2,
    length: 0,
    offset: 1
  });
  const checkOffset = (offset2) => {
    assert(offset2 <= data2.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: data2,
      length: data2.length,
      offset: offset2
    });
  };
  if (data2[offset] >= 248) {
    const lengthLength = data2[offset] - 247;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger(data2, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    return _decodeChildren(data2, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data2[offset] >= 192) {
    const length = data2[offset] - 192;
    checkOffset(offset + 1 + length);
    return _decodeChildren(data2, offset, offset + 1, length);
  } else if (data2[offset] >= 184) {
    const lengthLength = data2[offset] - 183;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger(data2, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    const result = hexlify(data2.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data2[offset] >= 128) {
    const length = data2[offset] - 128;
    checkOffset(offset + 1 + length);
    const result = hexlify(data2.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlifyByte(data2[offset]) };
}
function decodeRlp(_data4) {
  const data2 = getBytes(_data4, "data");
  const decoded = _decode(data2, 0);
  assertArgument(decoded.consumed === data2.length, "unexpected junk after rlp payload", "data", _data4);
  return decoded.result;
}
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function _encode(object2) {
  if (Array.isArray(object2)) {
    let payload = [];
    object2.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  const data2 = Array.prototype.slice.call(getBytes(object2, "object"));
  if (data2.length === 1 && data2[0] <= 127) {
    return data2;
  } else if (data2.length <= 55) {
    data2.unshift(128 + data2.length);
    return data2;
  }
  const length = arrayifyInteger(data2.length);
  length.unshift(183 + length.length);
  return length.concat(data2);
}
const nibbles = "0123456789abcdef";
function encodeRlp(object2) {
  let result = "0x";
  for (const v2 of _encode(object2)) {
    result += nibbles[v2 >> 4];
    result += nibbles[v2 & 15];
  }
  return result;
}
const names = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function formatUnits(value, unit) {
  let decimals = 18;
  if (typeof unit === "string") {
    const index2 = names.indexOf(unit);
    assertArgument(index2 >= 0, "invalid unit", "unit", unit);
    decimals = 3 * index2;
  } else if (unit != null) {
    decimals = getNumber(unit, "unit");
  }
  return FixedNumber.fromValue(value, decimals, { decimals, width: 512 }).toString();
}
function parseUnits$1(value, unit) {
  assertArgument(typeof value === "string", "value must be a string", "value", value);
  let decimals = 18;
  if (typeof unit === "string") {
    const index2 = names.indexOf(unit);
    assertArgument(index2 >= 0, "invalid unit", "unit", unit);
    decimals = 3 * index2;
  } else if (unit != null) {
    decimals = getNumber(unit, "unit");
  }
  return FixedNumber.fromString(value, { decimals, width: 512 }).value;
}
function formatEther(wei) {
  return formatUnits(wei, 18);
}
const WordSize = 32;
const Padding = new Uint8Array(WordSize);
const passProperties$1 = ["then"];
const _guard$2 = {};
const resultNames = /* @__PURE__ */ new WeakMap();
function getNames(result) {
  return resultNames.get(result);
}
function setNames(result, names2) {
  resultNames.set(result, names2);
}
function throwError(name, error) {
  const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);
  wrapped.error = error;
  throw wrapped;
}
function toObject(names2, items, deep) {
  if (names2.indexOf(null) >= 0) {
    return items.map((item, index2) => {
      if (item instanceof Result) {
        return toObject(getNames(item), item, deep);
      }
      return item;
    });
  }
  return names2.reduce((accum, name, index2) => {
    let item = items.getValue(name);
    if (!(name in accum)) {
      if (deep && item instanceof Result) {
        item = toObject(getNames(item), item, deep);
      }
      accum[name] = item;
    }
    return accum;
  }, {});
}
const _Result = class _Result extends Array {
  /**
   *  @private
   */
  constructor(...args) {
    const guard = args[0];
    let items = args[1];
    let names2 = (args[2] || []).slice();
    let wrap2 = true;
    if (guard !== _guard$2) {
      items = args;
      names2 = [];
      wrap2 = false;
    }
    super(items.length);
    // No longer used; but cannot be removed as it will remove the
    // #private field from the .d.ts which may break backwards
    // compatibility
    __privateAdd(this, _names);
    items.forEach((item, index2) => {
      this[index2] = item;
    });
    const nameCounts = names2.reduce((accum, name) => {
      if (typeof name === "string") {
        accum.set(name, (accum.get(name) || 0) + 1);
      }
      return accum;
    }, /* @__PURE__ */ new Map());
    setNames(this, Object.freeze(items.map((item, index2) => {
      const name = names2[index2];
      if (name != null && nameCounts.get(name) === 1) {
        return name;
      }
      return null;
    })));
    __privateSet(this, _names, []);
    if (__privateGet(this, _names) == null) {
      void __privateGet(this, _names);
    }
    if (!wrap2) {
      return;
    }
    Object.freeze(this);
    const proxy2 = new Proxy(this, {
      get: (target, prop, receiver) => {
        if (typeof prop === "string") {
          if (prop.match(/^[0-9]+$/)) {
            const index2 = getNumber(prop, "%index");
            if (index2 < 0 || index2 >= this.length) {
              throw new RangeError("out of result range");
            }
            const item = target[index2];
            if (item instanceof Error) {
              throwError(`index ${index2}`, item);
            }
            return item;
          }
          if (passProperties$1.indexOf(prop) >= 0) {
            return Reflect.get(target, prop, receiver);
          }
          const value = target[prop];
          if (value instanceof Function) {
            return function(...args2) {
              return value.apply(this === receiver ? target : this, args2);
            };
          } else if (!(prop in target)) {
            return target.getValue.apply(this === receiver ? target : this, [prop]);
          }
        }
        return Reflect.get(target, prop, receiver);
      }
    });
    setNames(proxy2, getNames(this));
    return proxy2;
  }
  /**
   *  Returns the Result as a normal Array. If %%deep%%, any children
   *  which are Result objects are also converted to a normal Array.
   *
   *  This will throw if there are any outstanding deferred
   *  errors.
   */
  toArray(deep) {
    const result = [];
    this.forEach((item, index2) => {
      if (item instanceof Error) {
        throwError(`index ${index2}`, item);
      }
      if (deep && item instanceof _Result) {
        item = item.toArray(deep);
      }
      result.push(item);
    });
    return result;
  }
  /**
   *  Returns the Result as an Object with each name-value pair. If
   *  %%deep%%, any children which are Result objects are also
   *  converted to an Object.
   *
   *  This will throw if any value is unnamed, or if there are
   *  any outstanding deferred errors.
   */
  toObject(deep) {
    const names2 = getNames(this);
    return names2.reduce((accum, name, index2) => {
      assert(name != null, `value at index ${index2} unnamed`, "UNSUPPORTED_OPERATION", {
        operation: "toObject()"
      });
      return toObject(names2, this, deep);
    }, {});
  }
  /**
   *  @_ignore
   */
  slice(start, end) {
    if (start == null) {
      start = 0;
    }
    if (start < 0) {
      start += this.length;
      if (start < 0) {
        start = 0;
      }
    }
    if (end == null) {
      end = this.length;
    }
    if (end < 0) {
      end += this.length;
      if (end < 0) {
        end = 0;
      }
    }
    if (end > this.length) {
      end = this.length;
    }
    const _names2 = getNames(this);
    const result = [], names2 = [];
    for (let i4 = start; i4 < end; i4++) {
      result.push(this[i4]);
      names2.push(_names2[i4]);
    }
    return new _Result(_guard$2, result, names2);
  }
  /**
   *  @_ignore
   */
  filter(callback, thisArg) {
    const _names2 = getNames(this);
    const result = [], names2 = [];
    for (let i4 = 0; i4 < this.length; i4++) {
      const item = this[i4];
      if (item instanceof Error) {
        throwError(`index ${i4}`, item);
      }
      if (callback.call(thisArg, item, i4, this)) {
        result.push(item);
        names2.push(_names2[i4]);
      }
    }
    return new _Result(_guard$2, result, names2);
  }
  /**
   *  @_ignore
   */
  map(callback, thisArg) {
    const result = [];
    for (let i4 = 0; i4 < this.length; i4++) {
      const item = this[i4];
      if (item instanceof Error) {
        throwError(`index ${i4}`, item);
      }
      result.push(callback.call(thisArg, item, i4, this));
    }
    return result;
  }
  /**
   *  Returns the value for %%name%%.
   *
   *  Since it is possible to have a key whose name conflicts with
   *  a method on a [[Result]] or its superclass Array, or any
   *  JavaScript keyword, this ensures all named values are still
   *  accessible by name.
   */
  getValue(name) {
    const index2 = getNames(this).indexOf(name);
    if (index2 === -1) {
      return void 0;
    }
    const value = this[index2];
    if (value instanceof Error) {
      throwError(`property ${JSON.stringify(name)}`, value.error);
    }
    return value;
  }
  /**
   *  Creates a new [[Result]] for %%items%% with each entry
   *  also accessible by its corresponding name in %%keys%%.
   */
  static fromItems(items, keys2) {
    return new _Result(_guard$2, items, keys2);
  }
};
_names = new WeakMap();
let Result = _Result;
function getValue$1(value) {
  let bytes2 = toBeArray(value);
  assert(bytes2.length <= WordSize, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: bytes2, length: WordSize, offset: bytes2.length });
  if (bytes2.length !== WordSize) {
    bytes2 = getBytesCopy(concat([Padding.slice(bytes2.length % WordSize), bytes2]));
  }
  return bytes2;
}
class Coder {
  constructor(name, type2, localName, dynamic) {
    // The coder name:
    //   - address, uint256, tuple, array, etc.
    __publicField(this, "name");
    // The fully expanded type, including composite types:
    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
    __publicField(this, "type");
    // The localName bound in the signature, in this example it is "baz":
    //   - tuple(address foo, uint bar) baz
    __publicField(this, "localName");
    // Whether this type is dynamic:
    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
    __publicField(this, "dynamic");
    defineProperties(this, { name, type: type2, localName, dynamic }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _throwError(message, value) {
    assertArgument(false, message, this.localName, value);
  }
}
class Writer {
  constructor() {
    __privateAdd(this, _Writer_instances);
    // An array of WordSize lengthed objects to concatenation
    __privateAdd(this, _data);
    __privateAdd(this, _dataLength);
    __privateSet(this, _data, []);
    __privateSet(this, _dataLength, 0);
  }
  get data() {
    return concat(__privateGet(this, _data));
  }
  get length() {
    return __privateGet(this, _dataLength);
  }
  appendWriter(writer) {
    return __privateMethod(this, _Writer_instances, writeData_fn).call(this, getBytesCopy(writer.data));
  }
  // Arrayish item; pad on the right to *nearest* WordSize
  writeBytes(value) {
    let bytes2 = getBytesCopy(value);
    const paddingOffset = bytes2.length % WordSize;
    if (paddingOffset) {
      bytes2 = getBytesCopy(concat([bytes2, Padding.slice(paddingOffset)]));
    }
    return __privateMethod(this, _Writer_instances, writeData_fn).call(this, bytes2);
  }
  // Numeric item; pad on the left *to* WordSize
  writeValue(value) {
    return __privateMethod(this, _Writer_instances, writeData_fn).call(this, getValue$1(value));
  }
  // Inserts a numeric place-holder, returning a callback that can
  // be used to asjust the value later
  writeUpdatableValue() {
    const offset = __privateGet(this, _data).length;
    __privateGet(this, _data).push(Padding);
    __privateSet(this, _dataLength, __privateGet(this, _dataLength) + WordSize);
    return (value) => {
      __privateGet(this, _data)[offset] = getValue$1(value);
    };
  }
}
_data = new WeakMap();
_dataLength = new WeakMap();
_Writer_instances = new WeakSet();
writeData_fn = function(data2) {
  __privateGet(this, _data).push(data2);
  __privateSet(this, _dataLength, __privateGet(this, _dataLength) + data2.length);
  return data2.length;
};
const _Reader = class _Reader {
  constructor(data2, allowLoose, maxInflation) {
    __privateAdd(this, _Reader_instances);
    // Allows incomplete unpadded data to be read; otherwise an error
    // is raised if attempting to overrun the buffer. This is required
    // to deal with an old Solidity bug, in which event data for
    // external (not public thoguh) was tightly packed.
    __publicField(this, "allowLoose");
    __privateAdd(this, _data2);
    __privateAdd(this, _offset);
    __privateAdd(this, _bytesRead);
    __privateAdd(this, _parent);
    __privateAdd(this, _maxInflation);
    defineProperties(this, { allowLoose: !!allowLoose });
    __privateSet(this, _data2, getBytesCopy(data2));
    __privateSet(this, _bytesRead, 0);
    __privateSet(this, _parent, null);
    __privateSet(this, _maxInflation, maxInflation != null ? maxInflation : 1024);
    __privateSet(this, _offset, 0);
  }
  get data() {
    return hexlify(__privateGet(this, _data2));
  }
  get dataLength() {
    return __privateGet(this, _data2).length;
  }
  get consumed() {
    return __privateGet(this, _offset);
  }
  get bytes() {
    return new Uint8Array(__privateGet(this, _data2));
  }
  // Create a sub-reader with the same underlying data, but offset
  subReader(offset) {
    const reader = new _Reader(__privateGet(this, _data2).slice(__privateGet(this, _offset) + offset), this.allowLoose, __privateGet(this, _maxInflation));
    __privateSet(reader, _parent, this);
    return reader;
  }
  // Read bytes
  readBytes(length, loose) {
    let bytes2 = __privateMethod(this, _Reader_instances, peekBytes_fn).call(this, 0, length, !!loose);
    __privateMethod(this, _Reader_instances, incrementBytesRead_fn).call(this, length);
    __privateSet(this, _offset, __privateGet(this, _offset) + bytes2.length);
    return bytes2.slice(0, length);
  }
  // Read a numeric values
  readValue() {
    return toBigInt(this.readBytes(WordSize));
  }
  readIndex() {
    return toNumber(this.readBytes(WordSize));
  }
};
_data2 = new WeakMap();
_offset = new WeakMap();
_bytesRead = new WeakMap();
_parent = new WeakMap();
_maxInflation = new WeakMap();
_Reader_instances = new WeakSet();
incrementBytesRead_fn = function(count) {
  var _a3;
  if (__privateGet(this, _parent)) {
    return __privateMethod(_a3 = __privateGet(this, _parent), _Reader_instances, incrementBytesRead_fn).call(_a3, count);
  }
  __privateSet(this, _bytesRead, __privateGet(this, _bytesRead) + count);
  assert(__privateGet(this, _maxInflation) < 1 || __privateGet(this, _bytesRead) <= __privateGet(this, _maxInflation) * this.dataLength, `compressed ABI data exceeds inflation ratio of ${__privateGet(this, _maxInflation)} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
    buffer: getBytesCopy(__privateGet(this, _data2)),
    offset: __privateGet(this, _offset),
    length: count,
    info: {
      bytesRead: __privateGet(this, _bytesRead),
      dataLength: this.dataLength
    }
  });
};
peekBytes_fn = function(offset, length, loose) {
  let alignedLength = Math.ceil(length / WordSize) * WordSize;
  if (__privateGet(this, _offset) + alignedLength > __privateGet(this, _data2).length) {
    if (this.allowLoose && loose && __privateGet(this, _offset) + length <= __privateGet(this, _data2).length) {
      alignedLength = length;
    } else {
      assert(false, "data out-of-bounds", "BUFFER_OVERRUN", {
        buffer: getBytesCopy(__privateGet(this, _data2)),
        length: __privateGet(this, _data2).length,
        offset: __privateGet(this, _offset) + alignedLength
      });
    }
  }
  return __privateGet(this, _data2).slice(__privateGet(this, _offset), __privateGet(this, _offset) + alignedLength);
};
let Reader = _Reader;
function number(n5) {
  if (!Number.isSafeInteger(n5) || n5 < 0)
    throw new Error(`Wrong positive integer: ${n5}`);
}
function bytes(b2, ...lengths) {
  if (!(b2 instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b2.length}`);
}
function hash(hash3) {
  if (typeof hash3 !== "function" || typeof hash3.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash3.outputLen);
  number(hash3.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error(`digestInto() expects output buffer of length at least ${min2}`);
  }
}
const crypto$1 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a$1 = (a2) => a2 instanceof Uint8Array;
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
const rotr = (word, shift) => word << 32 - shift | word >>> shift;
const isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes$1(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes$1(data2) {
  if (typeof data2 === "string")
    data2 = utf8ToBytes$1(data2);
  if (!u8a$1(data2))
    throw new Error(`expected Uint8Array, got ${typeof data2}`);
  return data2;
}
function concatBytes$1(...arrays) {
  const r3 = new Uint8Array(arrays.reduce((sum, a2) => sum + a2.length, 0));
  let pad3 = 0;
  arrays.forEach((a2) => {
    if (!u8a$1(a2))
      throw new Error("Uint8Array expected");
    r3.set(a2, pad3);
    pad3 += a2.length;
  });
  return r3;
}
class Hash {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes$1(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto$1 && typeof crypto$1.getRandomValues === "function") {
    return crypto$1.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
class HMAC extends Hash {
  constructor(hash$12, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash$12);
    const key2 = toBytes$1(_key);
    this.iHash = hash$12.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad3 = new Uint8Array(blockLen);
    pad3.set(key2.length > blockLen ? hash$12.create().update(key2).digest() : key2);
    for (let i4 = 0; i4 < pad3.length; i4++)
      pad3[i4] ^= 54;
    this.iHash.update(pad3);
    this.oHash = hash$12.create();
    for (let i4 = 0; i4 < pad3.length; i4++)
      pad3[i4] ^= 54 ^ 92;
    this.oHash.update(pad3);
    pad3.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to2) {
    to2 || (to2 = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to2 = to2;
    to2.finished = finished;
    to2.destroyed = destroyed;
    to2.blockLen = blockLen;
    to2.outputLen = outputLen;
    to2.oHash = oHash._cloneInto(to2.oHash);
    to2.iHash = iHash._cloneInto(to2.iHash);
    return to2;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
const hmac = (hash3, key2, message) => new HMAC(hash3, key2).update(message).digest();
hmac.create = (hash3, key2) => new HMAC(hash3, key2);
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h5 = isLE2 ? 4 : 0;
  const l2 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h5, wh, isLE2);
  view.setUint32(byteOffset + l2, wl, isLE2);
}
class SHA2 extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data2) {
    exists(this);
    const { view, buffer: buffer2, blockLen } = this;
    data2 = toBytes$1(data2);
    const len2 = data2.length;
    for (let pos = 0; pos < len2; ) {
      const take = Math.min(blockLen - this.pos, len2 - pos);
      if (take === blockLen) {
        const dataView = createView(data2);
        for (; blockLen <= len2 - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer2.set(data2.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data2.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i4 = pos; i4 < blockLen; i4++)
      buffer2[i4] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len2 = this.outputLen;
    if (len2 % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len2 / 4;
    const state2 = this.get();
    if (outLen > state2.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i4 = 0; i4 < outLen; i4++)
      oview.setUint32(4 * i4, state2[i4], isLE2);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to2) {
    to2 || (to2 = new this.constructor());
    to2.set(...this.get());
    const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
    to2.length = length;
    to2.pos = pos;
    to2.finished = finished;
    to2.destroyed = destroyed;
    if (length % blockLen)
      to2.buffer.set(buffer2);
    return to2;
  }
}
const Chi = (a2, b2, c2) => a2 & b2 ^ ~a2 & c2;
const Maj = (a2, b2, c2) => a2 & b2 ^ a2 & c2 ^ b2 & c2;
const SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A: A2, B: B3, C: C2, D: D2, E: E2, F: F2, G: G2, H: H3 } = this;
    return [A2, B3, C2, D2, E2, F2, G2, H3];
  }
  // prettier-ignore
  set(A2, B3, C2, D2, E2, F2, G2, H3) {
    this.A = A2 | 0;
    this.B = B3 | 0;
    this.C = C2 | 0;
    this.D = D2 | 0;
    this.E = E2 | 0;
    this.F = F2 | 0;
    this.G = G2 | 0;
    this.H = H3 | 0;
  }
  process(view, offset) {
    for (let i4 = 0; i4 < 16; i4++, offset += 4)
      SHA256_W[i4] = view.getUint32(offset, false);
    for (let i4 = 16; i4 < 64; i4++) {
      const W15 = SHA256_W[i4 - 15];
      const W2 = SHA256_W[i4 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i4] = s1 + SHA256_W[i4 - 7] + s0 + SHA256_W[i4 - 16] | 0;
    }
    let { A: A2, B: B3, C: C2, D: D2, E: E2, F: F2, G: G2, H: H3 } = this;
    for (let i4 = 0; i4 < 64; i4++) {
      const sigma1 = rotr(E2, 6) ^ rotr(E2, 11) ^ rotr(E2, 25);
      const T12 = H3 + sigma1 + Chi(E2, F2, G2) + SHA256_K[i4] + SHA256_W[i4] | 0;
      const sigma0 = rotr(A2, 2) ^ rotr(A2, 13) ^ rotr(A2, 22);
      const T2 = sigma0 + Maj(A2, B3, C2) | 0;
      H3 = G2;
      G2 = F2;
      F2 = E2;
      E2 = D2 + T12 | 0;
      D2 = C2;
      C2 = B3;
      B3 = A2;
      A2 = T12 + T2 | 0;
    }
    A2 = A2 + this.A | 0;
    B3 = B3 + this.B | 0;
    C2 = C2 + this.C | 0;
    D2 = D2 + this.D | 0;
    E2 = E2 + this.E | 0;
    F2 = F2 + this.F | 0;
    G2 = G2 + this.G | 0;
    H3 = H3 + this.H | 0;
    this.set(A2, B3, C2, D2, E2, F2, G2, H3);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
}
const sha256$1 = /* @__PURE__ */ wrapConstructor(() => new SHA256());
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n5, le2 = false) {
  if (le2)
    return { h: Number(n5 & U32_MASK64), l: Number(n5 >> _32n & U32_MASK64) };
  return { h: Number(n5 >> _32n & U32_MASK64) | 0, l: Number(n5 & U32_MASK64) | 0 };
}
function split$1(lst, le2 = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i4 = 0; i4 < lst.length; i4++) {
    const { h: h5, l: l2 } = fromBig(lst[i4], le2);
    [Ah[i4], Al[i4]] = [h5, l2];
  }
  return [Ah, Al];
}
const toBig = (h5, l2) => BigInt(h5 >>> 0) << _32n | BigInt(l2 >>> 0);
const shrSH = (h5, _l, s2) => h5 >>> s2;
const shrSL = (h5, l2, s2) => h5 << 32 - s2 | l2 >>> s2;
const rotrSH = (h5, l2, s2) => h5 >>> s2 | l2 << 32 - s2;
const rotrSL = (h5, l2, s2) => h5 << 32 - s2 | l2 >>> s2;
const rotrBH = (h5, l2, s2) => h5 << 64 - s2 | l2 >>> s2 - 32;
const rotrBL = (h5, l2, s2) => h5 >>> s2 - 32 | l2 << 64 - s2;
const rotr32H = (_h, l2) => l2;
const rotr32L = (h5, _l) => h5;
const rotlSH = (h5, l2, s2) => h5 << s2 | l2 >>> 32 - s2;
const rotlSL = (h5, l2, s2) => l2 << s2 | h5 >>> 32 - s2;
const rotlBH = (h5, l2, s2) => l2 << s2 - 32 | h5 >>> 64 - s2;
const rotlBL = (h5, l2, s2) => h5 << s2 - 32 | l2 >>> 64 - s2;
function add(Ah, Al, Bh, Bl) {
  const l2 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l2 / 2 ** 32 | 0) | 0, l: l2 | 0 };
}
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
const u64 = {
  fromBig,
  split: split$1,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
const [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n5) => BigInt(n5))))();
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends SHA2 {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i4 = 0; i4 < 16; i4++, offset += 4) {
      SHA512_W_H[i4] = view.getUint32(offset);
      SHA512_W_L[i4] = view.getUint32(offset += 4);
    }
    for (let i4 = 16; i4 < 80; i4++) {
      const W15h = SHA512_W_H[i4 - 15] | 0;
      const W15l = SHA512_W_L[i4 - 15] | 0;
      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i4 - 2] | 0;
      const W2l = SHA512_W_L[i4 - 2] | 0;
      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i4 - 7], SHA512_W_L[i4 - 16]);
      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i4 - 7], SHA512_W_H[i4 - 16]);
      SHA512_W_H[i4] = SUMh | 0;
      SHA512_W_L[i4] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i4 = 0; i4 < 80; i4++) {
      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i4], SHA512_W_L[i4]);
      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i4], SHA512_W_H[i4]);
      const T1l = T1ll | 0;
      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = u64.add3L(T1l, sigma0l, MAJl);
      Ah = u64.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const sha512 = /* @__PURE__ */ wrapConstructor(() => new SHA512());
function getGlobal$1() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global$1 !== "undefined") {
    return global$1;
  }
  throw new Error("unable to locate global object");
}
const anyGlobal = getGlobal$1();
anyGlobal.crypto || anyGlobal.msCrypto;
function createHash(algo) {
  switch (algo) {
    case "sha256":
      return sha256$1.create();
    case "sha512":
      return sha512.create();
  }
  assertArgument(false, "invalid hashing algorithm name", "algorithm", algo);
}
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n$4 = /* @__PURE__ */ BigInt(0);
const _1n$5 = /* @__PURE__ */ BigInt(1);
const _2n$3 = /* @__PURE__ */ BigInt(2);
const _7n = /* @__PURE__ */ BigInt(7);
const _256n = /* @__PURE__ */ BigInt(256);
const _0x71n = /* @__PURE__ */ BigInt(113);
for (let round2 = 0, R5 = _1n$5, x2 = 1, y4 = 0; round2 < 24; round2++) {
  [x2, y4] = [y4, (2 * x2 + 3 * y4) % 5];
  SHA3_PI.push(2 * (5 * y4 + x2));
  SHA3_ROTL.push((round2 + 1) * (round2 + 2) / 2 % 64);
  let t2 = _0n$4;
  for (let j2 = 0; j2 < 7; j2++) {
    R5 = (R5 << _1n$5 ^ (R5 >> _7n) * _0x71n) % _256n;
    if (R5 & _2n$3)
      t2 ^= _1n$5 << (_1n$5 << /* @__PURE__ */ BigInt(j2)) - _1n$5;
  }
  _SHA3_IOTA.push(t2);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split$1(_SHA3_IOTA, true);
const rotlH = (h5, l2, s2) => s2 > 32 ? rotlBH(h5, l2, s2) : rotlSH(h5, l2, s2);
const rotlL = (h5, l2, s2) => s2 > 32 ? rotlBL(h5, l2, s2) : rotlSL(h5, l2, s2);
function keccakP(s2, rounds = 24) {
  const B3 = new Uint32Array(5 * 2);
  for (let round2 = 24 - rounds; round2 < 24; round2++) {
    for (let x2 = 0; x2 < 10; x2++)
      B3[x2] = s2[x2] ^ s2[x2 + 10] ^ s2[x2 + 20] ^ s2[x2 + 30] ^ s2[x2 + 40];
    for (let x2 = 0; x2 < 10; x2 += 2) {
      const idx1 = (x2 + 8) % 10;
      const idx0 = (x2 + 2) % 10;
      const B0 = B3[idx0];
      const B1 = B3[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B3[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B3[idx1 + 1];
      for (let y4 = 0; y4 < 50; y4 += 10) {
        s2[x2 + y4] ^= Th;
        s2[x2 + y4 + 1] ^= Tl;
      }
    }
    let curH = s2[2];
    let curL = s2[3];
    for (let t2 = 0; t2 < 24; t2++) {
      const shift = SHA3_ROTL[t2];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t2];
      curH = s2[PI];
      curL = s2[PI + 1];
      s2[PI] = Th;
      s2[PI + 1] = Tl;
    }
    for (let y4 = 0; y4 < 50; y4 += 10) {
      for (let x2 = 0; x2 < 10; x2++)
        B3[x2] = s2[y4 + x2];
      for (let x2 = 0; x2 < 10; x2++)
        s2[y4 + x2] ^= ~B3[(x2 + 2) % 10] & B3[(x2 + 4) % 10];
    }
    s2[0] ^= SHA3_IOTA_H[round2];
    s2[1] ^= SHA3_IOTA_L[round2];
  }
  B3.fill(0);
}
class Keccak extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data2) {
    exists(this);
    const { blockLen, state: state2 } = this;
    data2 = toBytes$1(data2);
    const len2 = data2.length;
    for (let pos = 0; pos < len2; ) {
      const take = Math.min(blockLen - this.pos, len2 - pos);
      for (let i4 = 0; i4 < take; i4++)
        state2[this.pos++] ^= data2[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state: state2, suffix, pos, blockLen } = this;
    state2[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state2[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists(this, false);
    bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len2 = out.length; pos < len2; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len2 - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    number(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to2) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to2 || (to2 = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to2.state32.set(this.state32);
    to2.pos = this.pos;
    to2.posOut = this.posOut;
    to2.finished = this.finished;
    to2.rounds = rounds;
    to2.suffix = suffix;
    to2.outputLen = outputLen;
    to2.enableXOF = enableXOF;
    to2.destroyed = this.destroyed;
    return to2;
  }
}
const gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
const keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
let locked = false;
const _keccak256 = function(data2) {
  return keccak_256(data2);
};
let __keccak256 = _keccak256;
function keccak256$1(_data4) {
  const data2 = getBytes(_data4, "data");
  return hexlify(__keccak256(data2));
}
keccak256$1._ = _keccak256;
keccak256$1.lock = function() {
  locked = true;
};
keccak256$1.register = function(func) {
  if (locked) {
    throw new TypeError("keccak256 is locked");
  }
  __keccak256 = func;
};
Object.freeze(keccak256$1);
const _sha256 = function(data2) {
  return createHash("sha256").update(data2).digest();
};
let __sha256 = _sha256;
let locked256 = false;
function sha256(_data4) {
  const data2 = getBytes(_data4, "data");
  return hexlify(__sha256(data2));
}
sha256._ = _sha256;
sha256.lock = function() {
  locked256 = true;
};
sha256.register = function(func) {
  if (locked256) {
    throw new Error("sha256 is locked");
  }
  __sha256 = func;
};
Object.freeze(sha256);
Object.freeze(sha256);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$3 = BigInt(0);
const _1n$4 = BigInt(1);
const _2n$2 = BigInt(2);
const u8a = (a2) => a2 instanceof Uint8Array;
const hexes$1 = /* @__PURE__ */ Array.from({ length: 256 }, (_3, i4) => i4.toString(16).padStart(2, "0"));
function bytesToHex$1(bytes2) {
  if (!u8a(bytes2))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i4 = 0; i4 < bytes2.length; i4++) {
    hex += hexes$1[bytes2[i4]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber$1(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
function hexToBytes$1(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const len2 = hex.length;
  if (len2 % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + len2);
  const array = new Uint8Array(len2 / 2);
  for (let i4 = 0; i4 < array.length; i4++) {
    const j2 = i4 * 2;
    const hexByte = hex.slice(j2, j2 + 2);
    const byte2 = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte2) || byte2 < 0)
      throw new Error("Invalid byte sequence");
    array[i4] = byte2;
  }
  return array;
}
function bytesToNumberBE(bytes2) {
  return hexToNumber$1(bytesToHex$1(bytes2));
}
function bytesToNumberLE(bytes2) {
  if (!u8a(bytes2))
    throw new Error("Uint8Array expected");
  return hexToNumber$1(bytesToHex$1(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE(n5, len2) {
  return hexToBytes$1(n5.toString(16).padStart(len2 * 2, "0"));
}
function numberToBytesLE(n5, len2) {
  return numberToBytesBE(n5, len2).reverse();
}
function numberToVarBytesBE(n5) {
  return hexToBytes$1(numberToHexUnpadded(n5));
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes$1(hex);
    } catch (e3) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e3}`);
    }
  } else if (u8a(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len2 = res.length;
  if (typeof expectedLength === "number" && len2 !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len2}`);
  return res;
}
function concatBytes(...arrays) {
  const r3 = new Uint8Array(arrays.reduce((sum, a2) => sum + a2.length, 0));
  let pad3 = 0;
  arrays.forEach((a2) => {
    if (!u8a(a2))
      throw new Error("Uint8Array expected");
    r3.set(a2, pad3);
    pad3 += a2.length;
  });
  return r3;
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length)
    return false;
  for (let i4 = 0; i4 < b1.length; i4++)
    if (b1[i4] !== b2[i4])
      return false;
  return true;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n5) {
  let len2;
  for (len2 = 0; n5 > _0n$3; n5 >>= _1n$4, len2 += 1)
    ;
  return len2;
}
function bitGet(n5, pos) {
  return n5 >> BigInt(pos) & _1n$4;
}
const bitSet = (n5, pos, value) => {
  return n5 | (value ? _1n$4 : _0n$3) << BigInt(pos);
};
const bitMask = (n5) => (_2n$2 << BigInt(n5 - 1)) - _1n$4;
const u8n = (data2) => new Uint8Array(data2);
const u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v2 = u8n(hashLen);
  let k3 = u8n(hashLen);
  let i4 = 0;
  const reset = () => {
    v2.fill(1);
    k3.fill(0);
    i4 = 0;
  };
  const h5 = (...b2) => hmacFn(k3, v2, ...b2);
  const reseed2 = (seed = u8n()) => {
    k3 = h5(u8fr([0]), seed);
    v2 = h5();
    if (seed.length === 0)
      return;
    k3 = h5(u8fr([1]), seed);
    v2 = h5();
  };
  const gen2 = () => {
    if (i4++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len2 = 0;
    const out = [];
    while (len2 < qByteLen) {
      v2 = h5();
      const sl = v2.slice();
      out.push(sl);
      len2 += v2.length;
    }
    return concatBytes(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed2(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed2();
    reset();
    return res;
  };
  return genUntil;
}
const validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object2) => object2.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object2, validators, optValidators = {}) {
  const checkField = (fieldName, type2, isOptional) => {
    const checkVal = validatorFns[type2];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type2}", expected function`);
    const val = object2[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object2)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type2}`);
    }
  };
  for (const [fieldName, type2] of Object.entries(validators))
    checkField(fieldName, type2, false);
  for (const [fieldName, type2] of Object.entries(optValidators))
    checkField(fieldName, type2, true);
  return object2;
}
const ut$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet,
  bitLen,
  bitMask,
  bitSet,
  bytesToHex: bytesToHex$1,
  bytesToNumberBE,
  bytesToNumberLE,
  concatBytes,
  createHmacDrbg,
  ensureBytes,
  equalBytes,
  hexToBytes: hexToBytes$1,
  hexToNumber: hexToNumber$1,
  numberToBytesBE,
  numberToBytesLE,
  numberToHexUnpadded,
  numberToVarBytesBE,
  utf8ToBytes,
  validateObject
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$2 = BigInt(0), _1n$3 = BigInt(1), _2n$1 = BigInt(2), _3n$1 = BigInt(3);
const _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
BigInt(9);
BigInt(16);
function mod(a2, b2) {
  const result = a2 % b2;
  return result >= _0n$2 ? result : b2 + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n$2 || power < _0n$2)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n$3)
    return _0n$2;
  let res = _1n$3;
  while (power > _0n$2) {
    if (power & _1n$3)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n$3;
  }
  return res;
}
function pow2(x2, power, modulo) {
  let res = x2;
  while (power-- > _0n$2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n$2 || modulo <= _0n$2) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a2 = mod(number2, modulo);
  let b2 = modulo;
  let x2 = _0n$2, u2 = _1n$3;
  while (a2 !== _0n$2) {
    const q2 = b2 / a2;
    const r3 = b2 % a2;
    const m4 = x2 - u2 * q2;
    b2 = a2, a2 = r3, x2 = u2, u2 = m4;
  }
  const gcd = b2;
  if (gcd !== _1n$3)
    throw new Error("invert: does not exist");
  return mod(x2, modulo);
}
function tonelliShanks(P3) {
  const legendreC = (P3 - _1n$3) / _2n$1;
  let Q2, S4, Z3;
  for (Q2 = P3 - _1n$3, S4 = 0; Q2 % _2n$1 === _0n$2; Q2 /= _2n$1, S4++)
    ;
  for (Z3 = _2n$1; Z3 < P3 && pow(Z3, legendreC, P3) !== P3 - _1n$3; Z3++)
    ;
  if (S4 === 1) {
    const p1div4 = (P3 + _1n$3) / _4n;
    return function tonelliFast(Fp2, n5) {
      const root = Fp2.pow(n5, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n5))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q2 + _1n$3) / _2n$1;
  return function tonelliSlow(Fp2, n5) {
    if (Fp2.pow(n5, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r3 = S4;
    let g2 = Fp2.pow(Fp2.mul(Fp2.ONE, Z3), Q2);
    let x2 = Fp2.pow(n5, Q1div2);
    let b2 = Fp2.pow(n5, Q2);
    while (!Fp2.eql(b2, Fp2.ONE)) {
      if (Fp2.eql(b2, Fp2.ZERO))
        return Fp2.ZERO;
      let m4 = 1;
      for (let t2 = Fp2.sqr(b2); m4 < r3; m4++) {
        if (Fp2.eql(t2, Fp2.ONE))
          break;
        t2 = Fp2.sqr(t2);
      }
      const ge2 = Fp2.pow(g2, _1n$3 << BigInt(r3 - m4 - 1));
      g2 = Fp2.sqr(ge2);
      x2 = Fp2.mul(x2, ge2);
      b2 = Fp2.mul(b2, g2);
      r3 = m4;
    }
    return x2;
  };
}
function FpSqrt(P3) {
  if (P3 % _4n === _3n$1) {
    const p1div4 = (P3 + _1n$3) / _4n;
    return function sqrt3mod4(Fp2, n5) {
      const root = Fp2.pow(n5, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n5))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P3 % _8n === _5n) {
    const c1 = (P3 - _5n) / _8n;
    return function sqrt5mod8(Fp2, n5) {
      const n22 = Fp2.mul(n5, _2n$1);
      const v2 = Fp2.pow(n22, c1);
      const nv = Fp2.mul(n5, v2);
      const i4 = Fp2.mul(Fp2.mul(nv, _2n$1), v2);
      const root = Fp2.mul(nv, Fp2.sub(i4, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root), n5))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  return tonelliShanks(P3);
}
const FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f6, num, power) {
  if (power < _0n$2)
    throw new Error("Expected power > 0");
  if (power === _0n$2)
    return f6.ONE;
  if (power === _1n$3)
    return num;
  let p2 = f6.ONE;
  let d4 = num;
  while (power > _0n$2) {
    if (power & _1n$3)
      p2 = f6.mul(p2, d4);
    d4 = f6.sqr(d4);
    power >>= _1n$3;
  }
  return p2;
}
function FpInvertBatch(f6, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i4) => {
    if (f6.is0(num))
      return acc;
    tmp[i4] = acc;
    return f6.mul(acc, num);
  }, f6.ONE);
  const inverted = f6.inv(lastMultiplied);
  nums.reduceRight((acc, num, i4) => {
    if (f6.is0(num))
      return acc;
    tmp[i4] = f6.mul(acc, tmp[i4]);
    return f6.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n5, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n5.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n$2)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f6 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n$2,
    ONE: _1n$3,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n$2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n$2,
    isOdd: (num) => (num & _1n$3) === _1n$3,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f6, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n5) => sqrtP(f6, n5)),
    invertBatch: (lst) => FpInvertBatch(f6, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a2, b2, c2) => c2 ? b2 : a2,
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
      return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
    }
  });
  return Object.freeze(f6);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key2, fieldOrder, isLE2 = false) {
  const len2 = key2.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len2 < 16 || len2 < minLen || len2 > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len2}`);
  const num = isLE2 ? bytesToNumberBE(key2) : bytesToNumberLE(key2);
  const reduced = mod(num, fieldOrder - _1n$3) + _1n$3;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$1 = BigInt(0);
const _1n$2 = BigInt(1);
function wNAF(c2, bits) {
  const constTimeNegate = (condition, item) => {
    const neg4 = item.negate();
    return condition ? neg4 : item;
  };
  const opts = (W2) => {
    const windows = Math.ceil(bits / W2) + 1;
    const windowSize = 2 ** (W2 - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n5) {
      let p2 = c2.ZERO;
      let d4 = elm;
      while (n5 > _0n$1) {
        if (n5 & _1n$2)
          p2 = p2.add(d4);
        d4 = d4.double();
        n5 >>= _1n$2;
      }
      return p2;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W2) {
      const { windows, windowSize } = opts(W2);
      const points = [];
      let p2 = elm;
      let base3 = p2;
      for (let window2 = 0; window2 < windows; window2++) {
        base3 = p2;
        points.push(base3);
        for (let i4 = 1; i4 < windowSize; i4++) {
          base3 = base3.add(p2);
          points.push(base3);
        }
        p2 = base3.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W2, precomputes, n5) {
      const { windows, windowSize } = opts(W2);
      let p2 = c2.ZERO;
      let f6 = c2.BASE;
      const mask2 = BigInt(2 ** W2 - 1);
      const maxNumber = 2 ** W2;
      const shiftBy = BigInt(W2);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n5 & mask2);
        n5 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n5 += _1n$2;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f6 = f6.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p2 = p2.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p: p2, f: f6 };
    },
    wNAFCached(P3, precomputesMap, n5, transform) {
      const W2 = P3._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P3);
      if (!comp) {
        comp = this.precomputeWindow(P3, W2);
        if (W2 !== 1) {
          precomputesMap.set(P3, transform(comp));
        }
      }
      return this.wNAF(W2, comp, n5);
    }
  };
}
function validateBasic(curve2) {
  validateField(curve2.Fp);
  validateObject(curve2, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve2.n, curve2.nBitLength),
    ...curve2,
    ...{ p: curve2.Fp.ORDER }
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validatePointOpts(curve2) {
  const opts = validateBasic(curve2);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a: a2 } = opts;
  if (endo) {
    if (!Fp2.eql(a2, Fp2.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut$3;
const DER = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor(m4 = "") {
      super(m4);
    }
  },
  _parseInt(data2) {
    const { Err: E2 } = DER;
    if (data2.length < 2 || data2[0] !== 2)
      throw new E2("Invalid signature integer tag");
    const len2 = data2[1];
    const res = data2.subarray(2, len2 + 2);
    if (!len2 || res.length !== len2)
      throw new E2("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E2("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E2("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data2.subarray(len2 + 2) };
  },
  toSig(hex) {
    const { Err: E2 } = DER;
    const data2 = typeof hex === "string" ? h2b(hex) : hex;
    if (!(data2 instanceof Uint8Array))
      throw new Error("ui8a expected");
    let l2 = data2.length;
    if (l2 < 2 || data2[0] != 48)
      throw new E2("Invalid signature tag");
    if (data2[1] !== l2 - 2)
      throw new E2("Invalid signature: incorrect length");
    const { d: r3, l: sBytes } = DER._parseInt(data2.subarray(2));
    const { d: s2, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E2("Invalid signature: left bytes after parsing");
    return { r: r3, s: s2 };
  },
  hexFromSig(sig) {
    const slice = (s3) => Number.parseInt(s3[0], 16) & 8 ? "00" + s3 : s3;
    const h5 = (num) => {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    };
    const s2 = slice(h5(sig.s));
    const r3 = slice(h5(sig.r));
    const shl = s2.length / 2;
    const rhl = r3.length / 2;
    const sl = h5(shl);
    const rl = h5(rhl);
    return `30${h5(rhl + shl + 4)}02${rl}${r3}02${sl}${s2}`;
  }
};
const _0n = BigInt(0), _1n$1 = BigInt(1);
BigInt(2);
const _3n = BigInt(3);
BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp2 } = CURVE;
  const toBytes3 = CURVE.toBytes || ((_c3, point5, _isCompressed) => {
    const a2 = point5.toAffine();
    return concatBytes(Uint8Array.from([4]), Fp2.toBytes(a2.x), Fp2.toBytes(a2.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x2 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y4 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x: x2, y: y4 };
  });
  function weierstrassEquation(x2) {
    const { a: a2, b: b2 } = CURVE;
    const x22 = Fp2.sqr(x2);
    const x3 = Fp2.mul(x22, x2);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x2, a2)), b2);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key2) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n5 } = CURVE;
    if (lengths && typeof key2 !== "bigint") {
      if (key2 instanceof Uint8Array)
        key2 = bytesToHex$1(key2);
      if (typeof key2 !== "string" || !lengths.includes(key2.length))
        throw new Error("Invalid key");
      key2 = key2.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key2 === "bigint" ? key2 : bytesToNumberBE(ensureBytes("private key", key2, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key2}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n5);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  class Point2 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp2.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p2) {
      const { x: x2, y: y4 } = p2 || {};
      if (!p2 || !Fp2.isValid(x2) || !Fp2.isValid(y4))
        throw new Error("invalid affine point");
      if (p2 instanceof Point2)
        throw new Error("projective point not allowed");
      const is0 = (i4) => Fp2.eql(i4, Fp2.ZERO);
      if (is0(x2) && is0(y4))
        return Point2.ZERO;
      return new Point2(x2, y4, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p2) => p2.pz));
      return points.map((p2, i4) => p2.toAffine(toInv[i4])).map(Point2.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex) {
      const P3 = Point2.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
      P3.assertValidity();
      return P3;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: x2, y: y4 } = this.toAffine();
      if (!Fp2.isValid(x2) || !Fp2.isValid(y4))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y4);
      const right = weierstrassEquation(x2);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: y4 } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y4);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z22 } = other;
      const U1 = Fp2.eql(Fp2.mul(X1, Z22), Fp2.mul(X2, Z1));
      const U2 = Fp2.eql(Fp2.mul(Y1, Z22), Fp2.mul(Y2, Z1));
      return U1 && U2;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point2(this.px, Fp2.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a2, b: b2 } = CURVE;
      const b3 = Fp2.mul(b2, _3n);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a2, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a2, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a2, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z22 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a2 = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y2);
      let t2 = Fp2.mul(Z1, Z22);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y2);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z22);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y2, Z22);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a2, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a2, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a2, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    wNAF(n5) {
      return wnaf.wNAFCached(this, pointPrecomputes, n5, (comp) => {
        const toInv = Fp2.invertBatch(comp.map((p2) => p2.pz));
        return comp.map((p2, i4) => p2.toAffine(toInv[i4])).map(Point2.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n5) {
      const I4 = Point2.ZERO;
      if (n5 === _0n)
        return I4;
      assertGE(n5);
      if (n5 === _1n$1)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n5);
      let { k1neg, k1, k2neg, k2: k22 } = endo.splitScalar(n5);
      let k1p = I4;
      let k2p = I4;
      let d4 = this;
      while (k1 > _0n || k22 > _0n) {
        if (k1 & _1n$1)
          k1p = k1p.add(d4);
        if (k22 & _1n$1)
          k2p = k2p.add(d4);
        d4 = d4.double();
        k1 >>= _1n$1;
        k22 >>= _1n$1;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n5 = scalar;
      let point5, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2: k22 } = endo.splitScalar(n5);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k22);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point5 = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p: p2, f: f6 } = this.wNAF(n5);
        point5 = p2;
        fake = f6;
      }
      return Point2.normalizeZ([point5, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q2, a2, b2) {
      const G2 = Point2.BASE;
      const mul6 = (P3, a3) => a3 === _0n || a3 === _1n$1 || !P3.equals(G2) ? P3.multiplyUnsafe(a3) : P3.multiply(a3);
      const sum = mul6(this, a2).add(mul6(Q2, b2));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x2, py: y4, pz: z3 } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z3);
      const ax = Fp2.mul(x2, iz);
      const ay = Fp2.mul(y4, iz);
      const zz = Fp2.mul(z3, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n$1)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n$1)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes3(Point2, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex$1(this.toRawBytes(isCompressed));
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point2.ZERO = new Point2(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point2,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve2) {
  const opts = validateBasic(curve2);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n < num && num < Fp2.ORDER;
  }
  function modN(a2) {
    return mod(a2, CURVE_ORDER);
  }
  function invN(a2) {
    return invert(a2, CURVE_ORDER);
  }
  const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c3, point5, isCompressed) {
      const a2 = point5.toAffine();
      const x2 = Fp2.toBytes(a2.x);
      const cat = concatBytes;
      if (isCompressed) {
        return cat(Uint8Array.from([point5.hasEvenY() ? 2 : 3]), x2);
      } else {
        return cat(Uint8Array.from([4]), x2, Fp2.toBytes(a2.y));
      }
    },
    fromBytes(bytes2) {
      const len2 = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len2 === compressedLen && (head === 2 || head === 3)) {
        const x2 = bytesToNumberBE(tail);
        if (!isValidFieldElement(x2))
          throw new Error("Point is not on curve");
        const y22 = weierstrassEquation(x2);
        let y4 = Fp2.sqrt(y22);
        const isYOdd = (y4 & _1n$1) === _1n$1;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y4 = Fp2.neg(y4);
        return { x: x2, y: y4 };
      } else if (len2 === uncompressedLen && head === 4) {
        const x2 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y4 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x: x2, y: y4 };
      } else {
        throw new Error(`Point of length ${len2} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex$1(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n$1;
    return number2 > HALF;
  }
  function normalizeS(s2) {
    return isBiggerThanHalfOrder(s2) ? modN(-s2) : s2;
  }
  const slcNum = (b2, from2, to2) => bytesToNumberBE(b2.slice(from2, to2));
  class Signature2 {
    constructor(r3, s2, recovery) {
      this.r = r3;
      this.s = s2;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex) {
      const l2 = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l2 * 2);
      return new Signature2(slcNum(hex, 0, l2), slcNum(hex, l2, 2 * l2));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex) {
      const { r: r3, s: s2 } = DER.toSig(ensureBytes("DER", hex));
      return new Signature2(r3, s2);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature2(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r: r3, s: s2, recovery: rec } = this;
      const h5 = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r3 + CURVE.n : r3;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R5 = Point2.fromHex(prefix + numToNByteStr(radj));
      const ir4 = invN(radj);
      const u1 = modN(-h5 * ir4);
      const u2 = modN(s2 * ir4);
      const Q2 = Point2.BASE.multiplyAndAddUnsafe(R5, u1, u2);
      if (!Q2)
        throw new Error("point at infinify");
      Q2.assertValidity();
      return Q2;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature2(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes$1(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes$1(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils2 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point5 = Point2.BASE) {
      point5._setWindowSize(windowSize);
      point5.multiply(BigInt(3));
      return point5;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str = typeof item === "string";
    const len2 = (arr || str) && item.length;
    if (arr)
      return len2 === compressedLen || len2 === uncompressedLen;
    if (str)
      return len2 === 2 * compressedLen || len2 === 2 * uncompressedLen;
    if (item instanceof Point2)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b2 = Point2.fromHex(publicB);
    return b2.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    const num = bytesToNumberBE(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k3) => k3 in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash3, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash3(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d4 = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d4), int2octets(h1int)];
    if (ent != null) {
      const e3 = ent === true ? randomBytes2(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e3));
    }
    const seed = concatBytes(...seedArgs);
    const m4 = h1int;
    function k2sig(kBytes) {
      const k3 = bits2int(kBytes);
      if (!isWithinCurveOrder(k3))
        return;
      const ik = invN(k3);
      const q2 = Point2.BASE.multiply(k3).toAffine();
      const r3 = modN(q2.x);
      if (r3 === _0n)
        return;
      const s2 = modN(ik * modN(m4 + r3 * d4));
      if (s2 === _0n)
        return;
      let recovery = (q2.x === r3 ? 0 : 2) | Number(q2.y & _1n$1);
      let normS = s2;
      if (lowS && isBiggerThanHalfOrder(s2)) {
        normS = normalizeS(s2);
        recovery ^= 1;
      }
      return new Signature2(r3, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign5(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C2 = CURVE;
    const drbg = createHmacDrbg(C2.hash.outputLen, C2.nByteLength, C2.hmac);
    return drbg(seed, k2sig);
  }
  Point2.BASE._setWindowSize(8);
  function verify4(signature2, msgHash, publicKey, opts = defaultVerOpts) {
    var _a3;
    const sg = signature2;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig2 = void 0;
    let P3;
    try {
      if (typeof sg === "string" || sg instanceof Uint8Array) {
        try {
          _sig2 = Signature2.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig2 = Signature2.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r4, s: s3 } = sg;
        _sig2 = new Signature2(r4, s3);
      } else {
        throw new Error("PARSE");
      }
      P3 = Point2.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig2.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r: r3, s: s2 } = _sig2;
    const h5 = bits2int_modN(msgHash);
    const is2 = invN(s2);
    const u1 = modN(h5 * is2);
    const u2 = modN(r3 * is2);
    const R5 = (_a3 = Point2.BASE.multiplyAndAddUnsafe(P3, u1, u2)) == null ? void 0 : _a3.toAffine();
    if (!R5)
      return false;
    const v2 = modN(R5.x);
    return v2 === r3;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign: sign5,
    verify: verify4,
    ProjectivePoint: Point2,
    Signature: Signature2,
    utils: utils2
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash(hash3) {
  return {
    hash: hash3,
    hmac: (key2, ...msgs) => hmac(hash3, key2, concatBytes$1(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create2 = (hash3) => weierstrass({ ...curveDef, ...getHash(hash3) });
  return Object.freeze({ ...create2(defHash), create: create2 });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
const secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const _1n = BigInt(1);
const _2n = BigInt(2);
const divNearest = (a2, b2) => (a2 + b2 / _2n) / b2;
function sqrtMod(y4) {
  const P3 = secp256k1P;
  const _3n2 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y4 * y4 * y4 % P3;
  const b3 = b2 * b2 * y4 % P3;
  const b6 = pow2(b3, _3n2, P3) * b3 % P3;
  const b9 = pow2(b6, _3n2, P3) * b3 % P3;
  const b11 = pow2(b9, _2n, P3) * b2 % P3;
  const b22 = pow2(b11, _11n, P3) * b11 % P3;
  const b44 = pow2(b22, _22n, P3) * b22 % P3;
  const b88 = pow2(b44, _44n, P3) * b44 % P3;
  const b176 = pow2(b88, _88n, P3) * b88 % P3;
  const b220 = pow2(b176, _44n, P3) * b44 % P3;
  const b223 = pow2(b220, _3n2, P3) * b3 % P3;
  const t1 = pow2(b223, _23n, P3) * b22 % P3;
  const t2 = pow2(t1, _6n, P3) * b2 % P3;
  const root = pow2(t2, _2n, P3);
  if (!Fp.eql(Fp.sqr(root), y4))
    throw new Error("Cannot find square root");
  return root;
}
const Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
const secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k3) => {
      const n5 = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k3, n5);
      const c2 = divNearest(-b1 * k3, n5);
      let k1 = mod(k3 - c1 * a1 - c2 * a2, n5);
      let k22 = mod(-c1 * b1 - c2 * b2, n5);
      const k1neg = k1 > POW_2_128;
      const k2neg = k22 > POW_2_128;
      if (k1neg)
        k1 = n5 - k1;
      if (k2neg)
        k22 = n5 - k22;
      if (k1 > POW_2_128 || k22 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k3);
      }
      return { k1neg, k1, k2neg, k2: k22 };
    }
  }
}, sha256$1);
BigInt(0);
secp256k1.ProjectivePoint;
const ZeroAddress = "0x0000000000000000000000000000000000000000";
const ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
const BN_0$7 = BigInt(0);
const BN_1$2 = BigInt(1);
const BN_2$2 = BigInt(2);
const BN_27$1 = BigInt(27);
const BN_28$1 = BigInt(28);
const BN_35$1 = BigInt(35);
const _guard$1 = {};
function toUint256(value) {
  return zeroPadValue(toBeArray(value), 32);
}
const _Signature = class _Signature {
  /**
   *  @private
   */
  constructor(guard, r3, s2, v2) {
    __privateAdd(this, _r2);
    __privateAdd(this, _s2);
    __privateAdd(this, _v);
    __privateAdd(this, _networkV);
    assertPrivate(guard, _guard$1, "Signature");
    __privateSet(this, _r2, r3);
    __privateSet(this, _s2, s2);
    __privateSet(this, _v, v2);
    __privateSet(this, _networkV, null);
  }
  /**
   *  The ``r`` value for a signautre.
   *
   *  This represents the ``x`` coordinate of a "reference" or
   *  challenge point, from which the ``y`` can be computed.
   */
  get r() {
    return __privateGet(this, _r2);
  }
  set r(value) {
    assertArgument(dataLength(value) === 32, "invalid r", "value", value);
    __privateSet(this, _r2, hexlify(value));
  }
  /**
   *  The ``s`` value for a signature.
   */
  get s() {
    return __privateGet(this, _s2);
  }
  set s(_value2) {
    assertArgument(dataLength(_value2) === 32, "invalid s", "value", _value2);
    const value = hexlify(_value2);
    assertArgument(parseInt(value.substring(0, 3)) < 8, "non-canonical s", "value", value);
    __privateSet(this, _s2, value);
  }
  /**
   *  The ``v`` value for a signature.
   *
   *  Since a given ``x`` value for ``r`` has two possible values for
   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
   *  values to use.
   *
   *  It is normalized to the values ``27`` or ``28`` for legacy
   *  purposes.
   */
  get v() {
    return __privateGet(this, _v);
  }
  set v(value) {
    const v2 = getNumber(value, "value");
    assertArgument(v2 === 27 || v2 === 28, "invalid v", "v", value);
    __privateSet(this, _v, v2);
  }
  /**
   *  The EIP-155 ``v`` for legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get networkV() {
    return __privateGet(this, _networkV);
  }
  /**
   *  The chain ID for EIP-155 legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get legacyChainId() {
    const v2 = this.networkV;
    if (v2 == null) {
      return null;
    }
    return _Signature.getChainId(v2);
  }
  /**
   *  The ``yParity`` for the signature.
   *
   *  See ``v`` for more details on how this value is used.
   */
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  /**
   *  The [[link-eip-2098]] compact representation of the ``yParity``
   *  and ``s`` compacted into a single ``bytes32``.
   */
  get yParityAndS() {
    const yParityAndS = getBytes(this.s);
    if (this.yParity) {
      yParityAndS[0] |= 128;
    }
    return hexlify(yParityAndS);
  }
  /**
   *  The [[link-eip-2098]] compact representation.
   */
  get compactSerialized() {
    return concat([this.r, this.yParityAndS]);
  }
  /**
   *  The serialized representation.
   */
  get serialized() {
    return concat([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  /**
   *  Returns a new identical [[Signature]].
   */
  clone() {
    const clone = new _Signature(_guard$1, this.r, this.s, this.v);
    if (this.networkV) {
      __privateSet(clone, _networkV, this.networkV);
    }
    return clone;
  }
  /**
   *  Returns a representation that is compatible with ``JSON.stringify``.
   */
  toJSON() {
    const networkV = this.networkV;
    return {
      _type: "signature",
      networkV: networkV != null ? networkV.toString() : null,
      r: this.r,
      s: this.s,
      v: this.v
    };
  }
  /**
   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
   *
   *  @example:
   *    Signature.getChainId(45)
   *    //_result:
   *
   *    Signature.getChainId(46)
   *    //_result:
   */
  static getChainId(v2) {
    const bv = getBigInt(v2, "v");
    if (bv == BN_27$1 || bv == BN_28$1) {
      return BN_0$7;
    }
    assertArgument(bv >= BN_35$1, "invalid EIP-155 v", "v", v2);
    return (bv - BN_35$1) / BN_2$2;
  }
  /**
   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
   *
   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
   *  property to include the chain ID.
   *
   *  @example:
   *    Signature.getChainIdV(5, 27)
   *    //_result:
   *
   *    Signature.getChainIdV(5, 28)
   *    //_result:
   *
   */
  static getChainIdV(chainId, v2) {
    return getBigInt(chainId) * BN_2$2 + BigInt(35 + v2 - 27);
  }
  /**
   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
   *
   *  @example:
   *    // The values 0 and 1 imply v is actually yParity
   *    Signature.getNormalizedV(0)
   *    //_result:
   *
   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
   *    Signature.getNormalizedV(27)
   *    //_result:
   *
   *    // Legacy EIP-155 transaction (i.e. >= 35)
   *    Signature.getNormalizedV(46)
   *    //_result:
   *
   *    // Invalid values throw
   *    Signature.getNormalizedV(5)
   *    //_error:
   */
  static getNormalizedV(v2) {
    const bv = getBigInt(v2);
    if (bv === BN_0$7 || bv === BN_27$1) {
      return 27;
    }
    if (bv === BN_1$2 || bv === BN_28$1) {
      return 28;
    }
    assertArgument(bv >= BN_35$1, "invalid v", "v", v2);
    return bv & BN_1$2 ? 27 : 28;
  }
  /**
   *  Creates a new [[Signature]].
   *
   *  If no %%sig%% is provided, a new [[Signature]] is created
   *  with default values.
   *
   *  If %%sig%% is a string, it is parsed.
   */
  static from(sig) {
    function assertError(check, message) {
      assertArgument(check, message, "signature", sig);
    }
    if (sig == null) {
      return new _Signature(_guard$1, ZeroHash, ZeroHash, 27);
    }
    if (typeof sig === "string") {
      const bytes2 = getBytes(sig, "signature");
      if (bytes2.length === 64) {
        const r4 = hexlify(bytes2.slice(0, 32));
        const s3 = bytes2.slice(32, 64);
        const v3 = s3[0] & 128 ? 28 : 27;
        s3[0] &= 127;
        return new _Signature(_guard$1, r4, hexlify(s3), v3);
      }
      if (bytes2.length === 65) {
        const r4 = hexlify(bytes2.slice(0, 32));
        const s3 = bytes2.slice(32, 64);
        assertError((s3[0] & 128) === 0, "non-canonical s");
        const v3 = _Signature.getNormalizedV(bytes2[64]);
        return new _Signature(_guard$1, r4, hexlify(s3), v3);
      }
      assertError(false, "invalid raw signature length");
    }
    if (sig instanceof _Signature) {
      return sig.clone();
    }
    const _r3 = sig.r;
    assertError(_r3 != null, "missing r");
    const r3 = toUint256(_r3);
    const s2 = function(s3, yParityAndS) {
      if (s3 != null) {
        return toUint256(s3);
      }
      if (yParityAndS != null) {
        assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
        const bytes2 = getBytes(yParityAndS);
        bytes2[0] &= 127;
        return hexlify(bytes2);
      }
      assertError(false, "missing s");
    }(sig.s, sig.yParityAndS);
    assertError((getBytes(s2)[0] & 128) == 0, "non-canonical s");
    const { networkV, v: v2 } = function(_v2, yParityAndS, yParity) {
      if (_v2 != null) {
        const v3 = getBigInt(_v2);
        return {
          networkV: v3 >= BN_35$1 ? v3 : void 0,
          v: _Signature.getNormalizedV(v3)
        };
      }
      if (yParityAndS != null) {
        assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
        return { v: getBytes(yParityAndS)[0] & 128 ? 28 : 27 };
      }
      if (yParity != null) {
        switch (getNumber(yParity, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        assertError(false, "invalid yParity");
      }
      assertError(false, "missing v");
    }(sig.v, sig.yParityAndS, sig.yParity);
    const result = new _Signature(_guard$1, r3, s2, v2);
    if (networkV) {
      __privateSet(result, _networkV, networkV);
    }
    assertError(sig.yParity == null || getNumber(sig.yParity, "sig.yParity") === result.yParity, "yParity mismatch");
    assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, "yParityAndS mismatch");
    return result;
  }
};
_r2 = new WeakMap();
_s2 = new WeakMap();
_v = new WeakMap();
_networkV = new WeakMap();
let Signature = _Signature;
const _SigningKey = class _SigningKey {
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  constructor(privateKey) {
    __privateAdd(this, _privateKey);
    assertArgument(dataLength(privateKey) === 32, "invalid private key", "privateKey", "[REDACTED]");
    __privateSet(this, _privateKey, hexlify(privateKey));
  }
  /**
   *  The private key.
   */
  get privateKey() {
    return __privateGet(this, _privateKey);
  }
  /**
   *  The uncompressed public key.
   *
   * This will always begin with the prefix ``0x04`` and be 132
   * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
   */
  get publicKey() {
    return _SigningKey.computePublicKey(__privateGet(this, _privateKey));
  }
  /**
   *  The compressed public key.
   *
   *  This will always begin with either the prefix ``0x02`` or ``0x03``
   *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
   *  nibbles)
   */
  get compressedPublicKey() {
    return _SigningKey.computePublicKey(__privateGet(this, _privateKey), true);
  }
  /**
   *  Return the signature of the signed %%digest%%.
   */
  sign(digest9) {
    assertArgument(dataLength(digest9) === 32, "invalid digest length", "digest", digest9);
    const sig = secp256k1.sign(getBytesCopy(digest9), getBytesCopy(__privateGet(this, _privateKey)), {
      lowS: true
    });
    return Signature.from({
      r: toBeHex(sig.r, 32),
      s: toBeHex(sig.s, 32),
      v: sig.recovery ? 28 : 27
    });
  }
  /**
   *  Returns the [[link-wiki-ecdh]] shared secret between this
   *  private key and the %%other%% key.
   *
   *  The %%other%% key may be any type of key, a raw public key,
   *  a compressed/uncompressed pubic key or aprivate key.
   *
   *  Best practice is usually to use a cryptographic hash on the
   *  returned value before using it as a symetric secret.
   *
   *  @example:
   *    sign1 = new SigningKey(id("some-secret-1"))
   *    sign2 = new SigningKey(id("some-secret-2"))
   *
   *    // Notice that privA.computeSharedSecret(pubB)...
   *    sign1.computeSharedSecret(sign2.publicKey)
   *    //_result:
   *
   *    // ...is equal to privB.computeSharedSecret(pubA).
   *    sign2.computeSharedSecret(sign1.publicKey)
   *    //_result:
   */
  computeSharedSecret(other) {
    const pubKey = _SigningKey.computePublicKey(other);
    return hexlify(secp256k1.getSharedSecret(getBytesCopy(__privateGet(this, _privateKey)), getBytes(pubKey), false));
  }
  /**
   *  Compute the public key for %%key%%, optionally %%compressed%%.
   *
   *  The %%key%% may be any type of key, a raw public key, a
   *  compressed/uncompressed public key or private key.
   *
   *  @example:
   *    sign = new SigningKey(id("some-secret"));
   *
   *    // Compute the uncompressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey)
   *    //_result:
   *
   *    // Compute the compressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey, true)
   *    //_result:
   *
   *    // Compute the uncompressed public key
   *    SigningKey.computePublicKey(sign.publicKey, false);
   *    //_result:
   *
   *    // Compute the Compressed a public key
   *    SigningKey.computePublicKey(sign.publicKey, true);
   *    //_result:
   */
  static computePublicKey(key2, compressed) {
    let bytes2 = getBytes(key2, "key");
    if (bytes2.length === 32) {
      const pubKey = secp256k1.getPublicKey(bytes2, !!compressed);
      return hexlify(pubKey);
    }
    if (bytes2.length === 64) {
      const pub2 = new Uint8Array(65);
      pub2[0] = 4;
      pub2.set(bytes2, 1);
      bytes2 = pub2;
    }
    const point5 = secp256k1.ProjectivePoint.fromHex(bytes2);
    return hexlify(point5.toRawBytes(compressed));
  }
  /**
   *  Returns the public key for the private key which produced the
   *  %%signature%% for the given %%digest%%.
   *
   *  @example:
   *    key = new SigningKey(id("some-secret"))
   *    digest = id("hello world")
   *    sig = key.sign(digest)
   *
   *    // Notice the signer public key...
   *    key.publicKey
   *    //_result:
   *
   *    // ...is equal to the recovered public key
   *    SigningKey.recoverPublicKey(digest, sig)
   *    //_result:
   *
   */
  static recoverPublicKey(digest9, signature2) {
    assertArgument(dataLength(digest9) === 32, "invalid digest length", "digest", digest9);
    const sig = Signature.from(signature2);
    let secpSig = secp256k1.Signature.fromCompact(getBytesCopy(concat([sig.r, sig.s])));
    secpSig = secpSig.addRecoveryBit(sig.yParity);
    const pubKey = secpSig.recoverPublicKey(getBytesCopy(digest9));
    assertArgument(pubKey != null, "invalid signautre for digest", "signature", signature2);
    return "0x" + pubKey.toHex(false);
  }
  /**
   *  Returns the point resulting from adding the ellipic curve points
   *  %%p0%% and %%p1%%.
   *
   *  This is not a common function most developers should require, but
   *  can be useful for certain privacy-specific techniques.
   *
   *  For example, it is used by [[HDNodeWallet]] to compute child
   *  addresses from parent public keys and chain codes.
   */
  static addPoints(p0, p1, compressed) {
    const pub0 = secp256k1.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p0).substring(2));
    const pub1 = secp256k1.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p1).substring(2));
    return "0x" + pub0.add(pub1).toHex(!!compressed);
  }
};
_privateKey = new WeakMap();
let SigningKey = _SigningKey;
const BN_0$6 = BigInt(0);
const BN_36 = BigInt(36);
function getChecksumAddress(address) {
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i4 = 0; i4 < 40; i4++) {
    expanded[i4] = chars[i4].charCodeAt(0);
  }
  const hashed = getBytes(keccak256$1(expanded));
  for (let i4 = 0; i4 < 40; i4 += 2) {
    if (hashed[i4 >> 1] >> 4 >= 8) {
      chars[i4] = chars[i4].toUpperCase();
    }
    if ((hashed[i4 >> 1] & 15) >= 8) {
      chars[i4 + 1] = chars[i4 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
const ibanLookup = {};
for (let i4 = 0; i4 < 10; i4++) {
  ibanLookup[String(i4)] = String(i4);
}
for (let i4 = 0; i4 < 26; i4++) {
  ibanLookup[String.fromCharCode(65 + i4)] = String(10 + i4);
}
const safeDigits = 15;
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c2) => {
    return ibanLookup[c2];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
const Base36 = function() {
  const result = {};
  for (let i4 = 0; i4 < 36; i4++) {
    const key2 = "0123456789abcdefghijklmnopqrstuvwxyz"[i4];
    result[key2] = BigInt(i4);
  }
  return result;
}();
function fromBase36(value) {
  value = value.toLowerCase();
  let result = BN_0$6;
  for (let i4 = 0; i4 < value.length; i4++) {
    result = result * BN_36 + Base36[value[i4]];
  }
  return result;
}
function getAddress(address) {
  assertArgument(typeof address === "string", "invalid address", "address", address);
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (!address.startsWith("0x")) {
      address = "0x" + address;
    }
    const result = getChecksumAddress(address);
    assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, "bad address checksum", "address", address);
    return result;
  }
  if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    assertArgument(address.substring(2, 4) === ibanChecksum(address), "bad icap checksum", "address", address);
    let result = fromBase36(address.substring(4)).toString(16);
    while (result.length < 40) {
      result = "0" + result;
    }
    return getChecksumAddress("0x" + result);
  }
  assertArgument(false, "invalid address", "address", address);
}
function getCreateAddress(tx) {
  const from2 = getAddress(tx.from);
  const nonce = getBigInt(tx.nonce, "tx.nonce");
  let nonceHex = nonce.toString(16);
  if (nonceHex === "0") {
    nonceHex = "0x";
  } else if (nonceHex.length % 2) {
    nonceHex = "0x0" + nonceHex;
  } else {
    nonceHex = "0x" + nonceHex;
  }
  return getAddress(dataSlice(keccak256$1(encodeRlp([from2, nonceHex])), 12));
}
function isAddressable(value) {
  return value && typeof value.getAddress === "function";
}
async function checkAddress(target, promise) {
  const result = await promise;
  if (result == null || result === "0x0000000000000000000000000000000000000000") {
    assert(typeof target !== "string", "unconfigured name", "UNCONFIGURED_NAME", { value: target });
    assertArgument(false, "invalid AddressLike value; did not resolve to a value address", "target", target);
  }
  return getAddress(result);
}
function resolveAddress(target, resolver) {
  if (typeof target === "string") {
    if (target.match(/^0x[0-9a-f]{40}$/i)) {
      return getAddress(target);
    }
    assert(resolver != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" });
    return checkAddress(target, resolver.resolveName(target));
  } else if (isAddressable(target)) {
    return checkAddress(target, target.getAddress());
  } else if (target && typeof target.then === "function") {
    return checkAddress(target, target);
  }
  assertArgument(false, "unsupported addressable value", "target", target);
}
const _gaurd = {};
function n(value, width) {
  let signed2 = false;
  if (width < 0) {
    signed2 = true;
    width *= -1;
  }
  return new Typed(_gaurd, `${signed2 ? "" : "u"}int${width}`, value, { signed: signed2, width });
}
function b$1(value, size2) {
  return new Typed(_gaurd, `bytes${size2 ? size2 : ""}`, value, { size: size2 });
}
const _typedSymbol = Symbol.for("_ethers_typed");
const _Typed = class _Typed {
  /**
   *  @_ignore:
   */
  constructor(gaurd, type2, value, options) {
    /**
     *  The type, as a Solidity-compatible type.
     */
    __publicField(this, "type");
    /**
     *  The actual value.
     */
    __publicField(this, "value");
    __privateAdd(this, _options);
    /**
     *  @_ignore:
     */
    __publicField(this, "_typedSymbol");
    if (options == null) {
      options = null;
    }
    assertPrivate(_gaurd, gaurd, "Typed");
    defineProperties(this, { _typedSymbol, type: type2, value });
    __privateSet(this, _options, options);
    this.format();
  }
  /**
   *  Format the type as a Human-Readable type.
   */
  format() {
    if (this.type === "array") {
      throw new Error("");
    } else if (this.type === "dynamicArray") {
      throw new Error("");
    } else if (this.type === "tuple") {
      return `tuple(${this.value.map((v2) => v2.format()).join(",")})`;
    }
    return this.type;
  }
  /**
   *  The default value returned by this type.
   */
  defaultValue() {
    return 0;
  }
  /**
   *  The minimum value for numeric types.
   */
  minValue() {
    return 0;
  }
  /**
   *  The maximum value for numeric types.
   */
  maxValue() {
    return 0;
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
   */
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
   */
  isData() {
    return this.type.startsWith("bytes");
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
   */
  isString() {
    return this.type === "string";
  }
  /**
   *  Returns the tuple name, if this is a tuple. Throws otherwise.
   */
  get tupleName() {
    if (this.type !== "tuple") {
      throw TypeError("not a tuple");
    }
    return __privateGet(this, _options);
  }
  // Returns the length of this type as an array
  // - `null` indicates the length is unforced, it could be dynamic
  // - `-1` indicates the length is dynamic
  // - any other value indicates it is a static array and is its length
  /**
   *  Returns the length of the array type or ``-1`` if it is dynamic.
   *
   *  Throws if the type is not an array.
   */
  get arrayLength() {
    if (this.type !== "array") {
      throw TypeError("not an array");
    }
    if (__privateGet(this, _options) === true) {
      return -1;
    }
    if (__privateGet(this, _options) === false) {
      return this.value.length;
    }
    return null;
  }
  /**
   *  Returns a new **Typed** of %%type%% with the %%value%%.
   */
  static from(type2, value) {
    return new _Typed(_gaurd, type2, value);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static uint8(v2) {
    return n(v2, 8);
  }
  /**
   *  Return a new ``uint16`` type for %%v%%.
   */
  static uint16(v2) {
    return n(v2, 16);
  }
  /**
   *  Return a new ``uint24`` type for %%v%%.
   */
  static uint24(v2) {
    return n(v2, 24);
  }
  /**
   *  Return a new ``uint32`` type for %%v%%.
   */
  static uint32(v2) {
    return n(v2, 32);
  }
  /**
   *  Return a new ``uint40`` type for %%v%%.
   */
  static uint40(v2) {
    return n(v2, 40);
  }
  /**
   *  Return a new ``uint48`` type for %%v%%.
   */
  static uint48(v2) {
    return n(v2, 48);
  }
  /**
   *  Return a new ``uint56`` type for %%v%%.
   */
  static uint56(v2) {
    return n(v2, 56);
  }
  /**
   *  Return a new ``uint64`` type for %%v%%.
   */
  static uint64(v2) {
    return n(v2, 64);
  }
  /**
   *  Return a new ``uint72`` type for %%v%%.
   */
  static uint72(v2) {
    return n(v2, 72);
  }
  /**
   *  Return a new ``uint80`` type for %%v%%.
   */
  static uint80(v2) {
    return n(v2, 80);
  }
  /**
   *  Return a new ``uint88`` type for %%v%%.
   */
  static uint88(v2) {
    return n(v2, 88);
  }
  /**
   *  Return a new ``uint96`` type for %%v%%.
   */
  static uint96(v2) {
    return n(v2, 96);
  }
  /**
   *  Return a new ``uint104`` type for %%v%%.
   */
  static uint104(v2) {
    return n(v2, 104);
  }
  /**
   *  Return a new ``uint112`` type for %%v%%.
   */
  static uint112(v2) {
    return n(v2, 112);
  }
  /**
   *  Return a new ``uint120`` type for %%v%%.
   */
  static uint120(v2) {
    return n(v2, 120);
  }
  /**
   *  Return a new ``uint128`` type for %%v%%.
   */
  static uint128(v2) {
    return n(v2, 128);
  }
  /**
   *  Return a new ``uint136`` type for %%v%%.
   */
  static uint136(v2) {
    return n(v2, 136);
  }
  /**
   *  Return a new ``uint144`` type for %%v%%.
   */
  static uint144(v2) {
    return n(v2, 144);
  }
  /**
   *  Return a new ``uint152`` type for %%v%%.
   */
  static uint152(v2) {
    return n(v2, 152);
  }
  /**
   *  Return a new ``uint160`` type for %%v%%.
   */
  static uint160(v2) {
    return n(v2, 160);
  }
  /**
   *  Return a new ``uint168`` type for %%v%%.
   */
  static uint168(v2) {
    return n(v2, 168);
  }
  /**
   *  Return a new ``uint176`` type for %%v%%.
   */
  static uint176(v2) {
    return n(v2, 176);
  }
  /**
   *  Return a new ``uint184`` type for %%v%%.
   */
  static uint184(v2) {
    return n(v2, 184);
  }
  /**
   *  Return a new ``uint192`` type for %%v%%.
   */
  static uint192(v2) {
    return n(v2, 192);
  }
  /**
   *  Return a new ``uint200`` type for %%v%%.
   */
  static uint200(v2) {
    return n(v2, 200);
  }
  /**
   *  Return a new ``uint208`` type for %%v%%.
   */
  static uint208(v2) {
    return n(v2, 208);
  }
  /**
   *  Return a new ``uint216`` type for %%v%%.
   */
  static uint216(v2) {
    return n(v2, 216);
  }
  /**
   *  Return a new ``uint224`` type for %%v%%.
   */
  static uint224(v2) {
    return n(v2, 224);
  }
  /**
   *  Return a new ``uint232`` type for %%v%%.
   */
  static uint232(v2) {
    return n(v2, 232);
  }
  /**
   *  Return a new ``uint240`` type for %%v%%.
   */
  static uint240(v2) {
    return n(v2, 240);
  }
  /**
   *  Return a new ``uint248`` type for %%v%%.
   */
  static uint248(v2) {
    return n(v2, 248);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint256(v2) {
    return n(v2, 256);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint(v2) {
    return n(v2, 256);
  }
  /**
   *  Return a new ``int8`` type for %%v%%.
   */
  static int8(v2) {
    return n(v2, -8);
  }
  /**
   *  Return a new ``int16`` type for %%v%%.
   */
  static int16(v2) {
    return n(v2, -16);
  }
  /**
   *  Return a new ``int24`` type for %%v%%.
   */
  static int24(v2) {
    return n(v2, -24);
  }
  /**
   *  Return a new ``int32`` type for %%v%%.
   */
  static int32(v2) {
    return n(v2, -32);
  }
  /**
   *  Return a new ``int40`` type for %%v%%.
   */
  static int40(v2) {
    return n(v2, -40);
  }
  /**
   *  Return a new ``int48`` type for %%v%%.
   */
  static int48(v2) {
    return n(v2, -48);
  }
  /**
   *  Return a new ``int56`` type for %%v%%.
   */
  static int56(v2) {
    return n(v2, -56);
  }
  /**
   *  Return a new ``int64`` type for %%v%%.
   */
  static int64(v2) {
    return n(v2, -64);
  }
  /**
   *  Return a new ``int72`` type for %%v%%.
   */
  static int72(v2) {
    return n(v2, -72);
  }
  /**
   *  Return a new ``int80`` type for %%v%%.
   */
  static int80(v2) {
    return n(v2, -80);
  }
  /**
   *  Return a new ``int88`` type for %%v%%.
   */
  static int88(v2) {
    return n(v2, -88);
  }
  /**
   *  Return a new ``int96`` type for %%v%%.
   */
  static int96(v2) {
    return n(v2, -96);
  }
  /**
   *  Return a new ``int104`` type for %%v%%.
   */
  static int104(v2) {
    return n(v2, -104);
  }
  /**
   *  Return a new ``int112`` type for %%v%%.
   */
  static int112(v2) {
    return n(v2, -112);
  }
  /**
   *  Return a new ``int120`` type for %%v%%.
   */
  static int120(v2) {
    return n(v2, -120);
  }
  /**
   *  Return a new ``int128`` type for %%v%%.
   */
  static int128(v2) {
    return n(v2, -128);
  }
  /**
   *  Return a new ``int136`` type for %%v%%.
   */
  static int136(v2) {
    return n(v2, -136);
  }
  /**
   *  Return a new ``int144`` type for %%v%%.
   */
  static int144(v2) {
    return n(v2, -144);
  }
  /**
   *  Return a new ``int52`` type for %%v%%.
   */
  static int152(v2) {
    return n(v2, -152);
  }
  /**
   *  Return a new ``int160`` type for %%v%%.
   */
  static int160(v2) {
    return n(v2, -160);
  }
  /**
   *  Return a new ``int168`` type for %%v%%.
   */
  static int168(v2) {
    return n(v2, -168);
  }
  /**
   *  Return a new ``int176`` type for %%v%%.
   */
  static int176(v2) {
    return n(v2, -176);
  }
  /**
   *  Return a new ``int184`` type for %%v%%.
   */
  static int184(v2) {
    return n(v2, -184);
  }
  /**
   *  Return a new ``int92`` type for %%v%%.
   */
  static int192(v2) {
    return n(v2, -192);
  }
  /**
   *  Return a new ``int200`` type for %%v%%.
   */
  static int200(v2) {
    return n(v2, -200);
  }
  /**
   *  Return a new ``int208`` type for %%v%%.
   */
  static int208(v2) {
    return n(v2, -208);
  }
  /**
   *  Return a new ``int216`` type for %%v%%.
   */
  static int216(v2) {
    return n(v2, -216);
  }
  /**
   *  Return a new ``int224`` type for %%v%%.
   */
  static int224(v2) {
    return n(v2, -224);
  }
  /**
   *  Return a new ``int232`` type for %%v%%.
   */
  static int232(v2) {
    return n(v2, -232);
  }
  /**
   *  Return a new ``int240`` type for %%v%%.
   */
  static int240(v2) {
    return n(v2, -240);
  }
  /**
   *  Return a new ``int248`` type for %%v%%.
   */
  static int248(v2) {
    return n(v2, -248);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int256(v2) {
    return n(v2, -256);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int(v2) {
    return n(v2, -256);
  }
  /**
   *  Return a new ``bytes1`` type for %%v%%.
   */
  static bytes1(v2) {
    return b$1(v2, 1);
  }
  /**
   *  Return a new ``bytes2`` type for %%v%%.
   */
  static bytes2(v2) {
    return b$1(v2, 2);
  }
  /**
   *  Return a new ``bytes3`` type for %%v%%.
   */
  static bytes3(v2) {
    return b$1(v2, 3);
  }
  /**
   *  Return a new ``bytes4`` type for %%v%%.
   */
  static bytes4(v2) {
    return b$1(v2, 4);
  }
  /**
   *  Return a new ``bytes5`` type for %%v%%.
   */
  static bytes5(v2) {
    return b$1(v2, 5);
  }
  /**
   *  Return a new ``bytes6`` type for %%v%%.
   */
  static bytes6(v2) {
    return b$1(v2, 6);
  }
  /**
   *  Return a new ``bytes7`` type for %%v%%.
   */
  static bytes7(v2) {
    return b$1(v2, 7);
  }
  /**
   *  Return a new ``bytes8`` type for %%v%%.
   */
  static bytes8(v2) {
    return b$1(v2, 8);
  }
  /**
   *  Return a new ``bytes9`` type for %%v%%.
   */
  static bytes9(v2) {
    return b$1(v2, 9);
  }
  /**
   *  Return a new ``bytes10`` type for %%v%%.
   */
  static bytes10(v2) {
    return b$1(v2, 10);
  }
  /**
   *  Return a new ``bytes11`` type for %%v%%.
   */
  static bytes11(v2) {
    return b$1(v2, 11);
  }
  /**
   *  Return a new ``bytes12`` type for %%v%%.
   */
  static bytes12(v2) {
    return b$1(v2, 12);
  }
  /**
   *  Return a new ``bytes13`` type for %%v%%.
   */
  static bytes13(v2) {
    return b$1(v2, 13);
  }
  /**
   *  Return a new ``bytes14`` type for %%v%%.
   */
  static bytes14(v2) {
    return b$1(v2, 14);
  }
  /**
   *  Return a new ``bytes15`` type for %%v%%.
   */
  static bytes15(v2) {
    return b$1(v2, 15);
  }
  /**
   *  Return a new ``bytes16`` type for %%v%%.
   */
  static bytes16(v2) {
    return b$1(v2, 16);
  }
  /**
   *  Return a new ``bytes17`` type for %%v%%.
   */
  static bytes17(v2) {
    return b$1(v2, 17);
  }
  /**
   *  Return a new ``bytes18`` type for %%v%%.
   */
  static bytes18(v2) {
    return b$1(v2, 18);
  }
  /**
   *  Return a new ``bytes19`` type for %%v%%.
   */
  static bytes19(v2) {
    return b$1(v2, 19);
  }
  /**
   *  Return a new ``bytes20`` type for %%v%%.
   */
  static bytes20(v2) {
    return b$1(v2, 20);
  }
  /**
   *  Return a new ``bytes21`` type for %%v%%.
   */
  static bytes21(v2) {
    return b$1(v2, 21);
  }
  /**
   *  Return a new ``bytes22`` type for %%v%%.
   */
  static bytes22(v2) {
    return b$1(v2, 22);
  }
  /**
   *  Return a new ``bytes23`` type for %%v%%.
   */
  static bytes23(v2) {
    return b$1(v2, 23);
  }
  /**
   *  Return a new ``bytes24`` type for %%v%%.
   */
  static bytes24(v2) {
    return b$1(v2, 24);
  }
  /**
   *  Return a new ``bytes25`` type for %%v%%.
   */
  static bytes25(v2) {
    return b$1(v2, 25);
  }
  /**
   *  Return a new ``bytes26`` type for %%v%%.
   */
  static bytes26(v2) {
    return b$1(v2, 26);
  }
  /**
   *  Return a new ``bytes27`` type for %%v%%.
   */
  static bytes27(v2) {
    return b$1(v2, 27);
  }
  /**
   *  Return a new ``bytes28`` type for %%v%%.
   */
  static bytes28(v2) {
    return b$1(v2, 28);
  }
  /**
   *  Return a new ``bytes29`` type for %%v%%.
   */
  static bytes29(v2) {
    return b$1(v2, 29);
  }
  /**
   *  Return a new ``bytes30`` type for %%v%%.
   */
  static bytes30(v2) {
    return b$1(v2, 30);
  }
  /**
   *  Return a new ``bytes31`` type for %%v%%.
   */
  static bytes31(v2) {
    return b$1(v2, 31);
  }
  /**
   *  Return a new ``bytes32`` type for %%v%%.
   */
  static bytes32(v2) {
    return b$1(v2, 32);
  }
  /**
   *  Return a new ``address`` type for %%v%%.
   */
  static address(v2) {
    return new _Typed(_gaurd, "address", v2);
  }
  /**
   *  Return a new ``bool`` type for %%v%%.
   */
  static bool(v2) {
    return new _Typed(_gaurd, "bool", !!v2);
  }
  /**
   *  Return a new ``bytes`` type for %%v%%.
   */
  static bytes(v2) {
    return new _Typed(_gaurd, "bytes", v2);
  }
  /**
   *  Return a new ``string`` type for %%v%%.
   */
  static string(v2) {
    return new _Typed(_gaurd, "string", v2);
  }
  /**
   *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
   */
  static array(v2, dynamic) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
   */
  static tuple(v2, name) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static overrides(v2) {
    return new _Typed(_gaurd, "overrides", Object.assign({}, v2));
  }
  /**
   *  Returns true only if %%value%% is a [[Typed]] instance.
   */
  static isTyped(value) {
    return value && typeof value === "object" && "_typedSymbol" in value && value._typedSymbol === _typedSymbol;
  }
  /**
   *  If the value is a [[Typed]] instance, validates the underlying value
   *  and returns it, otherwise returns value directly.
   *
   *  This is useful for functions that with to accept either a [[Typed]]
   *  object or values.
   */
  static dereference(value, type2) {
    if (_Typed.isTyped(value)) {
      if (value.type !== type2) {
        throw new Error(`invalid type: expecetd ${type2}, got ${value.type}`);
      }
      return value.value;
    }
    return value;
  }
};
_options = new WeakMap();
let Typed = _Typed;
class AddressCoder extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, _value2) {
    let value = Typed.dereference(_value2, "string");
    try {
      value = getAddress(value);
    } catch (error) {
      return this._throwError(error.message, _value2);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    return getAddress(toBeHex(reader.readValue(), 20));
  }
}
class AnonymousCoder extends Coder {
  constructor(coder) {
    super(coder.name, coder.type, "_", coder.dynamic);
    __publicField(this, "coder");
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
}
function pack(writer, coders, values) {
  let arrayValues = [];
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name = coder.localName;
      assert(name, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      assert(!unique[name], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      unique[name] = true;
      return values[name];
    });
  } else {
    assertArgument(false, "invalid tuple value", "tuple", values);
  }
  assertArgument(coders.length === arrayValues.length, "types/value length mismatch", "tuple", values);
  let staticWriter = new Writer();
  let dynamicWriter = new Writer();
  let updateFuncs = [];
  coders.forEach((coder, index2) => {
    let value = arrayValues[index2];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = [];
  let keys2 = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readIndex();
      let offsetReader = baseReader.subReader(offset);
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (isError(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (isError(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value == void 0) {
      throw new Error("investigate");
    }
    values.push(value);
    keys2.push(coder.localName || null);
  });
  return Result.fromItems(values, keys2);
}
class ArrayCoder extends Coder {
  constructor(coder, length, localName) {
    const type2 = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic = length === -1 || coder.dynamic;
    super("array", type2, localName, dynamic);
    __publicField(this, "coder");
    __publicField(this, "length");
    defineProperties(this, { coder, length });
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i4 = 0; i4 < this.length; i4++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, _value2) {
    const value = Typed.dereference(_value2, "array");
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count = this.length;
    if (count === -1) {
      count = value.length;
      writer.writeValue(value.length);
    }
    assertArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i4 = 0; i4 < value.length; i4++) {
      coders.push(this.coder);
    }
    return pack(writer, coders, value);
  }
  decode(reader) {
    let count = this.length;
    if (count === -1) {
      count = reader.readIndex();
      assert(count * WordSize <= reader.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: reader.bytes, offset: count * WordSize, length: reader.dataLength });
    }
    let coders = [];
    for (let i4 = 0; i4 < count; i4++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return unpack(reader, coders);
  }
}
class BooleanCoder extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, _value2) {
    const value = Typed.dereference(_value2, "bool");
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader) {
    return !!reader.readValue();
  }
}
class DynamicBytesCoder extends Coder {
  constructor(type2, localName) {
    super(type2, type2, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = getBytesCopy(value);
    let length = writer.writeValue(value.length);
    length += writer.writeBytes(value);
    return length;
  }
  decode(reader) {
    return reader.readBytes(reader.readIndex(), true);
  }
}
class BytesCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return hexlify(super.decode(reader));
  }
}
class FixedBytesCoder extends Coder {
  constructor(size2, localName) {
    let name = "bytes" + String(size2);
    super(name, name, localName, false);
    __publicField(this, "size");
    defineProperties(this, { size: size2 }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, _value2) {
    let data2 = getBytesCopy(Typed.dereference(_value2, this.type));
    if (data2.length !== this.size) {
      this._throwError("incorrect data length", _value2);
    }
    return writer.writeBytes(data2);
  }
  decode(reader) {
    return hexlify(reader.readBytes(this.size));
  }
}
const Empty = new Uint8Array([]);
class NullCoder extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes(Empty);
  }
  decode(reader) {
    reader.readBytes(0);
    return null;
  }
}
const BN_0$5 = BigInt(0);
const BN_1$1 = BigInt(1);
const BN_MAX_UINT256$1 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
class NumberCoder extends Coder {
  constructor(size2, signed2, localName) {
    const name = (signed2 ? "int" : "uint") + size2 * 8;
    super(name, name, localName, false);
    __publicField(this, "size");
    __publicField(this, "signed");
    defineProperties(this, { size: size2, signed: signed2 }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(writer, _value2) {
    let value = getBigInt(Typed.dereference(_value2, this.type));
    let maxUintValue = mask(BN_MAX_UINT256$1, WordSize * 8);
    if (this.signed) {
      let bounds = mask(maxUintValue, this.size * 8 - 1);
      if (value > bounds || value < -(bounds + BN_1$1)) {
        this._throwError("value out-of-bounds", _value2);
      }
      value = toTwos(value, 8 * WordSize);
    } else if (value < BN_0$5 || value > mask(maxUintValue, this.size * 8)) {
      this._throwError("value out-of-bounds", _value2);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    let value = mask(reader.readValue(), this.size * 8);
    if (this.signed) {
      value = fromTwos(value, this.size * 8);
    }
    return value;
  }
}
class StringCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, _value2) {
    return super.encode(writer, toUtf8Bytes(Typed.dereference(_value2, "string")));
  }
  decode(reader) {
    return toUtf8String(super.decode(reader));
  }
}
class TupleCoder extends Coder {
  constructor(coders, localName) {
    let dynamic = false;
    const types2 = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types2.push(coder.type);
    });
    const type2 = "tuple(" + types2.join(",") + ")";
    super("tuple", type2, localName, dynamic);
    __publicField(this, "coders");
    defineProperties(this, { coders: Object.freeze(coders.slice()) });
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name = coder.localName;
      if (name) {
        if (!accum[name]) {
          accum[name] = 0;
        }
        accum[name]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index2) => {
      let name = coder.localName;
      if (!name || uniqueNames[name] !== 1) {
        return;
      }
      if (name === "length") {
        name = "_length";
      }
      if (values[name] != null) {
        return;
      }
      values[name] = values[index2];
    });
    return Object.freeze(values);
  }
  encode(writer, _value2) {
    const value = Typed.dereference(_value2, "tuple");
    return pack(writer, this.coders, value);
  }
  decode(reader) {
    return unpack(reader, this.coders);
  }
}
function id(value) {
  return keccak256$1(toUtf8Bytes(value));
}
var COMPRESSED$1 = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
const FENCED = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
const NSM_MAX = 4;
function decode_arithmetic(bytes2) {
  let pos = 0;
  function u16() {
    return bytes2[pos++] << 8 | bytes2[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i4 = 1; i4 < symbol_count; i4++) {
    acc.push(total += u16());
  }
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes2[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N3 = 31;
  const FULL = 2 ** N3;
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i4 = 0; i4 < N3; i4++) register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range2 = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range2);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0) break;
    symbols.push(start);
    let a2 = low + Math.floor(range2 * acc[start] / total);
    let b2 = low + Math.floor(range2 * acc[start + 1] / total) - 1;
    while (((a2 ^ b2) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a2 = a2 << 1 & MASK;
      b2 = b2 << 1 & MASK | 1;
    }
    while (a2 & ~b2 & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a2 = a2 << 1 ^ HALF;
      b2 = (b2 ^ HALF) << 1 | HALF | 1;
    }
    low = a2;
    range2 = 1 + b2 - a2;
  }
  let offset = symbol_count - 4;
  return symbols.map((x2) => {
    switch (x2 - offset) {
      case 3:
        return offset + 65792 + (bytes2[pos_payload++] << 16 | bytes2[pos_payload++] << 8 | bytes2[pos_payload++]);
      case 2:
        return offset + 256 + (bytes2[pos_payload++] << 8 | bytes2[pos_payload++]);
      case 1:
        return offset + bytes2[pos_payload++];
      default:
        return x2 - 1;
    }
  });
}
function read_payload(v2) {
  let pos = 0;
  return () => v2[pos++];
}
function read_compressed_payload(s2) {
  return read_payload(decode_arithmetic(unsafe_atob(s2)));
}
function unsafe_atob(s2) {
  let lookup2 = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((c2, i4) => lookup2[c2.charCodeAt(0)] = i4);
  let n5 = s2.length;
  let ret = new Uint8Array(6 * n5 >> 3);
  for (let i4 = 0, pos = 0, width = 0, carry = 0; i4 < n5; i4++) {
    carry = carry << 6 | lookup2[s2.charCodeAt(i4)];
    width += 6;
    if (width >= 8) {
      ret[pos++] = carry >> (width -= 8);
    }
  }
  return ret;
}
function signed(i4) {
  return i4 & 1 ? ~i4 >> 1 : i4 >> 1;
}
function read_deltas(n5, next) {
  let v2 = Array(n5);
  for (let i4 = 0, x2 = 0; i4 < n5; i4++) v2[i4] = x2 += signed(next());
  return v2;
}
function read_sorted(next, prev = 0) {
  let ret = [];
  while (true) {
    let x2 = next();
    let n5 = next();
    if (!n5) break;
    prev += x2;
    for (let i4 = 0; i4 < n5; i4++) {
      ret.push(prev + i4);
    }
    prev += n5 + 1;
  }
  return ret;
}
function read_sorted_arrays(next) {
  return read_array_while(() => {
    let v2 = read_sorted(next);
    if (v2.length) return v2;
  });
}
function read_mapped(next) {
  let ret = [];
  while (true) {
    let w2 = next();
    if (w2 == 0) break;
    ret.push(read_linear_table(w2, next));
  }
  while (true) {
    let w2 = next() - 1;
    if (w2 < 0) break;
    ret.push(read_replacement_table(w2, next));
  }
  return ret.flat();
}
function read_array_while(next) {
  let v2 = [];
  while (true) {
    let x2 = next(v2.length);
    if (!x2) break;
    v2.push(x2);
  }
  return v2;
}
function read_transposed(n5, w2, next) {
  let m4 = Array(n5).fill().map(() => []);
  for (let i4 = 0; i4 < w2; i4++) {
    read_deltas(n5, next).forEach((x2, j2) => m4[j2].push(x2));
  }
  return m4;
}
function read_linear_table(w2, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_array_while(next);
  let m4 = read_transposed(vN.length, 1 + w2, next);
  return m4.flatMap((v2, i4) => {
    let [x2, ...ys2] = v2;
    return Array(vN[i4]).fill().map((_3, j2) => {
      let j_dy = j2 * dy;
      return [x2 + j2 * dx, ys2.map((y4) => y4 + j_dy)];
    });
  });
}
function read_replacement_table(w2, next) {
  let n5 = 1 + next();
  let m4 = read_transposed(n5, 1 + w2, next);
  return m4.map((v2) => [v2[0], v2.slice(1)]);
}
function read_trie(next) {
  let ret = [];
  let sorted = read_sorted(next);
  expand(decode2([]), []);
  return ret;
  function decode2(Q2) {
    let S4 = next();
    let B3 = read_array_while(() => {
      let cps = read_sorted(next).map((i4) => sorted[i4]);
      if (cps.length) return decode2(cps);
    });
    return { S: S4, B: B3, Q: Q2 };
  }
  function expand({ S: S4, B: B3 }, cps, saved) {
    if (S4 & 4 && saved === cps[cps.length - 1]) return;
    if (S4 & 2) saved = cps[cps.length - 1];
    if (S4 & 1) ret.push(cps);
    for (let br2 of B3) {
      for (let cp of br2.Q) {
        expand(br2, [...cps, cp], saved);
      }
    }
  }
}
function hex_cp(cp) {
  return cp.toString(16).toUpperCase().padStart(2, "0");
}
function quote_cp(cp) {
  return `{${hex_cp(cp)}}`;
}
function explode_cp(s2) {
  let cps = [];
  for (let pos = 0, len2 = s2.length; pos < len2; ) {
    let cp = s2.codePointAt(pos);
    pos += cp < 65536 ? 1 : 2;
    cps.push(cp);
  }
  return cps;
}
function str_from_cps(cps) {
  const chunk = 4096;
  let len2 = cps.length;
  if (len2 < chunk) return String.fromCodePoint(...cps);
  let buf = [];
  for (let i4 = 0; i4 < len2; ) {
    buf.push(String.fromCodePoint(...cps.slice(i4, i4 += chunk)));
  }
  return buf.join("");
}
function compare_arrays(a2, b2) {
  let n5 = a2.length;
  let c2 = n5 - b2.length;
  for (let i4 = 0; c2 == 0 && i4 < n5; i4++) c2 = a2[i4] - b2[i4];
  return c2;
}
var COMPRESSED = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
const S0 = 44032;
const L0 = 4352;
const V0 = 4449;
const T0 = 4519;
const L_COUNT = 19;
const V_COUNT = 21;
const T_COUNT = 28;
const N_COUNT = V_COUNT * T_COUNT;
const S_COUNT = L_COUNT * N_COUNT;
const S1 = S0 + S_COUNT;
const L1 = L0 + L_COUNT;
const V1 = V0 + V_COUNT;
const T1 = T0 + T_COUNT;
function unpack_cc(packed) {
  return packed >> 24 & 255;
}
function unpack_cp(packed) {
  return packed & 16777215;
}
let SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP;
function init$1() {
  let r3 = read_compressed_payload(COMPRESSED);
  SHIFTED_RANK = new Map(read_sorted_arrays(r3).flatMap((v2, i4) => v2.map((x2) => [x2, i4 + 1 << 24])));
  EXCLUSIONS = new Set(read_sorted(r3));
  DECOMP = /* @__PURE__ */ new Map();
  RECOMP = /* @__PURE__ */ new Map();
  for (let [cp, cps] of read_mapped(r3)) {
    if (!EXCLUSIONS.has(cp) && cps.length == 2) {
      let [a2, b2] = cps;
      let bucket = RECOMP.get(a2);
      if (!bucket) {
        bucket = /* @__PURE__ */ new Map();
        RECOMP.set(a2, bucket);
      }
      bucket.set(b2, cp);
    }
    DECOMP.set(cp, cps.reverse());
  }
}
function is_hangul(cp) {
  return cp >= S0 && cp < S1;
}
function compose_pair(a2, b2) {
  if (a2 >= L0 && a2 < L1 && b2 >= V0 && b2 < V1) {
    return S0 + (a2 - L0) * N_COUNT + (b2 - V0) * T_COUNT;
  } else if (is_hangul(a2) && b2 > T0 && b2 < T1 && (a2 - S0) % T_COUNT == 0) {
    return a2 + (b2 - T0);
  } else {
    let recomp = RECOMP.get(a2);
    if (recomp) {
      recomp = recomp.get(b2);
      if (recomp) {
        return recomp;
      }
    }
    return -1;
  }
}
function decomposed(cps) {
  if (!SHIFTED_RANK) init$1();
  let ret = [];
  let buf = [];
  let check_order = false;
  function add6(cp) {
    let cc2 = SHIFTED_RANK.get(cp);
    if (cc2) {
      check_order = true;
      cp |= cc2;
    }
    ret.push(cp);
  }
  for (let cp of cps) {
    while (true) {
      if (cp < 128) {
        ret.push(cp);
      } else if (is_hangul(cp)) {
        let s_index = cp - S0;
        let l_index = s_index / N_COUNT | 0;
        let v_index = s_index % N_COUNT / T_COUNT | 0;
        let t_index = s_index % T_COUNT;
        add6(L0 + l_index);
        add6(V0 + v_index);
        if (t_index > 0) add6(T0 + t_index);
      } else {
        let mapped = DECOMP.get(cp);
        if (mapped) {
          buf.push(...mapped);
        } else {
          add6(cp);
        }
      }
      if (!buf.length) break;
      cp = buf.pop();
    }
  }
  if (check_order && ret.length > 1) {
    let prev_cc = unpack_cc(ret[0]);
    for (let i4 = 1; i4 < ret.length; i4++) {
      let cc2 = unpack_cc(ret[i4]);
      if (cc2 == 0 || prev_cc <= cc2) {
        prev_cc = cc2;
        continue;
      }
      let j2 = i4 - 1;
      while (true) {
        let tmp = ret[j2 + 1];
        ret[j2 + 1] = ret[j2];
        ret[j2] = tmp;
        if (!j2) break;
        prev_cc = unpack_cc(ret[--j2]);
        if (prev_cc <= cc2) break;
      }
      prev_cc = unpack_cc(ret[i4]);
    }
  }
  return ret;
}
function composed_from_decomposed(v2) {
  let ret = [];
  let stack = [];
  let prev_cp = -1;
  let prev_cc = 0;
  for (let packed of v2) {
    let cc2 = unpack_cc(packed);
    let cp = unpack_cp(packed);
    if (prev_cp == -1) {
      if (cc2 == 0) {
        prev_cp = cp;
      } else {
        ret.push(cp);
      }
    } else if (prev_cc > 0 && prev_cc >= cc2) {
      if (cc2 == 0) {
        ret.push(prev_cp, ...stack);
        stack.length = 0;
        prev_cp = cp;
      } else {
        stack.push(cp);
      }
      prev_cc = cc2;
    } else {
      let composed = compose_pair(prev_cp, cp);
      if (composed >= 0) {
        prev_cp = composed;
      } else if (prev_cc == 0 && cc2 == 0) {
        ret.push(prev_cp);
        prev_cp = cp;
      } else {
        stack.push(cp);
        prev_cc = cc2;
      }
    }
  }
  if (prev_cp >= 0) {
    ret.push(prev_cp, ...stack);
  }
  return ret;
}
function nfd(cps) {
  return decomposed(cps).map(unpack_cp);
}
function nfc(cps) {
  return composed_from_decomposed(decomposed(cps));
}
const HYPHEN = 45;
const STOP_CH = ".";
const FE0F = 65039;
const UNIQUE_PH = 1;
const Array_from = (x2) => Array.from(x2);
function group_has_cp(g2, cp) {
  return g2.P.has(cp) || g2.Q.has(cp);
}
class Emoji extends Array {
  get is_emoji() {
    return true;
  }
  // free tagging system
}
let MAPPED, IGNORED, CM, NSM, ESCAPE, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;
function init() {
  if (MAPPED) return;
  let r3 = read_compressed_payload(COMPRESSED$1);
  const read_sorted_array = () => read_sorted(r3);
  const read_sorted_set = () => new Set(read_sorted_array());
  const set_add_many = (set2, v2) => v2.forEach((x2) => set2.add(x2));
  MAPPED = new Map(read_mapped(r3));
  IGNORED = read_sorted_set();
  CM = read_sorted_array();
  NSM = new Set(read_sorted_array().map((i4) => CM[i4]));
  CM = new Set(CM);
  ESCAPE = read_sorted_set();
  read_sorted_set();
  let chunks = read_sorted_arrays(r3);
  let unrestricted = r3();
  const read_chunked = () => {
    let set2 = /* @__PURE__ */ new Set();
    read_sorted_array().forEach((i4) => set_add_many(set2, chunks[i4]));
    set_add_many(set2, read_sorted_array());
    return set2;
  };
  GROUPS = read_array_while((i4) => {
    let N3 = read_array_while(r3).map((x2) => x2 + 96);
    if (N3.length) {
      let R5 = i4 >= unrestricted;
      N3[0] -= 32;
      N3 = str_from_cps(N3);
      if (R5) N3 = `Restricted[${N3}]`;
      let P3 = read_chunked();
      let Q2 = read_chunked();
      let M4 = !r3();
      return { N: N3, P: P3, Q: Q2, M: M4, R: R5 };
    }
  });
  WHOLE_VALID = read_sorted_set();
  WHOLE_MAP = /* @__PURE__ */ new Map();
  let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a2, b2) => a2 - b2);
  wholes.forEach((cp, i4) => {
    let d4 = r3();
    let w2 = wholes[i4] = d4 ? wholes[i4 - d4] : { V: [], M: /* @__PURE__ */ new Map() };
    w2.V.push(cp);
    if (!WHOLE_VALID.has(cp)) {
      WHOLE_MAP.set(cp, w2);
    }
  });
  for (let { V: V3, M: M4 } of new Set(WHOLE_MAP.values())) {
    let recs = [];
    for (let cp of V3) {
      let gs2 = GROUPS.filter((g2) => group_has_cp(g2, cp));
      let rec = recs.find(({ G: G2 }) => gs2.some((g2) => G2.has(g2)));
      if (!rec) {
        rec = { G: /* @__PURE__ */ new Set(), V: [] };
        recs.push(rec);
      }
      rec.V.push(cp);
      set_add_many(rec.G, gs2);
    }
    let union = recs.flatMap((x2) => Array_from(x2.G));
    for (let { G: G2, V: V4 } of recs) {
      let complement = new Set(union.filter((g2) => !G2.has(g2)));
      for (let cp of V4) {
        M4.set(cp, complement);
      }
    }
  }
  VALID = /* @__PURE__ */ new Set();
  let multi = /* @__PURE__ */ new Set();
  const add_to_union = (cp) => VALID.has(cp) ? multi.add(cp) : VALID.add(cp);
  for (let g2 of GROUPS) {
    for (let cp of g2.P) add_to_union(cp);
    for (let cp of g2.Q) add_to_union(cp);
  }
  for (let cp of VALID) {
    if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
      WHOLE_MAP.set(cp, UNIQUE_PH);
    }
  }
  set_add_many(VALID, nfd(VALID));
  EMOJI_LIST = read_trie(r3).map((v2) => Emoji.from(v2)).sort(compare_arrays);
  EMOJI_ROOT = /* @__PURE__ */ new Map();
  for (let cps of EMOJI_LIST) {
    let prev = [EMOJI_ROOT];
    for (let cp of cps) {
      let next = prev.map((node2) => {
        let child = node2.get(cp);
        if (!child) {
          child = /* @__PURE__ */ new Map();
          node2.set(cp, child);
        }
        return child;
      });
      if (cp === FE0F) {
        prev.push(...next);
      } else {
        prev = next;
      }
    }
    for (let x2 of prev) {
      x2.V = cps;
    }
  }
}
function quoted_cp(cp) {
  return (should_escape(cp) ? "" : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);
}
function bidi_qq(s2) {
  return `"${s2}"`;
}
function check_label_extension(cps) {
  if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
    throw new Error(`invalid label extension: "${str_from_cps(cps.slice(0, 4))}"`);
  }
}
function check_leading_underscore(cps) {
  const UNDERSCORE = 95;
  for (let i4 = cps.lastIndexOf(UNDERSCORE); i4 > 0; ) {
    if (cps[--i4] !== UNDERSCORE) {
      throw new Error("underscore allowed only at start");
    }
  }
}
function check_fenced(cps) {
  let cp = cps[0];
  let prev = FENCED.get(cp);
  if (prev) throw error_placement(`leading ${prev}`);
  let n5 = cps.length;
  let last = -1;
  for (let i4 = 1; i4 < n5; i4++) {
    cp = cps[i4];
    let match = FENCED.get(cp);
    if (match) {
      if (last == i4) throw error_placement(`${prev} + ${match}`);
      last = i4 + 1;
      prev = match;
    }
  }
  if (last == n5) throw error_placement(`trailing ${prev}`);
}
function safe_str_from_cps(cps, max2 = Infinity, quoter = quote_cp) {
  let buf = [];
  if (is_combining_mark(cps[0])) buf.push("");
  if (cps.length > max2) {
    max2 >>= 1;
    cps = [...cps.slice(0, max2), 8230, ...cps.slice(-max2)];
  }
  let prev = 0;
  let n5 = cps.length;
  for (let i4 = 0; i4 < n5; i4++) {
    let cp = cps[i4];
    if (should_escape(cp)) {
      buf.push(str_from_cps(cps.slice(prev, i4)));
      buf.push(quoter(cp));
      prev = i4 + 1;
    }
  }
  buf.push(str_from_cps(cps.slice(prev, n5)));
  return buf.join("");
}
function is_combining_mark(cp) {
  init();
  return CM.has(cp);
}
function should_escape(cp) {
  init();
  return ESCAPE.has(cp);
}
function ens_normalize(name) {
  return flatten(split(name, nfc, filter_fe0f));
}
function split(name, nf, ef) {
  if (!name) return [];
  init();
  let offset = 0;
  return name.split(STOP_CH).map((label) => {
    let input = explode_cp(label);
    let info = {
      input,
      offset
      // codepoint, not substring!
    };
    offset += input.length + 1;
    try {
      let tokens = info.tokens = tokens_from_str(input, nf, ef);
      let token_count = tokens.length;
      let type2;
      if (!token_count) {
        throw new Error(`empty label`);
      }
      let norm = info.output = tokens.flat();
      check_leading_underscore(norm);
      let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji;
      if (!emoji && norm.every((cp) => cp < 128)) {
        check_label_extension(norm);
        type2 = "ASCII";
      } else {
        let chars = tokens.flatMap((x2) => x2.is_emoji ? [] : x2);
        if (!chars.length) {
          type2 = "Emoji";
        } else {
          if (CM.has(norm[0])) throw error_placement("leading combining mark");
          for (let i4 = 1; i4 < token_count; i4++) {
            let cps = tokens[i4];
            if (!cps.is_emoji && CM.has(cps[0])) {
              throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i4 - 1])} + ${safe_str_from_cps([cps[0]])}"`);
            }
          }
          check_fenced(norm);
          let unique = Array_from(new Set(chars));
          let [g2] = determine_group(unique);
          check_group(g2, chars);
          check_whole(g2, unique);
          type2 = g2.N;
        }
      }
      info.type = type2;
    } catch (err) {
      info.error = err;
    }
    return info;
  });
}
function check_whole(group, unique) {
  let maker;
  let shared = [];
  for (let cp of unique) {
    let whole = WHOLE_MAP.get(cp);
    if (whole === UNIQUE_PH) return;
    if (whole) {
      let set2 = whole.M.get(cp);
      maker = maker ? maker.filter((g2) => set2.has(g2)) : Array_from(set2);
      if (!maker.length) return;
    } else {
      shared.push(cp);
    }
  }
  if (maker) {
    for (let g2 of maker) {
      if (shared.every((cp) => group_has_cp(g2, cp))) {
        throw new Error(`whole-script confusable: ${group.N}/${g2.N}`);
      }
    }
  }
}
function determine_group(unique) {
  let groups = GROUPS;
  for (let cp of unique) {
    let gs2 = groups.filter((g2) => group_has_cp(g2, cp));
    if (!gs2.length) {
      if (!GROUPS.some((g2) => group_has_cp(g2, cp))) {
        throw error_disallowed(cp);
      } else {
        throw error_group_member(groups[0], cp);
      }
    }
    groups = gs2;
    if (gs2.length == 1) break;
  }
  return groups;
}
function flatten(split2) {
  return split2.map(({ input, error, output: output2 }) => {
    if (error) {
      let msg = error.message;
      throw new Error(split2.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`);
    }
    return str_from_cps(output2);
  }).join(STOP_CH);
}
function error_disallowed(cp) {
  return new Error(`disallowed character: ${quoted_cp(cp)}`);
}
function error_group_member(g2, cp) {
  let quoted = quoted_cp(cp);
  let gg = GROUPS.find((g3) => g3.P.has(cp));
  if (gg) {
    quoted = `${gg.N} ${quoted}`;
  }
  return new Error(`illegal mixture: ${g2.N} + ${quoted}`);
}
function error_placement(where) {
  return new Error(`illegal placement: ${where}`);
}
function check_group(g2, cps) {
  for (let cp of cps) {
    if (!group_has_cp(g2, cp)) {
      throw error_group_member(g2, cp);
    }
  }
  if (g2.M) {
    let decomposed2 = nfd(cps);
    for (let i4 = 1, e3 = decomposed2.length; i4 < e3; i4++) {
      if (NSM.has(decomposed2[i4])) {
        let j2 = i4 + 1;
        for (let cp; j2 < e3 && NSM.has(cp = decomposed2[j2]); j2++) {
          for (let k3 = i4; k3 < j2; k3++) {
            if (decomposed2[k3] == cp) {
              throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);
            }
          }
        }
        if (j2 - i4 > NSM_MAX) {
          throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed2.slice(i4 - 1, j2)))} (${j2 - i4}/${NSM_MAX})`);
        }
        i4 = j2;
      }
    }
  }
}
function tokens_from_str(input, nf, ef) {
  let ret = [];
  let chars = [];
  input = input.slice().reverse();
  while (input.length) {
    let emoji = consume_emoji_reversed(input);
    if (emoji) {
      if (chars.length) {
        ret.push(nf(chars));
        chars = [];
      }
      ret.push(ef(emoji));
    } else {
      let cp = input.pop();
      if (VALID.has(cp)) {
        chars.push(cp);
      } else {
        let cps = MAPPED.get(cp);
        if (cps) {
          chars.push(...cps);
        } else if (!IGNORED.has(cp)) {
          throw error_disallowed(cp);
        }
      }
    }
  }
  if (chars.length) {
    ret.push(nf(chars));
  }
  return ret;
}
function filter_fe0f(cps) {
  return cps.filter((cp) => cp != FE0F);
}
function consume_emoji_reversed(cps, eaten) {
  let node2 = EMOJI_ROOT;
  let emoji;
  let pos = cps.length;
  while (pos) {
    node2 = node2.get(cps[--pos]);
    if (!node2) break;
    let { V: V3 } = node2;
    if (V3) {
      emoji = V3;
      cps.length = pos;
    }
  }
  return emoji;
}
const Zeros = new Uint8Array(32);
Zeros.fill(0);
function checkComponent(comp) {
  assertArgument(comp.length !== 0, "invalid ENS name; empty component", "comp", comp);
  return comp;
}
function ensNameSplit(name) {
  const bytes2 = toUtf8Bytes(ensNormalize(name));
  const comps = [];
  if (name.length === 0) {
    return comps;
  }
  let last = 0;
  for (let i4 = 0; i4 < bytes2.length; i4++) {
    const d4 = bytes2[i4];
    if (d4 === 46) {
      comps.push(checkComponent(bytes2.slice(last, i4)));
      last = i4 + 1;
    }
  }
  assertArgument(last < bytes2.length, "invalid ENS name; empty component", "name", name);
  comps.push(checkComponent(bytes2.slice(last)));
  return comps;
}
function ensNormalize(name) {
  try {
    if (name.length === 0) {
      throw new Error("empty label");
    }
    return ens_normalize(name);
  } catch (error) {
    assertArgument(false, `invalid ENS name (${error.message})`, "name", name);
  }
}
function namehash(name) {
  assertArgument(typeof name === "string", "invalid ENS name; not a string", "name", name);
  assertArgument(name.length, `invalid ENS name (empty label)`, "name", name);
  let result = Zeros;
  const comps = ensNameSplit(name);
  while (comps.length) {
    result = keccak256$1(concat([result, keccak256$1(comps.pop())]));
  }
  return hexlify(result);
}
function dnsEncode(name, _maxLength) {
  const length = _maxLength;
  assertArgument(length <= 255, "DNS encoded label cannot exceed 255", "length", length);
  return hexlify(concat(ensNameSplit(name).map((comp) => {
    assertArgument(comp.length <= length, `label ${JSON.stringify(name)} exceeds ${length} bytes`, "name", name);
    const bytes2 = new Uint8Array(comp.length + 1);
    bytes2.set(comp, 1);
    bytes2[0] = bytes2.length - 1;
    return bytes2;
  }))) + "00";
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: storageKeys.map((storageKey, index2) => {
      assertArgument(isHexString(storageKey, 32), "invalid slot", `storageKeys[${index2}]`, storageKey);
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set2, index2) => {
      if (Array.isArray(set2)) {
        assertArgument(set2.length === 2, "invalid slot set", `value[${index2}]`, set2);
        return accessSetify(set2[0], set2[1]);
      }
      assertArgument(set2 != null && typeof set2 === "object", "invalid address-slot set", "value", value);
      return accessSetify(set2.address, set2.storageKeys);
    });
  }
  assertArgument(value != null && typeof value === "object", "invalid access list", "value", value);
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a2, b2) => a2.address.localeCompare(b2.address));
  return result;
}
function computeAddress(key2) {
  let pubkey;
  if (typeof key2 === "string") {
    pubkey = SigningKey.computePublicKey(key2, false);
  } else {
    pubkey = key2.publicKey;
  }
  return getAddress(keccak256$1("0x" + pubkey.substring(4)).substring(26));
}
function recoverAddress$1(digest9, signature2) {
  return computeAddress(SigningKey.recoverPublicKey(digest9, signature2));
}
const BN_0$4 = BigInt(0);
const BN_2$1 = BigInt(2);
const BN_27 = BigInt(27);
const BN_28 = BigInt(28);
const BN_35 = BigInt(35);
const BN_MAX_UINT = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const BLOB_SIZE = 4096 * 32;
function getVersionedHash(version2, hash3) {
  let versioned = version2.toString(16);
  while (versioned.length < 2) {
    versioned = "0" + versioned;
  }
  versioned += sha256(hash3).substring(4);
  return "0x" + versioned;
}
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
}
function handleAccessList(value, param) {
  try {
    return accessListify(value);
  } catch (error) {
    assertArgument(false, error.message, param, value);
  }
}
function handleNumber(_value2, param) {
  if (_value2 === "0x") {
    return 0;
  }
  return getNumber(_value2, param);
}
function handleUint(_value2, param) {
  if (_value2 === "0x") {
    return BN_0$4;
  }
  const value = getBigInt(_value2, param);
  assertArgument(value <= BN_MAX_UINT, "value exceeds uint size", param, value);
  return value;
}
function formatNumber(_value2, name) {
  const value = getBigInt(_value2, "value");
  const result = toBeArray(value);
  assertArgument(result.length <= 32, `value too large`, `tx.${name}`, value);
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map((set2) => [set2.address, set2.storageKeys]);
}
function formatHashes(value, param) {
  assertArgument(Array.isArray(value), `invalid ${param}`, "value", value);
  for (let i4 = 0; i4 < value.length; i4++) {
    assertArgument(isHexString(value[i4], 32), "invalid ${ param } hash", `value[${i4}]`, value[i4]);
  }
  return value;
}
function _parseLegacy(data2) {
  const fields = decodeRlp(data2);
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), "invalid field count for legacy transaction", "data", data2);
  const tx = {
    type: 0,
    nonce: handleNumber(fields[0], "nonce"),
    gasPrice: handleUint(fields[1], "gasPrice"),
    gasLimit: handleUint(fields[2], "gasLimit"),
    to: handleAddress(fields[3]),
    value: handleUint(fields[4], "value"),
    data: hexlify(fields[5]),
    chainId: BN_0$4
  };
  if (fields.length === 6) {
    return tx;
  }
  const v2 = handleUint(fields[6], "v");
  const r3 = handleUint(fields[7], "r");
  const s2 = handleUint(fields[8], "s");
  if (r3 === BN_0$4 && s2 === BN_0$4) {
    tx.chainId = v2;
  } else {
    let chainId = (v2 - BN_35) / BN_2$1;
    if (chainId < BN_0$4) {
      chainId = BN_0$4;
    }
    tx.chainId = chainId;
    assertArgument(chainId !== BN_0$4 || (v2 === BN_27 || v2 === BN_28), "non-canonical legacy v", "v", fields[6]);
    tx.signature = Signature.from({
      r: zeroPadValue(fields[7], 32),
      s: zeroPadValue(fields[8], 32),
      v: v2
    });
  }
  return tx;
}
function _serializeLegacy(tx, sig) {
  const fields = [
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.gasPrice || 0, "gasPrice"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data
  ];
  let chainId = BN_0$4;
  if (tx.chainId != BN_0$4) {
    chainId = getBigInt(tx.chainId, "tx.chainId");
    assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, "tx.chainId/sig.v mismatch", "sig", sig);
  } else if (tx.signature) {
    const legacy2 = tx.signature.legacyChainId;
    if (legacy2 != null) {
      chainId = legacy2;
    }
  }
  if (!sig) {
    if (chainId !== BN_0$4) {
      fields.push(toBeArray(chainId));
      fields.push("0x");
      fields.push("0x");
    }
    return encodeRlp(fields);
  }
  let v2 = BigInt(27 + sig.yParity);
  if (chainId !== BN_0$4) {
    v2 = Signature.getChainIdV(chainId, sig.v);
  } else if (BigInt(sig.v) !== v2) {
    assertArgument(false, "tx.chainId/sig.v mismatch", "sig", sig);
  }
  fields.push(toBeArray(v2));
  fields.push(toBeArray(sig.r));
  fields.push(toBeArray(sig.s));
  return encodeRlp(fields);
}
function _parseEipSignature(tx, fields) {
  let yParity;
  try {
    yParity = handleNumber(fields[0], "yParity");
    if (yParity !== 0 && yParity !== 1) {
      throw new Error("bad yParity");
    }
  } catch (error) {
    assertArgument(false, "invalid yParity", "yParity", fields[0]);
  }
  const r3 = zeroPadValue(fields[1], 32);
  const s2 = zeroPadValue(fields[2], 32);
  const signature2 = Signature.from({ r: r3, s: s2, yParity });
  tx.signature = signature2;
}
function _parseEip1559(data2) {
  const fields = decodeRlp(getBytes(data2).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), "invalid field count for transaction type: 2", "data", hexlify(data2));
  const tx = {
    type: 2,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList")
  };
  if (fields.length === 9) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(9));
  return tx;
}
function _serializeEip1559(tx, sig) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat(["0x02", encodeRlp(fields)]);
}
function _parseEip2930(data2) {
  const fields = decodeRlp(getBytes(data2).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), "invalid field count for transaction type: 1", "data", hexlify(data2));
  const tx = {
    type: 1,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    gasPrice: handleUint(fields[2], "gasPrice"),
    gasLimit: handleUint(fields[3], "gasLimit"),
    to: handleAddress(fields[4]),
    value: handleUint(fields[5], "value"),
    data: hexlify(fields[6]),
    accessList: handleAccessList(fields[7], "accessList")
  };
  if (fields.length === 8) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(8));
  return tx;
}
function _serializeEip2930(tx, sig) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.gasPrice || 0, "gasPrice"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "recoveryParam"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat(["0x01", encodeRlp(fields)]);
}
function _parseEip4844(data2) {
  let fields = decodeRlp(getBytes(data2).slice(1));
  let typeName = "3";
  let blobs = null;
  if (fields.length === 4 && Array.isArray(fields[0])) {
    typeName = "3 (network format)";
    const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];
    assertArgument(Array.isArray(fBlobs), "invalid network format: blobs not an array", "fields[1]", fBlobs);
    assertArgument(Array.isArray(fCommits), "invalid network format: commitments not an array", "fields[2]", fCommits);
    assertArgument(Array.isArray(fProofs), "invalid network format: proofs not an array", "fields[3]", fProofs);
    assertArgument(fBlobs.length === fCommits.length, "invalid network format: blobs/commitments length mismatch", "fields", fields);
    assertArgument(fBlobs.length === fProofs.length, "invalid network format: blobs/proofs length mismatch", "fields", fields);
    blobs = [];
    for (let i4 = 0; i4 < fields[1].length; i4++) {
      blobs.push({
        data: fBlobs[i4],
        commitment: fCommits[i4],
        proof: fProofs[i4]
      });
    }
    fields = fields[0];
  }
  assertArgument(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, "data", hexlify(data2));
  const tx = {
    type: 3,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList"),
    maxFeePerBlobGas: handleUint(fields[9], "maxFeePerBlobGas"),
    blobVersionedHashes: fields[10]
  };
  if (blobs) {
    tx.blobs = blobs;
  }
  assertArgument(tx.to != null, `invalid address for transaction type: ${typeName}`, "data", data2);
  assertArgument(Array.isArray(tx.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", data2);
  for (let i4 = 0; i4 < tx.blobVersionedHashes.length; i4++) {
    assertArgument(isHexString(tx.blobVersionedHashes[i4], 32), `invalid blobVersionedHash at index ${i4}: must be length 32`, "data", data2);
  }
  if (fields.length === 11) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(11));
  return tx;
}
function _serializeEip4844(tx, sig, blobs) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || ZeroAddress,
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || []),
    formatNumber(tx.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
    formatHashes(tx.blobVersionedHashes || [], "blobVersionedHashes")
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
    if (blobs) {
      return concat([
        "0x03",
        encodeRlp([
          fields,
          blobs.map((b2) => b2.data),
          blobs.map((b2) => b2.commitment),
          blobs.map((b2) => b2.proof)
        ])
      ]);
    }
  }
  return concat(["0x03", encodeRlp(fields)]);
}
const _Transaction = class _Transaction {
  /**
   *  Creates a new Transaction with default values.
   */
  constructor() {
    __privateAdd(this, _Transaction_instances);
    __privateAdd(this, _type);
    __privateAdd(this, _to);
    __privateAdd(this, _data3);
    __privateAdd(this, _nonce);
    __privateAdd(this, _gasLimit);
    __privateAdd(this, _gasPrice);
    __privateAdd(this, _maxPriorityFeePerGas);
    __privateAdd(this, _maxFeePerGas);
    __privateAdd(this, _value);
    __privateAdd(this, _chainId);
    __privateAdd(this, _sig);
    __privateAdd(this, _accessList);
    __privateAdd(this, _maxFeePerBlobGas);
    __privateAdd(this, _blobVersionedHashes);
    __privateAdd(this, _kzg);
    __privateAdd(this, _blobs);
    __privateSet(this, _type, null);
    __privateSet(this, _to, null);
    __privateSet(this, _nonce, 0);
    __privateSet(this, _gasLimit, BN_0$4);
    __privateSet(this, _gasPrice, null);
    __privateSet(this, _maxPriorityFeePerGas, null);
    __privateSet(this, _maxFeePerGas, null);
    __privateSet(this, _data3, "0x");
    __privateSet(this, _value, BN_0$4);
    __privateSet(this, _chainId, BN_0$4);
    __privateSet(this, _sig, null);
    __privateSet(this, _accessList, null);
    __privateSet(this, _maxFeePerBlobGas, null);
    __privateSet(this, _blobVersionedHashes, null);
    __privateSet(this, _blobs, null);
    __privateSet(this, _kzg, null);
  }
  /**
   *  The transaction type.
   *
   *  If null, the type will be automatically inferred based on
   *  explicit properties.
   */
  get type() {
    return __privateGet(this, _type);
  }
  set type(value) {
    switch (value) {
      case null:
        __privateSet(this, _type, null);
        break;
      case 0:
      case "legacy":
        __privateSet(this, _type, 0);
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        __privateSet(this, _type, 1);
        break;
      case 2:
      case "london":
      case "eip-1559":
        __privateSet(this, _type, 2);
        break;
      case 3:
      case "cancun":
      case "eip-4844":
        __privateSet(this, _type, 3);
        break;
      default:
        assertArgument(false, "unsupported transaction type", "type", value);
    }
  }
  /**
   *  The name of the transaction type.
   */
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
      case 3:
        return "eip-4844";
    }
    return null;
  }
  /**
   *  The ``to`` address for the transaction or ``null`` if the
   *  transaction is an ``init`` transaction.
   */
  get to() {
    const value = __privateGet(this, _to);
    if (value == null && this.type === 3) {
      return ZeroAddress;
    }
    return value;
  }
  set to(value) {
    __privateSet(this, _to, value == null ? null : getAddress(value));
  }
  /**
   *  The transaction nonce.
   */
  get nonce() {
    return __privateGet(this, _nonce);
  }
  set nonce(value) {
    __privateSet(this, _nonce, getNumber(value, "value"));
  }
  /**
   *  The gas limit.
   */
  get gasLimit() {
    return __privateGet(this, _gasLimit);
  }
  set gasLimit(value) {
    __privateSet(this, _gasLimit, getBigInt(value));
  }
  /**
   *  The gas price.
   *
   *  On legacy networks this defines the fee that will be paid. On
   *  EIP-1559 networks, this should be ``null``.
   */
  get gasPrice() {
    const value = __privateGet(this, _gasPrice);
    if (value == null && (this.type === 0 || this.type === 1)) {
      return BN_0$4;
    }
    return value;
  }
  set gasPrice(value) {
    __privateSet(this, _gasPrice, value == null ? null : getBigInt(value, "gasPrice"));
  }
  /**
   *  The maximum priority fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxPriorityFeePerGas() {
    const value = __privateGet(this, _maxPriorityFeePerGas);
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_0$4;
      }
      return null;
    }
    return value;
  }
  set maxPriorityFeePerGas(value) {
    __privateSet(this, _maxPriorityFeePerGas, value == null ? null : getBigInt(value, "maxPriorityFeePerGas"));
  }
  /**
   *  The maximum total fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxFeePerGas() {
    const value = __privateGet(this, _maxFeePerGas);
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_0$4;
      }
      return null;
    }
    return value;
  }
  set maxFeePerGas(value) {
    __privateSet(this, _maxFeePerGas, value == null ? null : getBigInt(value, "maxFeePerGas"));
  }
  /**
   *  The transaction data. For ``init`` transactions this is the
   *  deployment code.
   */
  get data() {
    return __privateGet(this, _data3);
  }
  set data(value) {
    __privateSet(this, _data3, hexlify(value));
  }
  /**
   *  The amount of ether (in wei) to send in this transactions.
   */
  get value() {
    return __privateGet(this, _value);
  }
  set value(value) {
    __privateSet(this, _value, getBigInt(value, "value"));
  }
  /**
   *  The chain ID this transaction is valid on.
   */
  get chainId() {
    return __privateGet(this, _chainId);
  }
  set chainId(value) {
    __privateSet(this, _chainId, getBigInt(value));
  }
  /**
   *  If signed, the signature for this transaction.
   */
  get signature() {
    return __privateGet(this, _sig) || null;
  }
  set signature(value) {
    __privateSet(this, _sig, value == null ? null : Signature.from(value));
  }
  /**
   *  The access list.
   *
   *  An access list permits discounted (but pre-paid) access to
   *  bytecode and state variable access within contract execution.
   */
  get accessList() {
    const value = __privateGet(this, _accessList) || null;
    if (value == null) {
      if (this.type === 1 || this.type === 2 || this.type === 3) {
        return [];
      }
      return null;
    }
    return value;
  }
  set accessList(value) {
    __privateSet(this, _accessList, value == null ? null : accessListify(value));
  }
  /**
   *  The max fee per blob gas for Cancun transactions.
   */
  get maxFeePerBlobGas() {
    const value = __privateGet(this, _maxFeePerBlobGas);
    if (value == null && this.type === 3) {
      return BN_0$4;
    }
    return value;
  }
  set maxFeePerBlobGas(value) {
    __privateSet(this, _maxFeePerBlobGas, value == null ? null : getBigInt(value, "maxFeePerBlobGas"));
  }
  /**
   *  The BLOb versioned hashes for Cancun transactions.
   */
  get blobVersionedHashes() {
    let value = __privateGet(this, _blobVersionedHashes);
    if (value == null && this.type === 3) {
      return [];
    }
    return value;
  }
  set blobVersionedHashes(value) {
    if (value != null) {
      assertArgument(Array.isArray(value), "blobVersionedHashes must be an Array", "value", value);
      value = value.slice();
      for (let i4 = 0; i4 < value.length; i4++) {
        assertArgument(isHexString(value[i4], 32), "invalid blobVersionedHash", `value[${i4}]`, value[i4]);
      }
    }
    __privateSet(this, _blobVersionedHashes, value);
  }
  /**
   *  The BLObs for the Transaction, if any.
   *
   *  If ``blobs`` is non-``null``, then the [[seriailized]]
   *  will return the network formatted sidecar, otherwise it
   *  will return the standard [[link-eip-2718]] payload. The
   *  [[unsignedSerialized]] is unaffected regardless.
   *
   *  When setting ``blobs``, either fully valid [[Blob]] objects
   *  may be specified (i.e. correctly padded, with correct
   *  committments and proofs) or a raw [[BytesLike]] may
   *  be provided.
   *
   *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
   *  be already set. The blob will be correctly padded and the
   *  [[KzgLibrary]] will be used to compute the committment and
   *  proof for the blob.
   *
   *  A BLOb is a sequence of field elements, each of which must
   *  be within the BLS field modulo, so some additional processing
   *  may be required to encode arbitrary data to ensure each 32 byte
   *  field is within the valid range.
   *
   *  Setting this automatically populates [[blobVersionedHashes]],
   *  overwriting any existing values. Setting this to ``null``
   *  does **not** remove the [[blobVersionedHashes]], leaving them
   *  present.
   */
  get blobs() {
    if (__privateGet(this, _blobs) == null) {
      return null;
    }
    return __privateGet(this, _blobs).map((b2) => Object.assign({}, b2));
  }
  set blobs(_blobs2) {
    if (_blobs2 == null) {
      __privateSet(this, _blobs, null);
      return;
    }
    const blobs = [];
    const versionedHashes = [];
    for (let i4 = 0; i4 < _blobs2.length; i4++) {
      const blob = _blobs2[i4];
      if (isBytesLike(blob)) {
        assert(__privateGet(this, _kzg), "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
          operation: "set blobs()"
        });
        let data2 = getBytes(blob);
        assertArgument(data2.length <= BLOB_SIZE, "blob is too large", `blobs[${i4}]`, blob);
        if (data2.length !== BLOB_SIZE) {
          const padded = new Uint8Array(BLOB_SIZE);
          padded.set(data2);
          data2 = padded;
        }
        const commit = __privateGet(this, _kzg).blobToKzgCommitment(data2);
        const proof = hexlify(__privateGet(this, _kzg).computeBlobKzgProof(data2, commit));
        blobs.push({
          data: hexlify(data2),
          commitment: hexlify(commit),
          proof
        });
        versionedHashes.push(getVersionedHash(1, commit));
      } else {
        const commit = hexlify(blob.commitment);
        blobs.push({
          data: hexlify(blob.data),
          commitment: commit,
          proof: hexlify(blob.proof)
        });
        versionedHashes.push(getVersionedHash(1, commit));
      }
    }
    __privateSet(this, _blobs, blobs);
    __privateSet(this, _blobVersionedHashes, versionedHashes);
  }
  get kzg() {
    return __privateGet(this, _kzg);
  }
  set kzg(kzg) {
    __privateSet(this, _kzg, kzg);
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  get hash() {
    if (this.signature == null) {
      return null;
    }
    return keccak256$1(__privateMethod(this, _Transaction_instances, getSerialized_fn).call(this, true, false));
  }
  /**
   *  The pre-image hash of this transaction.
   *
   *  This is the digest that a [[Signer]] must sign to authorize
   *  this transaction.
   */
  get unsignedHash() {
    return keccak256$1(this.unsignedSerialized);
  }
  /**
   *  The sending address, if signed. Otherwise, ``null``.
   */
  get from() {
    if (this.signature == null) {
      return null;
    }
    return recoverAddress$1(this.unsignedHash, this.signature);
  }
  /**
   *  The public key of the sender, if signed. Otherwise, ``null``.
   */
  get fromPublicKey() {
    if (this.signature == null) {
      return null;
    }
    return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);
  }
  /**
   *  Returns true if signed.
   *
   *  This provides a Type Guard that properties requiring a signed
   *  transaction are non-null.
   */
  isSigned() {
    return this.signature != null;
  }
  /**
   *  The serialized transaction.
   *
   *  This throws if the transaction is unsigned. For the pre-image,
   *  use [[unsignedSerialized]].
   */
  get serialized() {
    return __privateMethod(this, _Transaction_instances, getSerialized_fn).call(this, true, true);
  }
  /**
   *  The transaction pre-image.
   *
   *  The hash of this is the digest which needs to be signed to
   *  authorize this transaction.
   */
  get unsignedSerialized() {
    return __privateMethod(this, _Transaction_instances, getSerialized_fn).call(this, false, false);
  }
  /**
   *  Return the most "likely" type; currently the highest
   *  supported transaction type.
   */
  inferType() {
    const types2 = this.inferTypes();
    if (types2.indexOf(2) >= 0) {
      return 2;
    }
    return types2.pop();
  }
  /**
   *  Validates the explicit properties and returns a list of compatible
   *  transaction types.
   */
  inferTypes() {
    const hasGasPrice = this.gasPrice != null;
    const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;
    const hasAccessList = this.accessList != null;
    const hasBlob = __privateGet(this, _maxFeePerBlobGas) != null || __privateGet(this, _blobVersionedHashes);
    if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {
      assert(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this });
    }
    assert(!hasFee || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this });
    assert(this.type !== 0 || !hasAccessList, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const types2 = [];
    if (this.type != null) {
      types2.push(this.type);
    } else {
      if (hasFee) {
        types2.push(2);
      } else if (hasGasPrice) {
        types2.push(1);
        if (!hasAccessList) {
          types2.push(0);
        }
      } else if (hasAccessList) {
        types2.push(1);
        types2.push(2);
      } else if (hasBlob && this.to) {
        types2.push(3);
      } else {
        types2.push(0);
        types2.push(1);
        types2.push(2);
        types2.push(3);
      }
    }
    types2.sort();
    return types2;
  }
  /**
   *  Returns true if this transaction is a legacy transaction (i.e.
   *  ``type === 0``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if this transaction is berlin hardform transaction (i.e.
   *  ``type === 1``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if this transaction is london hardform transaction (i.e.
   *  ``type === 2``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if this transaction is an [[link-eip-4844]] BLOB
   *  transaction.
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Create a copy of this transaciton.
   */
  clone() {
    return _Transaction.from(this);
  }
  /**
   *  Return a JSON-friendly object.
   */
  toJSON() {
    const s2 = (v2) => {
      if (v2 == null) {
        return null;
      }
      return v2.toString();
    };
    return {
      type: this.type,
      to: this.to,
      //            from: this.from,
      data: this.data,
      nonce: this.nonce,
      gasLimit: s2(this.gasLimit),
      gasPrice: s2(this.gasPrice),
      maxPriorityFeePerGas: s2(this.maxPriorityFeePerGas),
      maxFeePerGas: s2(this.maxFeePerGas),
      value: s2(this.value),
      chainId: s2(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  /**
   *  Create a **Transaction** from a serialized transaction or a
   *  Transaction-like object.
   */
  static from(tx) {
    if (tx == null) {
      return new _Transaction();
    }
    if (typeof tx === "string") {
      const payload = getBytes(tx);
      if (payload[0] >= 127) {
        return _Transaction.from(_parseLegacy(payload));
      }
      switch (payload[0]) {
        case 1:
          return _Transaction.from(_parseEip2930(payload));
        case 2:
          return _Transaction.from(_parseEip1559(payload));
        case 3:
          return _Transaction.from(_parseEip4844(payload));
      }
      assert(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const result = new _Transaction();
    if (tx.type != null) {
      result.type = tx.type;
    }
    if (tx.to != null) {
      result.to = tx.to;
    }
    if (tx.nonce != null) {
      result.nonce = tx.nonce;
    }
    if (tx.gasLimit != null) {
      result.gasLimit = tx.gasLimit;
    }
    if (tx.gasPrice != null) {
      result.gasPrice = tx.gasPrice;
    }
    if (tx.maxPriorityFeePerGas != null) {
      result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
    }
    if (tx.maxFeePerGas != null) {
      result.maxFeePerGas = tx.maxFeePerGas;
    }
    if (tx.maxFeePerBlobGas != null) {
      result.maxFeePerBlobGas = tx.maxFeePerBlobGas;
    }
    if (tx.data != null) {
      result.data = tx.data;
    }
    if (tx.value != null) {
      result.value = tx.value;
    }
    if (tx.chainId != null) {
      result.chainId = tx.chainId;
    }
    if (tx.signature != null) {
      result.signature = Signature.from(tx.signature);
    }
    if (tx.accessList != null) {
      result.accessList = tx.accessList;
    }
    if (tx.blobVersionedHashes != null) {
      result.blobVersionedHashes = tx.blobVersionedHashes;
    }
    if (tx.kzg != null) {
      result.kzg = tx.kzg;
    }
    if (tx.blobs != null) {
      result.blobs = tx.blobs;
    }
    if (tx.hash != null) {
      assertArgument(result.isSigned(), "unsigned transaction cannot define '.hash'", "tx", tx);
      assertArgument(result.hash === tx.hash, "hash mismatch", "tx", tx);
    }
    if (tx.from != null) {
      assertArgument(result.isSigned(), "unsigned transaction cannot define '.from'", "tx", tx);
      assertArgument(result.from.toLowerCase() === (tx.from || "").toLowerCase(), "from mismatch", "tx", tx);
    }
    return result;
  }
};
_type = new WeakMap();
_to = new WeakMap();
_data3 = new WeakMap();
_nonce = new WeakMap();
_gasLimit = new WeakMap();
_gasPrice = new WeakMap();
_maxPriorityFeePerGas = new WeakMap();
_maxFeePerGas = new WeakMap();
_value = new WeakMap();
_chainId = new WeakMap();
_sig = new WeakMap();
_accessList = new WeakMap();
_maxFeePerBlobGas = new WeakMap();
_blobVersionedHashes = new WeakMap();
_kzg = new WeakMap();
_blobs = new WeakMap();
_Transaction_instances = new WeakSet();
getSerialized_fn = function(signed2, sidecar) {
  assert(!signed2 || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  const sig = signed2 ? this.signature : null;
  switch (this.inferType()) {
    case 0:
      return _serializeLegacy(this, sig);
    case 1:
      return _serializeEip2930(this, sig);
    case 2:
      return _serializeEip1559(this, sig);
    case 3:
      return _serializeEip4844(this, sig, sidecar ? this.blobs : null);
  }
  assert(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
};
let Transaction = _Transaction;
const padding = new Uint8Array(32);
padding.fill(0);
const BN__1 = BigInt(-1);
const BN_0$3 = BigInt(0);
const BN_1 = BigInt(1);
const BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  const bytes2 = getBytes(value);
  const padOffset = bytes2.length % 32;
  if (padOffset) {
    return concat([bytes2, padding.slice(padOffset)]);
  }
  return hexlify(bytes2);
}
const hexTrue = toBeHex(BN_1, 32);
const hexFalse = toBeHex(BN_0$3, 32);
const domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
const domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(key2) {
  return function(value) {
    assertArgument(typeof value === "string", `invalid domain value for ${JSON.stringify(key2)}`, `domain.${key2}`, value);
    return value;
  };
}
const domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(_value2) {
    const value = getBigInt(_value2, "domain.chainId");
    assertArgument(value >= 0, "invalid chain ID", "domain.chainId", _value2);
    if (Number.isSafeInteger(value)) {
      return Number(value);
    }
    return toQuantity(value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error) {
    }
    assertArgument(false, `invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    const bytes2 = getBytes(value, "domain.salt");
    assertArgument(bytes2.length === 32, `invalid domain value "salt"`, "domain.salt", value);
    return hexlify(bytes2);
  }
};
function getBaseEncoder(type2) {
  {
    const match = type2.match(/^(u?)int(\d+)$/);
    if (match) {
      const signed2 = match[1] === "";
      const width = parseInt(match[2]);
      assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), "invalid numeric width", "type", type2);
      const boundsUpper = mask(BN_MAX_UINT256, signed2 ? width - 1 : width);
      const boundsLower = signed2 ? (boundsUpper + BN_1) * BN__1 : BN_0$3;
      return function(_value2) {
        const value = getBigInt(_value2, "value");
        assertArgument(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type2}`, "value", value);
        return toBeHex(signed2 ? toTwos(value, 256) : value, 32);
      };
    }
  }
  {
    const match = type2.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      assertArgument(width !== 0 && width <= 32 && match[1] === String(width), "invalid bytes width", "type", type2);
      return function(value) {
        const bytes2 = getBytes(value);
        assertArgument(bytes2.length === width, `invalid length for ${type2}`, "value", value);
        return hexPadRight(value);
      };
    }
  }
  switch (type2) {
    case "address":
      return function(value) {
        return zeroPadValue(getAddress(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak256$1(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
}
function encodeType(name, fields) {
  return `${name}(${fields.map(({ name: name2, type: type2 }) => type2 + " " + name2).join(",")})`;
}
function splitArray(type2) {
  const match = type2.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
  if (match) {
    return {
      base: match[1],
      index: match[2] + match[4],
      array: {
        base: match[1],
        prefix: match[1] + match[2],
        count: match[5] ? parseInt(match[5]) : -1
      }
    };
  }
  return { base: type2 };
}
const _TypedDataEncoder = class _TypedDataEncoder {
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  constructor(_types2) {
    __privateAdd(this, _TypedDataEncoder_instances);
    /**
     *  The primary type for the structured [[types]].
     *
     *  This is derived automatically from the [[types]], since no
     *  recursion is possible, once the DAG for the types is consturcted
     *  internally, the primary type must be the only remaining type with
     *  no parent nodes.
     */
    __publicField(this, "primaryType");
    __privateAdd(this, _types);
    __privateAdd(this, _fullTypes);
    __privateAdd(this, _encoderCache);
    __privateSet(this, _fullTypes, /* @__PURE__ */ new Map());
    __privateSet(this, _encoderCache, /* @__PURE__ */ new Map());
    const links = /* @__PURE__ */ new Map();
    const parents = /* @__PURE__ */ new Map();
    const subtypes = /* @__PURE__ */ new Map();
    const types2 = {};
    Object.keys(_types2).forEach((type2) => {
      types2[type2] = _types2[type2].map(({ name, type: type3 }) => {
        let { base: base3, index: index2 } = splitArray(type3);
        if (base3 === "int" && !_types2["int"]) {
          base3 = "int256";
        }
        if (base3 === "uint" && !_types2["uint"]) {
          base3 = "uint256";
        }
        return { name, type: base3 + (index2 || "") };
      });
      links.set(type2, /* @__PURE__ */ new Set());
      parents.set(type2, []);
      subtypes.set(type2, /* @__PURE__ */ new Set());
    });
    __privateSet(this, _types, JSON.stringify(types2));
    for (const name in types2) {
      const uniqueNames = /* @__PURE__ */ new Set();
      for (const field of types2[name]) {
        assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", _types2);
        uniqueNames.add(field.name);
        const baseType = splitArray(field.type).base;
        assertArgument(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, "types", _types2);
        const encoder2 = getBaseEncoder(baseType);
        if (encoder2) {
          continue;
        }
        assertArgument(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, "types", _types2);
        parents.get(baseType).push(name);
        links.get(name).add(baseType);
      }
    }
    const primaryTypes = Array.from(parents.keys()).filter((n5) => parents.get(n5).length === 0);
    assertArgument(primaryTypes.length !== 0, "missing primary type", "types", _types2);
    assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t2) => JSON.stringify(t2)).join(", ")}`, "types", _types2);
    defineProperties(this, { primaryType: primaryTypes[0] });
    function checkCircular(type2, found) {
      assertArgument(!found.has(type2), `circular type reference to ${JSON.stringify(type2)}`, "types", _types2);
      found.add(type2);
      for (const child of links.get(type2)) {
        if (!parents.has(child)) {
          continue;
        }
        checkCircular(child, found);
        for (const subtype of found) {
          subtypes.get(subtype).add(child);
        }
      }
      found.delete(type2);
    }
    checkCircular(this.primaryType, /* @__PURE__ */ new Set());
    for (const [name, set2] of subtypes) {
      const st2 = Array.from(set2);
      st2.sort();
      __privateGet(this, _fullTypes).set(name, encodeType(name, types2[name]) + st2.map((t2) => encodeType(t2, types2[t2])).join(""));
    }
  }
  /**
   *  The types.
   */
  get types() {
    return JSON.parse(__privateGet(this, _types));
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  getEncoder(type2) {
    let encoder2 = __privateGet(this, _encoderCache).get(type2);
    if (!encoder2) {
      encoder2 = __privateMethod(this, _TypedDataEncoder_instances, getEncoder_fn).call(this, type2);
      __privateGet(this, _encoderCache).set(type2, encoder2);
    }
    return encoder2;
  }
  /**
   *  Return the full type for %%name%%.
   */
  encodeType(name) {
    const result = __privateGet(this, _fullTypes).get(name);
    assertArgument(result, `unknown type: ${JSON.stringify(name)}`, "name", name);
    return result;
  }
  /**
   *  Return the encoded %%value%% for the %%type%%.
   */
  encodeData(type2, value) {
    return this.getEncoder(type2)(value);
  }
  /**
   *  Returns the hash of %%value%% for the type of %%name%%.
   */
  hashStruct(name, value) {
    return keccak256$1(this.encodeData(name, value));
  }
  /**
   *  Return the fulled encoded %%value%% for the [[types]].
   */
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  /**
   *  Return the hash of the fully encoded %%value%% for the [[types]].
   */
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  /**
   *  @_ignore:
   */
  _visit(type2, value, callback) {
    {
      const encoder2 = getBaseEncoder(type2);
      if (encoder2) {
        return callback(type2, value);
      }
    }
    const array = splitArray(type2).array;
    if (array) {
      assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
      return value.map((v2) => this._visit(array.prefix, v2, callback));
    }
    const fields = this.types[type2];
    if (fields) {
      return fields.reduce((accum, { name, type: type3 }) => {
        accum[name] = this._visit(type3, value[name], callback);
        return accum;
      }, {});
    }
    assertArgument(false, `unknown type: ${type2}`, "type", type2);
  }
  /**
   *  Call %%calback%% for each value in %%value%%, passing the type and
   *  component within %%value%%.
   *
   *  This is useful for replacing addresses or other transformation that
   *  may be desired on each component, based on its type.
   */
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   */
  static from(types2) {
    return new _TypedDataEncoder(types2);
  }
  /**
   *  Return the primary type for %%types%%.
   */
  static getPrimaryType(types2) {
    return _TypedDataEncoder.from(types2).primaryType;
  }
  /**
   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
   */
  static hashStruct(name, types2, value) {
    return _TypedDataEncoder.from(types2).hashStruct(name, value);
  }
  /**
   *  Return the domain hash for %%domain%%.
   */
  static hashDomain(domain) {
    const domainFields = [];
    for (const name in domain) {
      if (domain[name] == null) {
        continue;
      }
      const type2 = domainFieldTypes[name];
      assertArgument(type2, `invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
      domainFields.push({ name, type: type2 });
    }
    domainFields.sort((a2, b2) => {
      return domainFieldNames.indexOf(a2.name) - domainFieldNames.indexOf(b2.name);
    });
    return _TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
  }
  /**
   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static encode(domain, types2, value) {
    return concat([
      "0x1901",
      _TypedDataEncoder.hashDomain(domain),
      _TypedDataEncoder.from(types2).hash(value)
    ]);
  }
  /**
   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static hash(domain, types2, value) {
    return keccak256$1(_TypedDataEncoder.encode(domain, types2, value));
  }
  // Replaces all address types with ENS names with their looked up address
  /**
   * Resolves to the value from resolving all addresses in %%value%% for
   * %%types%% and the %%domain%%.
   */
  static async resolveNames(domain, types2, value, resolveName) {
    domain = Object.assign({}, domain);
    for (const key2 in domain) {
      if (domain[key2] == null) {
        delete domain[key2];
      }
    }
    const ensCache = {};
    if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
      ensCache[domain.verifyingContract] = "0x";
    }
    const encoder2 = _TypedDataEncoder.from(types2);
    encoder2.visit(value, (type2, value2) => {
      if (type2 === "address" && !isHexString(value2, 20)) {
        ensCache[value2] = "0x";
      }
      return value2;
    });
    for (const name in ensCache) {
      ensCache[name] = await resolveName(name);
    }
    if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
      domain.verifyingContract = ensCache[domain.verifyingContract];
    }
    value = encoder2.visit(value, (type2, value2) => {
      if (type2 === "address" && ensCache[value2]) {
        return ensCache[value2];
      }
      return value2;
    });
    return { domain, value };
  }
  /**
   *  Returns the JSON-encoded payload expected by nodes which implement
   *  the JSON-RPC [[link-eip-712]] method.
   */
  static getPayload(domain, types2, value) {
    _TypedDataEncoder.hashDomain(domain);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name) => {
      const value2 = domain[name];
      if (value2 == null) {
        return;
      }
      domainValues[name] = domainChecks[name](value2);
      domainTypes.push({ name, type: domainFieldTypes[name] });
    });
    const encoder2 = _TypedDataEncoder.from(types2);
    types2 = encoder2.types;
    const typesWithDomain = Object.assign({}, types2);
    assertArgument(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types2);
    typesWithDomain.EIP712Domain = domainTypes;
    encoder2.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder2.primaryType,
      message: encoder2.visit(value, (type2, value2) => {
        if (type2.match(/^bytes(\d*)/)) {
          return hexlify(getBytes(value2));
        }
        if (type2.match(/^u?int/)) {
          return getBigInt(value2).toString();
        }
        switch (type2) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            assertArgument(typeof value2 === "string", "invalid string", "value", value2);
            return value2;
        }
        assertArgument(false, "unsupported type", "type", type2);
      })
    };
  }
};
_types = new WeakMap();
_fullTypes = new WeakMap();
_encoderCache = new WeakMap();
_TypedDataEncoder_instances = new WeakSet();
getEncoder_fn = function(type2) {
  {
    const encoder2 = getBaseEncoder(type2);
    if (encoder2) {
      return encoder2;
    }
  }
  const array = splitArray(type2).array;
  if (array) {
    const subtype = array.prefix;
    const subEncoder = this.getEncoder(subtype);
    return (value) => {
      assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
      let result = value.map(subEncoder);
      if (__privateGet(this, _fullTypes).has(subtype)) {
        result = result.map(keccak256$1);
      }
      return keccak256$1(concat(result));
    };
  }
  const fields = this.types[type2];
  if (fields) {
    const encodedType = id(__privateGet(this, _fullTypes).get(type2));
    return (value) => {
      const values = fields.map(({ name, type: type3 }) => {
        const result = this.getEncoder(type3)(value[name]);
        if (__privateGet(this, _fullTypes).has(type3)) {
          return keccak256$1(result);
        }
        return result;
      });
      values.unshift(encodedType);
      return concat(values);
    };
  }
  assertArgument(false, `unknown type: ${type2}`, "type", type2);
};
let TypedDataEncoder = _TypedDataEncoder;
function setify(items) {
  const result = /* @__PURE__ */ new Set();
  items.forEach((k3) => result.add(k3));
  return Object.freeze(result);
}
const _kwVisibDeploy = "external public payable override";
const KwVisibDeploy = setify(_kwVisibDeploy.split(" "));
const _kwVisib = "constant external internal payable private public pure view override";
const KwVisib = setify(_kwVisib.split(" "));
const _kwTypes = "constructor error event fallback function receive struct";
const KwTypes = setify(_kwTypes.split(" "));
const _kwModifiers = "calldata memory storage payable indexed";
const KwModifiers = setify(_kwModifiers.split(" "));
const _kwOther = "tuple returns";
const _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(" ");
const Keywords = setify(_keywords.split(" "));
const SimpleTokens = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
};
const regexWhitespacePrefix = new RegExp("^(\\s*)");
const regexNumberPrefix = new RegExp("^([0-9]+)");
const regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
const regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
const regexType = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
const _TokenString = class _TokenString {
  constructor(tokens) {
    __privateAdd(this, _TokenString_instances);
    __privateAdd(this, _offset2);
    __privateAdd(this, _tokens);
    __privateSet(this, _offset2, 0);
    __privateSet(this, _tokens, tokens.slice());
  }
  get offset() {
    return __privateGet(this, _offset2);
  }
  get length() {
    return __privateGet(this, _tokens).length - __privateGet(this, _offset2);
  }
  clone() {
    return new _TokenString(__privateGet(this, _tokens));
  }
  reset() {
    __privateSet(this, _offset2, 0);
  }
  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
  popKeyword(allowed) {
    const top = this.peek();
    if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
      throw new Error(`expected keyword ${top.text}`);
    }
    return this.pop().text;
  }
  // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  popType(type2) {
    if (this.peek().type !== type2) {
      const top = this.peek();
      throw new Error(`expected ${type2}; got ${top.type} ${JSON.stringify(top.text)}`);
    }
    return this.pop().text;
  }
  // Pops and returns a "(" TOKENS ")"
  popParen() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = __privateMethod(this, _TokenString_instances, subTokenString_fn).call(this, __privateGet(this, _offset2) + 1, top.match + 1);
    __privateSet(this, _offset2, top.match + 1);
    return result;
  }
  // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  popParams() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = [];
    while (__privateGet(this, _offset2) < top.match - 1) {
      const link = this.peek().linkNext;
      result.push(__privateMethod(this, _TokenString_instances, subTokenString_fn).call(this, __privateGet(this, _offset2) + 1, link));
      __privateSet(this, _offset2, link);
    }
    __privateSet(this, _offset2, top.match + 1);
    return result;
  }
  // Returns the top Token, throwing if out of tokens
  peek() {
    if (__privateGet(this, _offset2) >= __privateGet(this, _tokens).length) {
      throw new Error("out-of-bounds");
    }
    return __privateGet(this, _tokens)[__privateGet(this, _offset2)];
  }
  // Returns the next value, if it is a keyword in `allowed`
  peekKeyword(allowed) {
    const top = this.peekType("KEYWORD");
    return top != null && allowed.has(top) ? top : null;
  }
  // Returns the value of the next token if it is `type`
  peekType(type2) {
    if (this.length === 0) {
      return null;
    }
    const top = this.peek();
    return top.type === type2 ? top.text : null;
  }
  // Returns the next token; throws if out of tokens
  pop() {
    const result = this.peek();
    __privateWrapper(this, _offset2)._++;
    return result;
  }
  toString() {
    const tokens = [];
    for (let i4 = __privateGet(this, _offset2); i4 < __privateGet(this, _tokens).length; i4++) {
      const token = __privateGet(this, _tokens)[i4];
      tokens.push(`${token.type}:${token.text}`);
    }
    return `<TokenString ${tokens.join(" ")}>`;
  }
};
_offset2 = new WeakMap();
_tokens = new WeakMap();
_TokenString_instances = new WeakSet();
subTokenString_fn = function(from2 = 0, to2 = 0) {
  return new _TokenString(__privateGet(this, _tokens).slice(from2, to2).map((t2) => {
    return Object.freeze(Object.assign({}, t2, {
      match: t2.match - from2,
      linkBack: t2.linkBack - from2,
      linkNext: t2.linkNext - from2
    }));
  }));
};
let TokenString = _TokenString;
function lex(text) {
  const tokens = [];
  const throwError2 = (message) => {
    const token = offset < text.length ? JSON.stringify(text[offset]) : "$EOI";
    throw new Error(`invalid token ${token} at ${offset}: ${message}`);
  };
  let brackets = [];
  let commas = [];
  let offset = 0;
  while (offset < text.length) {
    let cur = text.substring(offset);
    let match = cur.match(regexWhitespacePrefix);
    if (match) {
      offset += match[1].length;
      cur = text.substring(offset);
    }
    const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset, value: -1 };
    tokens.push(token);
    let type2 = SimpleTokens[cur[0]] || "";
    if (type2) {
      token.type = type2;
      token.text = cur[0];
      offset++;
      if (type2 === "OPEN_PAREN") {
        brackets.push(tokens.length - 1);
        commas.push(tokens.length - 1);
      } else if (type2 == "CLOSE_PAREN") {
        if (brackets.length === 0) {
          throwError2("no matching open bracket");
        }
        token.match = brackets.pop();
        tokens[token.match].match = tokens.length - 1;
        token.depth--;
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
      } else if (type2 === "COMMA") {
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
        commas.push(tokens.length - 1);
      } else if (type2 === "OPEN_BRACKET") {
        token.type = "BRACKET";
      } else if (type2 === "CLOSE_BRACKET") {
        let suffix = tokens.pop().text;
        if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
          const value = tokens.pop().text;
          suffix = value + suffix;
          tokens[tokens.length - 1].value = getNumber(value);
        }
        if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
          throw new Error("missing opening bracket");
        }
        tokens[tokens.length - 1].text += suffix;
      }
      continue;
    }
    match = cur.match(regexIdPrefix);
    if (match) {
      token.text = match[1];
      offset += token.text.length;
      if (Keywords.has(token.text)) {
        token.type = "KEYWORD";
        continue;
      }
      if (token.text.match(regexType)) {
        token.type = "TYPE";
        continue;
      }
      token.type = "ID";
      continue;
    }
    match = cur.match(regexNumberPrefix);
    if (match) {
      token.text = match[1];
      token.type = "NUMBER";
      offset += token.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);
  }
  return new TokenString(tokens.map((t2) => Object.freeze(t2)));
}
function allowSingle(set2, allowed) {
  let included = [];
  for (const key2 in allowed.keys()) {
    if (set2.has(key2)) {
      included.push(key2);
    }
  }
  if (included.length > 1) {
    throw new Error(`conflicting types: ${included.join(", ")}`);
  }
}
function consumeName(type2, tokens) {
  if (tokens.peekKeyword(KwTypes)) {
    const keyword = tokens.pop().text;
    if (keyword !== type2) {
      throw new Error(`expected ${type2}, got ${keyword}`);
    }
  }
  return tokens.popType("ID");
}
function consumeKeywords(tokens, allowed) {
  const keywords = /* @__PURE__ */ new Set();
  while (true) {
    const keyword = tokens.peekType("KEYWORD");
    if (keyword == null || allowed && !allowed.has(keyword)) {
      break;
    }
    tokens.pop();
    if (keywords.has(keyword)) {
      throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
    }
    keywords.add(keyword);
  }
  return Object.freeze(keywords);
}
function consumeMutability(tokens) {
  let modifiers = consumeKeywords(tokens, KwVisib);
  allowSingle(modifiers, setify("constant payable nonpayable".split(" ")));
  allowSingle(modifiers, setify("pure view payable nonpayable".split(" ")));
  if (modifiers.has("view")) {
    return "view";
  }
  if (modifiers.has("pure")) {
    return "pure";
  }
  if (modifiers.has("payable")) {
    return "payable";
  }
  if (modifiers.has("nonpayable")) {
    return "nonpayable";
  }
  if (modifiers.has("constant")) {
    return "view";
  }
  return "nonpayable";
}
function consumeParams(tokens, allowIndexed) {
  return tokens.popParams().map((t2) => ParamType.from(t2, allowIndexed));
}
function consumeGas(tokens) {
  if (tokens.peekType("AT")) {
    tokens.pop();
    if (tokens.peekType("NUMBER")) {
      return getBigInt(tokens.pop().text);
    }
    throw new Error("invalid gas");
  }
  return null;
}
function consumeEoi(tokens) {
  if (tokens.length) {
    throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);
  }
}
const regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
function verifyBasicType(type2) {
  const match = type2.match(regexType);
  assertArgument(match, "invalid type", "type", type2);
  if (type2 === "uint") {
    return "uint256";
  }
  if (type2 === "int") {
    return "int256";
  }
  if (match[2]) {
    const length = parseInt(match[2]);
    assertArgument(length !== 0 && length <= 32, "invalid bytes length", "type", type2);
  } else if (match[3]) {
    const size2 = parseInt(match[3]);
    assertArgument(size2 !== 0 && size2 <= 256 && size2 % 8 === 0, "invalid numeric width", "type", type2);
  }
  return type2;
}
const _guard = {};
const internal$1 = Symbol.for("_ethers_internal");
const ParamTypeInternal = "_ParamTypeInternal";
const ErrorFragmentInternal = "_ErrorInternal";
const EventFragmentInternal = "_EventInternal";
const ConstructorFragmentInternal = "_ConstructorInternal";
const FallbackFragmentInternal = "_FallbackInternal";
const FunctionFragmentInternal = "_FunctionInternal";
const StructFragmentInternal = "_StructInternal";
const _ParamType = class _ParamType {
  /**
   *  @private
   */
  constructor(guard, name, type2, baseType, indexed, components, arrayLength, arrayChildren) {
    __privateAdd(this, _ParamType_instances);
    /**
     *  The local name of the parameter (or ``""`` if unbound)
     */
    __publicField(this, "name");
    /**
     *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
     *  ``"uint256[3][]"``)
     */
    __publicField(this, "type");
    /**
     *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
     */
    __publicField(this, "baseType");
    /**
     *  True if the parameters is indexed.
     *
     *  For non-indexable types this is ``null``.
     */
    __publicField(this, "indexed");
    /**
     *  The components for the tuple.
     *
     *  For non-tuple types this is ``null``.
     */
    __publicField(this, "components");
    /**
     *  The array length, or ``-1`` for dynamic-lengthed arrays.
     *
     *  For non-array types this is ``null``.
     */
    __publicField(this, "arrayLength");
    /**
     *  The type of each child in the array.
     *
     *  For non-array types this is ``null``.
     */
    __publicField(this, "arrayChildren");
    assertPrivate(guard, _guard, "ParamType");
    Object.defineProperty(this, internal$1, { value: ParamTypeInternal });
    if (components) {
      components = Object.freeze(components.slice());
    }
    if (baseType === "array") {
      if (arrayLength == null || arrayChildren == null) {
        throw new Error("");
      }
    } else if (arrayLength != null || arrayChildren != null) {
      throw new Error("");
    }
    if (baseType === "tuple") {
      if (components == null) {
        throw new Error("");
      }
    } else if (components != null) {
      throw new Error("");
    }
    defineProperties(this, {
      name,
      type: type2,
      baseType,
      indexed,
      components,
      arrayLength,
      arrayChildren
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  format(format2) {
    if (format2 == null) {
      format2 = "sighash";
    }
    if (format2 === "json") {
      const name = this.name || "";
      if (this.isArray()) {
        const result3 = JSON.parse(this.arrayChildren.format("json"));
        result3.name = name;
        result3.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
        return JSON.stringify(result3);
      }
      const result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.isTuple()) {
        result2.components = this.components.map((c2) => JSON.parse(c2.format(format2)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.isArray()) {
      result += this.arrayChildren.format(format2);
      result += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
    } else {
      if (this.isTuple()) {
        result += "(" + this.components.map((comp) => comp.format(format2)).join(format2 === "full" ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format2 !== "sighash") {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format2 === "full" && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  /**
   *  Returns true if %%this%% is an Array type.
   *
   *  This provides a type gaurd ensuring that [[arrayChildren]]
   *  and [[arrayLength]] are non-null.
   */
  isArray() {
    return this.baseType === "array";
  }
  /**
   *  Returns true if %%this%% is a Tuple type.
   *
   *  This provides a type gaurd ensuring that [[components]]
   *  is non-null.
   */
  isTuple() {
    return this.baseType === "tuple";
  }
  /**
   *  Returns true if %%this%% is an Indexable type.
   *
   *  This provides a type gaurd ensuring that [[indexed]]
   *  is non-null.
   */
  isIndexable() {
    return this.indexed != null;
  }
  /**
   *  Walks the **ParamType** with %%value%%, calling %%process%%
   *  on each type, destructing the %%value%% recursively.
   */
  walk(value, process2) {
    if (this.isArray()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v2) => _this.arrayChildren.walk(v2, process2));
    }
    if (this.isTuple()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid tuple value");
      }
      if (value.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v2, i4) => _this.components[i4].walk(v2, process2));
    }
    return process2(this.type, value);
  }
  /**
   *  Walks the **ParamType** with %%value%%, asynchronously calling
   *  %%process%% on each type, destructing the %%value%% recursively.
   *
   *  This can be used to resolve ENS names by walking and resolving each
   *  ``"address"`` type.
   */
  async walkAsync(value, process2) {
    const promises = [];
    const result = [value];
    __privateMethod(this, _ParamType_instances, walkAsync_fn).call(this, promises, value, process2, (value2) => {
      result[0] = value2;
    });
    if (promises.length) {
      await Promise.all(promises);
    }
    return result[0];
  }
  /**
   *  Creates a new **ParamType** for %%obj%%.
   *
   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
   *  otherwise the ``indexed`` keyword will throw an error.
   */
  static from(obj, allowIndexed) {
    if (_ParamType.isParamType(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _ParamType.from(lex(obj), allowIndexed);
      } catch (error) {
        assertArgument(false, "invalid param type", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      let type3 = "", baseType = "";
      let comps = null;
      if (consumeKeywords(obj, setify(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
        baseType = "tuple";
        comps = obj.popParams().map((t2) => _ParamType.from(t2));
        type3 = `tuple(${comps.map((c2) => c2.format()).join(",")})`;
      } else {
        type3 = verifyBasicType(obj.popType("TYPE"));
        baseType = type3;
      }
      let arrayChildren = null;
      let arrayLength = null;
      while (obj.length && obj.peekType("BRACKET")) {
        const bracket = obj.pop();
        arrayChildren = new _ParamType(_guard, "", type3, baseType, null, comps, arrayLength, arrayChildren);
        arrayLength = bracket.value;
        type3 += bracket.text;
        baseType = "array";
        comps = null;
      }
      let indexed2 = null;
      const keywords = consumeKeywords(obj, KwModifiers);
      if (keywords.has("indexed")) {
        if (!allowIndexed) {
          throw new Error("");
        }
        indexed2 = true;
      }
      const name2 = obj.peekType("ID") ? obj.pop().text : "";
      if (obj.length) {
        throw new Error("leftover tokens");
      }
      return new _ParamType(_guard, name2, type3, baseType, indexed2, comps, arrayLength, arrayChildren);
    }
    const name = obj.name;
    assertArgument(!name || typeof name === "string" && name.match(regexId), "invalid name", "obj.name", name);
    let indexed = obj.indexed;
    if (indexed != null) {
      assertArgument(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
      indexed = !!indexed;
    }
    let type2 = obj.type;
    let arrayMatch = type2.match(regexArrayType);
    if (arrayMatch) {
      const arrayLength = parseInt(arrayMatch[2] || "-1");
      const arrayChildren = _ParamType.from({
        type: arrayMatch[1],
        components: obj.components
      });
      return new _ParamType(_guard, name || "", type2, "array", indexed, null, arrayLength, arrayChildren);
    }
    if (type2 === "tuple" || type2.startsWith(
      "tuple("
      /* fix: ) */
    ) || type2.startsWith(
      "("
      /* fix: ) */
    )) {
      const comps = obj.components != null ? obj.components.map((c2) => _ParamType.from(c2)) : null;
      const tuple = new _ParamType(_guard, name || "", type2, "tuple", indexed, comps, null, null);
      return tuple;
    }
    type2 = verifyBasicType(obj.type);
    return new _ParamType(_guard, name || "", type2, type2, indexed, null, null, null);
  }
  /**
   *  Returns true if %%value%% is a **ParamType**.
   */
  static isParamType(value) {
    return value && value[internal$1] === ParamTypeInternal;
  }
};
_ParamType_instances = new WeakSet();
walkAsync_fn = function(promises, value, process2, setValue) {
  if (this.isArray()) {
    if (!Array.isArray(value)) {
      throw new Error("invalid array value");
    }
    if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
      throw new Error("array is wrong length");
    }
    const childType = this.arrayChildren;
    const result2 = value.slice();
    result2.forEach((value2, index2) => {
      var _a3;
      __privateMethod(_a3 = childType, _ParamType_instances, walkAsync_fn).call(_a3, promises, value2, process2, (value3) => {
        result2[index2] = value3;
      });
    });
    setValue(result2);
    return;
  }
  if (this.isTuple()) {
    const components = this.components;
    let result2;
    if (Array.isArray(value)) {
      result2 = value.slice();
    } else {
      if (value == null || typeof value !== "object") {
        throw new Error("invalid tuple value");
      }
      result2 = components.map((param) => {
        if (!param.name) {
          throw new Error("cannot use object value with unnamed components");
        }
        if (!(param.name in value)) {
          throw new Error(`missing value for component ${param.name}`);
        }
        return value[param.name];
      });
    }
    if (result2.length !== this.components.length) {
      throw new Error("array is wrong length");
    }
    result2.forEach((value2, index2) => {
      var _a3;
      __privateMethod(_a3 = components[index2], _ParamType_instances, walkAsync_fn).call(_a3, promises, value2, process2, (value3) => {
        result2[index2] = value3;
      });
    });
    setValue(result2);
    return;
  }
  const result = process2(this.type, value);
  if (result.then) {
    promises.push(async function() {
      setValue(await result);
    }());
  } else {
    setValue(result);
  }
};
let ParamType = _ParamType;
class Fragment {
  /**
   *  @private
   */
  constructor(guard, type2, inputs) {
    /**
     *  The type of the fragment.
     */
    __publicField(this, "type");
    /**
     *  The inputs for the fragment.
     */
    __publicField(this, "inputs");
    assertPrivate(guard, _guard, "Fragment");
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, { type: type2, inputs });
  }
  /**
   *  Creates a new **Fragment** for %%obj%%, wich can be any supported
   *  ABI frgament type.
   */
  static from(obj) {
    if (typeof obj === "string") {
      try {
        Fragment.from(JSON.parse(obj));
      } catch (e3) {
      }
      return Fragment.from(lex(obj));
    }
    if (obj instanceof TokenString) {
      const type2 = obj.peekKeyword(KwTypes);
      switch (type2) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
    } else if (typeof obj === "object") {
      switch (obj.type) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
      assert(false, `unsupported type: ${obj.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    assertArgument(false, "unsupported frgament object", "obj", obj);
  }
  /**
   *  Returns true if %%value%% is a [[ConstructorFragment]].
   */
  static isConstructor(value) {
    return ConstructorFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[ErrorFragment]].
   */
  static isError(value) {
    return ErrorFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[EventFragment]].
   */
  static isEvent(value) {
    return EventFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[FunctionFragment]].
   */
  static isFunction(value) {
    return FunctionFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[StructFragment]].
   */
  static isStruct(value) {
    return StructFragment.isFragment(value);
  }
}
class NamedFragment extends Fragment {
  /**
   *  @private
   */
  constructor(guard, type2, name, inputs) {
    super(guard, type2, inputs);
    /**
     *  The name of the fragment.
     */
    __publicField(this, "name");
    assertArgument(typeof name === "string" && name.match(regexId), "invalid identifier", "name", name);
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, { name });
  }
}
function joinParams(format2, params) {
  return "(" + params.map((p2) => p2.format(format2)).join(format2 === "full" ? ", " : ",") + ")";
}
class ErrorFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name, inputs) {
    super(guard, "error", name, inputs);
    Object.defineProperty(this, internal$1, { value: ErrorFragmentInternal });
  }
  /**
   *  The Custom Error selector.
   */
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this fragment as %%format%%.
   */
  format(format2) {
    if (format2 == null) {
      format2 = "sighash";
    }
    if (format2 === "json") {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format2)))
      });
    }
    const result = [];
    if (format2 !== "sighash") {
      result.push("error");
    }
    result.push(this.name + joinParams(format2, this.inputs));
    return result.join(" ");
  }
  /**
   *  Returns a new **ErrorFragment** for %%obj%%.
   */
  static from(obj) {
    if (ErrorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      return ErrorFragment.from(lex(obj));
    } else if (obj instanceof TokenString) {
      const name = consumeName("error", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new ErrorFragment(_guard, name, inputs);
    }
    return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **ErrorFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === ErrorFragmentInternal;
  }
}
class EventFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name, inputs, anonymous) {
    super(guard, "event", name, inputs);
    /**
     *  Whether this event is anonymous.
     */
    __publicField(this, "anonymous");
    Object.defineProperty(this, internal$1, { value: EventFragmentInternal });
    defineProperties(this, { anonymous });
  }
  /**
   *  The Event topic hash.
   */
  get topicHash() {
    return id(this.format("sighash"));
  }
  /**
   *  Returns a string representation of this event as %%format%%.
   */
  format(format2) {
    if (format2 == null) {
      format2 = "sighash";
    }
    if (format2 === "json") {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((i4) => JSON.parse(i4.format(format2)))
      });
    }
    const result = [];
    if (format2 !== "sighash") {
      result.push("event");
    }
    result.push(this.name + joinParams(format2, this.inputs));
    if (format2 !== "sighash" && this.anonymous) {
      result.push("anonymous");
    }
    return result.join(" ");
  }
  /**
   *  Return the topic hash for an event with %%name%% and %%params%%.
   */
  static getTopicHash(name, params) {
    params = (params || []).map((p2) => ParamType.from(p2));
    const fragment = new EventFragment(_guard, name, params, false);
    return fragment.topicHash;
  }
  /**
   *  Returns a new **EventFragment** for %%obj%%.
   */
  static from(obj) {
    if (EventFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return EventFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid event fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("event", obj);
      const inputs = consumeParams(obj, true);
      const anonymous = !!consumeKeywords(obj, setify(["anonymous"])).has("anonymous");
      consumeEoi(obj);
      return new EventFragment(_guard, name, inputs, anonymous);
    }
    return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map((p2) => ParamType.from(p2, true)) : [], !!obj.anonymous);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **EventFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === EventFragmentInternal;
  }
}
class ConstructorFragment extends Fragment {
  /**
   *  @private
   */
  constructor(guard, type2, inputs, payable, gas) {
    super(guard, type2, inputs);
    /**
     *  Whether the constructor can receive an endowment.
     */
    __publicField(this, "payable");
    /**
     *  The recommended gas limit for deployment or ``null``.
     */
    __publicField(this, "gas");
    Object.defineProperty(this, internal$1, { value: ConstructorFragmentInternal });
    defineProperties(this, { payable, gas });
  }
  /**
   *  Returns a string representation of this constructor as %%format%%.
   */
  format(format2) {
    assert(format2 != null && format2 !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" });
    if (format2 === "json") {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i4) => JSON.parse(i4.format(format2)))
      });
    }
    const result = [`constructor${joinParams(format2, this.inputs)}`];
    if (this.payable) {
      result.push("payable");
    }
    if (this.gas != null) {
      result.push(`@${this.gas.toString()}`);
    }
    return result.join(" ");
  }
  /**
   *  Returns a new **ConstructorFragment** for %%obj%%.
   */
  static from(obj) {
    if (ConstructorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return ConstructorFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid constuctor fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      consumeKeywords(obj, setify(["constructor"]));
      const inputs = consumeParams(obj);
      const payable = !!consumeKeywords(obj, KwVisibDeploy).has("payable");
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new ConstructorFragment(_guard, "constructor", inputs, payable, gas);
    }
    return new ConstructorFragment(_guard, "constructor", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **ConstructorFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === ConstructorFragmentInternal;
  }
}
class FallbackFragment extends Fragment {
  constructor(guard, inputs, payable) {
    super(guard, "fallback", inputs);
    /**
     *  If the function can be sent value during invocation.
     */
    __publicField(this, "payable");
    Object.defineProperty(this, internal$1, { value: FallbackFragmentInternal });
    defineProperties(this, { payable });
  }
  /**
   *  Returns a string representation of this fallback as %%format%%.
   */
  format(format2) {
    const type2 = this.inputs.length === 0 ? "receive" : "fallback";
    if (format2 === "json") {
      const stateMutability = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type: type2, stateMutability });
    }
    return `${type2}()${this.payable ? " payable" : ""}`;
  }
  /**
   *  Returns a new **FallbackFragment** for %%obj%%.
   */
  static from(obj) {
    if (FallbackFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return FallbackFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid fallback fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const errorObj = obj.toString();
      const topIsValid = obj.peekKeyword(setify(["fallback", "receive"]));
      assertArgument(topIsValid, "type must be fallback or receive", "obj", errorObj);
      const type2 = obj.popKeyword(setify(["fallback", "receive"]));
      if (type2 === "receive") {
        const inputs2 = consumeParams(obj);
        assertArgument(inputs2.length === 0, `receive cannot have arguments`, "obj.inputs", inputs2);
        consumeKeywords(obj, setify(["payable"]));
        consumeEoi(obj);
        return new FallbackFragment(_guard, [], true);
      }
      let inputs = consumeParams(obj);
      if (inputs.length) {
        assertArgument(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map((i4) => i4.format("minimal")).join(", "));
      } else {
        inputs = [ParamType.from("bytes")];
      }
      const mutability = consumeMutability(obj);
      assertArgument(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        const outputs = consumeParams(obj);
        assertArgument(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map((i4) => i4.format("minimal")).join(", "));
      }
      consumeEoi(obj);
      return new FallbackFragment(_guard, inputs, mutability === "payable");
    }
    if (obj.type === "receive") {
      return new FallbackFragment(_guard, [], true);
    }
    if (obj.type === "fallback") {
      const inputs = [ParamType.from("bytes")];
      const payable = obj.stateMutability === "payable";
      return new FallbackFragment(_guard, inputs, payable);
    }
    assertArgument(false, "invalid fallback description", "obj", obj);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FallbackFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === FallbackFragmentInternal;
  }
}
class FunctionFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name, stateMutability, inputs, outputs, gas) {
    super(guard, "function", name, inputs);
    /**
     *  If the function is constant (e.g. ``pure`` or ``view`` functions).
     */
    __publicField(this, "constant");
    /**
     *  The returned types for the result of calling this function.
     */
    __publicField(this, "outputs");
    /**
     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
     *  or ``pure``)
     */
    __publicField(this, "stateMutability");
    /**
     *  If the function can be sent value during invocation.
     */
    __publicField(this, "payable");
    /**
     *  The recommended gas limit to send when calling this function.
     */
    __publicField(this, "gas");
    Object.defineProperty(this, internal$1, { value: FunctionFragmentInternal });
    outputs = Object.freeze(outputs.slice());
    const constant = stateMutability === "view" || stateMutability === "pure";
    const payable = stateMutability === "payable";
    defineProperties(this, { constant, gas, outputs, payable, stateMutability });
  }
  /**
   *  The Function selector.
   */
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this function as %%format%%.
   */
  format(format2) {
    if (format2 == null) {
      format2 = "sighash";
    }
    if (format2 === "json") {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i4) => JSON.parse(i4.format(format2))),
        outputs: this.outputs.map((o3) => JSON.parse(o3.format(format2)))
      });
    }
    const result = [];
    if (format2 !== "sighash") {
      result.push("function");
    }
    result.push(this.name + joinParams(format2, this.inputs));
    if (format2 !== "sighash") {
      if (this.stateMutability !== "nonpayable") {
        result.push(this.stateMutability);
      }
      if (this.outputs && this.outputs.length) {
        result.push("returns");
        result.push(joinParams(format2, this.outputs));
      }
      if (this.gas != null) {
        result.push(`@${this.gas.toString()}`);
      }
    }
    return result.join(" ");
  }
  /**
   *  Return the selector for a function with %%name%% and %%params%%.
   */
  static getSelector(name, params) {
    params = (params || []).map((p2) => ParamType.from(p2));
    const fragment = new FunctionFragment(_guard, name, "view", params, [], null);
    return fragment.selector;
  }
  /**
   *  Returns a new **FunctionFragment** for %%obj%%.
   */
  static from(obj) {
    if (FunctionFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return FunctionFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid function fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("function", obj);
      const inputs = consumeParams(obj);
      const mutability = consumeMutability(obj);
      let outputs = [];
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        outputs = consumeParams(obj);
      }
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);
    }
    let stateMutability = obj.stateMutability;
    if (stateMutability == null) {
      stateMutability = "payable";
      if (typeof obj.constant === "boolean") {
        stateMutability = "view";
        if (!obj.constant) {
          stateMutability = "payable";
          if (typeof obj.payable === "boolean" && !obj.payable) {
            stateMutability = "nonpayable";
          }
        }
      } else if (typeof obj.payable === "boolean" && !obj.payable) {
        stateMutability = "nonpayable";
      }
    }
    return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FunctionFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === FunctionFragmentInternal;
  }
}
class StructFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name, inputs) {
    super(guard, "struct", name, inputs);
    Object.defineProperty(this, internal$1, { value: StructFragmentInternal });
  }
  /**
   *  Returns a string representation of this struct as %%format%%.
   */
  format() {
    throw new Error("@TODO");
  }
  /**
   *  Returns a new **StructFragment** for %%obj%%.
   */
  static from(obj) {
    if (typeof obj === "string") {
      try {
        return StructFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid struct fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("struct", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new StructFragment(_guard, name, inputs);
    }
    return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  // @TODO: fix this return type
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **StructFragment**.
   */
  static isFragment(value) {
    return value && value[internal$1] === StructFragmentInternal;
  }
}
const PanicReasons$1 = /* @__PURE__ */ new Map();
PanicReasons$1.set(0, "GENERIC_PANIC");
PanicReasons$1.set(1, "ASSERT_FALSE");
PanicReasons$1.set(17, "OVERFLOW");
PanicReasons$1.set(18, "DIVIDE_BY_ZERO");
PanicReasons$1.set(33, "ENUM_RANGE_ERROR");
PanicReasons$1.set(34, "BAD_STORAGE_DATA");
PanicReasons$1.set(49, "STACK_UNDERFLOW");
PanicReasons$1.set(50, "ARRAY_RANGE_ERROR");
PanicReasons$1.set(65, "OUT_OF_MEMORY");
PanicReasons$1.set(81, "UNINITIALIZED_FUNCTION_CALL");
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
let defaultCoder = null;
let defaultMaxInflation = 1024;
function getBuiltinCallException(action, tx, data2, abiCoder) {
  let message = "missing revert data";
  let reason = null;
  const invocation = null;
  let revert = null;
  if (data2) {
    message = "execution reverted";
    const bytes2 = getBytes(data2);
    data2 = hexlify(data2);
    if (bytes2.length === 0) {
      message += " (no data present; likely require(false) occurred";
      reason = "require(false)";
    } else if (bytes2.length % 32 !== 4) {
      message += " (could not decode reason; invalid data length)";
    } else if (hexlify(bytes2.slice(0, 4)) === "0x08c379a0") {
      try {
        reason = abiCoder.decode(["string"], bytes2.slice(4))[0];
        revert = {
          signature: "Error(string)",
          name: "Error",
          args: [reason]
        };
        message += `: ${JSON.stringify(reason)}`;
      } catch (error) {
        message += " (could not decode reason; invalid string data)";
      }
    } else if (hexlify(bytes2.slice(0, 4)) === "0x4e487b71") {
      try {
        const code2 = Number(abiCoder.decode(["uint256"], bytes2.slice(4))[0]);
        revert = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [code2]
        };
        reason = `Panic due to ${PanicReasons$1.get(code2) || "UNKNOWN"}(${code2})`;
        message += `: ${reason}`;
      } catch (error) {
        message += " (could not decode panic code)";
      }
    } else {
      message += " (unknown custom error)";
    }
  }
  const transaction = {
    to: tx.to ? getAddress(tx.to) : null,
    data: tx.data || "0x"
  };
  if (tx.from) {
    transaction.from = getAddress(tx.from);
  }
  return makeError(message, "CALL_EXCEPTION", {
    action,
    data: data2,
    reason,
    transaction,
    invocation,
    revert
  });
}
const _AbiCoder = class _AbiCoder {
  constructor() {
    __privateAdd(this, _AbiCoder_instances);
  }
  /**
   *  Get the default values for the given %%types%%.
   *
   *  For example, a ``uint`` is by default ``0`` and ``bool``
   *  is by default ``false``.
   */
  getDefaultValue(types2) {
    const coders = types2.map((type2) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, ParamType.from(type2)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  /**
   *  Encode the %%values%% as the %%types%% into ABI data.
   *
   *  @returns DataHexstring
   */
  encode(types2, values) {
    assertArgumentCount(values.length, types2.length, "types/values length mismatch");
    const coders = types2.map((type2) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, ParamType.from(type2)));
    const coder = new TupleCoder(coders, "_");
    const writer = new Writer();
    coder.encode(writer, values);
    return writer.data;
  }
  /**
   *  Decode the ABI %%data%% as the %%types%% into values.
   *
   *  If %%loose%% decoding is enabled, then strict padding is
   *  not enforced. Some older versions of Solidity incorrectly
   *  padded event data emitted from ``external`` functions.
   */
  decode(types2, data2, loose) {
    const coders = types2.map((type2) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, ParamType.from(type2)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(new Reader(data2, loose, defaultMaxInflation));
  }
  static _setDefaultMaxInflation(value) {
    assertArgument(typeof value === "number" && Number.isInteger(value), "invalid defaultMaxInflation factor", "value", value);
    defaultMaxInflation = value;
  }
  /**
   *  Returns the shared singleton instance of a default [[AbiCoder]].
   *
   *  On the first call, the instance is created internally.
   */
  static defaultAbiCoder() {
    if (defaultCoder == null) {
      defaultCoder = new _AbiCoder();
    }
    return defaultCoder;
  }
  /**
   *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
   *  result %%data%% for the [[CallExceptionAction]] %%action%% against
   *  the Transaction %%tx%%.
   */
  static getBuiltinCallException(action, tx, data2) {
    return getBuiltinCallException(action, tx, data2, _AbiCoder.defaultAbiCoder());
  }
};
_AbiCoder_instances = new WeakSet();
getCoder_fn = function(param) {
  if (param.isArray()) {
    return new ArrayCoder(__privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, param.arrayChildren), param.arrayLength, param.name);
  }
  if (param.isTuple()) {
    return new TupleCoder(param.components.map((c2) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, c2)), param.name);
  }
  switch (param.baseType) {
    case "address":
      return new AddressCoder(param.name);
    case "bool":
      return new BooleanCoder(param.name);
    case "string":
      return new StringCoder(param.name);
    case "bytes":
      return new BytesCoder(param.name);
    case "":
      return new NullCoder(param.name);
  }
  let match = param.type.match(paramTypeNumber);
  if (match) {
    let size2 = parseInt(match[2] || "256");
    assertArgument(size2 !== 0 && size2 <= 256 && size2 % 8 === 0, "invalid " + match[1] + " bit length", "param", param);
    return new NumberCoder(size2 / 8, match[1] === "int", param.name);
  }
  match = param.type.match(paramTypeBytes);
  if (match) {
    let size2 = parseInt(match[1]);
    assertArgument(size2 !== 0 && size2 <= 32, "invalid bytes length", "param", param);
    return new FixedBytesCoder(size2, param.name);
  }
  assertArgument(false, "invalid type", "type", param.type);
};
let AbiCoder = _AbiCoder;
class LogDescription {
  /**
   *  @_ignore:
   */
  constructor(fragment, topic, args) {
    /**
     *  The matching fragment for the ``topic0``.
     */
    __publicField(this, "fragment");
    /**
     *  The name of the Event.
     */
    __publicField(this, "name");
    /**
     *  The full Event signature.
     */
    __publicField(this, "signature");
    /**
     *  The topic hash for the Event.
     */
    __publicField(this, "topic");
    /**
     *  The arguments passed into the Event with ``emit``.
     */
    __publicField(this, "args");
    const name = fragment.name, signature2 = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      signature: signature2,
      topic,
      args
    });
  }
}
class TransactionDescription {
  /**
   *  @_ignore:
   */
  constructor(fragment, selector, args, value) {
    /**
     *  The matching fragment from the transaction ``data``.
     */
    __publicField(this, "fragment");
    /**
     *  The name of the Function from the transaction ``data``.
     */
    __publicField(this, "name");
    /**
     *  The arguments passed to the Function from the transaction ``data``.
     */
    __publicField(this, "args");
    /**
     *  The full Function signature from the transaction ``data``.
     */
    __publicField(this, "signature");
    /**
     *  The selector for the Function from the transaction ``data``.
     */
    __publicField(this, "selector");
    /**
     *  The ``value`` (in wei) from the transaction.
     */
    __publicField(this, "value");
    const name = fragment.name, signature2 = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      args,
      signature: signature2,
      selector,
      value
    });
  }
}
class ErrorDescription {
  /**
   *  @_ignore:
   */
  constructor(fragment, selector, args) {
    /**
     *  The matching fragment.
     */
    __publicField(this, "fragment");
    /**
     *  The name of the Error.
     */
    __publicField(this, "name");
    /**
     *  The arguments passed to the Error with ``revert``.
     */
    __publicField(this, "args");
    /**
     *  The full Error signature.
     */
    __publicField(this, "signature");
    /**
     *  The selector for the Error.
     */
    __publicField(this, "selector");
    const name = fragment.name, signature2 = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      args,
      signature: signature2,
      selector
    });
  }
}
class Indexed {
  /**
   *  @_ignore:
   */
  constructor(hash3) {
    /**
     *  The ``keccak256`` of the value logged.
     */
    __publicField(this, "hash");
    /**
     *  @_ignore:
     */
    __publicField(this, "_isIndexed");
    defineProperties(this, { hash: hash3, _isIndexed: true });
  }
  /**
   *  Returns ``true`` if %%value%% is an **Indexed**.
   *
   *  This provides a Type Guard for property access.
   */
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
}
const PanicReasons = {
  "0": "generic panic",
  "1": "assert(false)",
  "17": "arithmetic overflow",
  "18": "division or modulo by zero",
  "33": "enum overflow",
  "34": "invalid encoded storage byte array accessed",
  "49": "out-of-bounds array access; popping on an empty array",
  "50": "out-of-bounds access of an array or bytesN",
  "65": "out of memory",
  "81": "uninitialized function"
};
const BuiltinErrors = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (message) => {
      return `reverted with reason string ${JSON.stringify(message)}`;
    }
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (code2) => {
      let reason = "unknown panic code";
      if (code2 >= 0 && code2 <= 255 && PanicReasons[code2.toString()]) {
        reason = PanicReasons[code2.toString()];
      }
      return `reverted with panic code 0x${code2.toString(16)} (${reason})`;
    }
  }
};
const _Interface = class _Interface {
  /**
   *  Create a new Interface for the %%fragments%%.
   */
  constructor(fragments) {
    __privateAdd(this, _Interface_instances);
    /**
     *  All the Contract ABI members (i.e. methods, events, errors, etc).
     */
    __publicField(this, "fragments");
    /**
     *  The Contract constructor.
     */
    __publicField(this, "deploy");
    /**
     *  The Fallback method, if any.
     */
    __publicField(this, "fallback");
    /**
     *  If receiving ether is supported.
     */
    __publicField(this, "receive");
    __privateAdd(this, _errors);
    __privateAdd(this, _events);
    __privateAdd(this, _functions);
    //    #structs: Map<string, StructFragment>;
    __privateAdd(this, _abiCoder);
    let abi = [];
    if (typeof fragments === "string") {
      abi = JSON.parse(fragments);
    } else {
      abi = fragments;
    }
    __privateSet(this, _functions, /* @__PURE__ */ new Map());
    __privateSet(this, _errors, /* @__PURE__ */ new Map());
    __privateSet(this, _events, /* @__PURE__ */ new Map());
    const frags = [];
    for (const a2 of abi) {
      try {
        frags.push(Fragment.from(a2));
      } catch (error) {
        console.log(`[Warning] Invalid Fragment ${JSON.stringify(a2)}:`, error.message);
      }
    }
    defineProperties(this, {
      fragments: Object.freeze(frags)
    });
    let fallback2 = null;
    let receive = false;
    __privateSet(this, _abiCoder, this.getAbiCoder());
    this.fragments.forEach((fragment, index2) => {
      let bucket;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          defineProperties(this, { deploy: fragment });
          return;
        case "fallback":
          if (fragment.inputs.length === 0) {
            receive = true;
          } else {
            assertArgument(!fallback2 || fragment.payable !== fallback2.payable, "conflicting fallback fragments", `fragments[${index2}]`, fragment);
            fallback2 = fragment;
            receive = fallback2.payable;
          }
          return;
        case "function":
          bucket = __privateGet(this, _functions);
          break;
        case "event":
          bucket = __privateGet(this, _events);
          break;
        case "error":
          bucket = __privateGet(this, _errors);
          break;
        default:
          return;
      }
      const signature2 = fragment.format();
      if (bucket.has(signature2)) {
        return;
      }
      bucket.set(signature2, fragment);
    });
    if (!this.deploy) {
      defineProperties(this, {
        deploy: ConstructorFragment.from("constructor()")
      });
    }
    defineProperties(this, { fallback: fallback2, receive });
  }
  /**
   *  Returns the entire Human-Readable ABI, as an array of
   *  signatures, optionally as %%minimal%% strings, which
   *  removes parameter names and unneceesary spaces.
   */
  format(minimal) {
    const format2 = minimal ? "minimal" : "full";
    const abi = this.fragments.map((f6) => f6.format(format2));
    return abi;
  }
  /**
   *  Return the JSON-encoded ABI. This is the format Solidiy
   *  returns.
   */
  formatJson() {
    const abi = this.fragments.map((f6) => f6.format("json"));
    return JSON.stringify(abi.map((j2) => JSON.parse(j2)));
  }
  /**
   *  The ABI coder that will be used to encode and decode binary
   *  data.
   */
  getAbiCoder() {
    return AbiCoder.defaultAbiCoder();
  }
  /**
   *  Get the function name for %%key%%, which may be a function selector,
   *  function name or function signature that belongs to the ABI.
   */
  getFunctionName(key2) {
    const fragment = __privateMethod(this, _Interface_instances, getFunction_fn).call(this, key2, null, false);
    assertArgument(fragment, "no matching function", "key", key2);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (a function selector, function name or
   *  function signature) is present in the ABI.
   *
   *  In the case of a function name, the name may be ambiguous, so
   *  accessing the [[FunctionFragment]] may require refinement.
   */
  hasFunction(key2) {
    return !!__privateMethod(this, _Interface_instances, getFunction_fn).call(this, key2, null, false);
  }
  /**
   *  Get the [[FunctionFragment]] for %%key%%, which may be a function
   *  selector, function name or function signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple functions match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single function in
   *  the ABI, this will throw.
   */
  getFunction(key2, values) {
    return __privateMethod(this, _Interface_instances, getFunction_fn).call(this, key2, values || null, true);
  }
  /**
   *  Iterate over all functions, calling %%callback%%, sorted by their name.
   */
  forEachFunction(callback) {
    const names2 = Array.from(__privateGet(this, _functions).keys());
    names2.sort((a2, b2) => a2.localeCompare(b2));
    for (let i4 = 0; i4 < names2.length; i4++) {
      const name = names2[i4];
      callback(__privateGet(this, _functions).get(name), i4);
    }
  }
  /**
   *  Get the event name for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   */
  getEventName(key2) {
    const fragment = __privateMethod(this, _Interface_instances, getEvent_fn).call(this, key2, null, false);
    assertArgument(fragment, "no matching event", "key", key2);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (an event topic hash, event name or
   *  event signature) is present in the ABI.
   *
   *  In the case of an event name, the name may be ambiguous, so
   *  accessing the [[EventFragment]] may require refinement.
   */
  hasEvent(key2) {
    return !!__privateMethod(this, _Interface_instances, getEvent_fn).call(this, key2, null, false);
  }
  /**
   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple events match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single event in
   *  the ABI, this will throw.
   */
  getEvent(key2, values) {
    return __privateMethod(this, _Interface_instances, getEvent_fn).call(this, key2, values || null, true);
  }
  /**
   *  Iterate over all events, calling %%callback%%, sorted by their name.
   */
  forEachEvent(callback) {
    const names2 = Array.from(__privateGet(this, _events).keys());
    names2.sort((a2, b2) => a2.localeCompare(b2));
    for (let i4 = 0; i4 < names2.length; i4++) {
      const name = names2[i4];
      callback(__privateGet(this, _events).get(name), i4);
    }
  }
  /**
   *  Get the [[ErrorFragment]] for %%key%%, which may be an error
   *  selector, error name or error signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple errors match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single error in
   *  the ABI, this will throw.
   */
  getError(key2, values) {
    if (isHexString(key2)) {
      const selector = key2.toLowerCase();
      if (BuiltinErrors[selector]) {
        return ErrorFragment.from(BuiltinErrors[selector].signature);
      }
      for (const fragment of __privateGet(this, _errors).values()) {
        if (selector === fragment.selector) {
          return fragment;
        }
      }
      return null;
    }
    if (key2.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of __privateGet(this, _errors)) {
        if (name.split(
          "("
          /* fix:) */
        )[0] === key2) {
          matching.push(fragment);
        }
      }
      if (matching.length === 0) {
        if (key2 === "Error") {
          return ErrorFragment.from("error Error(string)");
        }
        if (key2 === "Panic") {
          return ErrorFragment.from("error Panic(uint256)");
        }
        return null;
      } else if (matching.length > 1) {
        const matchStr = matching.map((m4) => JSON.stringify(m4.format())).join(", ");
        assertArgument(false, `ambiguous error description (i.e. ${matchStr})`, "name", key2);
      }
      return matching[0];
    }
    key2 = ErrorFragment.from(key2).format();
    if (key2 === "Error(string)") {
      return ErrorFragment.from("error Error(string)");
    }
    if (key2 === "Panic(uint256)") {
      return ErrorFragment.from("error Panic(uint256)");
    }
    const result = __privateGet(this, _errors).get(key2);
    if (result) {
      return result;
    }
    return null;
  }
  /**
   *  Iterate over all errors, calling %%callback%%, sorted by their name.
   */
  forEachError(callback) {
    const names2 = Array.from(__privateGet(this, _errors).keys());
    names2.sort((a2, b2) => a2.localeCompare(b2));
    for (let i4 = 0; i4 < names2.length; i4++) {
      const name = names2[i4];
      callback(__privateGet(this, _errors).get(name), i4);
    }
  }
  // Get the 4-byte selector used by Solidity to identify a function
  /*
  getSelector(fragment: ErrorFragment | FunctionFragment): string {
      if (typeof(fragment) === "string") {
          const matches: Array<Fragment> = [ ];
  
          try { matches.push(this.getFunction(fragment)); } catch (error) { }
          try { matches.push(this.getError(<string>fragment)); } catch (_) { }
  
          if (matches.length === 0) {
              logger.throwArgumentError("unknown fragment", "key", fragment);
          } else if (matches.length > 1) {
              logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
          }
  
          fragment = matches[0];
      }
  
      return dataSlice(id(fragment.format()), 0, 4);
  }
      */
  // Get the 32-byte topic hash used by Solidity to identify an event
  /*
  getEventTopic(fragment: EventFragment): string {
      //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
      return id(fragment.format());
  }
  */
  _decodeParams(params, data2) {
    return __privateGet(this, _abiCoder).decode(params, data2);
  }
  _encodeParams(params, values) {
    return __privateGet(this, _abiCoder).encode(params, values);
  }
  /**
   *  Encodes a ``tx.data`` object for deploying the Contract with
   *  the %%values%% as the constructor arguments.
   */
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified error (see [[getError]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeErrorResult(fragment, data2) {
    if (typeof fragment === "string") {
      const f6 = this.getError(fragment);
      assertArgument(f6, "unknown error", "fragment", fragment);
      fragment = f6;
    }
    assertArgument(dataSlice(data2, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, "data", data2);
    return this._decodeParams(fragment.inputs, dataSlice(data2, 4));
  }
  /**
   *  Encodes the transaction revert data for a call result that
   *  reverted from the the Contract with the sepcified %%error%%
   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      const f6 = this.getError(fragment);
      assertArgument(f6, "unknown error", "fragment", fragment);
      fragment = f6;
    }
    return concat([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  /**
   *  Decodes the %%data%% from a transaction ``tx.data`` for
   *  the function specified (see [[getFunction]] for valid values
   *  for %%fragment%%).
   *
   *  Most developers should prefer the [[parseTransaction]] method
   *  instead, which will automatically detect the fragment.
   */
  decodeFunctionData(fragment, data2) {
    if (typeof fragment === "string") {
      const f6 = this.getFunction(fragment);
      assertArgument(f6, "unknown function", "fragment", fragment);
      fragment = f6;
    }
    assertArgument(dataSlice(data2, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, "data", data2);
    return this._decodeParams(fragment.inputs, dataSlice(data2, 4));
  }
  /**
   *  Encodes the ``tx.data`` for a transaction that calls the function
   *  specified (see [[getFunction]] for valid values for %%fragment%%) with
   *  the %%values%%.
   */
  encodeFunctionData(fragment, values) {
    if (typeof fragment === "string") {
      const f6 = this.getFunction(fragment);
      assertArgument(f6, "unknown function", "fragment", fragment);
      fragment = f6;
    }
    return concat([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeFunctionResult(fragment, data2) {
    if (typeof fragment === "string") {
      const f6 = this.getFunction(fragment);
      assertArgument(f6, "unknown function", "fragment", fragment);
      fragment = f6;
    }
    let message = "invalid length for result data";
    const bytes2 = getBytesCopy(data2);
    if (bytes2.length % 32 === 0) {
      try {
        return __privateGet(this, _abiCoder).decode(fragment.outputs, bytes2);
      } catch (error) {
        message = "could not decode result data";
      }
    }
    assert(false, message, "BAD_DATA", {
      value: hexlify(bytes2),
      info: { method: fragment.name, signature: fragment.format() }
    });
  }
  makeError(_data4, tx) {
    const data2 = getBytes(_data4, "data");
    const error = AbiCoder.getBuiltinCallException("call", tx, data2);
    const customPrefix = "execution reverted (unknown custom error)";
    if (error.message.startsWith(customPrefix)) {
      const selector = hexlify(data2.slice(0, 4));
      const ef = this.getError(selector);
      if (ef) {
        try {
          const args = __privateGet(this, _abiCoder).decode(ef.inputs, data2.slice(4));
          error.revert = {
            name: ef.name,
            signature: ef.format(),
            args
          };
          error.reason = error.revert.signature;
          error.message = `execution reverted: ${error.reason}`;
        } catch (e3) {
          error.message = `execution reverted (coult not decode custom error)`;
        }
      }
    }
    const parsed = this.parseTransaction(tx);
    if (parsed) {
      error.invocation = {
        method: parsed.name,
        signature: parsed.signature,
        args: parsed.args
      };
    }
    return error;
  }
  /**
   *  Encodes the result data (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values
   *  for %%fragment%%) with %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeFunctionResult(fragment, values) {
    if (typeof fragment === "string") {
      const f6 = this.getFunction(fragment);
      assertArgument(f6, "unknown function", "fragment", fragment);
      fragment = f6;
    }
    return hexlify(__privateGet(this, _abiCoder).encode(fragment.outputs, values || []));
  }
  /*
      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
          const promises: Array<Promise<>> = [ ];
          const process = function(type: ParamType, value: any): any {
              if (type.baseType === "array") {
                  return descend(type.child
              }
              if (type. === "address") {
              }
          };
  
          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
              if (inputs.length !== values.length) { throw new Error("length mismatch"); }
              
          };
  
          const result: Array<any> = [ ];
          values.forEach((value, index) => {
              if (value == null) {
                  topics.push(null);
              } else if (param.baseType === "array" || param.baseType === "tuple") {
                  logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
              } else if (Array.isArray(value)) {
                  topics.push(value.map((value) => encodeTopic(param, value)));
              } else {
                  topics.push(encodeTopic(param, value));
              }
          });
      }
  */
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(fragment, values) {
    if (typeof fragment === "string") {
      const f6 = this.getEvent(fragment);
      assertArgument(f6, "unknown event", "eventFragment", fragment);
      fragment = f6;
    }
    assert(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, "UNEXPECTED_ARGUMENT", { count: values.length, expectedCount: fragment.inputs.length });
    const topics = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id(value);
      } else if (param.type === "bytes") {
        return keccak256$1(hexlify(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      } else if (param.type.match(/^u?int/)) {
        value = toBeHex(value);
      } else if (param.type.match(/^bytes/)) {
        value = zeroPadBytes(value, 32);
      } else if (param.type === "address") {
        __privateGet(this, _abiCoder).encode(["address"], [value]);
      }
      return zeroPadValue(hexlify(value), 32);
    };
    values.forEach((value, index2) => {
      const param = fragment.inputs[index2];
      if (!param.indexed) {
        assertArgument(value == null, "cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        assertArgument(false, "filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(fragment, values) {
    if (typeof fragment === "string") {
      const f6 = this.getEvent(fragment);
      assertArgument(f6, "unknown event", "eventFragment", fragment);
      fragment = f6;
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    assertArgument(values.length === fragment.inputs.length, "event arguments/values mismatch", "values", values);
    fragment.inputs.forEach((param, index2) => {
      const value = values[index2];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id(value));
        } else if (param.type === "bytes") {
          topics.push(keccak256$1(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(__privateGet(this, _abiCoder).encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: __privateGet(this, _abiCoder).encode(dataTypes, dataValues),
      topics
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(fragment, data2, topics) {
    if (typeof fragment === "string") {
      const f6 = this.getEvent(fragment);
      assertArgument(f6, "unknown event", "eventFragment", fragment);
      fragment = f6;
    }
    if (topics != null && !fragment.anonymous) {
      const eventTopic = fragment.topicHash;
      assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
      topics = topics.slice(1);
    }
    const indexed = [];
    const nonIndexed = [];
    const dynamic = [];
    fragment.inputs.forEach((param, index2) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.from({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    const resultIndexed = topics != null ? __privateGet(this, _abiCoder).decode(indexed, concat(topics)) : null;
    const resultNonIndexed = __privateGet(this, _abiCoder).decode(nonIndexed, data2, true);
    const values = [];
    const keys2 = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    fragment.inputs.forEach((param, index2) => {
      let value = null;
      if (param.indexed) {
        if (resultIndexed == null) {
          value = new Indexed(null);
        } else if (dynamic[index2]) {
          value = new Indexed(resultIndexed[indexedIndex++]);
        } else {
          try {
            value = resultIndexed[indexedIndex++];
          } catch (error) {
            value = error;
          }
        }
      } else {
        try {
          value = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          value = error;
        }
      }
      values.push(value);
      keys2.push(param.name || null);
    });
    return Result.fromItems(values, keys2);
  }
  /**
   *  Parses a transaction, finding the matching function and extracts
   *  the parameter values along with other useful function details.
   *
   *  If the matching function cannot be found, return null.
   */
  parseTransaction(tx) {
    const data2 = getBytes(tx.data, "tx.data");
    const value = getBigInt(tx.value != null ? tx.value : 0, "tx.value");
    const fragment = this.getFunction(hexlify(data2.slice(0, 4)));
    if (!fragment) {
      return null;
    }
    const args = __privateGet(this, _abiCoder).decode(fragment.inputs, data2.slice(4));
    return new TransactionDescription(fragment, fragment.selector, args, value);
  }
  parseCallResult(data2) {
    throw new Error("@TODO");
  }
  /**
   *  Parses a receipt log, finding the matching event and extracts
   *  the parameter values along with other useful event details.
   *
   *  If the matching event cannot be found, returns null.
   */
  parseLog(log2) {
    const fragment = this.getEvent(log2.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log2.data, log2.topics));
  }
  /**
   *  Parses a revert data, finding the matching error and extracts
   *  the parameter values along with other useful error details.
   *
   *  If the matching error cannot be found, returns null.
   */
  parseError(data2) {
    const hexData = hexlify(data2);
    const fragment = this.getError(dataSlice(hexData, 0, 4));
    if (!fragment) {
      return null;
    }
    const args = __privateGet(this, _abiCoder).decode(fragment.inputs, dataSlice(hexData, 4));
    return new ErrorDescription(fragment, fragment.selector, args);
  }
  /**
   *  Creates a new [[Interface]] from the ABI %%value%%.
   *
   *  The %%value%% may be provided as an existing [[Interface]] object,
   *  a JSON-encoded ABI or any Human-Readable ABI format.
   */
  static from(value) {
    if (value instanceof _Interface) {
      return value;
    }
    if (typeof value === "string") {
      return new _Interface(JSON.parse(value));
    }
    if (typeof value.formatJson === "function") {
      return new _Interface(value.formatJson());
    }
    if (typeof value.format === "function") {
      return new _Interface(value.format("json"));
    }
    return new _Interface(value);
  }
};
_errors = new WeakMap();
_events = new WeakMap();
_functions = new WeakMap();
_abiCoder = new WeakMap();
_Interface_instances = new WeakSet();
// Find a function definition by any means necessary (unless it is ambiguous)
getFunction_fn = function(key2, values, forceUnique) {
  if (isHexString(key2)) {
    const selector = key2.toLowerCase();
    for (const fragment of __privateGet(this, _functions).values()) {
      if (selector === fragment.selector) {
        return fragment;
      }
    }
    return null;
  }
  if (key2.indexOf("(") === -1) {
    const matching = [];
    for (const [name, fragment] of __privateGet(this, _functions)) {
      if (name.split(
        "("
        /* fix:) */
      )[0] === key2) {
        matching.push(fragment);
      }
    }
    if (values) {
      const lastValue = values.length > 0 ? values[values.length - 1] : null;
      let valueLength = values.length;
      let allowOptions = true;
      if (Typed.isTyped(lastValue) && lastValue.type === "overrides") {
        allowOptions = false;
        valueLength--;
      }
      for (let i4 = matching.length - 1; i4 >= 0; i4--) {
        const inputs = matching[i4].inputs.length;
        if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
          matching.splice(i4, 1);
        }
      }
      for (let i4 = matching.length - 1; i4 >= 0; i4--) {
        const inputs = matching[i4].inputs;
        for (let j2 = 0; j2 < values.length; j2++) {
          if (!Typed.isTyped(values[j2])) {
            continue;
          }
          if (j2 >= inputs.length) {
            if (values[j2].type === "overrides") {
              continue;
            }
            matching.splice(i4, 1);
            break;
          }
          if (values[j2].type !== inputs[j2].baseType) {
            matching.splice(i4, 1);
            break;
          }
        }
      }
    }
    if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {
      const lastArg = values[values.length - 1];
      if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== "object") {
        matching.splice(0, 1);
      }
    }
    if (matching.length === 0) {
      return null;
    }
    if (matching.length > 1 && forceUnique) {
      const matchStr = matching.map((m4) => JSON.stringify(m4.format())).join(", ");
      assertArgument(false, `ambiguous function description (i.e. matches ${matchStr})`, "key", key2);
    }
    return matching[0];
  }
  const result = __privateGet(this, _functions).get(FunctionFragment.from(key2).format());
  if (result) {
    return result;
  }
  return null;
};
// Find an event definition by any means necessary (unless it is ambiguous)
getEvent_fn = function(key2, values, forceUnique) {
  if (isHexString(key2)) {
    const eventTopic = key2.toLowerCase();
    for (const fragment of __privateGet(this, _events).values()) {
      if (eventTopic === fragment.topicHash) {
        return fragment;
      }
    }
    return null;
  }
  if (key2.indexOf("(") === -1) {
    const matching = [];
    for (const [name, fragment] of __privateGet(this, _events)) {
      if (name.split(
        "("
        /* fix:) */
      )[0] === key2) {
        matching.push(fragment);
      }
    }
    if (values) {
      for (let i4 = matching.length - 1; i4 >= 0; i4--) {
        if (matching[i4].inputs.length < values.length) {
          matching.splice(i4, 1);
        }
      }
      for (let i4 = matching.length - 1; i4 >= 0; i4--) {
        const inputs = matching[i4].inputs;
        for (let j2 = 0; j2 < values.length; j2++) {
          if (!Typed.isTyped(values[j2])) {
            continue;
          }
          if (values[j2].type !== inputs[j2].baseType) {
            matching.splice(i4, 1);
            break;
          }
        }
      }
    }
    if (matching.length === 0) {
      return null;
    }
    if (matching.length > 1 && forceUnique) {
      const matchStr = matching.map((m4) => JSON.stringify(m4.format())).join(", ");
      assertArgument(false, `ambiguous event description (i.e. matches ${matchStr})`, "key", key2);
    }
    return matching[0];
  }
  const result = __privateGet(this, _events).get(EventFragment.from(key2).format());
  if (result) {
    return result;
  }
  return null;
};
let Interface = _Interface;
const BN_0$2 = BigInt(0);
function getValue(value) {
  if (value == null) {
    return null;
  }
  return value;
}
function toJson(value) {
  if (value == null) {
    return null;
  }
  return value.toString();
}
class FeeData {
  /**
   *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
   *  %%maxPriorityFeePerGas%%.
   */
  constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {
    /**
     *  The gas price for legacy networks.
     */
    __publicField(this, "gasPrice");
    /**
     *  The maximum fee to pay per gas.
     *
     *  The base fee per gas is defined by the network and based on
     *  congestion, increasing the cost during times of heavy load
     *  and lowering when less busy.
     *
     *  The actual fee per gas will be the base fee for the block
     *  and the priority fee, up to the max fee per gas.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    __publicField(this, "maxFeePerGas");
    /**
     *  The additional amout to pay per gas to encourage a validator
     *  to include the transaction.
     *
     *  The purpose of this is to compensate the validator for the
     *  adjusted risk for including a given transaction.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    __publicField(this, "maxPriorityFeePerGas");
    defineProperties(this, {
      gasPrice: getValue(gasPrice),
      maxFeePerGas: getValue(maxFeePerGas),
      maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)
    });
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;
    return {
      _type: "FeeData",
      gasPrice: toJson(gasPrice),
      maxFeePerGas: toJson(maxFeePerGas),
      maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)
    };
  }
}
function copyRequest(req) {
  const result = {};
  if (req.to) {
    result.to = req.to;
  }
  if (req.from) {
    result.from = req.from;
  }
  if (req.data) {
    result.data = hexlify(req.data);
  }
  const bigIntKeys = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  for (const key2 of bigIntKeys) {
    if (!(key2 in req) || req[key2] == null) {
      continue;
    }
    result[key2] = getBigInt(req[key2], `request.${key2}`);
  }
  const numberKeys = "type,nonce".split(/,/);
  for (const key2 of numberKeys) {
    if (!(key2 in req) || req[key2] == null) {
      continue;
    }
    result[key2] = getNumber(req[key2], `request.${key2}`);
  }
  if (req.accessList) {
    result.accessList = accessListify(req.accessList);
  }
  if ("blockTag" in req) {
    result.blockTag = req.blockTag;
  }
  if ("enableCcipRead" in req) {
    result.enableCcipRead = !!req.enableCcipRead;
  }
  if ("customData" in req) {
    result.customData = req.customData;
  }
  if ("blobVersionedHashes" in req && req.blobVersionedHashes) {
    result.blobVersionedHashes = req.blobVersionedHashes.slice();
  }
  if ("kzg" in req) {
    result.kzg = req.kzg;
  }
  if ("blobs" in req && req.blobs) {
    result.blobs = req.blobs.map((b2) => {
      if (isBytesLike(b2)) {
        return hexlify(b2);
      }
      return Object.assign({}, b2);
    });
  }
  return result;
}
class Block {
  /**
   *  Create a new **Block** object.
   *
   *  This should generally not be necessary as the unless implementing a
   *  low-level library.
   */
  constructor(block, provider) {
    /**
     *  The provider connected to the block used to fetch additional details
     *  if necessary.
     */
    __publicField(this, "provider");
    /**
     *  The block number, sometimes called the block height. This is a
     *  sequential number that is one higher than the parent block.
     */
    __publicField(this, "number");
    /**
     *  The block hash.
     *
     *  This hash includes all properties, so can be safely used to identify
     *  an exact set of block properties.
     */
    __publicField(this, "hash");
    /**
     *  The timestamp for this block, which is the number of seconds since
     *  epoch that this block was included.
     */
    __publicField(this, "timestamp");
    /**
     *  The block hash of the parent block.
     */
    __publicField(this, "parentHash");
    /**
     *  The hash tree root of the parent beacon block for the given
     *  execution block. See [[link-eip-4788]].
     */
    __publicField(this, "parentBeaconBlockRoot");
    /**
     *  The nonce.
     *
     *  On legacy networks, this is the random number inserted which
     *  permitted the difficulty target to be reached.
     */
    __publicField(this, "nonce");
    /**
     *  The difficulty target.
     *
     *  On legacy networks, this is the proof-of-work target required
     *  for a block to meet the protocol rules to be included.
     *
     *  On modern networks, this is a random number arrived at using
     *  randao.  @TODO: Find links?
     */
    __publicField(this, "difficulty");
    /**
     *  The total gas limit for this block.
     */
    __publicField(this, "gasLimit");
    /**
     *  The total gas used in this block.
     */
    __publicField(this, "gasUsed");
    /**
     *  The root hash for the global state after applying changes
     *  in this block.
     */
    __publicField(this, "stateRoot");
    /**
     *  The hash of the transaction receipts trie.
     */
    __publicField(this, "receiptsRoot");
    /**
     *  The total amount of blob gas consumed by the transactions
     *  within the block. See [[link-eip-4844]].
     */
    __publicField(this, "blobGasUsed");
    /**
     *  The running total of blob gas consumed in excess of the
     *  target, prior to the block. See [[link-eip-4844]].
     */
    __publicField(this, "excessBlobGas");
    /**
     *  The miner coinbase address, wihch receives any subsidies for
     *  including this block.
     */
    __publicField(this, "miner");
    /**
     *  The latest RANDAO mix of the post beacon state of
     *  the previous block.
     */
    __publicField(this, "prevRandao");
    /**
     *  Any extra data the validator wished to include.
     */
    __publicField(this, "extraData");
    /**
     *  The base fee per gas that all transactions in this block were
     *  charged.
     *
     *  This adjusts after each block, depending on how congested the network
     *  is.
     */
    __publicField(this, "baseFeePerGas");
    __privateAdd(this, _transactions);
    __privateSet(this, _transactions, block.transactions.map((tx) => {
      if (typeof tx !== "string") {
        return new TransactionResponse(tx, provider);
      }
      return tx;
    }));
    defineProperties(this, {
      provider,
      hash: getValue(block.hash),
      number: block.number,
      timestamp: block.timestamp,
      parentHash: block.parentHash,
      parentBeaconBlockRoot: block.parentBeaconBlockRoot,
      nonce: block.nonce,
      difficulty: block.difficulty,
      gasLimit: block.gasLimit,
      gasUsed: block.gasUsed,
      blobGasUsed: block.blobGasUsed,
      excessBlobGas: block.excessBlobGas,
      miner: block.miner,
      prevRandao: getValue(block.prevRandao),
      extraData: block.extraData,
      baseFeePerGas: getValue(block.baseFeePerGas),
      stateRoot: block.stateRoot,
      receiptsRoot: block.receiptsRoot
    });
  }
  /**
   *  Returns the list of transaction hashes, in the order
   *  they were executed within the block.
   */
  get transactions() {
    return __privateGet(this, _transactions).map((tx) => {
      if (typeof tx === "string") {
        return tx;
      }
      return tx.hash;
    });
  }
  /**
   *  Returns the complete transactions, in the order they
   *  were executed within the block.
   *
   *  This is only available for blocks which prefetched
   *  transactions, by passing ``true`` to %%prefetchTxs%%
   *  into [[Provider-getBlock]].
   */
  get prefetchedTransactions() {
    const txs = __privateGet(this, _transactions).slice();
    if (txs.length === 0) {
      return [];
    }
    assert(typeof txs[0] === "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
      operation: "transactionResponses()"
    });
    return txs;
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash: hash3, miner, prevRandao, nonce, number: number2, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp, transactions } = this;
    return {
      _type: "Block",
      baseFeePerGas: toJson(baseFeePerGas),
      difficulty: toJson(difficulty),
      extraData,
      gasLimit: toJson(gasLimit),
      gasUsed: toJson(gasUsed),
      blobGasUsed: toJson(this.blobGasUsed),
      excessBlobGas: toJson(this.excessBlobGas),
      hash: hash3,
      miner,
      prevRandao,
      nonce,
      number: number2,
      parentHash,
      timestamp,
      parentBeaconBlockRoot,
      stateRoot,
      receiptsRoot,
      transactions
    };
  }
  [Symbol.iterator]() {
    let index2 = 0;
    const txs = this.transactions;
    return {
      next: () => {
        if (index2 < this.length) {
          return {
            value: txs[index2++],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The number of transactions in this block.
   */
  get length() {
    return __privateGet(this, _transactions).length;
  }
  /**
   *  The [[link-js-date]] this block was included at.
   */
  get date() {
    if (this.timestamp == null) {
      return null;
    }
    return new Date(this.timestamp * 1e3);
  }
  /**
   *  Get the transaction at %%indexe%% within this block.
   */
  async getTransaction(indexOrHash) {
    let tx = void 0;
    if (typeof indexOrHash === "number") {
      tx = __privateGet(this, _transactions)[indexOrHash];
    } else {
      const hash3 = indexOrHash.toLowerCase();
      for (const v2 of __privateGet(this, _transactions)) {
        if (typeof v2 === "string") {
          if (v2 !== hash3) {
            continue;
          }
          tx = v2;
          break;
        } else {
          if (v2.hash === hash3) {
            continue;
          }
          tx = v2;
          break;
        }
      }
    }
    if (tx == null) {
      throw new Error("no such tx");
    }
    if (typeof tx === "string") {
      return await this.provider.getTransaction(tx);
    } else {
      return tx;
    }
  }
  /**
   *  If a **Block** was fetched with a request to include the transactions
   *  this will allow synchronous access to those transactions.
   *
   *  If the transactions were not prefetched, this will throw.
   */
  getPrefetchedTransaction(indexOrHash) {
    const txs = this.prefetchedTransactions;
    if (typeof indexOrHash === "number") {
      return txs[indexOrHash];
    }
    indexOrHash = indexOrHash.toLowerCase();
    for (const tx of txs) {
      if (tx.hash === indexOrHash) {
        return tx;
      }
    }
    assertArgument(false, "no matching transaction", "indexOrHash", indexOrHash);
  }
  /**
   *  Returns true if this block been mined. This provides a type guard
   *  for all properties on a [[MinedBlock]].
   */
  isMined() {
    return !!this.hash;
  }
  /**
   *  Returns true if this block is an [[link-eip-2930]] block.
   */
  isLondon() {
    return !!this.baseFeePerGas;
  }
  /**
   *  @_ignore:
   */
  orphanedEvent() {
    if (!this.isMined()) {
      throw new Error("");
    }
    return createOrphanedBlockFilter(this);
  }
}
_transactions = new WeakMap();
class Log {
  /**
   *  @_ignore:
   */
  constructor(log2, provider) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    __publicField(this, "provider");
    /**
     *  The transaction hash of the transaction this log occurred in. Use the
     *  [[Log-getTransaction]] to get the [[TransactionResponse]].
     */
    __publicField(this, "transactionHash");
    /**
     *  The block hash of the block this log occurred in. Use the
     *  [[Log-getBlock]] to get the [[Block]].
     */
    __publicField(this, "blockHash");
    /**
     *  The block number of the block this log occurred in. It is preferred
     *  to use the [[Block-hash]] when fetching the related [[Block]],
     *  since in the case of an orphaned block, the block at that height may
     *  have changed.
     */
    __publicField(this, "blockNumber");
    /**
     *  If the **Log** represents a block that was removed due to an orphaned
     *  block, this will be true.
     *
     *  This can only happen within an orphan event listener.
     */
    __publicField(this, "removed");
    /**
     *  The address of the contract that emitted this log.
     */
    __publicField(this, "address");
    /**
     *  The data included in this log when it was emitted.
     */
    __publicField(this, "data");
    /**
     *  The indexed topics included in this log when it was emitted.
     *
     *  All topics are included in the bloom filters, so they can be
     *  efficiently filtered using the [[Provider-getLogs]] method.
     */
    __publicField(this, "topics");
    /**
     *  The index within the block this log occurred at. This is generally
     *  not useful to developers, but can be used with the various roots
     *  to proof inclusion within a block.
     */
    __publicField(this, "index");
    /**
     *  The index within the transaction of this log.
     */
    __publicField(this, "transactionIndex");
    this.provider = provider;
    const topics = Object.freeze(log2.topics.slice());
    defineProperties(this, {
      transactionHash: log2.transactionHash,
      blockHash: log2.blockHash,
      blockNumber: log2.blockNumber,
      removed: log2.removed,
      address: log2.address,
      data: log2.data,
      topics,
      index: log2.index,
      transactionIndex: log2.transactionIndex
    });
  }
  /**
   *  Returns a JSON-compatible object.
   */
  toJSON() {
    const { address, blockHash, blockNumber, data: data2, index: index2, removed, topics, transactionHash, transactionIndex } = this;
    return {
      _type: "log",
      address,
      blockHash,
      blockNumber,
      data: data2,
      index: index2,
      removed,
      topics,
      transactionHash,
      transactionIndex
    };
  }
  /**
   *  Returns the block that this log occurred in.
   */
  async getBlock() {
    const block = await this.provider.getBlock(this.blockHash);
    assert(!!block, "failed to find transaction", "UNKNOWN_ERROR", {});
    return block;
  }
  /**
   *  Returns the transaction that this log occurred in.
   */
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.transactionHash);
    assert(!!tx, "failed to find transaction", "UNKNOWN_ERROR", {});
    return tx;
  }
  /**
   *  Returns the transaction receipt fot the transaction that this
   *  log occurred in.
   */
  async getTransactionReceipt() {
    const receipt = await this.provider.getTransactionReceipt(this.transactionHash);
    assert(!!receipt, "failed to find transaction receipt", "UNKNOWN_ERROR", {});
    return receipt;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return createRemovedLogFilter(this);
  }
}
class TransactionReceipt {
  /**
   *  @_ignore:
   */
  constructor(tx, provider) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    __publicField(this, "provider");
    /**
     *  The address the transaction was sent to.
     */
    __publicField(this, "to");
    /**
     *  The sender of the transaction.
     */
    __publicField(this, "from");
    /**
     *  The address of the contract if the transaction was directly
     *  responsible for deploying one.
     *
     *  This is non-null **only** if the ``to`` is empty and the ``data``
     *  was successfully executed as initcode.
     */
    __publicField(this, "contractAddress");
    /**
     *  The transaction hash.
     */
    __publicField(this, "hash");
    /**
     *  The index of this transaction within the block transactions.
     */
    __publicField(this, "index");
    /**
     *  The block hash of the [[Block]] this transaction was included in.
     */
    __publicField(this, "blockHash");
    /**
     *  The block number of the [[Block]] this transaction was included in.
     */
    __publicField(this, "blockNumber");
    /**
     *  The bloom filter bytes that represent all logs that occurred within
     *  this transaction. This is generally not useful for most developers,
     *  but can be used to validate the included logs.
     */
    __publicField(this, "logsBloom");
    /**
     *  The actual amount of gas used by this transaction.
     *
     *  When creating a transaction, the amount of gas that will be used can
     *  only be approximated, but the sender must pay the gas fee for the
     *  entire gas limit. After the transaction, the difference is refunded.
     */
    __publicField(this, "gasUsed");
    /**
     *  The gas used for BLObs. See [[link-eip-4844]].
     */
    __publicField(this, "blobGasUsed");
    /**
     *  The amount of gas used by all transactions within the block for this
     *  and all transactions with a lower ``index``.
     *
     *  This is generally not useful for developers but can be used to
     *  validate certain aspects of execution.
     */
    __publicField(this, "cumulativeGasUsed");
    /**
     *  The actual gas price used during execution.
     *
     *  Due to the complexity of [[link-eip-1559]] this value can only
     *  be caluclated after the transaction has been mined, snce the base
     *  fee is protocol-enforced.
     */
    __publicField(this, "gasPrice");
    /**
     *  The price paid per BLOB in gas. See [[link-eip-4844]].
     */
    __publicField(this, "blobGasPrice");
    /**
     *  The [[link-eip-2718]] transaction type.
     */
    __publicField(this, "type");
    //readonly byzantium!: boolean;
    /**
     *  The status of this transaction, indicating success (i.e. ``1``) or
     *  a revert (i.e. ``0``).
     *
     *  This is available in post-byzantium blocks, but some backends may
     *  backfill this value.
     */
    __publicField(this, "status");
    /**
     *  The root hash of this transaction.
     *
     *  This is no present and was only included in pre-byzantium blocks, but
     *  could be used to validate certain parts of the receipt.
     */
    __publicField(this, "root");
    __privateAdd(this, _logs);
    __privateSet(this, _logs, Object.freeze(tx.logs.map((log2) => {
      return new Log(log2, provider);
    })));
    let gasPrice = BN_0$2;
    if (tx.effectiveGasPrice != null) {
      gasPrice = tx.effectiveGasPrice;
    } else if (tx.gasPrice != null) {
      gasPrice = tx.gasPrice;
    }
    defineProperties(this, {
      provider,
      to: tx.to,
      from: tx.from,
      contractAddress: tx.contractAddress,
      hash: tx.hash,
      index: tx.index,
      blockHash: tx.blockHash,
      blockNumber: tx.blockNumber,
      logsBloom: tx.logsBloom,
      gasUsed: tx.gasUsed,
      cumulativeGasUsed: tx.cumulativeGasUsed,
      blobGasUsed: tx.blobGasUsed,
      gasPrice,
      blobGasPrice: tx.blobGasPrice,
      type: tx.type,
      //byzantium: tx.byzantium,
      status: tx.status,
      root: tx.root
    });
  }
  /**
   *  The logs for this transaction.
   */
  get logs() {
    return __privateGet(this, _logs);
  }
  /**
   *  Returns a JSON-compatible representation.
   */
  toJSON() {
    const {
      to: to2,
      from: from2,
      contractAddress,
      hash: hash3,
      index: index2,
      blockHash,
      blockNumber,
      logsBloom,
      logs,
      //byzantium, 
      status,
      root
    } = this;
    return {
      _type: "TransactionReceipt",
      blockHash,
      blockNumber,
      //byzantium, 
      contractAddress,
      cumulativeGasUsed: toJson(this.cumulativeGasUsed),
      from: from2,
      gasPrice: toJson(this.gasPrice),
      blobGasUsed: toJson(this.blobGasUsed),
      blobGasPrice: toJson(this.blobGasPrice),
      gasUsed: toJson(this.gasUsed),
      hash: hash3,
      index: index2,
      logs,
      logsBloom,
      root,
      status,
      to: to2
    };
  }
  /**
   *  @_ignore:
   */
  get length() {
    return this.logs.length;
  }
  [Symbol.iterator]() {
    let index2 = 0;
    return {
      next: () => {
        if (index2 < this.length) {
          return { value: this.logs[index2++], done: false };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The total fee for this transaction, in wei.
   */
  get fee() {
    return this.gasUsed * this.gasPrice;
  }
  /**
   *  Resolves to the block this transaction occurred in.
   */
  async getBlock() {
    const block = await this.provider.getBlock(this.blockHash);
    if (block == null) {
      throw new Error("TODO");
    }
    return block;
  }
  /**
   *  Resolves to the transaction this transaction occurred in.
   */
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.hash);
    if (tx == null) {
      throw new Error("TODO");
    }
    return tx;
  }
  /**
   *  Resolves to the return value of the execution of this transaction.
   *
   *  Support for this feature is limited, as it requires an archive node
   *  with the ``debug_`` or ``trace_`` API enabled.
   */
  async getResult() {
    return await this.provider.getTransactionResult(this.hash);
  }
  /**
   *  Resolves to the number of confirmations this transaction has.
   */
  async confirmations() {
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return createRemovedTransactionFilter(this);
  }
  /**
   *  @_ignore:
   */
  reorderedEvent(other) {
    assert(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" });
    return createReorderedTransactionFilter(this, other);
  }
}
_logs = new WeakMap();
const _TransactionResponse = class _TransactionResponse {
  /**
   *  @_ignore:
   */
  constructor(tx, provider) {
    /**
     *  The provider this is connected to, which will influence how its
     *  methods will resolve its async inspection methods.
     */
    __publicField(this, "provider");
    /**
     *  The block number of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    __publicField(this, "blockNumber");
    /**
     *  The blockHash of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    __publicField(this, "blockHash");
    /**
     *  The index within the block that this transaction resides at.
     */
    __publicField(this, "index");
    /**
     *  The transaction hash.
     */
    __publicField(this, "hash");
    /**
     *  The [[link-eip-2718]] transaction envelope type. This is
     *  ``0`` for legacy transactions types.
     */
    __publicField(this, "type");
    /**
     *  The receiver of this transaction.
     *
     *  If ``null``, then the transaction is an initcode transaction.
     *  This means the result of executing the [[data]] will be deployed
     *  as a new contract on chain (assuming it does not revert) and the
     *  address may be computed using [[getCreateAddress]].
     */
    __publicField(this, "to");
    /**
     *  The sender of this transaction. It is implicitly computed
     *  from the transaction pre-image hash (as the digest) and the
     *  [[signature]] using ecrecover.
     */
    __publicField(this, "from");
    /**
     *  The nonce, which is used to prevent replay attacks and offer
     *  a method to ensure transactions from a given sender are explicitly
     *  ordered.
     *
     *  When sending a transaction, this must be equal to the number of
     *  transactions ever sent by [[from]].
     */
    __publicField(this, "nonce");
    /**
     *  The maximum units of gas this transaction can consume. If execution
     *  exceeds this, the entries transaction is reverted and the sender
     *  is charged for the full amount, despite not state changes being made.
     */
    __publicField(this, "gasLimit");
    /**
     *  The gas price can have various values, depending on the network.
     *
     *  In modern networks, for transactions that are included this is
     *  the //effective gas price// (the fee per gas that was actually
     *  charged), while for transactions that have not been included yet
     *  is the [[maxFeePerGas]].
     *
     *  For legacy transactions, or transactions on legacy networks, this
     *  is the fee that will be charged per unit of gas the transaction
     *  consumes.
     */
    __publicField(this, "gasPrice");
    /**
     *  The maximum priority fee (per unit of gas) to allow a
     *  validator to charge the sender. This is inclusive of the
     *  [[maxFeeFeePerGas]].
     */
    __publicField(this, "maxPriorityFeePerGas");
    /**
     *  The maximum fee (per unit of gas) to allow this transaction
     *  to charge the sender.
     */
    __publicField(this, "maxFeePerGas");
    /**
     *  The [[link-eip-4844]] max fee per BLOb gas.
     */
    __publicField(this, "maxFeePerBlobGas");
    /**
     *  The data.
     */
    __publicField(this, "data");
    /**
     *  The value, in wei. Use [[formatEther]] to format this value
     *  as ether.
     */
    __publicField(this, "value");
    /**
     *  The chain ID.
     */
    __publicField(this, "chainId");
    /**
     *  The signature.
     */
    __publicField(this, "signature");
    /**
     *  The [[link-eip-2930]] access list for transaction types that
     *  support it, otherwise ``null``.
     */
    __publicField(this, "accessList");
    /**
     *  The [[link-eip-4844]] BLOb versioned hashes.
     */
    __publicField(this, "blobVersionedHashes");
    __privateAdd(this, _startBlock);
    this.provider = provider;
    this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
    this.blockHash = tx.blockHash != null ? tx.blockHash : null;
    this.hash = tx.hash;
    this.index = tx.index;
    this.type = tx.type;
    this.from = tx.from;
    this.to = tx.to || null;
    this.gasLimit = tx.gasLimit;
    this.nonce = tx.nonce;
    this.data = tx.data;
    this.value = tx.value;
    this.gasPrice = tx.gasPrice;
    this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;
    this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;
    this.maxFeePerBlobGas = tx.maxFeePerBlobGas != null ? tx.maxFeePerBlobGas : null;
    this.chainId = tx.chainId;
    this.signature = tx.signature;
    this.accessList = tx.accessList != null ? tx.accessList : null;
    this.blobVersionedHashes = tx.blobVersionedHashes != null ? tx.blobVersionedHashes : null;
    __privateSet(this, _startBlock, -1);
  }
  /**
   *  Returns a JSON-compatible representation of this transaction.
   */
  toJSON() {
    const { blockNumber, blockHash, index: index2, hash: hash3, type: type2, to: to2, from: from2, nonce, data: data2, signature: signature2, accessList, blobVersionedHashes } = this;
    return {
      _type: "TransactionResponse",
      accessList,
      blockNumber,
      blockHash,
      blobVersionedHashes,
      chainId: toJson(this.chainId),
      data: data2,
      from: from2,
      gasLimit: toJson(this.gasLimit),
      gasPrice: toJson(this.gasPrice),
      hash: hash3,
      maxFeePerGas: toJson(this.maxFeePerGas),
      maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
      maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),
      nonce,
      signature: signature2,
      to: to2,
      index: index2,
      type: type2,
      value: toJson(this.value)
    };
  }
  /**
   *  Resolves to the Block that this transaction was included in.
   *
   *  This will return null if the transaction has not been included yet.
   */
  async getBlock() {
    let blockNumber = this.blockNumber;
    if (blockNumber == null) {
      const tx = await this.getTransaction();
      if (tx) {
        blockNumber = tx.blockNumber;
      }
    }
    if (blockNumber == null) {
      return null;
    }
    const block = this.provider.getBlock(blockNumber);
    if (block == null) {
      throw new Error("TODO");
    }
    return block;
  }
  /**
   *  Resolves to this transaction being re-requested from the
   *  provider. This can be used if you have an unmined transaction
   *  and wish to get an up-to-date populated instance.
   */
  async getTransaction() {
    return this.provider.getTransaction(this.hash);
  }
  /**
   *  Resolve to the number of confirmations this transaction has.
   */
  async confirmations() {
    if (this.blockNumber == null) {
      const { tx, blockNumber: blockNumber2 } = await resolveProperties({
        tx: this.getTransaction(),
        blockNumber: this.provider.getBlockNumber()
      });
      if (tx == null || tx.blockNumber == null) {
        return 0;
      }
      return blockNumber2 - tx.blockNumber + 1;
    }
    const blockNumber = await this.provider.getBlockNumber();
    return blockNumber - this.blockNumber + 1;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(_confirms, _timeout2) {
    const confirms = _confirms == null ? 1 : _confirms;
    const timeout = _timeout2 == null ? 0 : _timeout2;
    let startBlock = __privateGet(this, _startBlock);
    let nextScan = -1;
    let stopScanning = startBlock === -1 ? true : false;
    const checkReplacement = async () => {
      if (stopScanning) {
        return null;
      }
      const { blockNumber, nonce } = await resolveProperties({
        blockNumber: this.provider.getBlockNumber(),
        nonce: this.provider.getTransactionCount(this.from)
      });
      if (nonce < this.nonce) {
        startBlock = blockNumber;
        return;
      }
      if (stopScanning) {
        return null;
      }
      const mined = await this.getTransaction();
      if (mined && mined.blockNumber != null) {
        return;
      }
      if (nextScan === -1) {
        nextScan = startBlock - 3;
        if (nextScan < __privateGet(this, _startBlock)) {
          nextScan = __privateGet(this, _startBlock);
        }
      }
      while (nextScan <= blockNumber) {
        if (stopScanning) {
          return null;
        }
        const block = await this.provider.getBlock(nextScan, true);
        if (block == null) {
          return;
        }
        for (const hash3 of block) {
          if (hash3 === this.hash) {
            return;
          }
        }
        for (let i4 = 0; i4 < block.length; i4++) {
          const tx = await block.getTransaction(i4);
          if (tx.from === this.from && tx.nonce === this.nonce) {
            if (stopScanning) {
              return null;
            }
            const receipt2 = await this.provider.getTransactionReceipt(tx.hash);
            if (receipt2 == null) {
              return;
            }
            if (blockNumber - receipt2.blockNumber + 1 < confirms) {
              return;
            }
            let reason = "replaced";
            if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {
              reason = "repriced";
            } else if (tx.data === "0x" && tx.from === tx.to && tx.value === BN_0$2) {
              reason = "cancelled";
            }
            assert(false, "transaction was replaced", "TRANSACTION_REPLACED", {
              cancelled: reason === "replaced" || reason === "cancelled",
              reason,
              replacement: tx.replaceableTransaction(startBlock),
              hash: tx.hash,
              receipt: receipt2
            });
          }
        }
        nextScan++;
      }
      return;
    };
    const checkReceipt = (receipt2) => {
      if (receipt2 == null || receipt2.status !== 0) {
        return receipt2;
      }
      assert(false, "transaction execution reverted", "CALL_EXCEPTION", {
        action: "sendTransaction",
        data: null,
        reason: null,
        invocation: null,
        revert: null,
        transaction: {
          to: receipt2.to,
          from: receipt2.from,
          data: ""
          // @TODO: in v7, split out sendTransaction properties
        },
        receipt: receipt2
      });
    };
    const receipt = await this.provider.getTransactionReceipt(this.hash);
    if (confirms === 0) {
      return checkReceipt(receipt);
    }
    if (receipt) {
      if (await receipt.confirmations() >= confirms) {
        return checkReceipt(receipt);
      }
    } else {
      await checkReplacement();
      if (confirms === 0) {
        return null;
      }
    }
    const waiter = new Promise((resolve, reject) => {
      const cancellers = [];
      const cancel = () => {
        cancellers.forEach((c2) => c2());
      };
      cancellers.push(() => {
        stopScanning = true;
      });
      if (timeout > 0) {
        const timer = setTimeout(() => {
          cancel();
          reject(makeError("wait for transaction timeout", "TIMEOUT"));
        }, timeout);
        cancellers.push(() => {
          clearTimeout(timer);
        });
      }
      const txListener = async (receipt2) => {
        if (await receipt2.confirmations() >= confirms) {
          cancel();
          try {
            resolve(checkReceipt(receipt2));
          } catch (error) {
            reject(error);
          }
        }
      };
      cancellers.push(() => {
        this.provider.off(this.hash, txListener);
      });
      this.provider.on(this.hash, txListener);
      if (startBlock >= 0) {
        const replaceListener = async () => {
          try {
            await checkReplacement();
          } catch (error) {
            if (isError(error, "TRANSACTION_REPLACED")) {
              cancel();
              reject(error);
              return;
            }
          }
          if (!stopScanning) {
            this.provider.once("block", replaceListener);
          }
        };
        cancellers.push(() => {
          this.provider.off("block", replaceListener);
        });
        this.provider.once("block", replaceListener);
      }
    });
    return await waiter;
  }
  /**
   *  Returns ``true`` if this transaction has been included.
   *
   *  This is effective only as of the time the TransactionResponse
   *  was instantiated. To get up-to-date information, use
   *  [[getTransaction]].
   *
   *  This provides a Type Guard that this transaction will have
   *  non-null property values for properties that are null for
   *  unmined transactions.
   */
  isMined() {
    return this.blockHash != null;
  }
  /**
   *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
   *  transaction.
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
   *  transaction. See [[link-eip-2070]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if the transaction is a London (i.e. ``type == 2``)
   *  transaction. See [[link-eip-1559]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)
   *  transaction. See [[link-eip-4844]].
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that evict this transaction.
   */
  removedEvent() {
    assert(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createRemovedTransactionFilter(this);
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that re-order this event against %%other%%.
   */
  reorderedEvent(other) {
    assert(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    assert(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createReorderedTransactionFilter(this, other);
  }
  /**
   *  Returns a new TransactionResponse instance which has the ability to
   *  detect (and throw an error) if the transaction is replaced, which
   *  will begin scanning at %%startBlock%%.
   *
   *  This should generally not be used by developers and is intended
   *  primarily for internal use. Setting an incorrect %%startBlock%% can
   *  have devastating performance consequences if used incorrectly.
   */
  replaceableTransaction(startBlock) {
    assertArgument(Number.isInteger(startBlock) && startBlock >= 0, "invalid startBlock", "startBlock", startBlock);
    const tx = new _TransactionResponse(this, this.provider);
    __privateSet(tx, _startBlock, startBlock);
    return tx;
  }
};
_startBlock = new WeakMap();
let TransactionResponse = _TransactionResponse;
function createOrphanedBlockFilter(block) {
  return { orphan: "drop-block", hash: block.hash, number: block.number };
}
function createReorderedTransactionFilter(tx, other) {
  return { orphan: "reorder-transaction", tx, other };
}
function createRemovedTransactionFilter(tx) {
  return { orphan: "drop-transaction", tx };
}
function createRemovedLogFilter(log2) {
  return { orphan: "drop-log", log: {
    transactionHash: log2.transactionHash,
    blockHash: log2.blockHash,
    blockNumber: log2.blockNumber,
    address: log2.address,
    data: log2.data,
    topics: Object.freeze(log2.topics.slice()),
    index: log2.index
  } };
}
class EventLog extends Log {
  /**
   * @_ignore:
   */
  constructor(log2, iface, fragment) {
    super(log2, log2.provider);
    /**
     *  The Contract Interface.
     */
    __publicField(this, "interface");
    /**
     *  The matching event.
     */
    __publicField(this, "fragment");
    /**
     *  The parsed arguments passed to the event by ``emit``.
     */
    __publicField(this, "args");
    const args = iface.decodeEventLog(fragment, log2.data, log2.topics);
    defineProperties(this, { args, fragment, interface: iface });
  }
  /**
   *  The name of the event.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The signature of the event.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
class UndecodedEventLog extends Log {
  /**
   * @_ignore:
   */
  constructor(log2, error) {
    super(log2, log2.provider);
    /**
     *  The error encounted when trying to decode the log.
     */
    __publicField(this, "error");
    defineProperties(this, { error });
  }
}
class ContractTransactionReceipt extends TransactionReceipt {
  /**
   *  @_ignore:
   */
  constructor(iface, provider, tx) {
    super(tx, provider);
    __privateAdd(this, _iface);
    __privateSet(this, _iface, iface);
  }
  /**
   *  The parsed logs for any [[Log]] which has a matching event in the
   *  Contract ABI.
   */
  get logs() {
    return super.logs.map((log2) => {
      const fragment = log2.topics.length ? __privateGet(this, _iface).getEvent(log2.topics[0]) : null;
      if (fragment) {
        try {
          return new EventLog(log2, __privateGet(this, _iface), fragment);
        } catch (error) {
          return new UndecodedEventLog(log2, error);
        }
      }
      return log2;
    });
  }
}
_iface = new WeakMap();
class ContractTransactionResponse extends TransactionResponse {
  /**
   *  @_ignore:
   */
  constructor(iface, provider, tx) {
    super(tx, provider);
    __privateAdd(this, _iface2);
    __privateSet(this, _iface2, iface);
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(confirms, timeout) {
    const receipt = await super.wait(confirms, timeout);
    if (receipt == null) {
      return null;
    }
    return new ContractTransactionReceipt(__privateGet(this, _iface2), this.provider, receipt);
  }
}
_iface2 = new WeakMap();
class ContractUnknownEventPayload extends EventPayload {
  /**
   *  @_event:
   */
  constructor(contract, listener, filter, log2) {
    super(contract, listener, filter);
    /**
     *  The log with no matching events.
     */
    __publicField(this, "log");
    defineProperties(this, { log: log2 });
  }
  /**
   *  Resolves to the block the event occured in.
   */
  async getBlock() {
    return await this.log.getBlock();
  }
  /**
   *  Resolves to the transaction the event occured in.
   */
  async getTransaction() {
    return await this.log.getTransaction();
  }
  /**
   *  Resolves to the transaction receipt the event occured in.
   */
  async getTransactionReceipt() {
    return await this.log.getTransactionReceipt();
  }
}
class ContractEventPayload extends ContractUnknownEventPayload {
  /**
   *  @_ignore:
   */
  constructor(contract, listener, filter, fragment, _log) {
    super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));
    const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);
    defineProperties(this, { args, fragment });
  }
  /**
   *  The event name.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The event signature.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
const BN_0$1 = BigInt(0);
function canCall(value) {
  return value && typeof value.call === "function";
}
function canEstimate(value) {
  return value && typeof value.estimateGas === "function";
}
function canResolve(value) {
  return value && typeof value.resolveName === "function";
}
function canSend(value) {
  return value && typeof value.sendTransaction === "function";
}
function getResolver(value) {
  if (value != null) {
    if (canResolve(value)) {
      return value;
    }
    if (value.provider) {
      return value.provider;
    }
  }
  return void 0;
}
class PreparedTopicFilter {
  constructor(contract, fragment, args) {
    __privateAdd(this, _filter);
    __publicField(this, "fragment");
    defineProperties(this, { fragment });
    if (fragment.inputs.length < args.length) {
      throw new Error("too many arguments");
    }
    const runner = getRunner(contract.runner, "resolveName");
    const resolver = canResolve(runner) ? runner : null;
    __privateSet(this, _filter, async function() {
      const resolvedArgs = await Promise.all(fragment.inputs.map((param, index2) => {
        const arg = args[index2];
        if (arg == null) {
          return null;
        }
        return param.walkAsync(args[index2], (type2, value) => {
          if (type2 === "address") {
            if (Array.isArray(value)) {
              return Promise.all(value.map((v2) => resolveAddress(v2, resolver)));
            }
            return resolveAddress(value, resolver);
          }
          return value;
        });
      }));
      return contract.interface.encodeFilterTopics(fragment, resolvedArgs);
    }());
  }
  getTopicFilter() {
    return __privateGet(this, _filter);
  }
}
_filter = new WeakMap();
function getRunner(value, feature) {
  if (value == null) {
    return null;
  }
  if (typeof value[feature] === "function") {
    return value;
  }
  if (value.provider && typeof value.provider[feature] === "function") {
    return value.provider;
  }
  return null;
}
function getProvider(value) {
  if (value == null) {
    return null;
  }
  return value.provider || null;
}
async function copyOverrides(arg, allowed) {
  const _overrides = Typed.dereference(arg, "overrides");
  assertArgument(typeof _overrides === "object", "invalid overrides parameter", "overrides", arg);
  const overrides = copyRequest(_overrides);
  assertArgument(overrides.to == null || (allowed || []).indexOf("to") >= 0, "cannot override to", "overrides.to", overrides.to);
  assertArgument(overrides.data == null || (allowed || []).indexOf("data") >= 0, "cannot override data", "overrides.data", overrides.data);
  if (overrides.from) {
    overrides.from = overrides.from;
  }
  return overrides;
}
async function resolveArgs(_runner, inputs, args) {
  const runner = getRunner(_runner, "resolveName");
  const resolver = canResolve(runner) ? runner : null;
  return await Promise.all(inputs.map((param, index2) => {
    return param.walkAsync(args[index2], (type2, value) => {
      value = Typed.dereference(value, type2);
      if (type2 === "address") {
        return resolveAddress(value, resolver);
      }
      return value;
    });
  }));
}
function buildWrappedFallback(contract) {
  const populateTransaction = async function(overrides) {
    const tx = await copyOverrides(overrides, ["data"]);
    tx.to = await contract.getAddress();
    if (tx.from) {
      tx.from = await resolveAddress(tx.from, getResolver(contract.runner));
    }
    const iface = contract.interface;
    const noValue = getBigInt(tx.value || BN_0$1, "overrides.value") === BN_0$1;
    const noData = (tx.data || "0x") === "0x";
    if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {
      assertArgument(false, "cannot send data to receive or send value to non-payable fallback", "overrides", overrides);
    }
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    const payable = iface.receive || iface.fallback && iface.fallback.payable;
    assertArgument(payable || noValue, "cannot send value to non-payable fallback", "overrides.value", tx.value);
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    return tx;
  };
  const staticCall = async function(overrides) {
    const runner = getRunner(contract.runner, "call");
    assert(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(overrides);
    try {
      return await runner.call(tx);
    } catch (error) {
      if (isCallException(error) && error.data) {
        throw contract.interface.makeError(error.data, tx);
      }
      throw error;
    }
  };
  const send = async function(overrides) {
    const runner = contract.runner;
    assert(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(overrides));
    const provider = getProvider(contract.runner);
    return new ContractTransactionResponse(contract.interface, provider, tx);
  };
  const estimateGas = async function(overrides) {
    const runner = getRunner(contract.runner, "estimateGas");
    assert(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(overrides));
  };
  const method = async (overrides) => {
    return await send(overrides);
  };
  defineProperties(method, {
    _contract: contract,
    estimateGas,
    populateTransaction,
    send,
    staticCall
  });
  return method;
}
function buildWrappedMethod(contract, key2) {
  const getFragment = function(...args) {
    const fragment = contract.interface.getFunction(key2, args);
    assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key: key2, args }
    });
    return fragment;
  };
  const populateTransaction = async function(...args) {
    const fragment = getFragment(...args);
    let overrides = {};
    if (fragment.inputs.length + 1 === args.length) {
      overrides = await copyOverrides(args.pop());
      if (overrides.from) {
        overrides.from = await resolveAddress(overrides.from, getResolver(contract.runner));
      }
    }
    if (fragment.inputs.length !== args.length) {
      throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
    }
    const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);
    return Object.assign({}, overrides, await resolveProperties({
      to: contract.getAddress(),
      data: contract.interface.encodeFunctionData(fragment, resolvedArgs)
    }));
  };
  const staticCall = async function(...args) {
    const result = await staticCallResult(...args);
    if (result.length === 1) {
      return result[0];
    }
    return result;
  };
  const send = async function(...args) {
    const runner = contract.runner;
    assert(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(...args));
    const provider = getProvider(contract.runner);
    return new ContractTransactionResponse(contract.interface, provider, tx);
  };
  const estimateGas = async function(...args) {
    const runner = getRunner(contract.runner, "estimateGas");
    assert(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(...args));
  };
  const staticCallResult = async function(...args) {
    const runner = getRunner(contract.runner, "call");
    assert(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(...args);
    let result = "0x";
    try {
      result = await runner.call(tx);
    } catch (error) {
      if (isCallException(error) && error.data) {
        throw contract.interface.makeError(error.data, tx);
      }
      throw error;
    }
    const fragment = getFragment(...args);
    return contract.interface.decodeFunctionResult(fragment, result);
  };
  const method = async (...args) => {
    const fragment = getFragment(...args);
    if (fragment.constant) {
      return await staticCall(...args);
    }
    return await send(...args);
  };
  defineProperties(method, {
    name: contract.interface.getFunctionName(key2),
    _contract: contract,
    _key: key2,
    getFragment,
    estimateGas,
    populateTransaction,
    send,
    staticCall,
    staticCallResult
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract.interface.getFunction(key2);
      assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key: key2 }
      });
      return fragment;
    }
  });
  return method;
}
function buildWrappedEvent(contract, key2) {
  const getFragment = function(...args) {
    const fragment = contract.interface.getEvent(key2, args);
    assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key: key2, args }
    });
    return fragment;
  };
  const method = function(...args) {
    return new PreparedTopicFilter(contract, getFragment(...args), args);
  };
  defineProperties(method, {
    name: contract.interface.getEventName(key2),
    _contract: contract,
    _key: key2,
    getFragment
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract.interface.getEvent(key2);
      assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key: key2 }
      });
      return fragment;
    }
  });
  return method;
}
const internal = Symbol.for("_ethersInternal_contract");
const internalValues = /* @__PURE__ */ new WeakMap();
function setInternal(contract, values) {
  internalValues.set(contract[internal], values);
}
function getInternal(contract) {
  return internalValues.get(contract[internal]);
}
function isDeferred(value) {
  return value && typeof value === "object" && "getTopicFilter" in value && typeof value.getTopicFilter === "function" && value.fragment;
}
async function getSubInfo(contract, event) {
  let topics;
  let fragment = null;
  if (Array.isArray(event)) {
    const topicHashify = function(name) {
      if (isHexString(name, 32)) {
        return name;
      }
      const fragment2 = contract.interface.getEvent(name);
      assertArgument(fragment2, "unknown fragment", "name", name);
      return fragment2.topicHash;
    };
    topics = event.map((e3) => {
      if (e3 == null) {
        return null;
      }
      if (Array.isArray(e3)) {
        return e3.map(topicHashify);
      }
      return topicHashify(e3);
    });
  } else if (event === "*") {
    topics = [null];
  } else if (typeof event === "string") {
    if (isHexString(event, 32)) {
      topics = [event];
    } else {
      fragment = contract.interface.getEvent(event);
      assertArgument(fragment, "unknown fragment", "event", event);
      topics = [fragment.topicHash];
    }
  } else if (isDeferred(event)) {
    topics = await event.getTopicFilter();
  } else if ("fragment" in event) {
    fragment = event.fragment;
    topics = [fragment.topicHash];
  } else {
    assertArgument(false, "unknown event name", "event", event);
  }
  topics = topics.map((t2) => {
    if (t2 == null) {
      return null;
    }
    if (Array.isArray(t2)) {
      const items = Array.from(new Set(t2.map((t3) => t3.toLowerCase())).values());
      if (items.length === 1) {
        return items[0];
      }
      items.sort();
      return items;
    }
    return t2.toLowerCase();
  });
  const tag = topics.map((t2) => {
    if (t2 == null) {
      return "null";
    }
    if (Array.isArray(t2)) {
      return t2.join("|");
    }
    return t2;
  }).join("&");
  return { fragment, tag, topics };
}
async function hasSub(contract, event) {
  const { subs } = getInternal(contract);
  return subs.get((await getSubInfo(contract, event)).tag) || null;
}
async function getSub(contract, operation, event) {
  const provider = getProvider(contract.runner);
  assert(provider, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation });
  const { fragment, tag, topics } = await getSubInfo(contract, event);
  const { addr, subs } = getInternal(contract);
  let sub = subs.get(tag);
  if (!sub) {
    const address = addr ? addr : contract;
    const filter = { address, topics };
    const listener = (log2) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = contract.interface.getEvent(log2.topics[0]);
        } catch (error) {
        }
      }
      if (foundFragment) {
        const _foundFragment = foundFragment;
        const args = fragment ? contract.interface.decodeEventLog(fragment, log2.data, log2.topics) : [];
        emit(contract, event, args, (listener2) => {
          return new ContractEventPayload(contract, listener2, event, _foundFragment, log2);
        });
      } else {
        emit(contract, event, [], (listener2) => {
          return new ContractUnknownEventPayload(contract, listener2, event, log2);
        });
      }
    };
    let starting = [];
    const start = () => {
      if (starting.length) {
        return;
      }
      starting.push(provider.on(filter, listener));
    };
    const stop = async () => {
      if (starting.length == 0) {
        return;
      }
      let started = starting;
      starting = [];
      await Promise.all(started);
      provider.off(filter, listener);
    };
    sub = { tag, listeners: [], start, stop };
    subs.set(tag, sub);
  }
  return sub;
}
let lastEmit = Promise.resolve();
async function _emit(contract, event, args, payloadFunc) {
  await lastEmit;
  const sub = await hasSub(contract, event);
  if (!sub) {
    return false;
  }
  const count = sub.listeners.length;
  sub.listeners = sub.listeners.filter(({ listener, once: once3 }) => {
    const passArgs = Array.from(args);
    if (payloadFunc) {
      passArgs.push(payloadFunc(once3 ? null : listener));
    }
    try {
      listener.call(contract, ...passArgs);
    } catch (error) {
    }
    return !once3;
  });
  if (sub.listeners.length === 0) {
    sub.stop();
    getInternal(contract).subs.delete(sub.tag);
  }
  return count > 0;
}
async function emit(contract, event, args, payloadFunc) {
  try {
    await lastEmit;
  } catch (error) {
  }
  const resultPromise = _emit(contract, event, args, payloadFunc);
  lastEmit = resultPromise;
  return await resultPromise;
}
const passProperties = ["then"];
_c2 = internal;
const _BaseContract = class _BaseContract {
  /**
   *  Creates a new contract connected to %%target%% with the %%abi%% and
   *  optionally connected to a %%runner%% to perform operations on behalf
   *  of.
   */
  constructor(target, abi, runner, _deployTx) {
    /**
     *  The target to connect to.
     *
     *  This can be an address, ENS name or any [[Addressable]], such as
     *  another contract. To get the resovled address, use the ``getAddress``
     *  method.
     */
    __publicField(this, "target");
    /**
     *  The contract Interface.
     */
    __publicField(this, "interface");
    /**
     *  The connected runner. This is generally a [[Provider]] or a
     *  [[Signer]], which dictates what operations are supported.
     *
     *  For example, a **Contract** connected to a [[Provider]] may
     *  only execute read-only operations.
     */
    __publicField(this, "runner");
    /**
     *  All the Events available on this contract.
     */
    __publicField(this, "filters");
    /**
     *  @_ignore:
     */
    __publicField(this, _c2);
    /**
     *  The fallback or receive function if any.
     */
    __publicField(this, "fallback");
    assertArgument(typeof target === "string" || isAddressable(target), "invalid value for Contract target", "target", target);
    if (runner == null) {
      runner = null;
    }
    const iface = Interface.from(abi);
    defineProperties(this, { target, runner, interface: iface });
    Object.defineProperty(this, internal, { value: {} });
    let addrPromise;
    let addr = null;
    let deployTx = null;
    if (_deployTx) {
      const provider = getProvider(runner);
      deployTx = new ContractTransactionResponse(this.interface, provider, _deployTx);
    }
    let subs = /* @__PURE__ */ new Map();
    if (typeof target === "string") {
      if (isHexString(target)) {
        addr = target;
        addrPromise = Promise.resolve(target);
      } else {
        const resolver = getRunner(runner, "resolveName");
        if (!canResolve(resolver)) {
          throw makeError("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
        }
        addrPromise = resolver.resolveName(target).then((addr2) => {
          if (addr2 == null) {
            throw makeError("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
              value: target
            });
          }
          getInternal(this).addr = addr2;
          return addr2;
        });
      }
    } else {
      addrPromise = target.getAddress().then((addr2) => {
        if (addr2 == null) {
          throw new Error("TODO");
        }
        getInternal(this).addr = addr2;
        return addr2;
      });
    }
    setInternal(this, { addrPromise, addr, deployTx, subs });
    const filters = new Proxy({}, {
      get: (target2, prop, receiver) => {
        if (typeof prop === "symbol" || passProperties.indexOf(prop) >= 0) {
          return Reflect.get(target2, prop, receiver);
        }
        try {
          return this.getEvent(prop);
        } catch (error) {
          if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
            throw error;
          }
        }
        return void 0;
      },
      has: (target2, prop) => {
        if (passProperties.indexOf(prop) >= 0) {
          return Reflect.has(target2, prop);
        }
        return Reflect.has(target2, prop) || this.interface.hasEvent(String(prop));
      }
    });
    defineProperties(this, { filters });
    defineProperties(this, {
      fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null
    });
    return new Proxy(this, {
      get: (target2, prop, receiver) => {
        if (typeof prop === "symbol" || prop in target2 || passProperties.indexOf(prop) >= 0) {
          return Reflect.get(target2, prop, receiver);
        }
        try {
          return target2.getFunction(prop);
        } catch (error) {
          if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
            throw error;
          }
        }
        return void 0;
      },
      has: (target2, prop) => {
        if (typeof prop === "symbol" || prop in target2 || passProperties.indexOf(prop) >= 0) {
          return Reflect.has(target2, prop);
        }
        return target2.interface.hasFunction(prop);
      }
    });
  }
  /**
   *  Return a new Contract instance with the same target and ABI, but
   *  a different %%runner%%.
   */
  connect(runner) {
    return new _BaseContract(this.target, this.interface, runner);
  }
  /**
   *  Return a new Contract instance with the same ABI and runner, but
   *  a different %%target%%.
   */
  attach(target) {
    return new _BaseContract(target, this.interface, this.runner);
  }
  /**
   *  Return the resolved address of this Contract.
   */
  async getAddress() {
    return await getInternal(this).addrPromise;
  }
  /**
   *  Return the deployed bytecode or null if no bytecode is found.
   */
  async getDeployedCode() {
    const provider = getProvider(this.runner);
    assert(provider, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
    const code2 = await provider.getCode(await this.getAddress());
    if (code2 === "0x") {
      return null;
    }
    return code2;
  }
  /**
   *  Resolve to this Contract once the bytecode has been deployed, or
   *  resolve immediately if already deployed.
   */
  async waitForDeployment() {
    const deployTx = this.deploymentTransaction();
    if (deployTx) {
      await deployTx.wait();
      return this;
    }
    const code2 = await this.getDeployedCode();
    if (code2 != null) {
      return this;
    }
    const provider = getProvider(this.runner);
    assert(provider != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" });
    return new Promise((resolve, reject) => {
      const checkCode = async () => {
        try {
          const code3 = await this.getDeployedCode();
          if (code3 != null) {
            return resolve(this);
          }
          provider.once("block", checkCode);
        } catch (error) {
          reject(error);
        }
      };
      checkCode();
    });
  }
  /**
   *  Return the transaction used to deploy this contract.
   *
   *  This is only available if this instance was returned from a
   *  [[ContractFactory]].
   */
  deploymentTransaction() {
    return getInternal(this).deployTx;
  }
  /**
   *  Return the function for a given name. This is useful when a contract
   *  method name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getFunction(key2) {
    if (typeof key2 !== "string") {
      key2 = key2.format();
    }
    const func = buildWrappedMethod(this, key2);
    return func;
  }
  /**
   *  Return the event for a given name. This is useful when a contract
   *  event name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getEvent(key2) {
    if (typeof key2 !== "string") {
      key2 = key2.format();
    }
    return buildWrappedEvent(this, key2);
  }
  /**
   *  @_ignore:
   */
  async queryTransaction(hash3) {
    throw new Error("@TODO");
  }
  /*
      // @TODO: this is a non-backwards compatible change, but will be added
      //        in v7 and in a potential SmartContract class in an upcoming
      //        v6 release
      async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
          const provider = getProvider(this.runner);
          assert(provider, "contract runner does not have a provider",
              "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });
  
          const receipt = await provider.getTransactionReceipt(hash);
          if (receipt == null) { return null; }
  
          return new ContractTransactionReceipt(this.interface, provider, receipt);
      }
      */
  /**
   *  Provide historic access to event data for %%event%% in the range
   *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
   *  inclusive.
   */
  async queryFilter(event, fromBlock, toBlock) {
    if (fromBlock == null) {
      fromBlock = 0;
    }
    if (toBlock == null) {
      toBlock = "latest";
    }
    const { addr, addrPromise } = getInternal(this);
    const address = addr ? addr : await addrPromise;
    const { fragment, topics } = await getSubInfo(this, event);
    const filter = { address, topics, fromBlock, toBlock };
    const provider = getProvider(this.runner);
    assert(provider, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" });
    return (await provider.getLogs(filter)).map((log2) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = this.interface.getEvent(log2.topics[0]);
        } catch (error) {
        }
      }
      if (foundFragment) {
        try {
          return new EventLog(log2, this.interface, foundFragment);
        } catch (error) {
          return new UndecodedEventLog(log2, error);
        }
      }
      return new Log(log2, provider);
    });
  }
  /**
   *  Add an event %%listener%% for the %%event%%.
   */
  async on(event, listener) {
    const sub = await getSub(this, "on", event);
    sub.listeners.push({ listener, once: false });
    sub.start();
    return this;
  }
  /**
   *  Add an event %%listener%% for the %%event%%, but remove the listener
   *  after it is fired once.
   */
  async once(event, listener) {
    const sub = await getSub(this, "once", event);
    sub.listeners.push({ listener, once: true });
    sub.start();
    return this;
  }
  /**
   *  Emit an %%event%% calling all listeners with %%args%%.
   *
   *  Resolves to ``true`` if any listeners were called.
   */
  async emit(event, ...args) {
    return await emit(this, event, args, null);
  }
  /**
   *  Resolves to the number of listeners of %%event%% or the total number
   *  of listeners if unspecified.
   */
  async listenerCount(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return 0;
      }
      return sub.listeners.length;
    }
    const { subs } = getInternal(this);
    let total = 0;
    for (const { listeners: listeners2 } of subs.values()) {
      total += listeners2.length;
    }
    return total;
  }
  /**
   *  Resolves to the listeners subscribed to %%event%% or all listeners
   *  if unspecified.
   */
  async listeners(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return [];
      }
      return sub.listeners.map(({ listener }) => listener);
    }
    const { subs } = getInternal(this);
    let result = [];
    for (const { listeners: listeners2 } of subs.values()) {
      result = result.concat(listeners2.map(({ listener }) => listener));
    }
    return result;
  }
  /**
   *  Remove the %%listener%% from the listeners for %%event%% or remove
   *  all listeners if unspecified.
   */
  async off(event, listener) {
    const sub = await hasSub(this, event);
    if (!sub) {
      return this;
    }
    if (listener) {
      const index2 = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index2 >= 0) {
        sub.listeners.splice(index2, 1);
      }
    }
    if (listener == null || sub.listeners.length === 0) {
      sub.stop();
      getInternal(this).subs.delete(sub.tag);
    }
    return this;
  }
  /**
   *  Remove all the listeners for %%event%% or remove all listeners if
   *  unspecified.
   */
  async removeAllListeners(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return this;
      }
      sub.stop();
      getInternal(this).subs.delete(sub.tag);
    } else {
      const { subs } = getInternal(this);
      for (const { tag, stop } of subs.values()) {
        stop();
        subs.delete(tag);
      }
    }
    return this;
  }
  /**
   *  Alias for [on].
   */
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  /**
   *  Alias for [off].
   */
  async removeListener(event, listener) {
    return await this.off(event, listener);
  }
  /**
   *  Create a new Class for the %%abi%%.
   */
  static buildClass(abi) {
    class CustomContract extends _BaseContract {
      constructor(address, runner = null) {
        super(address, abi, runner);
      }
    }
    return CustomContract;
  }
  /**
   *  Create a new BaseContract with a specified Interface.
   */
  static from(target, abi, runner) {
    if (runner == null) {
      runner = null;
    }
    const contract = new this(target, abi, runner);
    return contract;
  }
};
let BaseContract = _BaseContract;
function _ContractBase() {
  return BaseContract;
}
class Contract extends _ContractBase() {
}
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    assertArgument(false, "unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}
class MulticoinProviderPlugin {
  /**
   *  Creates a new **MulticoinProviderPluing** for %%name%%.
   */
  constructor(name) {
    /**
     *  The name.
     */
    __publicField(this, "name");
    defineProperties(this, { name });
  }
  connect(proivder) {
    return this;
  }
  /**
   *  Returns ``true`` if %%coinType%% is supported by this plugin.
   */
  supportsCoinType(coinType) {
    return false;
  }
  /**
   *  Resolves to the encoded %%address%% for %%coinType%%.
   */
  async encodeAddress(coinType, address) {
    throw new Error("unsupported coin");
  }
  /**
   *  Resolves to the decoded %%data%% for %%coinType%%.
   */
  async decodeAddress(coinType, data2) {
    throw new Error("unsupported coin");
  }
}
const matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
const matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
const _EnsResolver = class _EnsResolver {
  constructor(provider, address, name) {
    __privateAdd(this, _EnsResolver_instances);
    /**
     *  The connected provider.
     */
    __publicField(this, "provider");
    /**
     *  The address of the resolver.
     */
    __publicField(this, "address");
    /**
     *  The name this resolver was resolved against.
     */
    __publicField(this, "name");
    // For EIP-2544 names, the ancestor that provided the resolver
    __privateAdd(this, _supports2544);
    __privateAdd(this, _resolver);
    defineProperties(this, { provider, address, name });
    __privateSet(this, _supports2544, null);
    __privateSet(this, _resolver, new Contract(address, [
      "function supportsInterface(bytes4) view returns (bool)",
      "function resolve(bytes, bytes) view returns (bytes)",
      "function addr(bytes32) view returns (address)",
      "function addr(bytes32, uint) view returns (bytes)",
      "function text(bytes32, string) view returns (string)",
      "function contenthash(bytes32) view returns (bytes)"
    ], provider));
  }
  /**
   *  Resolves to true if the resolver supports wildcard resolution.
   */
  async supportsWildcard() {
    if (__privateGet(this, _supports2544) == null) {
      __privateSet(this, _supports2544, (async () => {
        try {
          return await __privateGet(this, _resolver).supportsInterface("0x9061b923");
        } catch (error) {
          if (isError(error, "CALL_EXCEPTION")) {
            return false;
          }
          __privateSet(this, _supports2544, null);
          throw error;
        }
      })());
    }
    return await __privateGet(this, _supports2544);
  }
  /**
   *  Resolves to the address for %%coinType%% or null if the
   *  provided %%coinType%% has not been configured.
   */
  async getAddress(coinType) {
    if (coinType == null) {
      coinType = 60;
    }
    if (coinType === 60) {
      try {
        const result = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "addr(bytes32)");
        if (result == null || result === ZeroAddress) {
          return null;
        }
        return result;
      } catch (error) {
        if (isError(error, "CALL_EXCEPTION")) {
          return null;
        }
        throw error;
      }
    }
    if (coinType >= 0 && coinType < 2147483648) {
      let ethCoinType = coinType + 2147483648;
      const data3 = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "addr(bytes32,uint)", [ethCoinType]);
      if (isHexString(data3, 20)) {
        return getAddress(data3);
      }
    }
    let coinPlugin = null;
    for (const plugin of this.provider.plugins) {
      if (!(plugin instanceof MulticoinProviderPlugin)) {
        continue;
      }
      if (plugin.supportsCoinType(coinType)) {
        coinPlugin = plugin;
        break;
      }
    }
    if (coinPlugin == null) {
      return null;
    }
    const data2 = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "addr(bytes32,uint)", [coinType]);
    if (data2 == null || data2 === "0x") {
      return null;
    }
    const address = await coinPlugin.decodeAddress(coinType, data2);
    if (address != null) {
      return address;
    }
    assert(false, `invalid coin data`, "UNSUPPORTED_OPERATION", {
      operation: `getAddress(${coinType})`,
      info: { coinType, data: data2 }
    });
  }
  /**
   *  Resolves to the EIP-634 text record for %%key%%, or ``null``
   *  if unconfigured.
   */
  async getText(key2) {
    const data2 = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "text(bytes32,string)", [key2]);
    if (data2 == null || data2 === "0x") {
      return null;
    }
    return data2;
  }
  /**
   *  Rsolves to the content-hash or ``null`` if unconfigured.
   */
  async getContentHash() {
    const data2 = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "contenthash(bytes32)");
    if (data2 == null || data2 === "0x") {
      return null;
    }
    const ipfs = data2.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
    if (ipfs) {
      const scheme = ipfs[1] === "e3010170" ? "ipfs" : "ipns";
      const length = parseInt(ipfs[4], 16);
      if (ipfs[5].length === length * 2) {
        return `${scheme}://${encodeBase58("0x" + ipfs[2])}`;
      }
    }
    const swarm = data2.match(/^0xe40101fa011b20([0-9a-f]*)$/);
    if (swarm && swarm[1].length === 64) {
      return `bzz://${swarm[1]}`;
    }
    assert(false, `invalid or unsupported content hash data`, "UNSUPPORTED_OPERATION", {
      operation: "getContentHash()",
      info: { data: data2 }
    });
  }
  /**
   *  Resolves to the avatar url or ``null`` if the avatar is either
   *  unconfigured or incorrectly configured (e.g. references an NFT
   *  not owned by the address).
   *
   *  If diagnosing issues with configurations, the [[_getAvatar]]
   *  method may be useful.
   */
  async getAvatar() {
    const avatar = await this._getAvatar();
    return avatar.url;
  }
  /**
   *  When resolving an avatar, there are many steps involved, such
   *  fetching metadata and possibly validating ownership of an
   *  NFT.
   *
   *  This method can be used to examine each step and the value it
   *  was working from.
   */
  async _getAvatar() {
    const linkage = [{ type: "name", value: this.name }];
    try {
      const avatar = await this.getText("avatar");
      if (avatar == null) {
        linkage.push({ type: "!avatar", value: "" });
        return { url: null, linkage };
      }
      linkage.push({ type: "avatar", value: avatar });
      for (let i4 = 0; i4 < matchers.length; i4++) {
        const match = avatar.match(matchers[i4]);
        if (match == null) {
          continue;
        }
        const scheme = match[1].toLowerCase();
        switch (scheme) {
          case "https":
          case "data":
            linkage.push({ type: "url", value: avatar });
            return { linkage, url: avatar };
          case "ipfs": {
            const url = getIpfsLink(avatar);
            linkage.push({ type: "ipfs", value: avatar });
            linkage.push({ type: "url", value: url });
            return { linkage, url };
          }
          case "erc721":
          case "erc1155": {
            const selector = scheme === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
            linkage.push({ type: scheme, value: avatar });
            const owner = await this.getAddress();
            if (owner == null) {
              linkage.push({ type: "!owner", value: "" });
              return { url: null, linkage };
            }
            const comps = (match[2] || "").split("/");
            if (comps.length !== 2) {
              linkage.push({ type: `!${scheme}caip`, value: match[2] || "" });
              return { url: null, linkage };
            }
            const tokenId = comps[1];
            const contract = new Contract(comps[0], [
              // ERC-721
              "function tokenURI(uint) view returns (string)",
              "function ownerOf(uint) view returns (address)",
              // ERC-1155
              "function uri(uint) view returns (string)",
              "function balanceOf(address, uint256) view returns (uint)"
            ], this.provider);
            if (scheme === "erc721") {
              const tokenOwner = await contract.ownerOf(tokenId);
              if (owner !== tokenOwner) {
                linkage.push({ type: "!owner", value: tokenOwner });
                return { url: null, linkage };
              }
              linkage.push({ type: "owner", value: tokenOwner });
            } else if (scheme === "erc1155") {
              const balance = await contract.balanceOf(owner, tokenId);
              if (!balance) {
                linkage.push({ type: "!balance", value: "0" });
                return { url: null, linkage };
              }
              linkage.push({ type: "balance", value: balance.toString() });
            }
            let metadataUrl = await contract[selector](tokenId);
            if (metadataUrl == null || metadataUrl === "0x") {
              linkage.push({ type: "!metadata-url", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata-url-base", value: metadataUrl });
            if (scheme === "erc1155") {
              metadataUrl = metadataUrl.replace("{id}", toBeHex(tokenId, 32).substring(2));
              linkage.push({ type: "metadata-url-expanded", value: metadataUrl });
            }
            if (metadataUrl.match(/^ipfs:/i)) {
              metadataUrl = getIpfsLink(metadataUrl);
            }
            linkage.push({ type: "metadata-url", value: metadataUrl });
            let metadata = {};
            const response = await new FetchRequest(metadataUrl).send();
            response.assertOk();
            try {
              metadata = response.bodyJson;
            } catch (error) {
              try {
                linkage.push({ type: "!metadata", value: response.bodyText });
              } catch (error2) {
                const bytes2 = response.body;
                if (bytes2) {
                  linkage.push({ type: "!metadata", value: hexlify(bytes2) });
                }
                return { url: null, linkage };
              }
              return { url: null, linkage };
            }
            if (!metadata) {
              linkage.push({ type: "!metadata", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata", value: JSON.stringify(metadata) });
            let imageUrl = metadata.image;
            if (typeof imageUrl !== "string") {
              linkage.push({ type: "!imageUrl", value: "" });
              return { url: null, linkage };
            }
            if (imageUrl.match(/^(https:\/\/|data:)/i)) {
            } else {
              const ipfs = imageUrl.match(matcherIpfs);
              if (ipfs == null) {
                linkage.push({ type: "!imageUrl-ipfs", value: imageUrl });
                return { url: null, linkage };
              }
              linkage.push({ type: "imageUrl-ipfs", value: imageUrl });
              imageUrl = getIpfsLink(imageUrl);
            }
            linkage.push({ type: "url", value: imageUrl });
            return { linkage, url: imageUrl };
          }
        }
      }
    } catch (error) {
    }
    return { linkage, url: null };
  }
  static async getEnsAddress(provider) {
    const network = await provider.getNetwork();
    const ensPlugin = network.getPlugin("org.ethers.plugins.network.Ens");
    assert(ensPlugin, "network does not support ENS", "UNSUPPORTED_OPERATION", {
      operation: "getEnsAddress",
      info: { network }
    });
    return ensPlugin.address;
  }
  /**
   *  Resolve to the ENS resolver for %%name%% using %%provider%% or
   *  ``null`` if unconfigured.
   */
  static async fromName(provider, name) {
    var _a3;
    let currentName = name;
    while (true) {
      if (currentName === "" || currentName === ".") {
        return null;
      }
      if (name !== "eth" && currentName === "eth") {
        return null;
      }
      const addr = await __privateMethod(_a3 = _EnsResolver, _EnsResolver_static, getResolver_fn).call(_a3, provider, currentName);
      if (addr != null) {
        const resolver = new _EnsResolver(provider, addr, name);
        if (currentName !== name && !await resolver.supportsWildcard()) {
          return null;
        }
        return resolver;
      }
      currentName = currentName.split(".").slice(1).join(".");
    }
  }
};
_supports2544 = new WeakMap();
_resolver = new WeakMap();
_EnsResolver_instances = new WeakSet();
fetch_fn = async function(funcName, params) {
  params = (params || []).slice();
  const iface = __privateGet(this, _resolver).interface;
  params.unshift(namehash(this.name));
  let fragment = null;
  if (await this.supportsWildcard()) {
    fragment = iface.getFunction(funcName);
    assert(fragment, "missing fragment", "UNKNOWN_ERROR", {
      info: { funcName }
    });
    params = [
      dnsEncode(this.name, 255),
      iface.encodeFunctionData(fragment, params)
    ];
    funcName = "resolve(bytes,bytes)";
  }
  params.push({
    enableCcipRead: true
  });
  try {
    const result = await __privateGet(this, _resolver)[funcName](...params);
    if (fragment) {
      return iface.decodeFunctionResult(fragment, result)[0];
    }
    return result;
  } catch (error) {
    if (!isError(error, "CALL_EXCEPTION")) {
      throw error;
    }
  }
  return null;
};
_EnsResolver_static = new WeakSet();
getResolver_fn = async function(provider, name) {
  const ensAddr = await _EnsResolver.getEnsAddress(provider);
  try {
    const contract = new Contract(ensAddr, [
      "function resolver(bytes32) view returns (address)"
    ], provider);
    const addr = await contract.resolver(namehash(name), {
      enableCcipRead: true
    });
    if (addr === ZeroAddress) {
      return null;
    }
    return addr;
  } catch (error) {
    throw error;
  }
  return null;
};
__privateAdd(_EnsResolver, _EnsResolver_static);
let EnsResolver = _EnsResolver;
const BN_0 = BigInt(0);
function allowNull(format2, nullValue) {
  return function(value) {
    if (value == null) {
      return nullValue;
    }
    return format2(value);
  };
}
function arrayOf(format2, allowNull2) {
  return (array) => {
    if (allowNull2 && array == null) {
      return null;
    }
    if (!Array.isArray(array)) {
      throw new Error("not an array");
    }
    return array.map((i4) => format2(i4));
  };
}
function object(format2, altNames) {
  return (value) => {
    const result = {};
    for (const key2 in format2) {
      let srcKey = key2;
      if (altNames && key2 in altNames && !(srcKey in value)) {
        for (const altKey of altNames[key2]) {
          if (altKey in value) {
            srcKey = altKey;
            break;
          }
        }
      }
      try {
        const nv = format2[key2](value[srcKey]);
        if (nv !== void 0) {
          result[key2] = nv;
        }
      } catch (error) {
        const message = error instanceof Error ? error.message : "not-an-error";
        assert(false, `invalid value for value.${key2} (${message})`, "BAD_DATA", { value });
      }
    }
    return result;
  };
}
function formatBoolean(value) {
  switch (value) {
    case true:
    case "true":
      return true;
    case false:
    case "false":
      return false;
  }
  assertArgument(false, `invalid boolean; ${JSON.stringify(value)}`, "value", value);
}
function formatData(value) {
  assertArgument(isHexString(value, true), "invalid data", "value", value);
  return value;
}
function formatHash(value) {
  assertArgument(isHexString(value, 32), "invalid hash", "value", value);
  return value;
}
const _formatLog = object({
  address: getAddress,
  blockHash: formatHash,
  blockNumber: getNumber,
  data: formatData,
  index: getNumber,
  removed: allowNull(formatBoolean, false),
  topics: arrayOf(formatHash),
  transactionHash: formatHash,
  transactionIndex: getNumber
}, {
  index: ["logIndex"]
});
function formatLog(value) {
  return _formatLog(value);
}
const _formatBlock = object({
  hash: allowNull(formatHash),
  parentHash: formatHash,
  parentBeaconBlockRoot: allowNull(formatHash, null),
  number: getNumber,
  timestamp: getNumber,
  nonce: allowNull(formatData),
  difficulty: getBigInt,
  gasLimit: getBigInt,
  gasUsed: getBigInt,
  stateRoot: allowNull(formatHash, null),
  receiptsRoot: allowNull(formatHash, null),
  blobGasUsed: allowNull(getBigInt, null),
  excessBlobGas: allowNull(getBigInt, null),
  miner: allowNull(getAddress),
  prevRandao: allowNull(formatHash, null),
  extraData: formatData,
  baseFeePerGas: allowNull(getBigInt)
}, {
  prevRandao: ["mixHash"]
});
function formatBlock(value) {
  const result = _formatBlock(value);
  result.transactions = value.transactions.map((tx) => {
    if (typeof tx === "string") {
      return tx;
    }
    return formatTransactionResponse(tx);
  });
  return result;
}
const _formatReceiptLog = object({
  transactionIndex: getNumber,
  blockNumber: getNumber,
  transactionHash: formatHash,
  address: getAddress,
  topics: arrayOf(formatHash),
  data: formatData,
  index: getNumber,
  blockHash: formatHash
}, {
  index: ["logIndex"]
});
function formatReceiptLog(value) {
  return _formatReceiptLog(value);
}
const _formatTransactionReceipt = object({
  to: allowNull(getAddress, null),
  from: allowNull(getAddress, null),
  contractAddress: allowNull(getAddress, null),
  // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
  index: getNumber,
  root: allowNull(hexlify),
  gasUsed: getBigInt,
  blobGasUsed: allowNull(getBigInt, null),
  logsBloom: allowNull(formatData),
  blockHash: formatHash,
  hash: formatHash,
  logs: arrayOf(formatReceiptLog),
  blockNumber: getNumber,
  //confirmations: allowNull(getNumber, null),
  cumulativeGasUsed: getBigInt,
  effectiveGasPrice: allowNull(getBigInt),
  blobGasPrice: allowNull(getBigInt, null),
  status: allowNull(getNumber),
  type: allowNull(getNumber, 0)
}, {
  effectiveGasPrice: ["gasPrice"],
  hash: ["transactionHash"],
  index: ["transactionIndex"]
});
function formatTransactionReceipt(value) {
  return _formatTransactionReceipt(value);
}
function formatTransactionResponse(value) {
  if (value.to && getBigInt(value.to) === BN_0) {
    value.to = "0x0000000000000000000000000000000000000000";
  }
  const result = object({
    hash: formatHash,
    // Some nodes do not return this, usually test nodes (like Ganache)
    index: allowNull(getNumber, void 0),
    type: (value2) => {
      if (value2 === "0x" || value2 == null) {
        return 0;
      }
      return getNumber(value2);
    },
    accessList: allowNull(accessListify, null),
    blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),
    blockHash: allowNull(formatHash, null),
    blockNumber: allowNull(getNumber, null),
    transactionIndex: allowNull(getNumber, null),
    from: getAddress,
    // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
    gasPrice: allowNull(getBigInt),
    maxPriorityFeePerGas: allowNull(getBigInt),
    maxFeePerGas: allowNull(getBigInt),
    maxFeePerBlobGas: allowNull(getBigInt, null),
    gasLimit: getBigInt,
    to: allowNull(getAddress, null),
    value: getBigInt,
    nonce: getNumber,
    data: formatData,
    creates: allowNull(getAddress, null),
    chainId: allowNull(getBigInt, null)
  }, {
    data: ["input"],
    gasLimit: ["gas"],
    index: ["transactionIndex"]
  })(value);
  if (result.to == null && result.creates == null) {
    result.creates = getCreateAddress(result);
  }
  if ((value.type === 1 || value.type === 2) && value.accessList == null) {
    result.accessList = [];
  }
  if (value.signature) {
    result.signature = Signature.from(value.signature);
  } else {
    result.signature = Signature.from(value);
  }
  if (result.chainId == null) {
    const chainId = result.signature.legacyChainId;
    if (chainId != null) {
      result.chainId = chainId;
    }
  }
  if (result.blockHash && getBigInt(result.blockHash) === BN_0) {
    result.blockHash = null;
  }
  return result;
}
const EnsAddress = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
class NetworkPlugin {
  /**
   *  Creates a new **NetworkPlugin**.
   */
  constructor(name) {
    /**
     *  The name of the plugin.
     *
     *  It is recommended to use reverse-domain-notation, which permits
     *  unique names with a known authority as well as hierarchal entries.
     */
    __publicField(this, "name");
    defineProperties(this, { name });
  }
  /**
   *  Creates a copy of this plugin.
   */
  clone() {
    return new NetworkPlugin(this.name);
  }
}
class GasCostPlugin extends NetworkPlugin {
  /**
   *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
   *  latest block or another GasCostPlugin supercedes that block number,
   *  with the associated %%costs%%.
   */
  constructor(effectiveBlock, costs) {
    if (effectiveBlock == null) {
      effectiveBlock = 0;
    }
    super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);
    /**
     *  The block number to treat these values as valid from.
     *
     *  This allows a hardfork to have updated values included as well as
     *  mulutiple hardforks to be supported.
     */
    __publicField(this, "effectiveBlock");
    /**
     *  The transactions base fee.
     */
    __publicField(this, "txBase");
    /**
     *  The fee for creating a new account.
     */
    __publicField(this, "txCreate");
    /**
     *  The fee per zero-byte in the data.
     */
    __publicField(this, "txDataZero");
    /**
     *  The fee per non-zero-byte in the data.
     */
    __publicField(this, "txDataNonzero");
    /**
     *  The fee per storage key in the [[link-eip-2930]] access list.
     */
    __publicField(this, "txAccessListStorageKey");
    /**
     *  The fee per address in the [[link-eip-2930]] access list.
     */
    __publicField(this, "txAccessListAddress");
    const props = { effectiveBlock };
    function set2(name, nullish) {
      let value = (costs || {})[name];
      if (value == null) {
        value = nullish;
      }
      assertArgument(typeof value === "number", `invalud value for ${name}`, "costs", costs);
      props[name] = value;
    }
    set2("txBase", 21e3);
    set2("txCreate", 32e3);
    set2("txDataZero", 4);
    set2("txDataNonzero", 16);
    set2("txAccessListStorageKey", 1900);
    set2("txAccessListAddress", 2400);
    defineProperties(this, props);
  }
  clone() {
    return new GasCostPlugin(this.effectiveBlock, this);
  }
}
class EnsPlugin extends NetworkPlugin {
  /**
   *  Creates a new **EnsPlugin** connected to %%address%% on the
   *  %%targetNetwork%%. The default ENS address and mainnet is used
   *  if unspecified.
   */
  constructor(address, targetNetwork) {
    super("org.ethers.plugins.network.Ens");
    /**
     *  The ENS Registrty Contract address.
     */
    __publicField(this, "address");
    /**
     *  The chain ID that the ENS contract lives on.
     */
    __publicField(this, "targetNetwork");
    defineProperties(this, {
      address: address || EnsAddress,
      targetNetwork: targetNetwork == null ? 1 : targetNetwork
    });
  }
  clone() {
    return new EnsPlugin(this.address, this.targetNetwork);
  }
}
class FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {
  /**
   *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
   *  be used when computing the fee data for the network.
   */
  constructor(url, processFunc) {
    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    __privateAdd(this, _url2);
    __privateAdd(this, _processFunc);
    __privateSet(this, _url2, url);
    __privateSet(this, _processFunc, processFunc);
  }
  /**
   *  The URL to initialize the FetchRequest with in %%processFunc%%.
   */
  get url() {
    return __privateGet(this, _url2);
  }
  /**
   *  The callback to use when computing the FeeData.
   */
  get processFunc() {
    return __privateGet(this, _processFunc);
  }
  // We are immutable, so we can serve as our own clone
  clone() {
    return this;
  }
}
_url2 = new WeakMap();
_processFunc = new WeakMap();
const Networks = /* @__PURE__ */ new Map();
const _Network = class _Network {
  /**
   *  Creates a new **Network** for %%name%% and %%chainId%%.
   */
  constructor(name, chainId) {
    __privateAdd(this, _name);
    __privateAdd(this, _chainId2);
    __privateAdd(this, _plugins);
    __privateSet(this, _name, name);
    __privateSet(this, _chainId2, getBigInt(chainId));
    __privateSet(this, _plugins, /* @__PURE__ */ new Map());
  }
  /**
   *  Returns a JSON-compatible representation of a Network.
   */
  toJSON() {
    return { name: this.name, chainId: String(this.chainId) };
  }
  /**
   *  The network common name.
   *
   *  This is the canonical name, as networks migh have multiple
   *  names.
   */
  get name() {
    return __privateGet(this, _name);
  }
  set name(value) {
    __privateSet(this, _name, value);
  }
  /**
   *  The network chain ID.
   */
  get chainId() {
    return __privateGet(this, _chainId2);
  }
  set chainId(value) {
    __privateSet(this, _chainId2, getBigInt(value, "chainId"));
  }
  /**
   *  Returns true if %%other%% matches this network. Any chain ID
   *  must match, and if no chain ID is present, the name must match.
   *
   *  This method does not currently check for additional properties,
   *  such as ENS address or plug-in compatibility.
   */
  matches(other) {
    if (other == null) {
      return false;
    }
    if (typeof other === "string") {
      try {
        return this.chainId === getBigInt(other);
      } catch (error) {
      }
      return this.name === other;
    }
    if (typeof other === "number" || typeof other === "bigint") {
      try {
        return this.chainId === getBigInt(other);
      } catch (error) {
      }
      return false;
    }
    if (typeof other === "object") {
      if (other.chainId != null) {
        try {
          return this.chainId === getBigInt(other.chainId);
        } catch (error) {
        }
        return false;
      }
      if (other.name != null) {
        return this.name === other.name;
      }
      return false;
    }
    return false;
  }
  /**
   *  Returns the list of plugins currently attached to this Network.
   */
  get plugins() {
    return Array.from(__privateGet(this, _plugins).values());
  }
  /**
   *  Attach a new %%plugin%% to this Network. The network name
   *  must be unique, excluding any fragment.
   */
  attachPlugin(plugin) {
    if (__privateGet(this, _plugins).get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    __privateGet(this, _plugins).set(plugin.name, plugin.clone());
    return this;
  }
  /**
   *  Return the plugin, if any, matching %%name%% exactly. Plugins
   *  with fragments will not be returned unless %%name%% includes
   *  a fragment.
   */
  getPlugin(name) {
    return __privateGet(this, _plugins).get(name) || null;
  }
  /**
   *  Gets a list of all plugins that match %%name%%, with otr without
   *  a fragment.
   */
  getPlugins(basename) {
    return this.plugins.filter((p2) => p2.name.split("#")[0] === basename);
  }
  /**
   *  Create a copy of this Network.
   */
  clone() {
    const clone = new _Network(this.name, this.chainId);
    this.plugins.forEach((plugin) => {
      clone.attachPlugin(plugin.clone());
    });
    return clone;
  }
  /**
   *  Compute the intrinsic gas required for a transaction.
   *
   *  A GasCostPlugin can be attached to override the default
   *  values.
   */
  computeIntrinsicGas(tx) {
    const costs = this.getPlugin("org.ethers.plugins.network.GasCost") || new GasCostPlugin();
    let gas = costs.txBase;
    if (tx.to == null) {
      gas += costs.txCreate;
    }
    if (tx.data) {
      for (let i4 = 2; i4 < tx.data.length; i4 += 2) {
        if (tx.data.substring(i4, i4 + 2) === "00") {
          gas += costs.txDataZero;
        } else {
          gas += costs.txDataNonzero;
        }
      }
    }
    if (tx.accessList) {
      const accessList = accessListify(tx.accessList);
      for (const addr in accessList) {
        gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;
      }
    }
    return gas;
  }
  /**
   *  Returns a new Network for the %%network%% name or chainId.
   */
  static from(network) {
    injectCommonNetworks();
    if (network == null) {
      return _Network.from("mainnet");
    }
    if (typeof network === "number") {
      network = BigInt(network);
    }
    if (typeof network === "string" || typeof network === "bigint") {
      const networkFunc = Networks.get(network);
      if (networkFunc) {
        return networkFunc();
      }
      if (typeof network === "bigint") {
        return new _Network("unknown", network);
      }
      assertArgument(false, "unknown network", "network", network);
    }
    if (typeof network.clone === "function") {
      const clone = network.clone();
      return clone;
    }
    if (typeof network === "object") {
      assertArgument(typeof network.name === "string" && typeof network.chainId === "number", "invalid network object name or chainId", "network", network);
      const custom2 = new _Network(network.name, network.chainId);
      if (network.ensAddress || network.ensNetwork != null) {
        custom2.attachPlugin(new EnsPlugin(network.ensAddress, network.ensNetwork));
      }
      return custom2;
    }
    assertArgument(false, "invalid network", "network", network);
  }
  /**
   *  Register %%nameOrChainId%% with a function which returns
   *  an instance of a Network representing that chain.
   */
  static register(nameOrChainId, networkFunc) {
    if (typeof nameOrChainId === "number") {
      nameOrChainId = BigInt(nameOrChainId);
    }
    const existing = Networks.get(nameOrChainId);
    if (existing) {
      assertArgument(false, `conflicting network for ${JSON.stringify(existing.name)}`, "nameOrChainId", nameOrChainId);
    }
    Networks.set(nameOrChainId, networkFunc);
  }
};
_name = new WeakMap();
_chainId2 = new WeakMap();
_plugins = new WeakMap();
let Network = _Network;
function parseUnits(_value2, decimals) {
  const value = String(_value2);
  if (!value.match(/^[0-9.]+$/)) {
    throw new Error(`invalid gwei value: ${_value2}`);
  }
  const comps = value.split(".");
  if (comps.length === 1) {
    comps.push("");
  }
  if (comps.length !== 2) {
    throw new Error(`invalid gwei value: ${_value2}`);
  }
  while (comps[1].length < decimals) {
    comps[1] += "0";
  }
  if (comps[1].length > 9) {
    let frac = BigInt(comps[1].substring(0, 9));
    if (!comps[1].substring(9).match(/^0+$/)) {
      frac++;
    }
    comps[1] = frac.toString();
  }
  return BigInt(comps[0] + comps[1]);
}
function getGasStationPlugin(url) {
  return new FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request) => {
    request.setHeader("User-Agent", "ethers");
    let response;
    try {
      const [_response, _feeData] = await Promise.all([
        request.send(),
        fetchFeeData()
      ]);
      response = _response;
      const payload = response.bodyJson.standard;
      const feeData = {
        gasPrice: _feeData.gasPrice,
        maxFeePerGas: parseUnits(payload.maxFee, 9),
        maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9)
      };
      return feeData;
    } catch (error) {
      assert(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, "SERVER_ERROR", { request, response, error });
    }
  });
}
let injected = false;
function injectCommonNetworks() {
  if (injected) {
    return;
  }
  injected = true;
  function registerEth(name, chainId, options) {
    const func = function() {
      const network = new Network(name, chainId);
      if (options.ensNetwork != null) {
        network.attachPlugin(new EnsPlugin(null, options.ensNetwork));
      }
      network.attachPlugin(new GasCostPlugin());
      (options.plugins || []).forEach((plugin) => {
        network.attachPlugin(plugin);
      });
      return network;
    };
    Network.register(name, func);
    Network.register(chainId, func);
    if (options.altNames) {
      options.altNames.forEach((name2) => {
        Network.register(name2, func);
      });
    }
  }
  registerEth("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] });
  registerEth("ropsten", 3, { ensNetwork: 3 });
  registerEth("rinkeby", 4, { ensNetwork: 4 });
  registerEth("goerli", 5, { ensNetwork: 5 });
  registerEth("kovan", 42, { ensNetwork: 42 });
  registerEth("sepolia", 11155111, { ensNetwork: 11155111 });
  registerEth("holesky", 17e3, { ensNetwork: 17e3 });
  registerEth("classic", 61, {});
  registerEth("classicKotti", 6, {});
  registerEth("arbitrum", 42161, {
    ensNetwork: 1
  });
  registerEth("arbitrum-goerli", 421613, {});
  registerEth("arbitrum-sepolia", 421614, {});
  registerEth("base", 8453, { ensNetwork: 1 });
  registerEth("base-goerli", 84531, {});
  registerEth("base-sepolia", 84532, {});
  registerEth("bnb", 56, { ensNetwork: 1 });
  registerEth("bnbt", 97, {});
  registerEth("linea", 59144, { ensNetwork: 1 });
  registerEth("linea-goerli", 59140, {});
  registerEth("linea-sepolia", 59141, {});
  registerEth("matic", 137, {
    ensNetwork: 1,
    plugins: [
      getGasStationPlugin("https://gasstation.polygon.technology/v2")
    ]
  });
  registerEth("matic-amoy", 80002, {});
  registerEth("matic-mumbai", 80001, {
    altNames: ["maticMumbai", "maticmum"],
    plugins: [
      getGasStationPlugin("https://gasstation-testnet.polygon.technology/v2")
    ]
  });
  registerEth("optimism", 10, {
    ensNetwork: 1,
    plugins: []
  });
  registerEth("optimism-goerli", 420, {});
  registerEth("optimism-sepolia", 11155420, {});
  registerEth("xdai", 100, { ensNetwork: 1 });
}
function copy$2(obj) {
  return JSON.parse(JSON.stringify(obj));
}
class PollingBlockSubscriber {
  /**
   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.
   */
  constructor(provider) {
    __privateAdd(this, _PollingBlockSubscriber_instances);
    __privateAdd(this, _provider);
    __privateAdd(this, _poller);
    __privateAdd(this, _interval);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    __privateAdd(this, _blockNumber);
    __privateSet(this, _provider, provider);
    __privateSet(this, _poller, null);
    __privateSet(this, _interval, 4e3);
    __privateSet(this, _blockNumber, -2);
  }
  /**
   *  The polling interval.
   */
  get pollingInterval() {
    return __privateGet(this, _interval);
  }
  set pollingInterval(value) {
    __privateSet(this, _interval, value);
  }
  start() {
    if (__privateGet(this, _poller)) {
      return;
    }
    __privateSet(this, _poller, __privateGet(this, _provider)._setTimeout(__privateMethod(this, _PollingBlockSubscriber_instances, poll_fn).bind(this), __privateGet(this, _interval)));
    __privateMethod(this, _PollingBlockSubscriber_instances, poll_fn).call(this);
  }
  stop() {
    if (!__privateGet(this, _poller)) {
      return;
    }
    __privateGet(this, _provider)._clearTimeout(__privateGet(this, _poller));
    __privateSet(this, _poller, null);
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      __privateSet(this, _blockNumber, -2);
    }
  }
  resume() {
    this.start();
  }
}
_provider = new WeakMap();
_poller = new WeakMap();
_interval = new WeakMap();
_blockNumber = new WeakMap();
_PollingBlockSubscriber_instances = new WeakSet();
poll_fn = async function() {
  try {
    const blockNumber = await __privateGet(this, _provider).getBlockNumber();
    if (__privateGet(this, _blockNumber) === -2) {
      __privateSet(this, _blockNumber, blockNumber);
      return;
    }
    if (blockNumber !== __privateGet(this, _blockNumber)) {
      for (let b2 = __privateGet(this, _blockNumber) + 1; b2 <= blockNumber; b2++) {
        if (__privateGet(this, _poller) == null) {
          return;
        }
        await __privateGet(this, _provider).emit("block", b2);
      }
      __privateSet(this, _blockNumber, blockNumber);
    }
  } catch (error) {
  }
  if (__privateGet(this, _poller) == null) {
    return;
  }
  __privateSet(this, _poller, __privateGet(this, _provider)._setTimeout(__privateMethod(this, _PollingBlockSubscriber_instances, poll_fn).bind(this), __privateGet(this, _interval)));
};
class OnBlockSubscriber {
  /**
   *  Create a new **OnBlockSubscriber** attached to %%provider%%.
   */
  constructor(provider) {
    __privateAdd(this, _provider2);
    __privateAdd(this, _poll);
    __privateAdd(this, _running);
    __privateSet(this, _provider2, provider);
    __privateSet(this, _running, false);
    __privateSet(this, _poll, (blockNumber) => {
      this._poll(blockNumber, __privateGet(this, _provider2));
    });
  }
  /**
   *  Called on every new block.
   */
  async _poll(blockNumber, provider) {
    throw new Error("sub-classes must override this");
  }
  start() {
    if (__privateGet(this, _running)) {
      return;
    }
    __privateSet(this, _running, true);
    __privateGet(this, _poll).call(this, -2);
    __privateGet(this, _provider2).on("block", __privateGet(this, _poll));
  }
  stop() {
    if (!__privateGet(this, _running)) {
      return;
    }
    __privateSet(this, _running, false);
    __privateGet(this, _provider2).off("block", __privateGet(this, _poll));
  }
  pause(dropWhilePaused) {
    this.stop();
  }
  resume() {
    this.start();
  }
}
_provider2 = new WeakMap();
_poll = new WeakMap();
_running = new WeakMap();
class PollingBlockTagSubscriber extends OnBlockSubscriber {
  constructor(provider, tag) {
    super(provider);
    __privateAdd(this, _tag);
    __privateAdd(this, _lastBlock);
    __privateSet(this, _tag, tag);
    __privateSet(this, _lastBlock, -2);
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      __privateSet(this, _lastBlock, -2);
    }
    super.pause(dropWhilePaused);
  }
  async _poll(blockNumber, provider) {
    const block = await provider.getBlock(__privateGet(this, _tag));
    if (block == null) {
      return;
    }
    if (__privateGet(this, _lastBlock) === -2) {
      __privateSet(this, _lastBlock, block.number);
    } else if (block.number > __privateGet(this, _lastBlock)) {
      provider.emit(__privateGet(this, _tag), block.number);
      __privateSet(this, _lastBlock, block.number);
    }
  }
}
_tag = new WeakMap();
_lastBlock = new WeakMap();
class PollingOrphanSubscriber extends OnBlockSubscriber {
  constructor(provider, filter) {
    super(provider);
    __privateAdd(this, _filter2);
    __privateSet(this, _filter2, copy$2(filter));
  }
  async _poll(blockNumber, provider) {
    throw new Error("@TODO");
  }
}
_filter2 = new WeakMap();
class PollingTransactionSubscriber extends OnBlockSubscriber {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%hash%%.
   */
  constructor(provider, hash3) {
    super(provider);
    __privateAdd(this, _hash);
    __privateSet(this, _hash, hash3);
  }
  async _poll(blockNumber, provider) {
    const tx = await provider.getTransactionReceipt(__privateGet(this, _hash));
    if (tx) {
      provider.emit(__privateGet(this, _hash), tx);
    }
  }
}
_hash = new WeakMap();
class PollingEventSubscriber {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%filter%%.
   */
  constructor(provider, filter) {
    __privateAdd(this, _PollingEventSubscriber_instances);
    __privateAdd(this, _provider3);
    __privateAdd(this, _filter3);
    __privateAdd(this, _poller2);
    __privateAdd(this, _running2);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    __privateAdd(this, _blockNumber2);
    __privateSet(this, _provider3, provider);
    __privateSet(this, _filter3, copy$2(filter));
    __privateSet(this, _poller2, __privateMethod(this, _PollingEventSubscriber_instances, poll_fn2).bind(this));
    __privateSet(this, _running2, false);
    __privateSet(this, _blockNumber2, -2);
  }
  start() {
    if (__privateGet(this, _running2)) {
      return;
    }
    __privateSet(this, _running2, true);
    if (__privateGet(this, _blockNumber2) === -2) {
      __privateGet(this, _provider3).getBlockNumber().then((blockNumber) => {
        __privateSet(this, _blockNumber2, blockNumber);
      });
    }
    __privateGet(this, _provider3).on("block", __privateGet(this, _poller2));
  }
  stop() {
    if (!__privateGet(this, _running2)) {
      return;
    }
    __privateSet(this, _running2, false);
    __privateGet(this, _provider3).off("block", __privateGet(this, _poller2));
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      __privateSet(this, _blockNumber2, -2);
    }
  }
  resume() {
    this.start();
  }
}
_provider3 = new WeakMap();
_filter3 = new WeakMap();
_poller2 = new WeakMap();
_running2 = new WeakMap();
_blockNumber2 = new WeakMap();
_PollingEventSubscriber_instances = new WeakSet();
poll_fn2 = async function(blockNumber) {
  if (__privateGet(this, _blockNumber2) === -2) {
    return;
  }
  const filter = copy$2(__privateGet(this, _filter3));
  filter.fromBlock = __privateGet(this, _blockNumber2) + 1;
  filter.toBlock = blockNumber;
  const logs = await __privateGet(this, _provider3).getLogs(filter);
  if (logs.length === 0) {
    if (__privateGet(this, _blockNumber2) < blockNumber - 60) {
      __privateSet(this, _blockNumber2, blockNumber - 60);
    }
    return;
  }
  for (const log2 of logs) {
    __privateGet(this, _provider3).emit(__privateGet(this, _filter3), log2);
    __privateSet(this, _blockNumber2, log2.blockNumber);
  }
};
const BN_2 = BigInt(2);
const MAX_CCIP_REDIRECTS = 10;
function isPromise(value) {
  return value && typeof value.then === "function";
}
function getTag(prefix, value) {
  return prefix + ":" + JSON.stringify(value, (k3, v2) => {
    if (v2 == null) {
      return "null";
    }
    if (typeof v2 === "bigint") {
      return `bigint:${v2.toString()}`;
    }
    if (typeof v2 === "string") {
      return v2.toLowerCase();
    }
    if (typeof v2 === "object" && !Array.isArray(v2)) {
      const keys2 = Object.keys(v2);
      keys2.sort();
      return keys2.reduce((accum, key2) => {
        accum[key2] = v2[key2];
        return accum;
      }, {});
    }
    return v2;
  });
}
class UnmanagedSubscriber {
  /**
   *  Create a new UnmanagedSubscriber with %%name%%.
   */
  constructor(name) {
    /**
     *  The name fof the event.
     */
    __publicField(this, "name");
    defineProperties(this, { name });
  }
  start() {
  }
  stop() {
  }
  pause(dropWhilePaused) {
  }
  resume() {
  }
}
function copy$1(value) {
  return JSON.parse(JSON.stringify(value));
}
function concisify(items) {
  items = Array.from(new Set(items).values());
  items.sort();
  return items;
}
async function getSubscription(_event2, provider) {
  if (_event2 == null) {
    throw new Error("invalid event");
  }
  if (Array.isArray(_event2)) {
    _event2 = { topics: _event2 };
  }
  if (typeof _event2 === "string") {
    switch (_event2) {
      case "block":
      case "debug":
      case "error":
      case "finalized":
      case "network":
      case "pending":
      case "safe": {
        return { type: _event2, tag: _event2 };
      }
    }
  }
  if (isHexString(_event2, 32)) {
    const hash3 = _event2.toLowerCase();
    return { type: "transaction", tag: getTag("tx", { hash: hash3 }), hash: hash3 };
  }
  if (_event2.orphan) {
    const event = _event2;
    return { type: "orphan", tag: getTag("orphan", event), filter: copy$1(event) };
  }
  if (_event2.address || _event2.topics) {
    const event = _event2;
    const filter = {
      topics: (event.topics || []).map((t2) => {
        if (t2 == null) {
          return null;
        }
        if (Array.isArray(t2)) {
          return concisify(t2.map((t3) => t3.toLowerCase()));
        }
        return t2.toLowerCase();
      })
    };
    if (event.address) {
      const addresses = [];
      const promises = [];
      const addAddress = (addr) => {
        if (isHexString(addr)) {
          addresses.push(addr);
        } else {
          promises.push((async () => {
            addresses.push(await resolveAddress(addr, provider));
          })());
        }
      };
      if (Array.isArray(event.address)) {
        event.address.forEach(addAddress);
      } else {
        addAddress(event.address);
      }
      if (promises.length) {
        await Promise.all(promises);
      }
      filter.address = concisify(addresses.map((a2) => a2.toLowerCase()));
    }
    return { filter, tag: getTag("event", filter), type: "event" };
  }
  assertArgument(false, "unknown ProviderEvent", "event", _event2);
}
function getTime() {
  return (/* @__PURE__ */ new Date()).getTime();
}
const defaultOptions$1 = {
  cacheTimeout: 250,
  pollingInterval: 4e3
};
class AbstractProvider {
  /**
   *  Create a new **AbstractProvider** connected to %%network%%, or
   *  use the various network detection capabilities to discover the
   *  [[Network]] if necessary.
   */
  constructor(_network3, options) {
    __privateAdd(this, _AbstractProvider_instances);
    __privateAdd(this, _subs);
    __privateAdd(this, _plugins2);
    // null=unpaused, true=paused+dropWhilePaused, false=paused
    __privateAdd(this, _pausedState);
    __privateAdd(this, _destroyed);
    __privateAdd(this, _networkPromise);
    __privateAdd(this, _anyNetwork);
    __privateAdd(this, _performCache);
    // The most recent block number if running an event or -1 if no "block" event
    __privateAdd(this, _lastBlockNumber);
    __privateAdd(this, _nextTimer);
    __privateAdd(this, _timers);
    __privateAdd(this, _disableCcipRead);
    __privateAdd(this, _options2);
    __privateSet(this, _options2, Object.assign({}, defaultOptions$1, options || {}));
    if (_network3 === "any") {
      __privateSet(this, _anyNetwork, true);
      __privateSet(this, _networkPromise, null);
    } else if (_network3) {
      const network = Network.from(_network3);
      __privateSet(this, _anyNetwork, false);
      __privateSet(this, _networkPromise, Promise.resolve(network));
      setTimeout(() => {
        this.emit("network", network, null);
      }, 0);
    } else {
      __privateSet(this, _anyNetwork, false);
      __privateSet(this, _networkPromise, null);
    }
    __privateSet(this, _lastBlockNumber, -1);
    __privateSet(this, _performCache, /* @__PURE__ */ new Map());
    __privateSet(this, _subs, /* @__PURE__ */ new Map());
    __privateSet(this, _plugins2, /* @__PURE__ */ new Map());
    __privateSet(this, _pausedState, null);
    __privateSet(this, _destroyed, false);
    __privateSet(this, _nextTimer, 1);
    __privateSet(this, _timers, /* @__PURE__ */ new Map());
    __privateSet(this, _disableCcipRead, false);
  }
  get pollingInterval() {
    return __privateGet(this, _options2).pollingInterval;
  }
  /**
   *  Returns ``this``, to allow an **AbstractProvider** to implement
   *  the [[ContractRunner]] interface.
   */
  get provider() {
    return this;
  }
  /**
   *  Returns all the registered plug-ins.
   */
  get plugins() {
    return Array.from(__privateGet(this, _plugins2).values());
  }
  /**
   *  Attach a new plug-in.
   */
  attachPlugin(plugin) {
    if (__privateGet(this, _plugins2).get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    __privateGet(this, _plugins2).set(plugin.name, plugin.connect(this));
    return this;
  }
  /**
   *  Get a plugin by name.
   */
  getPlugin(name) {
    return __privateGet(this, _plugins2).get(name) || null;
  }
  /**
   *  Prevent any CCIP-read operation, regardless of whether requested
   *  in a [[call]] using ``enableCcipRead``.
   */
  get disableCcipRead() {
    return __privateGet(this, _disableCcipRead);
  }
  set disableCcipRead(value) {
    __privateSet(this, _disableCcipRead, !!value);
  }
  /**
   *  Resolves to the data for executing the CCIP-read operations.
   */
  async ccipReadFetch(tx, calldata, urls) {
    if (this.disableCcipRead || urls.length === 0 || tx.to == null) {
      return null;
    }
    const sender = tx.to.toLowerCase();
    const data2 = calldata.toLowerCase();
    const errorMessages = [];
    for (let i4 = 0; i4 < urls.length; i4++) {
      const url = urls[i4];
      const href = url.replace("{sender}", sender).replace("{data}", data2);
      const request = new FetchRequest(href);
      if (url.indexOf("{data}") === -1) {
        request.body = { data: data2, sender };
      }
      this.emit("debug", { action: "sendCcipReadFetchRequest", request, index: i4, urls });
      let errorMessage = "unknown error";
      const resp = await request.send();
      try {
        const result = resp.bodyJson;
        if (result.data) {
          this.emit("debug", { action: "receiveCcipReadFetchResult", request, result });
          return result.data;
        }
        if (result.message) {
          errorMessage = result.message;
        }
        this.emit("debug", { action: "receiveCcipReadFetchError", request, result });
      } catch (error) {
      }
      assert(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: tx, info: { url, errorMessage } });
      errorMessages.push(errorMessage);
    }
    assert(false, `error encountered during CCIP fetch: ${errorMessages.map((m4) => JSON.stringify(m4)).join(", ")}`, "OFFCHAIN_FAULT", {
      reason: "500_SERVER_ERROR",
      transaction: tx,
      info: { urls, errorMessages }
    });
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a block before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Block]].
   */
  _wrapBlock(value, network) {
    return new Block(formatBlock(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a log before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Log]].
   */
  _wrapLog(value, network) {
    return new Log(formatLog(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  receipt before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionReceipt]].
   */
  _wrapTransactionReceipt(value, network) {
    return new TransactionReceipt(formatTransactionReceipt(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  response before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionResponse]].
   */
  _wrapTransactionResponse(tx, network) {
    return new TransactionResponse(formatTransactionResponse(tx), this);
  }
  /**
   *  Resolves to the Network, forcing a network detection using whatever
   *  technique the sub-class requires.
   *
   *  Sub-classes **must** override this.
   */
  _detectNetwork() {
    assert(false, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
      operation: "_detectNetwork"
    });
  }
  /**
   *  Sub-classes should use this to perform all built-in operations. All
   *  methods sanitizes and normalizes the values passed into this.
   *
   *  Sub-classes **must** override this.
   */
  async _perform(req) {
    assert(false, `unsupported method: ${req.method}`, "UNSUPPORTED_OPERATION", {
      operation: req.method,
      info: req
    });
  }
  // State
  async getBlockNumber() {
    const blockNumber = getNumber(await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getBlockNumber" }), "%response");
    if (__privateGet(this, _lastBlockNumber) >= 0) {
      __privateSet(this, _lastBlockNumber, blockNumber);
    }
    return blockNumber;
  }
  /**
   *  Returns or resolves to the address for %%address%%, resolving ENS
   *  names and [[Addressable]] objects and returning if already an
   *  address.
   */
  _getAddress(address) {
    return resolveAddress(address, this);
  }
  /**
   *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
   *  negative values and returning if already a valid block tag.
   */
  _getBlockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    switch (blockTag) {
      case "earliest":
        return "0x0";
      case "finalized":
      case "latest":
      case "pending":
      case "safe":
        return blockTag;
    }
    if (isHexString(blockTag)) {
      if (isHexString(blockTag, 32)) {
        return blockTag;
      }
      return toQuantity(blockTag);
    }
    if (typeof blockTag === "bigint") {
      blockTag = getNumber(blockTag, "blockTag");
    }
    if (typeof blockTag === "number") {
      if (blockTag >= 0) {
        return toQuantity(blockTag);
      }
      if (__privateGet(this, _lastBlockNumber) >= 0) {
        return toQuantity(__privateGet(this, _lastBlockNumber) + blockTag);
      }
      return this.getBlockNumber().then((b2) => toQuantity(b2 + blockTag));
    }
    assertArgument(false, "invalid blockTag", "blockTag", blockTag);
  }
  /**
   *  Returns or resolves to a filter for %%filter%%, resolving any ENS
   *  names or [[Addressable]] object and returning if already a valid
   *  filter.
   */
  _getFilter(filter) {
    const topics = (filter.topics || []).map((t2) => {
      if (t2 == null) {
        return null;
      }
      if (Array.isArray(t2)) {
        return concisify(t2.map((t3) => t3.toLowerCase()));
      }
      return t2.toLowerCase();
    });
    const blockHash = "blockHash" in filter ? filter.blockHash : void 0;
    const resolve = (_address, fromBlock2, toBlock2) => {
      let address2 = void 0;
      switch (_address.length) {
        case 0:
          break;
        case 1:
          address2 = _address[0];
          break;
        default:
          _address.sort();
          address2 = _address;
      }
      if (blockHash) {
        if (fromBlock2 != null || toBlock2 != null) {
          throw new Error("invalid filter");
        }
      }
      const filter2 = {};
      if (address2) {
        filter2.address = address2;
      }
      if (topics.length) {
        filter2.topics = topics;
      }
      if (fromBlock2) {
        filter2.fromBlock = fromBlock2;
      }
      if (toBlock2) {
        filter2.toBlock = toBlock2;
      }
      if (blockHash) {
        filter2.blockHash = blockHash;
      }
      return filter2;
    };
    let address = [];
    if (filter.address) {
      if (Array.isArray(filter.address)) {
        for (const addr of filter.address) {
          address.push(this._getAddress(addr));
        }
      } else {
        address.push(this._getAddress(filter.address));
      }
    }
    let fromBlock = void 0;
    if ("fromBlock" in filter) {
      fromBlock = this._getBlockTag(filter.fromBlock);
    }
    let toBlock = void 0;
    if ("toBlock" in filter) {
      toBlock = this._getBlockTag(filter.toBlock);
    }
    if (address.filter((a2) => typeof a2 !== "string").length || fromBlock != null && typeof fromBlock !== "string" || toBlock != null && typeof toBlock !== "string") {
      return Promise.all([Promise.all(address), fromBlock, toBlock]).then((result) => {
        return resolve(result[0], result[1], result[2]);
      });
    }
    return resolve(address, fromBlock, toBlock);
  }
  /**
   *  Returns or resolves to a transaction for %%request%%, resolving
   *  any ENS names or [[Addressable]] and returning if already a valid
   *  transaction.
   */
  _getTransactionRequest(_request3) {
    const request = copyRequest(_request3);
    const promises = [];
    ["to", "from"].forEach((key2) => {
      if (request[key2] == null) {
        return;
      }
      const addr = resolveAddress(request[key2], this);
      if (isPromise(addr)) {
        promises.push(async function() {
          request[key2] = await addr;
        }());
      } else {
        request[key2] = addr;
      }
    });
    if (request.blockTag != null) {
      const blockTag = this._getBlockTag(request.blockTag);
      if (isPromise(blockTag)) {
        promises.push(async function() {
          request.blockTag = await blockTag;
        }());
      } else {
        request.blockTag = blockTag;
      }
    }
    if (promises.length) {
      return async function() {
        await Promise.all(promises);
        return request;
      }();
    }
    return request;
  }
  async getNetwork() {
    if (__privateGet(this, _networkPromise) == null) {
      const detectNetwork = (async () => {
        try {
          const network = await this._detectNetwork();
          this.emit("network", network, null);
          return network;
        } catch (error) {
          if (__privateGet(this, _networkPromise) === detectNetwork) {
            __privateSet(this, _networkPromise, null);
          }
          throw error;
        }
      })();
      __privateSet(this, _networkPromise, detectNetwork);
      return (await detectNetwork).clone();
    }
    const networkPromise = __privateGet(this, _networkPromise);
    const [expected, actual] = await Promise.all([
      networkPromise,
      this._detectNetwork()
      // The actual connected network
    ]);
    if (expected.chainId !== actual.chainId) {
      if (__privateGet(this, _anyNetwork)) {
        this.emit("network", actual, expected);
        if (__privateGet(this, _networkPromise) === networkPromise) {
          __privateSet(this, _networkPromise, Promise.resolve(actual));
        }
      } else {
        assert(false, `network changed: ${expected.chainId} => ${actual.chainId} `, "NETWORK_ERROR", {
          event: "changed"
        });
      }
    }
    return expected.clone();
  }
  async getFeeData() {
    const network = await this.getNetwork();
    const getFeeDataFunc = async () => {
      const { _block, gasPrice, priorityFee } = await resolveProperties({
        _block: __privateMethod(this, _AbstractProvider_instances, getBlock_fn).call(this, "latest", false),
        gasPrice: (async () => {
          try {
            const value = await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getGasPrice" });
            return getBigInt(value, "%response");
          } catch (error) {
          }
          return null;
        })(),
        priorityFee: (async () => {
          try {
            const value = await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getPriorityFee" });
            return getBigInt(value, "%response");
          } catch (error) {
          }
          return null;
        })()
      });
      let maxFeePerGas = null;
      let maxPriorityFeePerGas = null;
      const block = this._wrapBlock(_block, network);
      if (block && block.baseFeePerGas) {
        maxPriorityFeePerGas = priorityFee != null ? priorityFee : BigInt("1000000000");
        maxFeePerGas = block.baseFeePerGas * BN_2 + maxPriorityFeePerGas;
      }
      return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);
    };
    const plugin = network.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    if (plugin) {
      const req = new FetchRequest(plugin.url);
      const feeData = await plugin.processFunc(getFeeDataFunc, this, req);
      return new FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);
    }
    return await getFeeDataFunc();
  }
  async estimateGas(_tx) {
    let tx = this._getTransactionRequest(_tx);
    if (isPromise(tx)) {
      tx = await tx;
    }
    return getBigInt(await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, {
      method: "estimateGas",
      transaction: tx
    }), "%response");
  }
  async call(_tx) {
    const { tx, blockTag } = await resolveProperties({
      tx: this._getTransactionRequest(_tx),
      blockTag: this._getBlockTag(_tx.blockTag)
    });
    return await __privateMethod(this, _AbstractProvider_instances, checkNetwork_fn).call(this, __privateMethod(this, _AbstractProvider_instances, call_fn).call(this, tx, blockTag, _tx.enableCcipRead ? 0 : -1));
  }
  async getBalance(address, blockTag) {
    return getBigInt(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getBalance" }, address, blockTag), "%response");
  }
  async getTransactionCount(address, blockTag) {
    return getNumber(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getTransactionCount" }, address, blockTag), "%response");
  }
  async getCode(address, blockTag) {
    return hexlify(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getCode" }, address, blockTag));
  }
  async getStorage(address, _position, blockTag) {
    const position = getBigInt(_position, "position");
    return hexlify(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getStorage", position }, address, blockTag));
  }
  // Write
  async broadcastTransaction(signedTx) {
    const { blockNumber, hash: hash3, network } = await resolveProperties({
      blockNumber: this.getBlockNumber(),
      hash: this._perform({
        method: "broadcastTransaction",
        signedTransaction: signedTx
      }),
      network: this.getNetwork()
    });
    const tx = Transaction.from(signedTx);
    if (tx.hash !== hash3) {
      throw new Error("@TODO: the returned hash did not match");
    }
    return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);
  }
  // Queries
  async getBlock(block, prefetchTxs) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: __privateMethod(this, _AbstractProvider_instances, getBlock_fn).call(this, block, !!prefetchTxs)
    });
    if (params == null) {
      return null;
    }
    return this._wrapBlock(params, network);
  }
  async getTransaction(hash3) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransaction", hash: hash3 })
    });
    if (params == null) {
      return null;
    }
    return this._wrapTransactionResponse(params, network);
  }
  async getTransactionReceipt(hash3) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransactionReceipt", hash: hash3 })
    });
    if (params == null) {
      return null;
    }
    if (params.gasPrice == null && params.effectiveGasPrice == null) {
      const tx = await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransaction", hash: hash3 });
      if (tx == null) {
        throw new Error("report this; could not find tx or effectiveGasPrice");
      }
      params.effectiveGasPrice = tx.gasPrice;
    }
    return this._wrapTransactionReceipt(params, network);
  }
  async getTransactionResult(hash3) {
    const { result } = await resolveProperties({
      network: this.getNetwork(),
      result: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransactionResult", hash: hash3 })
    });
    if (result == null) {
      return null;
    }
    return hexlify(result);
  }
  // Bloom-filter Queries
  async getLogs(_filter5) {
    let filter = this._getFilter(_filter5);
    if (isPromise(filter)) {
      filter = await filter;
    }
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getLogs", filter })
    });
    return params.map((p2) => this._wrapLog(p2, network));
  }
  // ENS
  _getProvider(chainId) {
    assert(false, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
      operation: "_getProvider()"
    });
  }
  async getResolver(name) {
    return await EnsResolver.fromName(this, name);
  }
  async getAvatar(name) {
    const resolver = await this.getResolver(name);
    if (resolver) {
      return await resolver.getAvatar();
    }
    return null;
  }
  async resolveName(name) {
    const resolver = await this.getResolver(name);
    if (resolver) {
      return await resolver.getAddress();
    }
    return null;
  }
  async lookupAddress(address) {
    address = getAddress(address);
    const node2 = namehash(address.substring(2).toLowerCase() + ".addr.reverse");
    try {
      const ensAddr = await EnsResolver.getEnsAddress(this);
      const ensContract = new Contract(ensAddr, [
        "function resolver(bytes32) view returns (address)"
      ], this);
      const resolver = await ensContract.resolver(node2);
      if (resolver == null || resolver === ZeroAddress) {
        return null;
      }
      const resolverContract = new Contract(resolver, [
        "function name(bytes32) view returns (string)"
      ], this);
      const name = await resolverContract.name(node2);
      const check = await this.resolveName(name);
      if (check !== address) {
        return null;
      }
      return name;
    } catch (error) {
      if (isError(error, "BAD_DATA") && error.value === "0x") {
        return null;
      }
      if (isError(error, "CALL_EXCEPTION")) {
        return null;
      }
      throw error;
    }
    return null;
  }
  async waitForTransaction(hash3, _confirms, timeout) {
    const confirms = _confirms != null ? _confirms : 1;
    if (confirms === 0) {
      return this.getTransactionReceipt(hash3);
    }
    return new Promise(async (resolve, reject) => {
      let timer = null;
      const listener = async (blockNumber) => {
        try {
          const receipt = await this.getTransactionReceipt(hash3);
          if (receipt != null) {
            if (blockNumber - receipt.blockNumber + 1 >= confirms) {
              resolve(receipt);
              if (timer) {
                clearTimeout(timer);
                timer = null;
              }
              return;
            }
          }
        } catch (error) {
          console.log("EEE", error);
        }
        this.once("block", listener);
      };
      if (timeout != null) {
        timer = setTimeout(() => {
          if (timer == null) {
            return;
          }
          timer = null;
          this.off("block", listener);
          reject(makeError("timeout", "TIMEOUT", { reason: "timeout" }));
        }, timeout);
      }
      listener(await this.getBlockNumber());
    });
  }
  async waitForBlock(blockTag) {
    assert(false, "not implemented yet", "NOT_IMPLEMENTED", {
      operation: "waitForBlock"
    });
  }
  /**
   *  Clear a timer created using the [[_setTimeout]] method.
   */
  _clearTimeout(timerId) {
    const timer = __privateGet(this, _timers).get(timerId);
    if (!timer) {
      return;
    }
    if (timer.timer) {
      clearTimeout(timer.timer);
    }
    __privateGet(this, _timers).delete(timerId);
  }
  /**
   *  Create a timer that will execute %%func%% after at least %%timeout%%
   *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
   *  in the next event loop.
   *
   *  [Pausing](AbstractProvider-paused) the provider will pause any
   *  associated timers.
   */
  _setTimeout(_func, timeout) {
    if (timeout == null) {
      timeout = 0;
    }
    const timerId = __privateWrapper(this, _nextTimer)._++;
    const func = () => {
      __privateGet(this, _timers).delete(timerId);
      _func();
    };
    if (this.paused) {
      __privateGet(this, _timers).set(timerId, { timer: null, func, time: timeout });
    } else {
      const timer = setTimeout(func, timeout);
      __privateGet(this, _timers).set(timerId, { timer, func, time: getTime() });
    }
    return timerId;
  }
  /**
   *  Perform %%func%% on each subscriber.
   */
  _forEachSubscriber(func) {
    for (const sub of __privateGet(this, _subs).values()) {
      func(sub.subscriber);
    }
  }
  /**
   *  Sub-classes may override this to customize subscription
   *  implementations.
   */
  _getSubscriber(sub) {
    switch (sub.type) {
      case "debug":
      case "error":
      case "network":
        return new UnmanagedSubscriber(sub.type);
      case "block": {
        const subscriber = new PollingBlockSubscriber(this);
        subscriber.pollingInterval = this.pollingInterval;
        return subscriber;
      }
      case "safe":
      case "finalized":
        return new PollingBlockTagSubscriber(this, sub.type);
      case "event":
        return new PollingEventSubscriber(this, sub.filter);
      case "transaction":
        return new PollingTransactionSubscriber(this, sub.hash);
      case "orphan":
        return new PollingOrphanSubscriber(this, sub.filter);
    }
    throw new Error(`unsupported event: ${sub.type}`);
  }
  /**
   *  If a [[Subscriber]] fails and needs to replace itself, this
   *  method may be used.
   *
   *  For example, this is used for providers when using the
   *  ``eth_getFilterChanges`` method, which can return null if state
   *  filters are not supported by the backend, allowing the Subscriber
   *  to swap in a [[PollingEventSubscriber]].
   */
  _recoverSubscriber(oldSub, newSub) {
    for (const sub of __privateGet(this, _subs).values()) {
      if (sub.subscriber === oldSub) {
        if (sub.started) {
          sub.subscriber.stop();
        }
        sub.subscriber = newSub;
        if (sub.started) {
          newSub.start();
        }
        if (__privateGet(this, _pausedState) != null) {
          newSub.pause(__privateGet(this, _pausedState));
        }
        break;
      }
    }
  }
  async on(event, listener) {
    const sub = await __privateMethod(this, _AbstractProvider_instances, getSub_fn).call(this, event);
    sub.listeners.push({ listener, once: false });
    if (!sub.started) {
      sub.subscriber.start();
      sub.started = true;
      if (__privateGet(this, _pausedState) != null) {
        sub.subscriber.pause(__privateGet(this, _pausedState));
      }
    }
    return this;
  }
  async once(event, listener) {
    const sub = await __privateMethod(this, _AbstractProvider_instances, getSub_fn).call(this, event);
    sub.listeners.push({ listener, once: true });
    if (!sub.started) {
      sub.subscriber.start();
      sub.started = true;
      if (__privateGet(this, _pausedState) != null) {
        sub.subscriber.pause(__privateGet(this, _pausedState));
      }
    }
    return this;
  }
  async emit(event, ...args) {
    const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event, args);
    if (!sub || sub.listeners.length === 0) {
      return false;
    }
    const count = sub.listeners.length;
    sub.listeners = sub.listeners.filter(({ listener, once: once3 }) => {
      const payload = new EventPayload(this, once3 ? null : listener, event);
      try {
        listener.call(this, ...args, payload);
      } catch (error) {
      }
      return !once3;
    });
    if (sub.listeners.length === 0) {
      if (sub.started) {
        sub.subscriber.stop();
      }
      __privateGet(this, _subs).delete(sub.tag);
    }
    return count > 0;
  }
  async listenerCount(event) {
    if (event) {
      const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event);
      if (!sub) {
        return 0;
      }
      return sub.listeners.length;
    }
    let total = 0;
    for (const { listeners: listeners2 } of __privateGet(this, _subs).values()) {
      total += listeners2.length;
    }
    return total;
  }
  async listeners(event) {
    if (event) {
      const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event);
      if (!sub) {
        return [];
      }
      return sub.listeners.map(({ listener }) => listener);
    }
    let result = [];
    for (const { listeners: listeners2 } of __privateGet(this, _subs).values()) {
      result = result.concat(listeners2.map(({ listener }) => listener));
    }
    return result;
  }
  async off(event, listener) {
    const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event);
    if (!sub) {
      return this;
    }
    if (listener) {
      const index2 = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index2 >= 0) {
        sub.listeners.splice(index2, 1);
      }
    }
    if (!listener || sub.listeners.length === 0) {
      if (sub.started) {
        sub.subscriber.stop();
      }
      __privateGet(this, _subs).delete(sub.tag);
    }
    return this;
  }
  async removeAllListeners(event) {
    if (event) {
      const { tag, started, subscriber } = await __privateMethod(this, _AbstractProvider_instances, getSub_fn).call(this, event);
      if (started) {
        subscriber.stop();
      }
      __privateGet(this, _subs).delete(tag);
    } else {
      for (const [tag, { started, subscriber }] of __privateGet(this, _subs)) {
        if (started) {
          subscriber.stop();
        }
        __privateGet(this, _subs).delete(tag);
      }
    }
    return this;
  }
  // Alias for "on"
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  // Alias for "off"
  async removeListener(event, listener) {
    return this.off(event, listener);
  }
  /**
   *  If this provider has been destroyed using the [[destroy]] method.
   *
   *  Once destroyed, all resources are reclaimed, internal event loops
   *  and timers are cleaned up and no further requests may be sent to
   *  the provider.
   */
  get destroyed() {
    return __privateGet(this, _destroyed);
  }
  /**
   *  Sub-classes may use this to shutdown any sockets or release their
   *  resources and reject any pending requests.
   *
   *  Sub-classes **must** call ``super.destroy()``.
   */
  destroy() {
    this.removeAllListeners();
    for (const timerId of __privateGet(this, _timers).keys()) {
      this._clearTimeout(timerId);
    }
    __privateSet(this, _destroyed, true);
  }
  /**
   *  Whether the provider is currently paused.
   *
   *  A paused provider will not emit any events, and generally should
   *  not make any requests to the network, but that is up to sub-classes
   *  to manage.
   *
   *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
   *  which will buffer any events that occur while paused until the
   *  provider is unpaused.
   */
  get paused() {
    return __privateGet(this, _pausedState) != null;
  }
  set paused(pause) {
    if (!!pause === this.paused) {
      return;
    }
    if (this.paused) {
      this.resume();
    } else {
      this.pause(false);
    }
  }
  /**
   *  Pause the provider. If %%dropWhilePaused%%, any events that occur
   *  while paused are dropped, otherwise all events will be emitted once
   *  the provider is unpaused.
   */
  pause(dropWhilePaused) {
    __privateSet(this, _lastBlockNumber, -1);
    if (__privateGet(this, _pausedState) != null) {
      if (__privateGet(this, _pausedState) == !!dropWhilePaused) {
        return;
      }
      assert(false, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
        operation: "pause"
      });
    }
    this._forEachSubscriber((s2) => s2.pause(dropWhilePaused));
    __privateSet(this, _pausedState, !!dropWhilePaused);
    for (const timer of __privateGet(this, _timers).values()) {
      if (timer.timer) {
        clearTimeout(timer.timer);
      }
      timer.time = getTime() - timer.time;
    }
  }
  /**
   *  Resume the provider.
   */
  resume() {
    if (__privateGet(this, _pausedState) == null) {
      return;
    }
    this._forEachSubscriber((s2) => s2.resume());
    __privateSet(this, _pausedState, null);
    for (const timer of __privateGet(this, _timers).values()) {
      let timeout = timer.time;
      if (timeout < 0) {
        timeout = 0;
      }
      timer.time = getTime();
      setTimeout(timer.func, timeout);
    }
  }
}
_subs = new WeakMap();
_plugins2 = new WeakMap();
_pausedState = new WeakMap();
_destroyed = new WeakMap();
_networkPromise = new WeakMap();
_anyNetwork = new WeakMap();
_performCache = new WeakMap();
_lastBlockNumber = new WeakMap();
_nextTimer = new WeakMap();
_timers = new WeakMap();
_disableCcipRead = new WeakMap();
_options2 = new WeakMap();
_AbstractProvider_instances = new WeakSet();
perform_fn = async function(req) {
  const timeout = __privateGet(this, _options2).cacheTimeout;
  if (timeout < 0) {
    return await this._perform(req);
  }
  const tag = getTag(req.method, req);
  let perform = __privateGet(this, _performCache).get(tag);
  if (!perform) {
    perform = this._perform(req);
    __privateGet(this, _performCache).set(tag, perform);
    setTimeout(() => {
      if (__privateGet(this, _performCache).get(tag) === perform) {
        __privateGet(this, _performCache).delete(tag);
      }
    }, timeout);
  }
  return await perform;
};
call_fn = async function(tx, blockTag, attempt) {
  assert(attempt < MAX_CCIP_REDIRECTS, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
    reason: "TOO_MANY_REDIRECTS",
    transaction: Object.assign({}, tx, { blockTag, enableCcipRead: true })
  });
  const transaction = copyRequest(tx);
  try {
    return hexlify(await this._perform({ method: "call", transaction, blockTag }));
  } catch (error) {
    if (!this.disableCcipRead && isCallException(error) && error.data && attempt >= 0 && blockTag === "latest" && transaction.to != null && dataSlice(error.data, 0, 4) === "0x556f1830") {
      const data2 = error.data;
      const txSender = await resolveAddress(transaction.to, this);
      let ccipArgs;
      try {
        ccipArgs = parseOffchainLookup(dataSlice(error.data, 4));
      } catch (error2) {
        assert(false, error2.message, "OFFCHAIN_FAULT", {
          reason: "BAD_DATA",
          transaction,
          info: { data: data2 }
        });
      }
      assert(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
        action: "call",
        data: data2,
        reason: "OffchainLookup",
        transaction,
        invocation: null,
        revert: {
          signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
          name: "OffchainLookup",
          args: ccipArgs.errorArgs
        }
      });
      const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);
      assert(ccipResult != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
        reason: "FETCH_FAILED",
        transaction,
        info: { data: error.data, errorArgs: ccipArgs.errorArgs }
      });
      const tx2 = {
        to: txSender,
        data: concat([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])
      };
      this.emit("debug", { action: "sendCcipReadCall", transaction: tx2 });
      try {
        const result = await __privateMethod(this, _AbstractProvider_instances, call_fn).call(this, tx2, blockTag, attempt + 1);
        this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, tx2), result });
        return result;
      } catch (error2) {
        this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, tx2), error: error2 });
        throw error2;
      }
    }
    throw error;
  }
};
checkNetwork_fn = async function(promise) {
  const { value } = await resolveProperties({
    network: this.getNetwork(),
    value: promise
  });
  return value;
};
getAccountValue_fn = async function(request, _address, _blockTag) {
  let address = this._getAddress(_address);
  let blockTag = this._getBlockTag(_blockTag);
  if (typeof address !== "string" || typeof blockTag !== "string") {
    [address, blockTag] = await Promise.all([address, blockTag]);
  }
  return await __privateMethod(this, _AbstractProvider_instances, checkNetwork_fn).call(this, __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, Object.assign(request, { address, blockTag })));
};
getBlock_fn = async function(block, includeTransactions) {
  if (isHexString(block, 32)) {
    return await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, {
      method: "getBlock",
      blockHash: block,
      includeTransactions
    });
  }
  let blockTag = this._getBlockTag(block);
  if (typeof blockTag !== "string") {
    blockTag = await blockTag;
  }
  return await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, {
    method: "getBlock",
    blockTag,
    includeTransactions
  });
};
hasSub_fn = async function(event, emitArgs) {
  let sub = await getSubscription(event, this);
  if (sub.type === "event" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {
    sub = await getSubscription({ orphan: "drop-log", log: emitArgs[0] }, this);
  }
  return __privateGet(this, _subs).get(sub.tag) || null;
};
getSub_fn = async function(event) {
  const subscription = await getSubscription(event, this);
  const tag = subscription.tag;
  let sub = __privateGet(this, _subs).get(tag);
  if (!sub) {
    const subscriber = this._getSubscriber(subscription);
    const addressableMap = /* @__PURE__ */ new WeakMap();
    const nameMap = /* @__PURE__ */ new Map();
    sub = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [] };
    __privateGet(this, _subs).set(tag, sub);
  }
  return sub;
};
function _parseString(result, start) {
  try {
    const bytes2 = _parseBytes(result, start);
    if (bytes2) {
      return toUtf8String(bytes2);
    }
  } catch (error) {
  }
  return null;
}
function _parseBytes(result, start) {
  if (result === "0x") {
    return null;
  }
  try {
    const offset = getNumber(dataSlice(result, start, start + 32));
    const length = getNumber(dataSlice(result, offset, offset + 32));
    return dataSlice(result, offset + 32, offset + 32 + length);
  } catch (error) {
  }
  return null;
}
function numPad(value) {
  const result = toBeArray(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
}
const empty = new Uint8Array([]);
function encodeBytes(datas) {
  const result = [];
  let byteCount = 0;
  for (let i4 = 0; i4 < datas.length; i4++) {
    result.push(empty);
    byteCount += 32;
  }
  for (let i4 = 0; i4 < datas.length; i4++) {
    const data2 = getBytes(datas[i4]);
    result[i4] = numPad(byteCount);
    result.push(numPad(data2.length));
    result.push(bytesPad(data2));
    byteCount += 32 + Math.ceil(data2.length / 32) * 32;
  }
  return concat(result);
}
const zeros = "0x0000000000000000000000000000000000000000000000000000000000000000";
function parseOffchainLookup(data2) {
  const result = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: []
  };
  assert(dataLength(data2) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data"
  });
  const sender = dataSlice(data2, 0, 32);
  assert(dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup sender"
  });
  result.sender = dataSlice(sender, 12);
  try {
    const urls = [];
    const urlsOffset = getNumber(dataSlice(data2, 32, 64));
    const urlsLength = getNumber(dataSlice(data2, urlsOffset, urlsOffset + 32));
    const urlsData = dataSlice(data2, urlsOffset + 32);
    for (let u2 = 0; u2 < urlsLength; u2++) {
      const url = _parseString(urlsData, u2 * 32);
      if (url == null) {
        throw new Error("abort");
      }
      urls.push(url);
    }
    result.urls = urls;
  } catch (error) {
    assert(false, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls"
    });
  }
  try {
    const calldata = _parseBytes(data2, 64);
    if (calldata == null) {
      throw new Error("abort");
    }
    result.calldata = calldata;
  } catch (error) {
    assert(false, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata"
    });
  }
  assert(dataSlice(data2, 100, 128) === dataSlice(zeros, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup callbaackSelector"
  });
  result.selector = dataSlice(data2, 96, 100);
  try {
    const extraData = _parseBytes(data2, 128);
    if (extraData == null) {
      throw new Error("abort");
    }
    result.extraData = extraData;
  } catch (error) {
    assert(false, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData"
    });
  }
  result.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((k3) => result[k3]);
  return result;
}
function checkProvider(signer, operation) {
  if (signer.provider) {
    return signer.provider;
  }
  assert(false, "missing provider", "UNSUPPORTED_OPERATION", { operation });
}
async function populate(signer, tx) {
  let pop = copyRequest(tx);
  if (pop.to != null) {
    pop.to = resolveAddress(pop.to, signer);
  }
  if (pop.from != null) {
    const from2 = pop.from;
    pop.from = Promise.all([
      signer.getAddress(),
      resolveAddress(from2, signer)
    ]).then(([address, from3]) => {
      assertArgument(address.toLowerCase() === from3.toLowerCase(), "transaction from mismatch", "tx.from", from3);
      return address;
    });
  } else {
    pop.from = signer.getAddress();
  }
  return await resolveProperties(pop);
}
class AbstractSigner {
  /**
   *  Creates a new Signer connected to %%provider%%.
   */
  constructor(provider) {
    /**
     *  The provider this signer is connected to.
     */
    __publicField(this, "provider");
    defineProperties(this, { provider: provider || null });
  }
  async getNonce(blockTag) {
    return checkProvider(this, "getTransactionCount").getTransactionCount(await this.getAddress(), blockTag);
  }
  async populateCall(tx) {
    const pop = await populate(this, tx);
    return pop;
  }
  async populateTransaction(tx) {
    const provider = checkProvider(this, "populateTransaction");
    const pop = await populate(this, tx);
    if (pop.nonce == null) {
      pop.nonce = await this.getNonce("pending");
    }
    if (pop.gasLimit == null) {
      pop.gasLimit = await this.estimateGas(pop);
    }
    const network = await this.provider.getNetwork();
    if (pop.chainId != null) {
      const chainId = getBigInt(pop.chainId);
      assertArgument(chainId === network.chainId, "transaction chainId mismatch", "tx.chainId", tx.chainId);
    } else {
      pop.chainId = network.chainId;
    }
    const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;
    if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
      assertArgument(false, "eip-1559 transaction do not support gasPrice", "tx", tx);
    } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
      assertArgument(false, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", tx);
    }
    if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {
      pop.type = 2;
    } else if (pop.type === 0 || pop.type === 1) {
      const feeData = await provider.getFeeData();
      assert(feeData.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
        operation: "getGasPrice"
      });
      if (pop.gasPrice == null) {
        pop.gasPrice = feeData.gasPrice;
      }
    } else {
      const feeData = await provider.getFeeData();
      if (pop.type == null) {
        if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
          pop.type = 2;
          if (pop.gasPrice != null) {
            const gasPrice = pop.gasPrice;
            delete pop.gasPrice;
            pop.maxFeePerGas = gasPrice;
            pop.maxPriorityFeePerGas = gasPrice;
          } else {
            if (pop.maxFeePerGas == null) {
              pop.maxFeePerGas = feeData.maxFeePerGas;
            }
            if (pop.maxPriorityFeePerGas == null) {
              pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
            }
          }
        } else if (feeData.gasPrice != null) {
          assert(!hasEip1559, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
            operation: "populateTransaction"
          });
          if (pop.gasPrice == null) {
            pop.gasPrice = feeData.gasPrice;
          }
          pop.type = 0;
        } else {
          assert(false, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
            operation: "signer.getFeeData"
          });
        }
      } else if (pop.type === 2 || pop.type === 3) {
        if (pop.maxFeePerGas == null) {
          pop.maxFeePerGas = feeData.maxFeePerGas;
        }
        if (pop.maxPriorityFeePerGas == null) {
          pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
        }
      }
    }
    return await resolveProperties(pop);
  }
  async estimateGas(tx) {
    return checkProvider(this, "estimateGas").estimateGas(await this.populateCall(tx));
  }
  async call(tx) {
    return checkProvider(this, "call").call(await this.populateCall(tx));
  }
  async resolveName(name) {
    const provider = checkProvider(this, "resolveName");
    return await provider.resolveName(name);
  }
  async sendTransaction(tx) {
    const provider = checkProvider(this, "sendTransaction");
    const pop = await this.populateTransaction(tx);
    delete pop.from;
    const txObj = Transaction.from(pop);
    return await provider.broadcastTransaction(await this.signTransaction(txObj));
  }
}
const shown = /* @__PURE__ */ new Set();
function showThrottleMessage(service) {
  if (shown.has(service)) {
    return;
  }
  shown.add(service);
  console.log("========= NOTICE =========");
  console.log(`Request-Rate Exceeded for ${service} (this message will not be repeated)`);
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https://docs.ethers.org/api-keys/");
  console.log("==========================");
}
function copy(obj) {
  return JSON.parse(JSON.stringify(obj));
}
class FilterIdSubscriber {
  /**
   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]
   *  and [[_emitResults]] to setup the subscription and provide the event
   *  to the %%provider%%.
   */
  constructor(provider) {
    __privateAdd(this, _FilterIdSubscriber_instances);
    __privateAdd(this, _provider4);
    __privateAdd(this, _filterIdPromise);
    __privateAdd(this, _poller3);
    __privateAdd(this, _running3);
    __privateAdd(this, _network);
    __privateAdd(this, _hault);
    __privateSet(this, _provider4, provider);
    __privateSet(this, _filterIdPromise, null);
    __privateSet(this, _poller3, __privateMethod(this, _FilterIdSubscriber_instances, poll_fn3).bind(this));
    __privateSet(this, _running3, false);
    __privateSet(this, _network, null);
    __privateSet(this, _hault, false);
  }
  /**
   *  Sub-classes **must** override this to begin the subscription.
   */
  _subscribe(provider) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle the events.
   */
  _emitResults(provider, result) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle recovery on errors.
   */
  _recover(provider) {
    throw new Error("subclasses must override this");
  }
  start() {
    if (__privateGet(this, _running3)) {
      return;
    }
    __privateSet(this, _running3, true);
    __privateMethod(this, _FilterIdSubscriber_instances, poll_fn3).call(this, -2);
  }
  stop() {
    if (!__privateGet(this, _running3)) {
      return;
    }
    __privateSet(this, _running3, false);
    __privateSet(this, _hault, true);
    __privateMethod(this, _FilterIdSubscriber_instances, teardown_fn).call(this);
    __privateGet(this, _provider4).off("block", __privateGet(this, _poller3));
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      __privateMethod(this, _FilterIdSubscriber_instances, teardown_fn).call(this);
    }
    __privateGet(this, _provider4).off("block", __privateGet(this, _poller3));
  }
  resume() {
    this.start();
  }
}
_provider4 = new WeakMap();
_filterIdPromise = new WeakMap();
_poller3 = new WeakMap();
_running3 = new WeakMap();
_network = new WeakMap();
_hault = new WeakMap();
_FilterIdSubscriber_instances = new WeakSet();
poll_fn3 = async function(blockNumber) {
  try {
    if (__privateGet(this, _filterIdPromise) == null) {
      __privateSet(this, _filterIdPromise, this._subscribe(__privateGet(this, _provider4)));
    }
    let filterId = null;
    try {
      filterId = await __privateGet(this, _filterIdPromise);
    } catch (error) {
      if (!isError(error, "UNSUPPORTED_OPERATION") || error.operation !== "eth_newFilter") {
        throw error;
      }
    }
    if (filterId == null) {
      __privateSet(this, _filterIdPromise, null);
      __privateGet(this, _provider4)._recoverSubscriber(this, this._recover(__privateGet(this, _provider4)));
      return;
    }
    const network = await __privateGet(this, _provider4).getNetwork();
    if (!__privateGet(this, _network)) {
      __privateSet(this, _network, network);
    }
    if (__privateGet(this, _network).chainId !== network.chainId) {
      throw new Error("chaid changed");
    }
    if (__privateGet(this, _hault)) {
      return;
    }
    const result = await __privateGet(this, _provider4).send("eth_getFilterChanges", [filterId]);
    await this._emitResults(__privateGet(this, _provider4), result);
  } catch (error) {
    console.log("@TODO", error);
  }
  __privateGet(this, _provider4).once("block", __privateGet(this, _poller3));
};
teardown_fn = function() {
  const filterIdPromise = __privateGet(this, _filterIdPromise);
  if (filterIdPromise) {
    __privateSet(this, _filterIdPromise, null);
    filterIdPromise.then((filterId) => {
      if (__privateGet(this, _provider4).destroyed) {
        return;
      }
      __privateGet(this, _provider4).send("eth_uninstallFilter", [filterId]);
    });
  }
};
class FilterIdEventSubscriber extends FilterIdSubscriber {
  /**
   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%
   *  listening for %%filter%%.
   */
  constructor(provider, filter) {
    super(provider);
    __privateAdd(this, _event);
    __privateSet(this, _event, copy(filter));
  }
  _recover(provider) {
    return new PollingEventSubscriber(provider, __privateGet(this, _event));
  }
  async _subscribe(provider) {
    const filterId = await provider.send("eth_newFilter", [__privateGet(this, _event)]);
    return filterId;
  }
  async _emitResults(provider, results) {
    for (const result of results) {
      provider.emit(__privateGet(this, _event), provider._wrapLog(result, provider._network));
    }
  }
}
_event = new WeakMap();
class FilterIdPendingSubscriber extends FilterIdSubscriber {
  async _subscribe(provider) {
    return await provider.send("eth_newPendingTransactionFilter", []);
  }
  async _emitResults(provider, results) {
    for (const result of results) {
      provider.emit("pending", result);
    }
  }
}
const Primitive = "bigint,boolean,function,number,string,symbol".split(/,/g);
function deepCopy(value) {
  if (value == null || Primitive.indexOf(typeof value) >= 0) {
    return value;
  }
  if (typeof value.getAddress === "function") {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map(deepCopy);
  }
  if (typeof value === "object") {
    return Object.keys(value).reduce((accum, key2) => {
      accum[key2] = value[key2];
      return accum;
    }, {});
  }
  throw new Error(`should not happen: ${value} (${typeof value})`);
}
function stall(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
function isPollable(value) {
  return value && typeof value.pollingInterval === "number";
}
const defaultOptions = {
  polling: false,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100,
  cacheTimeout: 250,
  pollingInterval: 4e3
};
class JsonRpcSigner extends AbstractSigner {
  constructor(provider, address) {
    super(provider);
    __publicField(this, "address");
    address = getAddress(address);
    defineProperties(this, { address });
  }
  connect(provider) {
    assert(false, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
      operation: "signer.connect"
    });
  }
  async getAddress() {
    return this.address;
  }
  // JSON-RPC will automatially fill in nonce, etc. so we just check from
  async populateTransaction(tx) {
    return await this.populateCall(tx);
  }
  // Returns just the hash of the transaction after sent, which is what
  // the bare JSON-RPC API does;
  async sendUncheckedTransaction(_tx) {
    const tx = deepCopy(_tx);
    const promises = [];
    if (tx.from) {
      const _from = tx.from;
      promises.push((async () => {
        const from2 = await resolveAddress(_from, this.provider);
        assertArgument(from2 != null && from2.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
        tx.from = from2;
      })());
    } else {
      tx.from = this.address;
    }
    if (tx.gasLimit == null) {
      promises.push((async () => {
        tx.gasLimit = await this.provider.estimateGas({ ...tx, from: this.address });
      })());
    }
    if (tx.to != null) {
      const _to2 = tx.to;
      promises.push((async () => {
        tx.to = await resolveAddress(_to2, this.provider);
      })());
    }
    if (promises.length) {
      await Promise.all(promises);
    }
    const hexTx = this.provider.getRpcTransaction(tx);
    return this.provider.send("eth_sendTransaction", [hexTx]);
  }
  async sendTransaction(tx) {
    const blockNumber = await this.provider.getBlockNumber();
    const hash3 = await this.sendUncheckedTransaction(tx);
    return await new Promise((resolve, reject) => {
      const timeouts = [1e3, 100];
      let invalids = 0;
      const checkTx = async () => {
        try {
          const tx2 = await this.provider.getTransaction(hash3);
          if (tx2 != null) {
            resolve(tx2.replaceableTransaction(blockNumber));
            return;
          }
        } catch (error) {
          if (isError(error, "CANCELLED") || isError(error, "BAD_DATA") || isError(error, "NETWORK_ERROR")) {
            if (error.info == null) {
              error.info = {};
            }
            error.info.sendTransactionHash = hash3;
            reject(error);
            return;
          }
          if (isError(error, "INVALID_ARGUMENT")) {
            invalids++;
            if (error.info == null) {
              error.info = {};
            }
            error.info.sendTransactionHash = hash3;
            if (invalids > 10) {
              reject(error);
              return;
            }
          }
          this.provider.emit("error", makeError("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", { error }));
        }
        this.provider._setTimeout(() => {
          checkTx();
        }, timeouts.pop() || 4e3);
      };
      checkTx();
    });
  }
  async signTransaction(_tx) {
    const tx = deepCopy(_tx);
    if (tx.from) {
      const from2 = await resolveAddress(tx.from, this.provider);
      assertArgument(from2 != null && from2.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
      tx.from = from2;
    } else {
      tx.from = this.address;
    }
    const hexTx = this.provider.getRpcTransaction(tx);
    return await this.provider.send("eth_signTransaction", [hexTx]);
  }
  async signMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
    return await this.provider.send("personal_sign", [
      hexlify(message),
      this.address.toLowerCase()
    ]);
  }
  async signTypedData(domain, types2, _value2) {
    const value = deepCopy(_value2);
    const populated = await TypedDataEncoder.resolveNames(domain, types2, value, async (value2) => {
      const address = await resolveAddress(value2);
      assertArgument(address != null, "TypedData does not support null address", "value", value2);
      return address;
    });
    return await this.provider.send("eth_signTypedData_v4", [
      this.address.toLowerCase(),
      JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types2, populated.value))
    ]);
  }
  async unlock(password) {
    return this.provider.send("personal_unlockAccount", [
      this.address.toLowerCase(),
      password,
      null
    ]);
  }
  // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
  async _legacySignMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
    return await this.provider.send("eth_sign", [
      this.address.toLowerCase(),
      hexlify(message)
    ]);
  }
}
class JsonRpcApiProvider extends AbstractProvider {
  constructor(network, options) {
    super(network, options);
    __privateAdd(this, _JsonRpcApiProvider_instances);
    __privateAdd(this, _options3);
    // The next ID to use for the JSON-RPC ID field
    __privateAdd(this, _nextId);
    // Payloads are queued and triggered in batches using the drainTimer
    __privateAdd(this, _payloads);
    __privateAdd(this, _drainTimer);
    __privateAdd(this, _notReady);
    __privateAdd(this, _network2);
    __privateAdd(this, _pendingDetectNetwork);
    __privateSet(this, _nextId, 1);
    __privateSet(this, _options3, Object.assign({}, defaultOptions, options || {}));
    __privateSet(this, _payloads, []);
    __privateSet(this, _drainTimer, null);
    __privateSet(this, _network2, null);
    __privateSet(this, _pendingDetectNetwork, null);
    {
      let resolve = null;
      const promise = new Promise((_resolve) => {
        resolve = _resolve;
      });
      __privateSet(this, _notReady, { promise, resolve });
    }
    const staticNetwork = this._getOption("staticNetwork");
    if (typeof staticNetwork === "boolean") {
      assertArgument(!staticNetwork || network !== "any", "staticNetwork cannot be used on special network 'any'", "options", options);
      if (staticNetwork && network != null) {
        __privateSet(this, _network2, Network.from(network));
      }
    } else if (staticNetwork) {
      assertArgument(network == null || staticNetwork.matches(network), "staticNetwork MUST match network object", "options", options);
      __privateSet(this, _network2, staticNetwork);
    }
  }
  /**
   *  Returns the value associated with the option %%key%%.
   *
   *  Sub-classes can use this to inquire about configuration options.
   */
  _getOption(key2) {
    return __privateGet(this, _options3)[key2];
  }
  /**
   *  Gets the [[Network]] this provider has committed to. On each call, the network
   *  is detected, and if it has changed, the call will reject.
   */
  get _network() {
    assert(__privateGet(this, _network2), "network is not available yet", "NETWORK_ERROR");
    return __privateGet(this, _network2);
  }
  /**
   *  Resolves to the non-normalized value by performing %%req%%.
   *
   *  Sub-classes may override this to modify behavior of actions,
   *  and should generally call ``super._perform`` as a fallback.
   */
  async _perform(req) {
    if (req.method === "call" || req.method === "estimateGas") {
      let tx = req.transaction;
      if (tx && tx.type != null && getBigInt(tx.type)) {
        if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
          const feeData = await this.getFeeData();
          if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
            req = Object.assign({}, req, {
              transaction: Object.assign({}, tx, { type: void 0 })
            });
          }
        }
      }
    }
    const request = this.getRpcRequest(req);
    if (request != null) {
      return await this.send(request.method, request.args);
    }
    return super._perform(req);
  }
  /**
   *  Sub-classes may override this; it detects the *actual* network that
   *  we are **currently** connected to.
   *
   *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
   *  _send primitive must be used instead.
   */
  async _detectNetwork() {
    const network = this._getOption("staticNetwork");
    if (network) {
      if (network === true) {
        if (__privateGet(this, _network2)) {
          return __privateGet(this, _network2);
        }
      } else {
        return network;
      }
    }
    if (__privateGet(this, _pendingDetectNetwork)) {
      return await __privateGet(this, _pendingDetectNetwork);
    }
    if (this.ready) {
      __privateSet(this, _pendingDetectNetwork, (async () => {
        try {
          const result = Network.from(getBigInt(await this.send("eth_chainId", [])));
          __privateSet(this, _pendingDetectNetwork, null);
          return result;
        } catch (error) {
          __privateSet(this, _pendingDetectNetwork, null);
          throw error;
        }
      })());
      return await __privateGet(this, _pendingDetectNetwork);
    }
    __privateSet(this, _pendingDetectNetwork, (async () => {
      const payload = {
        id: __privateWrapper(this, _nextId)._++,
        method: "eth_chainId",
        params: [],
        jsonrpc: "2.0"
      };
      this.emit("debug", { action: "sendRpcPayload", payload });
      let result;
      try {
        result = (await this._send(payload))[0];
        __privateSet(this, _pendingDetectNetwork, null);
      } catch (error) {
        __privateSet(this, _pendingDetectNetwork, null);
        this.emit("debug", { action: "receiveRpcError", error });
        throw error;
      }
      this.emit("debug", { action: "receiveRpcResult", result });
      if ("result" in result) {
        return Network.from(getBigInt(result.result));
      }
      throw this.getRpcError(payload, result);
    })());
    return await __privateGet(this, _pendingDetectNetwork);
  }
  /**
   *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
   *  will be passed to [[_send]] from [[send]]. If it is overridden, then
   *  ``super._start()`` **MUST** be called.
   *
   *  Calling it multiple times is safe and has no effect.
   */
  _start() {
    if (__privateGet(this, _notReady) == null || __privateGet(this, _notReady).resolve == null) {
      return;
    }
    __privateGet(this, _notReady).resolve();
    __privateSet(this, _notReady, null);
    (async () => {
      while (__privateGet(this, _network2) == null && !this.destroyed) {
        try {
          __privateSet(this, _network2, await this._detectNetwork());
        } catch (error) {
          if (this.destroyed) {
            break;
          }
          console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)");
          this.emit("error", makeError("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error } }));
          await stall(1e3);
        }
      }
      __privateMethod(this, _JsonRpcApiProvider_instances, scheduleDrain_fn).call(this);
    })();
  }
  /**
   *  Resolves once the [[_start]] has been called. This can be used in
   *  sub-classes to defer sending data until the connection has been
   *  established.
   */
  async _waitUntilReady() {
    if (__privateGet(this, _notReady) == null) {
      return;
    }
    return await __privateGet(this, _notReady).promise;
  }
  /**
   *  Return a Subscriber that will manage the %%sub%%.
   *
   *  Sub-classes may override this to modify the behavior of
   *  subscription management.
   */
  _getSubscriber(sub) {
    if (sub.type === "pending") {
      return new FilterIdPendingSubscriber(this);
    }
    if (sub.type === "event") {
      if (this._getOption("polling")) {
        return new PollingEventSubscriber(this, sub.filter);
      }
      return new FilterIdEventSubscriber(this, sub.filter);
    }
    if (sub.type === "orphan" && sub.filter.orphan === "drop-log") {
      return new UnmanagedSubscriber("orphan");
    }
    return super._getSubscriber(sub);
  }
  /**
   *  Returns true only if the [[_start]] has been called.
   */
  get ready() {
    return __privateGet(this, _notReady) == null;
  }
  /**
   *  Returns %%tx%% as a normalized JSON-RPC transaction request,
   *  which has all values hexlified and any numeric values converted
   *  to Quantity values.
   */
  getRpcTransaction(tx) {
    const result = {};
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((key2) => {
      if (tx[key2] == null) {
        return;
      }
      let dstKey = key2;
      if (key2 === "gasLimit") {
        dstKey = "gas";
      }
      result[dstKey] = toQuantity(getBigInt(tx[key2], `tx.${key2}`));
    });
    ["from", "to", "data"].forEach((key2) => {
      if (tx[key2] == null) {
        return;
      }
      result[key2] = hexlify(tx[key2]);
    });
    if (tx.accessList) {
      result["accessList"] = accessListify(tx.accessList);
    }
    if (tx.blobVersionedHashes) {
      result["blobVersionedHashes"] = tx.blobVersionedHashes.map((h5) => h5.toLowerCase());
    }
    return result;
  }
  /**
   *  Returns the request method and arguments required to perform
   *  %%req%%.
   */
  getRpcRequest(req) {
    switch (req.method) {
      case "chainId":
        return { method: "eth_chainId", args: [] };
      case "getBlockNumber":
        return { method: "eth_blockNumber", args: [] };
      case "getGasPrice":
        return { method: "eth_gasPrice", args: [] };
      case "getPriorityFee":
        return { method: "eth_maxPriorityFeePerGas", args: [] };
      case "getBalance":
        return {
          method: "eth_getBalance",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getTransactionCount":
        return {
          method: "eth_getTransactionCount",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getCode":
        return {
          method: "eth_getCode",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getStorage":
        return {
          method: "eth_getStorageAt",
          args: [
            getLowerCase(req.address),
            "0x" + req.position.toString(16),
            req.blockTag
          ]
        };
      case "broadcastTransaction":
        return {
          method: "eth_sendRawTransaction",
          args: [req.signedTransaction]
        };
      case "getBlock":
        if ("blockTag" in req) {
          return {
            method: "eth_getBlockByNumber",
            args: [req.blockTag, !!req.includeTransactions]
          };
        } else if ("blockHash" in req) {
          return {
            method: "eth_getBlockByHash",
            args: [req.blockHash, !!req.includeTransactions]
          };
        }
        break;
      case "getTransaction":
        return {
          method: "eth_getTransactionByHash",
          args: [req.hash]
        };
      case "getTransactionReceipt":
        return {
          method: "eth_getTransactionReceipt",
          args: [req.hash]
        };
      case "call":
        return {
          method: "eth_call",
          args: [this.getRpcTransaction(req.transaction), req.blockTag]
        };
      case "estimateGas": {
        return {
          method: "eth_estimateGas",
          args: [this.getRpcTransaction(req.transaction)]
        };
      }
      case "getLogs":
        if (req.filter && req.filter.address != null) {
          if (Array.isArray(req.filter.address)) {
            req.filter.address = req.filter.address.map(getLowerCase);
          } else {
            req.filter.address = getLowerCase(req.filter.address);
          }
        }
        return { method: "eth_getLogs", args: [req.filter] };
    }
    return null;
  }
  /**
   *  Returns an ethers-style Error for the given JSON-RPC error
   *  %%payload%%, coalescing the various strings and error shapes
   *  that different nodes return, coercing them into a machine-readable
   *  standardized error.
   */
  getRpcError(payload, _error2) {
    const { method } = payload;
    const { error } = _error2;
    if (method === "eth_estimateGas" && error.message) {
      const msg = error.message;
      if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {
        return makeError("insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: payload.params[0],
          info: { payload, error }
        });
      }
    }
    if (method === "eth_call" || method === "eth_estimateGas") {
      const result = spelunkData(error);
      const e3 = AbiCoder.getBuiltinCallException(method === "eth_call" ? "call" : "estimateGas", payload.params[0], result ? result.data : null);
      e3.info = { error, payload };
      return e3;
    }
    const message = JSON.stringify(spelunkMessage(error));
    if (typeof error.message === "string" && error.message.match(/user denied|ethers-user-denied/i)) {
      const actionMap = {
        eth_sign: "signMessage",
        personal_sign: "signMessage",
        eth_signTypedData_v4: "signTypedData",
        eth_signTransaction: "signTransaction",
        eth_sendTransaction: "sendTransaction",
        eth_requestAccounts: "requestAccess",
        wallet_requestAccounts: "requestAccess"
      };
      return makeError(`user rejected action`, "ACTION_REJECTED", {
        action: actionMap[method] || "unknown",
        reason: "rejected",
        info: { payload, error }
      });
    }
    if (method === "eth_sendRawTransaction" || method === "eth_sendTransaction") {
      const transaction = payload.params[0];
      if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
        return makeError("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
          transaction,
          info: { error }
        });
      }
      if (message.match(/nonce/i) && message.match(/too low/i)) {
        return makeError("nonce has already been used", "NONCE_EXPIRED", { transaction, info: { error } });
      }
      if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {
        return makeError("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction, info: { error } });
      }
      if (message.match(/only replay-protected/i)) {
        return makeError("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
          operation: method,
          info: { transaction, info: { error } }
        });
      }
    }
    let unsupported = !!message.match(/the method .* does not exist/i);
    if (!unsupported) {
      if (error && error.details && error.details.startsWith("Unauthorized method:")) {
        unsupported = true;
      }
    }
    if (unsupported) {
      return makeError("unsupported operation", "UNSUPPORTED_OPERATION", {
        operation: payload.method,
        info: { error, payload }
      });
    }
    return makeError("could not coalesce error", "UNKNOWN_ERROR", { error, payload });
  }
  /**
   *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
   *  over the underlying channel. This can be used to call methods
   *  on the backend that do not have a high-level API within the Provider
   *  API.
   *
   *  This method queues requests according to the batch constraints
   *  in the options, assigns the request a unique ID.
   *
   *  **Do NOT override** this method in sub-classes; instead
   *  override [[_send]] or force the options values in the
   *  call to the constructor to modify this method's behavior.
   */
  send(method, params) {
    if (this.destroyed) {
      return Promise.reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: method }));
    }
    const id2 = __privateWrapper(this, _nextId)._++;
    const promise = new Promise((resolve, reject) => {
      __privateGet(this, _payloads).push({
        resolve,
        reject,
        payload: { method, params, id: id2, jsonrpc: "2.0" }
      });
    });
    __privateMethod(this, _JsonRpcApiProvider_instances, scheduleDrain_fn).call(this);
    return promise;
  }
  /**
   *  Resolves to the [[Signer]] account for  %%address%% managed by
   *  the client.
   *
   *  If the %%address%% is a number, it is used as an index in the
   *  the accounts from [[listAccounts]].
   *
   *  This can only be used on clients which manage accounts (such as
   *  Geth with imported account or MetaMask).
   *
   *  Throws if the account doesn't exist.
   */
  async getSigner(address) {
    if (address == null) {
      address = 0;
    }
    const accountsPromise = this.send("eth_accounts", []);
    if (typeof address === "number") {
      const accounts2 = await accountsPromise;
      if (address >= accounts2.length) {
        throw new Error("no such account");
      }
      return new JsonRpcSigner(this, accounts2[address]);
    }
    const { accounts } = await resolveProperties({
      network: this.getNetwork(),
      accounts: accountsPromise
    });
    address = getAddress(address);
    for (const account of accounts) {
      if (getAddress(account) === address) {
        return new JsonRpcSigner(this, address);
      }
    }
    throw new Error("invalid account");
  }
  async listAccounts() {
    const accounts = await this.send("eth_accounts", []);
    return accounts.map((a2) => new JsonRpcSigner(this, a2));
  }
  destroy() {
    if (__privateGet(this, _drainTimer)) {
      clearTimeout(__privateGet(this, _drainTimer));
      __privateSet(this, _drainTimer, null);
    }
    for (const { payload, reject } of __privateGet(this, _payloads)) {
      reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload.method }));
    }
    __privateSet(this, _payloads, []);
    super.destroy();
  }
}
_options3 = new WeakMap();
_nextId = new WeakMap();
_payloads = new WeakMap();
_drainTimer = new WeakMap();
_notReady = new WeakMap();
_network2 = new WeakMap();
_pendingDetectNetwork = new WeakMap();
_JsonRpcApiProvider_instances = new WeakSet();
scheduleDrain_fn = function() {
  if (__privateGet(this, _drainTimer)) {
    return;
  }
  const stallTime = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
  __privateSet(this, _drainTimer, setTimeout(() => {
    __privateSet(this, _drainTimer, null);
    const payloads = __privateGet(this, _payloads);
    __privateSet(this, _payloads, []);
    while (payloads.length) {
      const batch = [payloads.shift()];
      while (payloads.length) {
        if (batch.length === __privateGet(this, _options3).batchMaxCount) {
          break;
        }
        batch.push(payloads.shift());
        const bytes2 = JSON.stringify(batch.map((p2) => p2.payload));
        if (bytes2.length > __privateGet(this, _options3).batchMaxSize) {
          payloads.unshift(batch.pop());
          break;
        }
      }
      (async () => {
        const payload = batch.length === 1 ? batch[0].payload : batch.map((p2) => p2.payload);
        this.emit("debug", { action: "sendRpcPayload", payload });
        try {
          const result = await this._send(payload);
          this.emit("debug", { action: "receiveRpcResult", result });
          for (const { resolve, reject, payload: payload2 } of batch) {
            if (this.destroyed) {
              reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload2.method }));
              continue;
            }
            const resp = result.filter((r3) => r3.id === payload2.id)[0];
            if (resp == null) {
              const error = makeError("missing response for request", "BAD_DATA", {
                value: result,
                info: { payload: payload2 }
              });
              this.emit("error", error);
              reject(error);
              continue;
            }
            if ("error" in resp) {
              reject(this.getRpcError(payload2, resp));
              continue;
            }
            resolve(resp.result);
          }
        } catch (error) {
          this.emit("debug", { action: "receiveRpcError", error });
          for (const { reject } of batch) {
            reject(error);
          }
        }
      })();
    }
  }, stallTime));
};
class JsonRpcApiPollingProvider extends JsonRpcApiProvider {
  constructor(network, options) {
    super(network, options);
    __privateAdd(this, _pollingInterval);
    let pollingInterval = this._getOption("pollingInterval");
    if (pollingInterval == null) {
      pollingInterval = defaultOptions.pollingInterval;
    }
    __privateSet(this, _pollingInterval, pollingInterval);
  }
  _getSubscriber(sub) {
    const subscriber = super._getSubscriber(sub);
    if (isPollable(subscriber)) {
      subscriber.pollingInterval = __privateGet(this, _pollingInterval);
    }
    return subscriber;
  }
  /**
   *  The polling interval (default: 4000 ms)
   */
  get pollingInterval() {
    return __privateGet(this, _pollingInterval);
  }
  set pollingInterval(value) {
    if (!Number.isInteger(value) || value < 0) {
      throw new Error("invalid interval");
    }
    __privateSet(this, _pollingInterval, value);
    this._forEachSubscriber((sub) => {
      if (isPollable(sub)) {
        sub.pollingInterval = __privateGet(this, _pollingInterval);
      }
    });
  }
}
_pollingInterval = new WeakMap();
class JsonRpcProvider extends JsonRpcApiPollingProvider {
  constructor(url, network, options) {
    if (url == null) {
      url = "http://localhost:8545";
    }
    super(network, options);
    __privateAdd(this, _connect);
    if (typeof url === "string") {
      __privateSet(this, _connect, new FetchRequest(url));
    } else {
      __privateSet(this, _connect, url.clone());
    }
  }
  _getConnection() {
    return __privateGet(this, _connect).clone();
  }
  async send(method, params) {
    await this._start();
    return await super.send(method, params);
  }
  async _send(payload) {
    const request = this._getConnection();
    request.body = JSON.stringify(payload);
    request.setHeader("content-type", "application/json");
    const response = await request.send();
    response.assertOk();
    let resp = response.bodyJson;
    if (!Array.isArray(resp)) {
      resp = [resp];
    }
    return resp;
  }
}
_connect = new WeakMap();
function spelunkData(value) {
  if (value == null) {
    return null;
  }
  if (typeof value.message === "string" && value.message.match(/revert/i) && isHexString(value.data)) {
    return { message: value.message, data: value.data };
  }
  if (typeof value === "object") {
    for (const key2 in value) {
      const result = spelunkData(value[key2]);
      if (result) {
        return result;
      }
    }
    return null;
  }
  if (typeof value === "string") {
    try {
      return spelunkData(JSON.parse(value));
    } catch (error) {
    }
  }
  return null;
}
function _spelunkMessage(value, result) {
  if (value == null) {
    return;
  }
  if (typeof value.message === "string") {
    result.push(value.message);
  }
  if (typeof value === "object") {
    for (const key2 in value) {
      _spelunkMessage(value[key2], result);
    }
  }
  if (typeof value === "string") {
    try {
      return _spelunkMessage(JSON.parse(value), result);
    } catch (error) {
    }
  }
}
function spelunkMessage(value) {
  const result = [];
  _spelunkMessage(value, result);
  return result;
}
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global$1 !== "undefined") {
    return global$1;
  }
  throw new Error("unable to locate global object");
}
const _WebSocket = getGlobal().WebSocket;
class SocketSubscriber {
  /**
   *  Creates a new **SocketSubscriber** attached to %%provider%% listening
   *  to %%filter%%.
   */
  constructor(provider, filter) {
    __privateAdd(this, _provider5);
    __privateAdd(this, _filter4);
    __privateAdd(this, _filterId);
    __privateAdd(this, _paused);
    __privateAdd(this, _emitPromise);
    __privateSet(this, _provider5, provider);
    __privateSet(this, _filter4, JSON.stringify(filter));
    __privateSet(this, _filterId, null);
    __privateSet(this, _paused, null);
    __privateSet(this, _emitPromise, null);
  }
  /**
   *  The filter.
   */
  get filter() {
    return JSON.parse(__privateGet(this, _filter4));
  }
  start() {
    __privateSet(this, _filterId, __privateGet(this, _provider5).send("eth_subscribe", this.filter).then((filterId) => {
      __privateGet(this, _provider5)._register(filterId, this);
      return filterId;
    }));
  }
  stop() {
    __privateGet(this, _filterId).then((filterId) => {
      if (__privateGet(this, _provider5).destroyed) {
        return;
      }
      __privateGet(this, _provider5).send("eth_unsubscribe", [filterId]);
    });
    __privateSet(this, _filterId, null);
  }
  // @TODO: pause should trap the current blockNumber, unsub, and on resume use getLogs
  //        and resume
  pause(dropWhilePaused) {
    assert(dropWhilePaused, "preserve logs while paused not supported by SocketSubscriber yet", "UNSUPPORTED_OPERATION", { operation: "pause(false)" });
    __privateSet(this, _paused, !!dropWhilePaused);
  }
  resume() {
    __privateSet(this, _paused, null);
  }
  /**
   *  @_ignore:
   */
  _handleMessage(message) {
    if (__privateGet(this, _filterId) == null) {
      return;
    }
    if (__privateGet(this, _paused) === null) {
      let emitPromise = __privateGet(this, _emitPromise);
      if (emitPromise == null) {
        emitPromise = this._emit(__privateGet(this, _provider5), message);
      } else {
        emitPromise = emitPromise.then(async () => {
          await this._emit(__privateGet(this, _provider5), message);
        });
      }
      __privateSet(this, _emitPromise, emitPromise.then(() => {
        if (__privateGet(this, _emitPromise) === emitPromise) {
          __privateSet(this, _emitPromise, null);
        }
      }));
    }
  }
  /**
   *  Sub-classes **must** override this to emit the events on the
   *  provider.
   */
  async _emit(provider, message) {
    throw new Error("sub-classes must implemente this; _emit");
  }
}
_provider5 = new WeakMap();
_filter4 = new WeakMap();
_filterId = new WeakMap();
_paused = new WeakMap();
_emitPromise = new WeakMap();
class SocketBlockSubscriber extends SocketSubscriber {
  /**
   *  @_ignore:
   */
  constructor(provider) {
    super(provider, ["newHeads"]);
  }
  async _emit(provider, message) {
    provider.emit("block", parseInt(message.number));
  }
}
class SocketPendingSubscriber extends SocketSubscriber {
  /**
   *  @_ignore:
   */
  constructor(provider) {
    super(provider, ["newPendingTransactions"]);
  }
  async _emit(provider, message) {
    provider.emit("pending", message);
  }
}
class SocketEventSubscriber extends SocketSubscriber {
  /**
   *  @_ignore:
   */
  constructor(provider, filter) {
    super(provider, ["logs", filter]);
    __privateAdd(this, _logFilter);
    __privateSet(this, _logFilter, JSON.stringify(filter));
  }
  /**
   *  The filter.
   */
  get logFilter() {
    return JSON.parse(__privateGet(this, _logFilter));
  }
  async _emit(provider, message) {
    provider.emit(this.logFilter, provider._wrapLog(message, provider._network));
  }
}
_logFilter = new WeakMap();
class SocketProvider extends JsonRpcApiProvider {
  /**
   *  Creates a new **SocketProvider** connected to %%network%%.
   *
   *  If unspecified, the network will be discovered.
   */
  constructor(network, _options4) {
    const options = Object.assign({}, _options4 != null ? _options4 : {});
    assertArgument(options.batchMaxCount == null || options.batchMaxCount === 1, "sockets-based providers do not support batches", "options.batchMaxCount", _options4);
    options.batchMaxCount = 1;
    if (options.staticNetwork == null) {
      options.staticNetwork = true;
    }
    super(network, options);
    __privateAdd(this, _callbacks);
    // Maps each filterId to its subscriber
    __privateAdd(this, _subs2);
    // If any events come in before a subscriber has finished
    // registering, queue them
    __privateAdd(this, _pending);
    __privateSet(this, _callbacks, /* @__PURE__ */ new Map());
    __privateSet(this, _subs2, /* @__PURE__ */ new Map());
    __privateSet(this, _pending, /* @__PURE__ */ new Map());
  }
  // This value is only valid after _start has been called
  /*
  get _network(): Network {
      if (this.#network == null) {
          throw new Error("this shouldn't happen");
      }
      return this.#network.clone();
  }
  */
  _getSubscriber(sub) {
    switch (sub.type) {
      case "close":
        return new UnmanagedSubscriber("close");
      case "block":
        return new SocketBlockSubscriber(this);
      case "pending":
        return new SocketPendingSubscriber(this);
      case "event":
        return new SocketEventSubscriber(this, sub.filter);
      case "orphan":
        if (sub.filter.orphan === "drop-log") {
          return new UnmanagedSubscriber("drop-log");
        }
    }
    return super._getSubscriber(sub);
  }
  /**
   *  Register a new subscriber. This is used internalled by Subscribers
   *  and generally is unecessary unless extending capabilities.
   */
  _register(filterId, subscriber) {
    __privateGet(this, _subs2).set(filterId, subscriber);
    const pending = __privateGet(this, _pending).get(filterId);
    if (pending) {
      for (const message of pending) {
        subscriber._handleMessage(message);
      }
      __privateGet(this, _pending).delete(filterId);
    }
  }
  async _send(payload) {
    assertArgument(!Array.isArray(payload), "WebSocket does not support batch send", "payload", payload);
    const promise = new Promise((resolve, reject) => {
      __privateGet(this, _callbacks).set(payload.id, { payload, resolve, reject });
    });
    await this._waitUntilReady();
    await this._write(JSON.stringify(payload));
    return [await promise];
  }
  // Sub-classes must call this once they are connected
  /*
      async _start(): Promise<void> {
          if (this.#ready) { return; }
  
          for (const { payload } of this.#callbacks.values()) {
              await this._write(JSON.stringify(payload));
          }
  
          this.#ready = (async function() {
              await super._start();
          })();
      }
      */
  /**
   *  Sub-classes **must** call this with messages received over their
   *  transport to be processed and dispatched.
   */
  async _processMessage(message) {
    const result = JSON.parse(message);
    if (result && typeof result === "object" && "id" in result) {
      const callback = __privateGet(this, _callbacks).get(result.id);
      if (callback == null) {
        this.emit("error", makeError("received result for unknown id", "UNKNOWN_ERROR", {
          reasonCode: "UNKNOWN_ID",
          result
        }));
        return;
      }
      __privateGet(this, _callbacks).delete(result.id);
      callback.resolve(result);
    } else if (result && result.method === "eth_subscription") {
      const filterId = result.params.subscription;
      const subscriber = __privateGet(this, _subs2).get(filterId);
      if (subscriber) {
        subscriber._handleMessage(result.params.result);
      } else {
        let pending = __privateGet(this, _pending).get(filterId);
        if (pending == null) {
          pending = [];
          __privateGet(this, _pending).set(filterId, pending);
        }
        pending.push(result.params.result);
      }
    } else {
      this.emit("error", makeError("received unexpected message", "UNKNOWN_ERROR", {
        reasonCode: "UNEXPECTED_MESSAGE",
        result
      }));
      return;
    }
  }
  /**
   *  Sub-classes **must** override this to send %%message%% over their
   *  transport.
   */
  async _write(message) {
    throw new Error("sub-classes must override this");
  }
}
_callbacks = new WeakMap();
_subs2 = new WeakMap();
_pending = new WeakMap();
class WebSocketProvider extends SocketProvider {
  constructor(url, network, options) {
    super(network, options);
    __privateAdd(this, _connect2);
    __privateAdd(this, _websocket);
    if (typeof url === "string") {
      __privateSet(this, _connect2, () => {
        return new _WebSocket(url);
      });
      __privateSet(this, _websocket, __privateGet(this, _connect2).call(this));
    } else if (typeof url === "function") {
      __privateSet(this, _connect2, url);
      __privateSet(this, _websocket, url());
    } else {
      __privateSet(this, _connect2, null);
      __privateSet(this, _websocket, url);
    }
    this.websocket.onopen = async () => {
      try {
        await this._start();
        this.resume();
      } catch (error) {
        console.log("failed to start WebsocketProvider", error);
      }
    };
    this.websocket.onmessage = (message) => {
      this._processMessage(message.data);
    };
  }
  get websocket() {
    if (__privateGet(this, _websocket) == null) {
      throw new Error("websocket closed");
    }
    return __privateGet(this, _websocket);
  }
  async _write(message) {
    this.websocket.send(message);
  }
  async destroy() {
    if (__privateGet(this, _websocket) != null) {
      __privateGet(this, _websocket).close();
      __privateSet(this, _websocket, null);
    }
    super.destroy();
  }
}
_connect2 = new WeakMap();
_websocket = new WeakMap();
const defaultProjectId = "84842078b09946638c03157f83405213";
function getHost(name) {
  switch (name) {
    case "mainnet":
      return "mainnet.infura.io";
    case "goerli":
      return "goerli.infura.io";
    case "sepolia":
      return "sepolia.infura.io";
    case "arbitrum":
      return "arbitrum-mainnet.infura.io";
    case "arbitrum-goerli":
      return "arbitrum-goerli.infura.io";
    case "arbitrum-sepolia":
      return "arbitrum-sepolia.infura.io";
    case "base":
      return "base-mainnet.infura.io";
    case "base-goerlia":
      return "base-goerli.infura.io";
    case "base-sepolia":
      return "base-sepolia.infura.io";
    case "bnb":
      return "bnbsmartchain-mainnet.infura.io";
    case "bnbt":
      return "bnbsmartchain-testnet.infura.io";
    case "linea":
      return "linea-mainnet.infura.io";
    case "linea-goerli":
      return "linea-goerli.infura.io";
    case "linea-sepolia":
      return "linea-sepolia.infura.io";
    case "matic":
      return "polygon-mainnet.infura.io";
    case "matic-amoy":
      return "polygon-amoy.infura.io";
    case "matic-mumbai":
      return "polygon-mumbai.infura.io";
    case "optimism":
      return "optimism-mainnet.infura.io";
    case "optimism-goerli":
      return "optimism-goerli.infura.io";
    case "optimism-sepolia":
      return "optimism-sepolia.infura.io";
  }
  assertArgument(false, "unsupported network", "network", name);
}
class InfuraWebSocketProvider extends WebSocketProvider {
  /**
   *  Creates a new **InfuraWebSocketProvider**.
   */
  constructor(network, projectId) {
    const provider = new InfuraProvider(network, projectId);
    const req = provider._getConnection();
    assert(!req.credentials, "INFURA WebSocket project secrets unsupported", "UNSUPPORTED_OPERATION", { operation: "InfuraProvider.getWebSocketProvider()" });
    const url = req.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    super(url, provider._network);
    /**
     *  The Project ID for the INFURA connection.
     */
    __publicField(this, "projectId");
    /**
     *  The Project Secret.
     *
     *  If null, no authenticated requests are made. This should not
     *  be used outside of private contexts.
     */
    __publicField(this, "projectSecret");
    defineProperties(this, {
      projectId: provider.projectId,
      projectSecret: provider.projectSecret
    });
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
}
class InfuraProvider extends JsonRpcProvider {
  /**
   *  Creates a new **InfuraProvider**.
   */
  constructor(_network3, projectId, projectSecret) {
    if (_network3 == null) {
      _network3 = "mainnet";
    }
    const network = Network.from(_network3);
    if (projectId == null) {
      projectId = defaultProjectId;
    }
    if (projectSecret == null) {
      projectSecret = null;
    }
    const request = InfuraProvider.getRequest(network, projectId, projectSecret);
    super(request, network, { staticNetwork: network });
    /**
     *  The Project ID for the INFURA connection.
     */
    __publicField(this, "projectId");
    /**
     *  The Project Secret.
     *
     *  If null, no authenticated requests are made. This should not
     *  be used outside of private contexts.
     */
    __publicField(this, "projectSecret");
    defineProperties(this, { projectId, projectSecret });
  }
  _getProvider(chainId) {
    try {
      return new InfuraProvider(chainId, this.projectId, this.projectSecret);
    } catch (error) {
    }
    return super._getProvider(chainId);
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
  /**
   *  Creates a new **InfuraWebSocketProvider**.
   */
  static getWebSocketProvider(network, projectId) {
    return new InfuraWebSocketProvider(network, projectId);
  }
  /**
   *  Returns a prepared request for connecting to %%network%%
   *  with %%projectId%% and %%projectSecret%%.
   */
  static getRequest(network, projectId, projectSecret) {
    if (projectId == null) {
      projectId = defaultProjectId;
    }
    if (projectSecret == null) {
      projectSecret = null;
    }
    const request = new FetchRequest(`https://${getHost(network.name)}/v3/${projectId}`);
    request.allowGzip = true;
    if (projectSecret) {
      request.setCredentials("", projectSecret);
    }
    if (projectId === defaultProjectId) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("InfuraProvider");
        return true;
      };
    }
    return request;
  }
}
class BrowserProvider extends JsonRpcApiPollingProvider {
  /**
   *  Connnect to the %%ethereum%% provider, optionally forcing the
   *  %%network%%.
   */
  constructor(ethereum, network, _options4) {
    const options = Object.assign({}, _options4 != null ? _options4 : {}, { batchMaxCount: 1 });
    assertArgument(ethereum && ethereum.request, "invalid EIP-1193 provider", "ethereum", ethereum);
    super(network, options);
    __privateAdd(this, _request2);
    __privateSet(this, _request2, async (method, params) => {
      const payload = { method, params };
      this.emit("debug", { action: "sendEip1193Request", payload });
      try {
        const result = await ethereum.request(payload);
        this.emit("debug", { action: "receiveEip1193Result", result });
        return result;
      } catch (e3) {
        const error = new Error(e3.message);
        error.code = e3.code;
        error.data = e3.data;
        error.payload = payload;
        this.emit("debug", { action: "receiveEip1193Error", error });
        throw error;
      }
    });
  }
  async send(method, params) {
    await this._start();
    return await super.send(method, params);
  }
  async _send(payload) {
    assertArgument(!Array.isArray(payload), "EIP-1193 does not support batch request", "payload", payload);
    try {
      const result = await __privateGet(this, _request2).call(this, payload.method, payload.params || []);
      return [{ id: payload.id, result }];
    } catch (e3) {
      return [{
        id: payload.id,
        error: { code: e3.code, data: e3.data, message: e3.message }
      }];
    }
  }
  getRpcError(payload, error) {
    error = JSON.parse(JSON.stringify(error));
    switch (error.error.code || -1) {
      case 4001:
        error.error.message = `ethers-user-denied: ${error.error.message}`;
        break;
      case 4200:
        error.error.message = `ethers-unsupported: ${error.error.message}`;
        break;
    }
    return super.getRpcError(payload, error);
  }
  /**
   *  Resolves to ``true`` if the provider manages the %%address%%.
   */
  async hasSigner(address) {
    if (address == null) {
      address = 0;
    }
    const accounts = await this.send("eth_accounts", []);
    if (typeof address === "number") {
      return accounts.length > address;
    }
    address = address.toLowerCase();
    return accounts.filter((a2) => a2.toLowerCase() === address).length !== 0;
  }
  async getSigner(address) {
    if (address == null) {
      address = 0;
    }
    if (!await this.hasSigner(address)) {
      try {
        await __privateGet(this, _request2).call(this, "eth_requestAccounts", []);
      } catch (error) {
        const payload = error.payload;
        throw this.getRpcError(payload, { id: payload.id, error });
      }
    }
    return await super.getSigner(address);
  }
}
_request2 = new WeakMap();
async function pollingTx(hash3, signer) {
  return await new Promise((resolve, reject) => {
    console.log(`pollingTx with hash: ${hash3}`);
    const timeouts = [1e3, 100];
    const checkTx = async () => {
      try {
        const tx = await signer.provider.getTransaction(hash3);
        if (tx != null) {
          console.log(`tx found: ${JSON.stringify(tx, (key2, value) => typeof value === "bigint" ? value.toString() : value, 2)}`);
          resolve(hash3);
          return;
        }
      } catch (error) {
        console.log(`pollingTx error: ${error} just return result with hash`);
        resolve(hash3);
      }
      signer.provider._setTimeout(() => {
        checkTx();
      }, timeouts.pop() || 4e3);
    };
    checkTx();
  });
}
const EthersMethods = {
  signMessage: async (message, provider, address, customData) => {
    if (!provider) {
      throw new Error("signMessage - provider is undefined");
    }
    const hexMessage = isHexString(message) ? message : hexlify(toUtf8Bytes(message));
    const signature2 = await provider.request({
      method: "personal_sign",
      params: [hexMessage, address, customData]
    });
    return signature2;
  },
  etherSignMessage: async (message, address, provider) => {
    if (!provider) {
      throw new Error("etherSignMessage - provider is undefined");
    }
    const signature2 = await provider.request({
      method: "eth_sign",
      params: [address, message]
    });
    return signature2;
  },
  signTypedDataV4: async (paramsData, provider, customData) => {
    if (!provider) {
      throw new Error("signTypedDataV4 - provider is undefined");
    }
    if (!paramsData) {
      throw new Error("signTypedDataV4 - paramsData is required");
    }
    try {
      console.log(`signTypedDataV4 - paramsData: ${JSON.stringify(paramsData, null, 2)}`);
      const signature2 = await provider.request({
        method: "eth_signTypedData_v4",
        params: [paramsData, customData]
      });
      return signature2;
    } catch (error) {
      console.error("signTypedDataV4 error:", error);
      throw error;
    }
  },
  signEIP712: async (data2, provider) => {
    if (!provider) {
      throw new Error("signEIP712 - provider is undefined");
    }
    try {
      const { contractAddress, fromAddress, spenderAddress, value, name, nonce, deadline, customData } = data2;
      const domain = {
        name,
        version: "1",
        chainId: data2.chainId,
        verifyingContract: contractAddress
      };
      console.log(`signEIP712 - domain: ${JSON.stringify(domain)}`);
      const types2 = {
        Permit: [
          { name: "owner", type: "address" },
          { name: "spender", type: "address" },
          { name: "value", type: "uint256" },
          { name: "nonce", type: "uint256" },
          { name: "deadline", type: "uint256" }
        ]
      };
      const message = {
        owner: fromAddress,
        spender: spenderAddress,
        nonce: toQuantity(getBigInt(nonce)),
        value: toQuantity(getBigInt(value)),
        deadline: toQuantity(getBigInt(deadline))
      };
      console.log(`signEIP712 with hexSign: ${JSON.stringify(message)}`);
      const signature2 = await provider.request({
        method: "eth_signTypedData_v4",
        params: [{ domain, types: types2, message }, customData]
      });
      return signature2;
    } catch (error) {
      console.log(`signEIP712 error: ${error}`);
      throw error;
    }
  },
  estimateGas: async (data2, provider, address, networkId) => {
    if (!provider) {
      throw new Error("estimateGas - provider is undefined");
    }
    if (!address) {
      throw new Error("estimateGas - address is undefined");
    }
    if (data2.chainNamespace && data2.chainNamespace !== "eip155") {
      throw new Error("estimateGas - chainNamespace is not eip155");
    }
    const txParams = {
      from: data2.address,
      to: data2.to,
      data: data2.data,
      type: 0
    };
    const browserProvider = new BrowserProvider(provider, networkId);
    const signer = new JsonRpcSigner(browserProvider, address);
    return await signer.estimateGas(txParams);
  },
  sendTransaction: async (data2, provider, address, networkId) => {
    if (!provider) {
      throw new Error("sendTransaction - provider is undefined");
    }
    if (!address) {
      throw new Error("sendTransaction - address is undefined");
    }
    if (data2.chainNamespace && data2.chainNamespace !== "eip155") {
      throw new Error("sendTransaction - chainNamespace is not eip155");
    }
    const type2 = data2.type ?? ConstantsUtil$3.TRANSACTION_TYPE.LEGACY;
    if (type2 !== ConstantsUtil$3.TRANSACTION_TYPE.LEGACY && type2 !== ConstantsUtil$3.TRANSACTION_TYPE.DYNAMIC) {
      throw new Error("sendTransaction - invalid transaction type");
    }
    if (data2) {
      console.log(`sendTransaction - data: `, data2);
    }
    let txParams = {
      to: data2.to,
      value: data2.value,
      data: data2.data
    };
    const browserProvider = new BrowserProvider(provider, networkId);
    const signer = new JsonRpcSigner(browserProvider, address);
    const from2 = await signer.getAddress();
    const gasLimit = data2.gas ?? await browserProvider.estimateGas({ ...txParams, from: await signer.getAddress() });
    txParams = {
      ...txParams,
      gasLimit
    };
    if (type2 === ConstantsUtil$3.TRANSACTION_TYPE.LEGACY) {
      const gasPrice = data2.gasPrice ?? (await browserProvider.getFeeData()).gasPrice ?? BigInt(2e9);
      txParams = {
        ...txParams,
        gasPrice
      };
    } else if (type2 === ConstantsUtil$3.TRANSACTION_TYPE.DYNAMIC) {
      const maxFee = data2.maxFee ?? (await browserProvider.getFeeData()).maxFeePerGas ?? BigInt(32e8);
      const maxPriorityFee = data2.maxPriorityFee ?? (await browserProvider.getFeeData()).maxPriorityFeePerGas ?? BigInt(2e9);
      txParams = {
        ...txParams,
        maxFeePerGas: maxFee,
        maxPriorityFeePerGas: maxPriorityFee
      };
    }
    const txToSign = { ...txParams, from: from2 };
    const hexSign = browserProvider.getRpcTransaction(txToSign);
    const hash3 = await provider.request({
      method: "eth_sendTransaction",
      params: [hexSign, data2.customData]
    });
    return await pollingTx(hash3, signer);
  },
  writeContract: async (data2, provider, address, chainId) => {
    console.log("writeContract", data2, provider, address, chainId);
    if (!provider) {
      throw new Error("writeContract - provider is undefined");
    }
    if (!address) {
      throw new Error("writeContract - address is undefined");
    }
    const type2 = data2.type ?? ConstantsUtil$3.TRANSACTION_TYPE.LEGACY;
    if (type2 !== ConstantsUtil$3.TRANSACTION_TYPE.LEGACY && type2 !== ConstantsUtil$3.TRANSACTION_TYPE.DYNAMIC) {
      throw new Error("sendTransaction - invalid transaction type");
    }
    const browserProvider = new BrowserProvider(provider, chainId);
    const signer = new JsonRpcSigner(browserProvider, address);
    const contract = new Contract(data2.contractAddress, data2.abi, signer);
    if (!contract || !data2.method) {
      throw new Error("Contract method is undefined");
    }
    const method = contract[data2.method];
    if (method) {
      console.log("writeContract", signer, contract, data2.method, data2.args);
      const txContract = await method.populateTransaction(...data2.args);
      const gasLimit = data2.gas ?? await browserProvider.estimateGas({
        ...txContract,
        from: await signer.getAddress()
      });
      const from2 = await signer.getAddress();
      let txToSign = { ...txContract, from: from2, gasLimit };
      if (data2.type === ConstantsUtil$3.TRANSACTION_TYPE.LEGACY) {
        const gasPrice = data2.gasPrice ?? (await browserProvider.getFeeData()).gasPrice ?? BigInt(2e9);
        txToSign = {
          ...txToSign,
          gasPrice
        };
      } else if (data2.type === ConstantsUtil$3.TRANSACTION_TYPE.DYNAMIC) {
        const maxFee = data2.maxFee ?? (await browserProvider.getFeeData()).maxFeePerGas ?? BigInt(32e8);
        const maxPriorityFee = data2.maxPriorityFee ?? (await browserProvider.getFeeData()).maxPriorityFeePerGas ?? BigInt(2e9);
        txToSign = {
          ...txToSign,
          maxFeePerGas: maxFee,
          maxPriorityFeePerGas: maxPriorityFee
        };
      }
      const hexSign = browserProvider.getRpcTransaction(txToSign);
      const hash3 = await provider.request({
        method: "eth_sendTransaction",
        params: [hexSign, data2.customData]
      });
      return await pollingTx(hash3, signer);
    }
    throw new Error("Contract method is undefined");
  },
  readContract: async (data2, provider, chainId) => {
    if (!provider) {
      throw new Error("readContract - provider is undefined");
    }
    const browserProvider = new BrowserProvider(provider, chainId);
    const contract = new Contract(data2.contractAddress, data2.abi, browserProvider);
    if (!contract || !data2.method) {
      throw new Error("Contract method is undefined");
    }
    const method = contract[data2.method];
    if (method) {
      const result = await method(...data2.args);
      return result;
    }
    throw new Error("Contract method is undefined");
  },
  getEnsAddress: async (value, caipNetwork) => {
    try {
      console.log("getEnsAddress", value, caipNetwork);
      const chainId = Number(caipNetwork.id);
      let ensName = null;
      let wcName = false;
      console.log("getEnsAddress", value, chainId);
      if (isReownName(value)) {
        wcName = await WcHelpersUtil.resolveReownName(value) || false;
      }
      console.log("getEnsAddress", value, chainId, wcName);
      if (chainId === 1) {
        const ensProvider = new InfuraProvider("mainnet");
        ensName = await ensProvider.resolveName(value);
      }
      console.log("getEnsAddress", value, chainId, ensName);
      return ensName || wcName || false;
    } catch {
      return false;
    }
  },
  getEnsAvatar: async (value, chainId) => {
    if (chainId === 1) {
      const ensProvider = new InfuraProvider("mainnet");
      const avatar = await ensProvider.getAvatar(value);
      return avatar || false;
    }
    return false;
  },
  parseWalletCapabilities: (str) => {
    try {
      return JSON.parse(str);
    } catch (error) {
      throw new Error("Error parsing wallet capabilities");
    }
  },
  parseUnits: parseUnits$1,
  formatUnits
};
class EthersAdapter extends AdapterBlueprint {
  constructor() {
    super({});
    this.adapterType = "ethers";
    this.balancePromises = {};
    this.providerHandlers = null;
    this.namespace = ConstantsUtil$4.CHAIN.EVM;
  }
  async createEthersConfig(options) {
    if (!options.metadata) {
      return void 0;
    }
    let injectedProvider = void 0;
    function getInjectedProvider() {
      if (injectedProvider) {
        return injectedProvider;
      }
      if (typeof window === "undefined") {
        return void 0;
      }
      if (!window.ethereum) {
        return void 0;
      }
      injectedProvider = window.ethereum;
      return injectedProvider;
    }
    async function getCoinbaseProvider() {
      var _a3, _b2, _c3;
      try {
        const { createCoinbaseWalletSDK } = await import("./index-bMhrZAK6.js");
        if (typeof window === "undefined") {
          return void 0;
        }
        const coinbaseSdk = createCoinbaseWalletSDK({
          appName: (_a3 = options == null ? void 0 : options.metadata) == null ? void 0 : _a3.name,
          appLogoUrl: (_b2 = options == null ? void 0 : options.metadata) == null ? void 0 : _b2.icons[0],
          appChainIds: ((_c3 = options.networks) == null ? void 0 : _c3.map((caipNetwork) => caipNetwork.id)) || [1, 84532],
          preference: {
            options: options.coinbasePreference ?? "all"
          }
        });
        return coinbaseSdk.getProvider();
      } catch (error) {
        console.error("Failed to import Coinbase Wallet SDK:", error);
        return void 0;
      }
    }
    const providers = { metadata: options.metadata };
    if (options.enableInjected !== false) {
      providers.injected = getInjectedProvider();
    }
    if (options.enableCoinbase !== false) {
      const coinbaseProvider = await getCoinbaseProvider();
      if (coinbaseProvider) {
        providers.coinbase = coinbaseProvider;
      }
    }
    providers.EIP6963 = options.enableEIP6963 !== false;
    return providers;
  }
  async signMessage(params) {
    const { message, address, provider } = params;
    if (!provider) {
      throw new Error("Provider is undefined");
    }
    try {
      const signature2 = await EthersMethods.signMessage(message, provider, address, params.customData);
      return { signature: signature2 };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : JSON.stringify(error, null, 2);
      throw new Error(`EthersAdapter:signMessage - Sign message failed: ${errorMessage}`);
    }
  }
  async etherSignMessage(params) {
    const { message, address, provider } = params;
    if (!provider) {
      throw new Error("Provider is undefined");
    }
    try {
      const signature2 = await EthersMethods.etherSignMessage(message, address, provider);
      return { signature: signature2 };
    } catch (error) {
      throw new Error("EthersAdapter:etherSignMessage - Sign message failed");
    }
  }
  async signEIP712(params) {
    try {
      const signature2 = await EthersMethods.signEIP712({
        contractAddress: params.contractAddress,
        fromAddress: params.fromAddress,
        spenderAddress: params.spenderAddress,
        value: params.value,
        name: params.name,
        nonce: params.nonce,
        deadline: params.deadline,
        chainNamespace: params.chainNamespace,
        chainId: params.chainId,
        customData: params.customData
      }, params.provider);
      return { signature: signature2 };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : JSON.stringify(error, null, 2);
      throw new Error(`EthersAdapter:signEIP712 failed: ${errorMessage}`);
    }
  }
  async signTypedDataV4(params) {
    try {
      const signature2 = await EthersMethods.signTypedDataV4(params.paramsData, params.provider, params.customData);
      return { signature: signature2 };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : JSON.stringify(error, null, 2);
      throw new Error(`EthersAdapter:signTypedDataV4 failed: ${errorMessage}`);
    }
  }
  async sendTransaction(params) {
    var _a3;
    if (!params.provider) {
      throw new Error("Provider is undefined");
    }
    const tx = await EthersMethods.sendTransaction({
      value: params.value,
      to: params.to,
      data: params.data,
      gas: params.gas,
      gasPrice: params.gasPrice,
      maxFee: params.maxFee,
      maxPriorityFee: params.maxPriorityFee,
      address: params.address,
      customData: params.customData,
      type: params.type
    }, params.provider, params.address, Number((_a3 = params.caipNetwork) == null ? void 0 : _a3.id));
    return { hash: tx };
  }
  async writeContract(params) {
    var _a3, _b2;
    if (!params.provider) {
      throw new Error("Provider is undefined");
    }
    const { address } = ParseUtil.parseCaipAddress(params.caipAddress);
    const result = await EthersMethods.writeContract({
      contractAddress: params.contractAddress,
      fromAddress: params.fromAddress,
      method: params.method,
      abi: params.abi,
      args: params.args,
      customData: params.customData,
      chainNamespace: (_a3 = params.caipNetwork) == null ? void 0 : _a3.chainNamespace,
      type: params.type
    }, params.provider, address, Number((_b2 = params.caipNetwork) == null ? void 0 : _b2.id));
    return { hash: result };
  }
  async readContract(params) {
    var _a3;
    const { provider } = params;
    if (!provider) {
      throw new Error("Provider is undefined");
    }
    const result = await EthersMethods.readContract(params, provider, Number((_a3 = params.caipNetwork) == null ? void 0 : _a3.id));
    return result;
  }
  async estimateGas(params) {
    const { provider, caipNetwork, address } = params;
    if (!provider) {
      throw new Error("Provider is undefined");
    }
    try {
      const result = await EthersMethods.estimateGas({
        data: params.data,
        to: params.to,
        address
      }, provider, address, Number(caipNetwork == null ? void 0 : caipNetwork.id));
      return { gas: result };
    } catch (error) {
      throw new Error("EthersAdapter:estimateGas - Estimate gas failed");
    }
  }
  async getEnsAddress(params) {
    const { name, caipNetwork } = params;
    if (caipNetwork) {
      const result = await EthersMethods.getEnsAddress(name, caipNetwork);
      return { address: result };
    }
    return { address: "" };
  }
  parseUnits(params) {
    return EthersMethods.parseUnits(params.value, params.decimals);
  }
  formatUnits(params) {
    return EthersMethods.formatUnits(params.value, params.decimals);
  }
  async syncConnection(params) {
    const { id: id2, chainId } = params;
    const connector = this.connectors.find((c2) => c2.id === id2);
    const selectedProvider = connector == null ? void 0 : connector.provider;
    if (!selectedProvider) {
      throw new Error("Provider not found");
    }
    const accounts = await selectedProvider.request({
      method: "eth_requestAccounts"
    });
    const requestChainId = await selectedProvider.request({
      method: "eth_chainId"
    });
    this.listenProviderEvents(selectedProvider);
    if (!accounts[0]) {
      throw new Error("No accounts found");
    }
    if (!(connector == null ? void 0 : connector.type)) {
      throw new Error("Connector type not found");
    }
    return {
      address: accounts[0],
      chainId: Number(requestChainId) || Number(chainId),
      provider: selectedProvider,
      type: connector.type,
      id: id2
    };
  }
  async syncConnectors(options) {
    var _a3;
    this.ethersConfig = await this.createEthersConfig(options);
    if ((_a3 = this.ethersConfig) == null ? void 0 : _a3.EIP6963) {
      this.listenInjectedConnector(true);
    }
    const connectors = Object.keys(this.ethersConfig || {}).filter((key2) => key2 !== "metadata" && key2 !== "EIP6963");
    connectors.forEach((connector) => {
      var _a4, _b2;
      const key2 = connector === "coinbase" ? "coinbaseWalletSDK" : connector;
      const isInjectedConnector = connector === ConstantsUtil$4.CONNECTOR_ID.INJECTED;
      if (this.namespace) {
        this.addConnector({
          id: key2,
          explorerId: PresetsUtil.ConnectorExplorerIds[key2],
          imageUrl: (_a4 = options == null ? void 0 : options.connectorImages) == null ? void 0 : _a4[key2],
          name: PresetsUtil.ConnectorNamesMap[key2] || "Unknown",
          imageId: PresetsUtil.ConnectorImageIds[key2],
          type: PresetsUtil.ConnectorTypesMap[key2] ?? "EXTERNAL",
          info: isInjectedConnector ? void 0 : { rdns: key2 },
          chain: this.namespace,
          chains: [],
          provider: (_b2 = this.ethersConfig) == null ? void 0 : _b2[connector]
        });
      }
    });
  }
  setUniversalProvider(universalProvider) {
    this.addConnector(new WalletConnectConnector({
      provider: universalProvider,
      caipNetworks: this.caipNetworks || [],
      namespace: "eip155"
    }));
  }
  eip6963EventHandler(event) {
    var _a3;
    if (event.detail) {
      const { info, provider } = event.detail;
      const existingConnector = (_a3 = this.connectors) == null ? void 0 : _a3.find((c2) => c2.name === (info == null ? void 0 : info.name));
      if (!existingConnector) {
        const type2 = PresetsUtil.ConnectorTypesMap[ConstantsUtil$4.CONNECTOR_ID.EIP6963];
        const id2 = (info == null ? void 0 : info.rdns) || (info == null ? void 0 : info.name) || (info == null ? void 0 : info.uuid);
        if (type2 && this.namespace && id2) {
          this.addConnector({
            id: id2,
            type: type2,
            imageUrl: info == null ? void 0 : info.icon,
            name: (info == null ? void 0 : info.name) || "Unknown",
            provider,
            info,
            chain: this.namespace,
            chains: []
          });
        }
      }
    }
  }
  listenInjectedConnector(enableEIP6963) {
    if (typeof window !== "undefined" && enableEIP6963) {
      const handler = this.eip6963EventHandler.bind(this);
      window.addEventListener(ConstantsUtil$1.EIP6963_CROSS_ANNOUNCE_EVENT, handler);
      window.dispatchEvent(new Event(ConstantsUtil$1.EIP6963_CROSS_REQUEST_EVENT));
    }
  }
  async connect({ id: id2, type: type2, chainId }) {
    var _a3;
    const connector = this.connectors.find((c2) => c2.id === id2);
    const selectedProvider = connector == null ? void 0 : connector.provider;
    if (!selectedProvider) {
      throw new Error("Provider not found");
    }
    if (type2 === "ANNOUNCED" || type2 === "INJECTED" || type2 === "EXTERNAL") {
      try {
        const isAlreadyConnected = Boolean(AccountController.state.address);
        if (isAlreadyConnected) {
          await ChainController.disconnect();
        }
      } catch (error) {
      }
    }
    let accounts = [];
    let requestChainId = void 0;
    if (type2 === "AUTH") {
      const { address } = await selectedProvider.connect({
        chainId,
        preferredAccountType: OptionsController.state.defaultAccountTypes.eip155
      });
      accounts = [address];
      console.log(`EthersAdapter:connect - type is AUTH, target chainId: ${chainId}`);
    } else {
      accounts = await selectedProvider.request({
        method: "eth_requestAccounts"
      });
      const currentAddress = AccountController.state.address;
      if (currentAddress && currentAddress !== (accounts == null ? void 0 : accounts[0])) {
        try {
          await ChainController.disconnect();
        } catch (error) {
        }
      }
      requestChainId = await selectedProvider.request({
        method: "eth_chainId"
      });
      console.log(`EthersAdapter:connect - eth_chainId from wallet: ${requestChainId} connecting chainId: ${chainId}`);
      if (requestChainId !== chainId) {
        const caipNetwork = (_a3 = this.caipNetworks) == null ? void 0 : _a3.find((n5) => n5.id === chainId);
        if (!caipNetwork) {
          throw new Error("EthersAdapter:connect - could not find the caipNetwork to switch");
        }
        try {
          await this.switchNetwork({
            caipNetwork,
            provider: selectedProvider,
            providerType: type2
          });
        } catch (error) {
          throw new Error("EthersAdapter:connect - Switch network failed");
        }
      }
      this.listenProviderEvents(selectedProvider);
    }
    return {
      address: accounts[0],
      chainId: Number(chainId),
      provider: selectedProvider,
      type: type2,
      id: id2
    };
  }
  async reconnect(params) {
    const { id: id2, chainId } = params;
    const connector = this.connectors.find((c2) => c2.id === id2);
    if (connector && connector.type === "AUTH" && chainId) {
      await connector.provider.connect({
        chainId,
        preferredAccountType: OptionsController.state.defaultAccountTypes.eip155
      });
    }
  }
  async getAccounts(params) {
    const connector = this.connectors.find((c2) => c2.id === params.id);
    const selectedProvider = connector == null ? void 0 : connector.provider;
    if (!selectedProvider || !connector) {
      throw new Error("Provider not found");
    }
    if (params.id === ConstantsUtil$4.CONNECTOR_ID.AUTH) {
      const provider = connector["provider"];
      const { address, accounts: accounts2 } = await provider.connect();
      return Promise.resolve({
        accounts: (accounts2 || [{ address, type: "eoa" }]).map((account) => CoreHelperUtil.createAccount("eip155", account.address, account.type))
      });
    }
    const accounts = await selectedProvider.request({
      method: "eth_requestAccounts"
    });
    return {
      accounts: accounts.map((account) => CoreHelperUtil.createAccount("eip155", account, "eoa"))
    };
  }
  async disconnect(params) {
    var _a3, _b2, _c3, _d;
    if (!params.provider || !params.providerType) {
      throw new Error("Provider or providerType not provided");
    }
    switch (params.providerType) {
      case "WALLET_CONNECT":
        const universalProvider = params.provider;
        console.log(" [EthersAdapter] WALLET_CONNECT   ");
        console.log(" [EthersAdapter] UniversalProvider :", {
          hasSession: Boolean(universalProvider.session),
          sessionTopic: (_a3 = universalProvider.session) == null ? void 0 : _a3.topic,
          sessionExpiry: (_b2 = universalProvider.session) == null ? void 0 : _b2.expiry,
          sessionSelf: (_c3 = universalProvider.session) == null ? void 0 : _c3.self,
          sessionPeer: (_d = universalProvider.session) == null ? void 0 : _d.peer
        });
        if (universalProvider.session) {
          console.log(" [EthersAdapter]    :", {
            topic: universalProvider.session.topic,
            expiry: new Date(universalProvider.session.expiry * 1e3).toISOString(),
            selfPublicKey: universalProvider.session.self.publicKey,
            peerMetadata: universalProvider.session.peer.metadata
          });
          try {
            console.log(" [EthersAdapter] UniversalProvider.disconnect()  ...");
            await universalProvider.disconnect();
            console.log(" [EthersAdapter]  UniversalProvider.disconnect() !");
          } catch (error) {
            console.log(" [EthersAdapter]  UniversalProvider.disconnect() :", error);
            throw error;
          }
        } else {
          console.log(" [EthersAdapter]  WalletConnect   disconnect ");
        }
        break;
      case "AUTH":
        await params.provider.disconnect();
        break;
      case "ANNOUNCED":
      case "EXTERNAL":
        await this.revokeProviderPermissions(params.provider);
        break;
      default:
        throw new Error("Unsupported provider type");
    }
  }
  async getBalance(params) {
    var _a3;
    const caipNetwork = (_a3 = this.caipNetworks) == null ? void 0 : _a3.find((c2) => c2.id === params.chainId);
    if (caipNetwork && caipNetwork.chainNamespace === "eip155") {
      const caipAddress = `${caipNetwork.caipNetworkId}:${params.address}`;
      const cachedPromise = this.balancePromises[caipAddress];
      if (cachedPromise) {
        return cachedPromise;
      }
      const cachedBalance = StorageUtil.getNativeBalanceCacheForCaipAddress(caipAddress);
      if (cachedBalance) {
        if (params.ignoreCache) {
          console.log(`found cached balance: ${cachedBalance.balance}, but proceed to getBalance by jsonRpcProvider`);
        } else {
          return { balance: cachedBalance.balance, symbol: cachedBalance.symbol };
        }
      }
      const jsonRpcProvider = new JsonRpcProvider(caipNetwork.rpcUrls.default.http[0], {
        chainId: caipNetwork.id,
        name: caipNetwork.name
      });
      if (jsonRpcProvider) {
        try {
          this.balancePromises[caipAddress] = new Promise(async (resolve) => {
            const balance = await jsonRpcProvider.getBalance(params.address);
            console.log(`address: ${params.address} raw balance: ${balance}`);
            const formattedBalance = formatEther(balance);
            StorageUtil.updateNativeBalanceCache({
              caipAddress,
              balance: formattedBalance,
              symbol: caipNetwork.nativeCurrency.symbol,
              timestamp: Date.now()
            });
            resolve({
              balance: formattedBalance,
              symbol: caipNetwork.nativeCurrency.symbol
            });
          }).finally(() => {
            delete this.balancePromises[caipAddress];
          });
          return this.balancePromises[caipAddress] || { balance: "", symbol: "" };
        } catch (error) {
          return { balance: "", symbol: "" };
        }
      }
    }
    return { balance: "", symbol: "" };
  }
  async getProfile(params) {
    if (params.chainId === 1) {
      const ensProvider = new InfuraProvider("mainnet");
      const name = await ensProvider.lookupAddress(params.address);
      const avatar = await ensProvider.getAvatar(params.address);
      return { profileName: name || void 0, profileImage: avatar || void 0 };
    }
    return { profileName: void 0, profileImage: void 0 };
  }
  listenProviderEvents(provider) {
    const disconnect = () => {
      this.removeProviderListeners(provider);
      this.emit("disconnect");
    };
    const accountsChangedHandler = (accounts) => {
      if (accounts.length > 0) {
        this.emit("accountChanged", {
          address: accounts[0]
        });
      } else {
        disconnect();
      }
    };
    const chainChangedHandler = (chainId) => {
      const chainIdNumber = typeof chainId === "string" ? EthersHelpersUtil.hexStringToNumber(chainId) : Number(chainId);
      this.emit("switchNetwork", { chainId: chainIdNumber });
    };
    provider.on("disconnect", disconnect);
    provider.on("accountsChanged", accountsChangedHandler);
    provider.on("chainChanged", chainChangedHandler);
    this.providerHandlers = {
      disconnect,
      accountsChanged: accountsChangedHandler,
      chainChanged: chainChangedHandler
    };
  }
  removeProviderListeners(provider) {
    if (this.providerHandlers) {
      provider.removeListener("disconnect", this.providerHandlers.disconnect);
      provider.removeListener("accountsChanged", this.providerHandlers.accountsChanged);
      provider.removeListener("chainChanged", this.providerHandlers.chainChanged);
      this.providerHandlers = null;
    }
  }
  async switchNetwork(params) {
    var _a3, _b2;
    const { caipNetwork, provider, providerType } = params;
    if (providerType === "AUTH") {
      await super.switchNetwork(params);
      return;
    }
    try {
      await provider.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: EthersHelpersUtil.numberToHexString(caipNetwork.id) }]
      });
    } catch (switchError) {
      if (switchError.code === WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID || switchError.code === WcConstantsUtil.ERROR_INVALID_CHAIN_ID || switchError.code === WcConstantsUtil.ERROR_CODE_DEFAULT || ((_b2 = (_a3 = switchError == null ? void 0 : switchError.data) == null ? void 0 : _a3.originalError) == null ? void 0 : _b2.code) === WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID) {
        await EthersHelpersUtil.addEthereumChain(provider, caipNetwork);
      } else if (providerType === "ANNOUNCED" || providerType === "EXTERNAL" || providerType === "INJECTED") {
        throw new Error("Chain is not supported");
      }
    }
  }
  getWalletConnectProvider() {
    var _a3;
    return (_a3 = this.connectors.find((c2) => c2.type === "WALLET_CONNECT")) == null ? void 0 : _a3.provider;
  }
  async revokeProviderPermissions(provider) {
    try {
      const permissions = await provider.request({
        method: "wallet_getPermissions"
      });
      const ethAccountsPermission = permissions.find((permission) => permission.parentCapability === "eth_accounts");
      if (ethAccountsPermission) {
        await provider.request({
          method: "wallet_revokePermissions",
          params: [{ eth_accounts: {} }]
        });
      }
    } catch (error) {
      console.info("Could not revoke permissions from wallet. Disconnecting...", error);
    }
  }
  async getCapabilities(params) {
    var _a3, _b2;
    const provider = ProviderUtil.getProvider(ConstantsUtil$4.CHAIN.EVM);
    if (!provider) {
      throw new Error("Provider is undefined");
    }
    const walletCapabilitiesString = (_b2 = (_a3 = provider.session) == null ? void 0 : _a3.sessionProperties) == null ? void 0 : _b2["capabilities"];
    if (walletCapabilitiesString) {
      const walletCapabilities = EthersMethods.parseWalletCapabilities(walletCapabilitiesString);
      const accountCapabilities = walletCapabilities[params];
      if (accountCapabilities) {
        return accountCapabilities;
      }
    }
    return await provider.request({ method: "wallet_getCapabilities", params: [params] });
  }
  async grantPermissions(params) {
    const provider = ProviderUtil.getProvider(ConstantsUtil$4.CHAIN.EVM);
    if (!provider) {
      throw new Error("Provider is undefined");
    }
    return await provider.request({ method: "wallet_grantPermissions", params });
  }
  async revokePermissions(params) {
    const provider = ProviderUtil.getProvider(ConstantsUtil$4.CHAIN.EVM);
    if (!provider) {
      throw new Error("Provider is undefined");
    }
    return await provider.request({ method: "wallet_revokePermissions", params: [params] });
  }
  async walletGetAssets(params) {
    const provider = ProviderUtil.getProvider(ConstantsUtil$4.CHAIN.EVM);
    if (!provider) {
      throw new Error("Provider is undefined");
    }
    return await provider.request({
      method: "wallet_getAssets",
      params: [params]
    });
  }
}
const ConstantsUtil = {
  SECURE_SITE_ORIGIN: "https://secure.walletconnect.org",
  Socials: ["google", "github", "apple", "facebook", "x", "discord", "farcaster"],
  WalletButtonsIds: {
    coinbase: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
    metamask: "c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96",
    trust: "4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0",
    okx: "971e689d0a5be527bac79629b4ee9b925e82208e5168b733496a09c0faed0709",
    bitget: "38f5d18bd8522c244bdd70cb4a68e0e718865155811c043f052fb9f1c51de662",
    binance: "8a0ee50d1f22f6651afcae7eb4253e52a3310b90af5daef78a8c4929a9bb99d4",
    uniswap: "c03dfee351b6fcc421b4494ea33b9d4b92a984f87aa76d1663bb28705e95034a",
    safepal: "0b415a746fb9ee99cce155c2ceca0c6f6061b1dbca2d722b3ba16381d0562150",
    rainbow: "1ae92b26df02f0abca6304df07debccd18262fdf5fe82daa81593582dac9a369",
    bybit: "15c8b91ade1a4e58f3ce4e7a0dd7f42b47db0c8df7e0d84f63eb39bcb96c4e0f",
    tokenpocket: "20459438007b75f4f4acb98bf29aa3b800550309646d375da5fd4aac6c2a2c66",
    ledger: "19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927",
    "timeless-x": "344d0e58b139eb1b6da0c29ea71d52a8eace8b57897c6098cb9b46012665c193",
    safe: "225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f",
    zerion: "ecc4036f814562b41a5268adc86270fba1365471402006302e70169465b7ac18",
    oneinch: "c286eebc742a537cd1d6818363e9dc53b21759a1e8e5d9b263d0c03ec7703576",
    "crypto-com": "f2436c67184f158d1beda5df53298ee84abfc367581e4505134b5bcf5f46697d",
    imtoken: "ef333840daf915aafdc4a004525502d6d49d77bd9c65e0642dbaefb3c2893bef",
    kraken: "18450873727504ae9315a084fa7624b5297d2fe5880f0982979c17345a138277",
    ronin: "541d5dcd4ede02f3afaf75bf8e3e4c4f1fb09edb5fa6c4377ebf31c2785d9adf",
    robinhood: "8837dd9413b1d9b585ee937d27a816590248386d9dbf59f5cd3422dbbb65683e",
    exodus: "e9ff15be73584489ca4a66f64d32c4537711797e30b6660dbcb71ea72a42b1f4",
    argent: "bc949c5d968ae81310268bf9193f9c9fb7bb4e1283e1284af8f2bd4992535fd6",
    jupiter: "0ef262ca2a56b88d179c93a21383fee4e135bd7bc6680e5c2356ff8e38301037",
    solflare: "1ca0bdd4747578705b1939af023d120677c64fe6ca76add81fda36e350605e79",
    phantom: "a797aa35c0fadbfc1a53e7f675162ed5226968b44a19ee3d24385c64d1d3c393",
    coin98: "2a3c89040ac3b723a1972a33a125b1db11e258a6975d3a61252cd64e6ea5ea01",
    "magic-eden": "8b830a2b724a9c3fbab63af6f55ed29c9dfa8a55e732dc88c80a196a2ba136c6",
    backpack: "2bd8c14e035c2d48f184aaa168559e86b0e3433228d3c4075900a221785019b0",
    frontier: "85db431492aa2e8672e93f4ea7acf10c88b97b867b0d373107af63dc4880f041",
    xverse: "2a87d74ae02e10bdd1f51f7ce6c4e1cc53cd5f2c0b6b5ad0d7b3007d2b13de7b",
    leather: "483afe1df1df63daf313109971ff3ef8356ddf1cc4e45877d205eee0b7893a13"
  }
};
const baseUrl = CoreHelperUtil.getApiUrl();
const api = new FetchUtil({ baseUrl, clientId: null });
const state$1 = proxy({
  walletButtons: [],
  fetching: false
});
const ApiController = {
  state: state$1,
  subscribeKey(key2, callback) {
    return subscribeKey(state$1, key2, callback);
  },
  async fetchWalletButtons() {
    if (state$1.fetching) {
      return;
    }
    state$1.fetching = true;
    const walletButtonIds = Object.values(ConstantsUtil.WalletButtonsIds);
    const { data: data2 } = await api.get({
      path: "/getWallets",
      params: {
        ...ApiController$1._getSdkProperties(),
        page: "1",
        entries: String(walletButtonIds.length),
        include: walletButtonIds == null ? void 0 : walletButtonIds.join(",")
      }
    });
    const images = data2.map((d4) => d4.image_id).filter(Boolean);
    await Promise.allSettled(images.map((id2) => ApiController$1._fetchWalletImage(id2)));
    state$1.walletButtons = data2;
  }
};
const state = proxy({
  ready: false,
  pending: false
});
const WalletButtonController = {
  state,
  setReady(ready) {
    state.ready = ready;
  },
  setPending(pending) {
    state.pending = pending;
  },
  setError(error) {
    state.error = error;
  },
  setData(data2) {
    state.data = data2;
  }
};
const ConnectorUtil = {
  connectWalletConnect({ walletConnect, wallet, connector }) {
    return new Promise(async (resolve, reject) => {
      const isAlreadyConnected = Boolean(AccountController.state.address);
      if (isAlreadyConnected) {
        console.log(" WalletConnect       ...");
        try {
          await ChainController.disconnect();
          console.log("    ");
        } catch (error) {
          console.log("       ( ):", error);
        }
      }
      if (walletConnect) {
        ConnectorController.setActiveConnector(connector);
      }
      await ModalController.open();
      RouterController.push("ConnectingWalletConnect", { wallet });
      const unsubscribeModalController = ModalController.subscribeKey("open", (val) => {
        if (!val) {
          if (RouterController.state.view !== "Connect") {
            RouterController.push("Connect");
          }
          unsubscribeModalController();
          reject(new Error("Modal closed"));
        }
      });
      const unsubscribeChainController = ChainController.subscribeKey("activeCaipAddress", (val) => {
        if (val) {
          ModalController.close();
          unsubscribeChainController();
          resolve(ParseUtil.parseCaipAddress(val));
        }
      });
    });
  },
  connectExternal(connector) {
    return new Promise(async (resolve, reject) => {
      let isResolved = false;
      let connectionStartTime = Date.now();
      const isAlreadyConnected = Boolean(AccountController.state.address);
      if (isAlreadyConnected) {
        try {
          await ChainController.disconnect();
        } catch (error) {
        }
      }
      const unsubscribeChainController = ChainController.subscribeKey("activeCaipAddress", (val) => {
        if (val && !isResolved && Date.now() - connectionStartTime > 100) {
          isResolved = true;
          ModalController.close();
          unsubscribeChainController();
          clearTimeout(timeout);
          resolve(ParseUtil.parseCaipAddress(val));
        }
      });
      const unsubscribeModalController = ModalController.subscribeKey("open", (isOpen) => {
        if (!isOpen && !isResolved && Date.now() - connectionStartTime > 1e3) {
          isResolved = true;
          unsubscribeChainController();
          unsubscribeModalController();
          clearTimeout(timeout);
          reject(new Error("Connection rejected by user"));
        }
      });
      const timeout = setTimeout(() => {
        if (!isResolved) {
          isResolved = true;
          unsubscribeChainController();
          unsubscribeModalController();
          reject(new Error("Connection timeout"));
        }
      }, 3e4);
      try {
        await ConnectionController.connectExternal(connector, connector.chain);
      } catch (error) {
        if (!isResolved) {
          isResolved = true;
          clearTimeout(timeout);
          unsubscribeChainController();
          unsubscribeModalController();
          const errorMessage = error instanceof Error ? error.message : String(error);
          if (errorMessage.includes("User rejected") || errorMessage.includes("User denied") || errorMessage.includes("rejected")) {
            reject(new Error("Connection rejected by user"));
          } else {
            reject(new Error("Connection failed"));
          }
        }
      }
    });
  },
  connectSocial(social) {
    let socialWindow = AccountController.state.socialWindow;
    let socialProvider = AccountController.state.socialProvider;
    let connectingSocial = false;
    let popupWindow = null;
    const unsubscribeChainController = ChainController.subscribeKey("activeCaipAddress", (val) => {
      if (val) {
        ModalController.close();
        unsubscribeChainController();
      }
    });
    return new Promise((resolve, reject) => {
      async function handleSocialConnection(event) {
        var _a3;
        if ((_a3 = event.data) == null ? void 0 : _a3.resultUri) {
          if (event.origin === ConstantsUtil.SECURE_SITE_ORIGIN) {
            window.removeEventListener("message", handleSocialConnection, false);
            try {
              const authConnector = ConnectorController.getAuthConnector();
              if (authConnector && !connectingSocial) {
                if (socialWindow) {
                  socialWindow.close();
                  AccountController.setSocialWindow(void 0, ChainController.state.activeChain);
                  socialWindow = AccountController.state.socialWindow;
                }
                connectingSocial = true;
                const uri2 = event.data.resultUri;
                if (socialProvider) {
                  EventsController.sendEvent({
                    type: "track",
                    event: "SOCIAL_LOGIN_REQUEST_USER_DATA",
                    properties: { provider: socialProvider }
                  });
                }
                await authConnector.provider.connectSocial(uri2);
                if (socialProvider) {
                  StorageUtil.setConnectedSocialProvider(socialProvider);
                  await ConnectionController.connectExternal(authConnector, authConnector.chain);
                  const caipAddress = ChainController.state.activeCaipAddress;
                  if (!caipAddress) {
                    reject(new Error("Failed to connect"));
                    return;
                  }
                  resolve(ParseUtil.parseCaipAddress(caipAddress));
                  EventsController.sendEvent({
                    type: "track",
                    event: "SOCIAL_LOGIN_SUCCESS",
                    properties: { provider: socialProvider }
                  });
                }
              }
            } catch (err) {
              reject(new Error("Failed to connect"));
              if (socialProvider) {
                EventsController.sendEvent({
                  type: "track",
                  event: "SOCIAL_LOGIN_ERROR",
                  properties: { provider: socialProvider }
                });
              }
            }
          } else if (socialProvider) {
            EventsController.sendEvent({
              type: "track",
              event: "SOCIAL_LOGIN_ERROR",
              properties: { provider: socialProvider }
            });
          }
        }
      }
      async function connectSocial() {
        if (social) {
          AccountController.setSocialProvider(social, ChainController.state.activeChain);
          socialProvider = AccountController.state.socialProvider;
          EventsController.sendEvent({
            type: "track",
            event: "SOCIAL_LOGIN_STARTED",
            properties: { provider: socialProvider }
          });
        }
        if (socialProvider === SocialProviderEnum.Farcaster) {
          ModalController.open({ view: "ConnectingFarcaster" });
          const unsubscribeModalController = ModalController.subscribeKey("open", (val) => {
            if (!val && social === "farcaster") {
              reject(new Error("Popup closed"));
              RouterController.push("Connect");
              unsubscribeModalController();
            }
          });
          const authConnector = ConnectorController.getAuthConnector();
          if (authConnector) {
            if (!AccountController.state.farcasterUrl) {
              try {
                const { url } = await authConnector.provider.getFarcasterUri();
                AccountController.setFarcasterUrl(url, ChainController.state.activeChain);
              } catch {
                reject(new Error("Failed to connect to farcaster"));
              }
            }
          }
        } else {
          const authConnector = ConnectorController.getAuthConnector();
          popupWindow = CoreHelperUtil.returnOpenHref("", "popupWindow", "width=600,height=800,scrollbars=yes");
          try {
            if (authConnector && socialProvider) {
              const { uri: uri2 } = await authConnector.provider.getSocialRedirectUri({
                provider: socialProvider
              });
              if (popupWindow && uri2) {
                AccountController.setSocialWindow(popupWindow, ChainController.state.activeChain);
                socialWindow = AccountController.state.socialWindow;
                popupWindow.location.href = uri2;
                const interval = setInterval(() => {
                  if ((socialWindow == null ? void 0 : socialWindow.closed) && !connectingSocial) {
                    reject(new Error("Popup closed"));
                    clearInterval(interval);
                  }
                }, 1e3);
                window.addEventListener("message", handleSocialConnection, false);
              } else {
                popupWindow == null ? void 0 : popupWindow.close();
                reject(new Error("Failed to initiate social connection"));
              }
            }
          } catch {
            reject(new Error("Failed to initiate social connection"));
            popupWindow == null ? void 0 : popupWindow.close();
          }
        }
      }
      connectSocial();
    });
  },
  connectCrossExtensionWallet() {
    return new Promise(async (resolve, reject) => {
      try {
        const { customWallets } = OptionsController.state;
        const crossWallet = customWallets == null ? void 0 : customWallets.find((w2) => w2.id === "cross_wallet");
        if (!crossWallet) {
          throw new Error("CROSSx Wallet customWallets  .");
        }
        if (!crossWallet.rdns) {
          throw new Error("CROSSx Wallet RDNS  .");
        }
        const currentConnectors = ConnectorController.state.connectors;
        const crossWalletExtensionConnectors = currentConnectors.filter((c2) => {
          var _a3;
          return (c2.type === "ANNOUNCED" || c2.type === "INJECTED") && ((_a3 = c2.info) == null ? void 0 : _a3.rdns) === crossWallet.rdns;
        });
        if (!crossWalletExtensionConnectors || crossWalletExtensionConnectors.length === 0) {
          throw new Error("CROSSx Wallet   .");
        }
        const browserConnector = crossWalletExtensionConnectors[0];
        if (browserConnector) {
          const result = await ConnectorUtil.connectExternal(browserConnector);
          resolve(result);
        } else {
          throw new Error("CROSSx Wallet    .");
        }
      } catch (err) {
        reject(err);
      }
    });
  },
  async authenticateCrossExtensionWallet() {
    const siwx = OptionsController.state.siwx;
    if (!siwx) {
      await ConnectorUtil.connectCrossExtensionWallet();
      return { authenticated: false, sessions: [] };
    }
    console.log(" Setting _isAuthenticating = true before connecting extension");
    SIWXUtil._isAuthenticating = true;
    try {
      console.log(" Starting extension connection...");
      await ConnectorUtil.connectCrossExtensionWallet();
      console.log(" Extension connected");
      const caipAddress = await new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          unsubscribe();
          reject(new Error("Connection timeout waiting for address"));
        }, 1e4);
        const unsubscribe = AccountController.subscribeKey("address", (address2) => {
          if (address2) {
            clearTimeout(timeout);
            unsubscribe();
            resolve(ChainController.getActiveCaipAddress() || "");
          }
        });
        const currentAddress = AccountController.state.address;
        if (currentAddress) {
          clearTimeout(timeout);
          unsubscribe();
          resolve(ChainController.getActiveCaipAddress() || "");
        }
      });
      if (!caipAddress) {
        throw new Error("Failed to get CAIP address after connection");
      }
      const address = CoreHelperUtil.getPlainAddress(caipAddress);
      const network = ChainController.getActiveCaipNetwork();
      if (!address || !network) {
        throw new Error("Failed to get address or network information");
      }
      const siwxMessage = await siwx.createMessage({
        chainId: network.caipNetworkId,
        accountAddress: address
      });
      const message = siwxMessage.toString();
      const client = ConnectionController._getClient();
      if (!client) {
        throw new Error("No connection client available");
      }
      const signature2 = await client.signMessage({ message });
      if (!signature2) {
        throw new Error("Failed to get signature");
      }
      const session = {
        data: {
          accountAddress: siwxMessage.accountAddress,
          chainId: siwxMessage.chainId,
          domain: siwxMessage.domain,
          uri: siwxMessage.uri,
          version: siwxMessage.version,
          nonce: siwxMessage.nonce,
          issuedAt: siwxMessage.issuedAt,
          expirationTime: siwxMessage.expirationTime,
          statement: siwxMessage.statement,
          requestId: siwxMessage.requestId,
          resources: siwxMessage.resources,
          notBefore: siwxMessage.notBefore
        },
        message,
        signature: signature2,
        cacao: void 0
      };
      await siwx.addSession(session);
      let savedSessions = await siwx.getSessions(network.caipNetworkId, address);
      if (savedSessions.length === 0) {
        console.warn(" Session not found immediately after saving, waiting...");
        await new Promise((resolve) => setTimeout(resolve, 100));
        savedSessions = await siwx.getSessions(network.caipNetworkId, address);
        console.log(" Re-checked sessions after delay:", savedSessions.length);
      }
      setTimeout(() => {
        console.log(" Clearing _isAuthenticating flag (delayed)");
        SIWXUtil._isAuthenticating = false;
      }, 200);
      return {
        authenticated: true,
        sessions: [session]
      };
    } catch (error) {
      console.error(" Authentication failed:", error);
      SIWXUtil._isAuthenticating = false;
      throw error;
    }
  },
  isInstalledCrossExtensionWallet() {
    const { customWallets } = OptionsController.state;
    const crossWallet = customWallets == null ? void 0 : customWallets.find((w2) => w2.id === "cross_wallet");
    if (!crossWallet || !crossWallet.rdns) {
      return false;
    }
    const { connectors } = ConnectorController.state;
    const crossWalletExtensionConnectors = connectors.filter((c2) => {
      var _a3;
      return (c2.type === "ANNOUNCED" || c2.type === "INJECTED") && ((_a3 = c2.info) == null ? void 0 : _a3.rdns) === crossWallet.rdns;
    });
    return crossWalletExtensionConnectors && crossWalletExtensionConnectors.length > 0;
  }
};
const WalletUtil = {
  getWalletButton(wallet) {
    const walletButtonIds = ConstantsUtil.WalletButtonsIds;
    if (wallet in walletButtonIds) {
      return ApiController.state.walletButtons.find((walletButton) => walletButton.id === walletButtonIds[wallet]);
    }
    return void 0;
  },
  isWalletButtonReady(wallet) {
    if (wallet in ConstantsUtil.WalletButtonsIds) {
      return Boolean(WalletUtil.getWalletButton(wallet));
    }
    return true;
  }
};
var __decorate = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r3 = (c2 < 3 ? d4(r3) : c2 > 3 ? d4(target, key2, r3) : d4(target, key2)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
};
let AppKitWalletButton = class AppKitWalletButton2 extends i$1 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.wallet = "metamask";
    this.connectors = ConnectorController.state.connectors;
    this.caipAddress = ChainController.state.activeCaipAddress;
    this.loading = false;
    this.error = false;
    this.ready = WalletUtil.isWalletButtonReady(this.wallet);
    this.modalLoading = ModalController.state.loading;
    this.unsubscribe.push(...[
      ModalController.subscribeKey("loading", (val) => this.modalLoading = val),
      ConnectorController.subscribeKey("connectors", (val) => this.connectors = val),
      ChainController.subscribeKey("activeCaipAddress", (val) => {
        if (val) {
          this.error = false;
        }
        this.caipAddress = val;
      }),
      ApiController.subscribeKey("walletButtons", () => {
        this.ready = WalletUtil.isWalletButtonReady(this.wallet);
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  firstUpdated() {
    if (!WalletUtil.isWalletButtonReady(this.wallet)) {
      ApiController.fetchWalletButtons();
    }
  }
  render() {
    if (ConstantsUtil.Socials.some((social) => social === this.wallet)) {
      return this.socialTemplate();
    }
    const walletButton = WalletUtil.getWalletButton(this.wallet);
    const connector = walletButton ? ConnectorController.getConnector(walletButton.id, walletButton.rdns) : void 0;
    if (connector) {
      return this.externalTemplate(connector);
    }
    return this.walletButtonTemplate();
  }
  walletButtonTemplate() {
    const walletConnect = this.wallet === "walletConnect";
    const loading = walletConnect ? this.loading : this.loading || !this.ready;
    const walletButton = WalletUtil.getWalletButton(this.wallet);
    const walletImage = AssetUtil.getWalletImageById(walletButton == null ? void 0 : walletButton.image_id);
    const walletName = this.wallet === "walletConnect" ? "WalletConnect" : walletButton == null ? void 0 : walletButton.name;
    return x$3`
      <cross-wui-wallet-button
        data-testid="apkt-wallet-button"
        name=${!this.ready && !walletConnect || this.modalLoading ? "Loading..." : o$2(walletName)}
        @click=${async () => {
      this.loading = true;
      await ConnectorUtil.connectWalletConnect({
        walletConnect: this.wallet === "walletConnect",
        wallet: walletButton,
        connector: this.connectors.find((c2) => c2.id === "walletConnect")
      }).catch(() => {
      }).finally(() => this.loading = false);
    }}
        .icon=${o$2(this.wallet === "walletConnect" ? "walletConnect" : void 0)}
        .imageSrc=${o$2(walletImage)}
        ?disabled=${Boolean(this.caipAddress) || loading || this.modalLoading}
        ?loading=${loading || this.modalLoading}
      ></cross-wui-wallet-button>
    `;
  }
  externalTemplate(connector) {
    const walletButton = WalletUtil.getWalletButton(this.wallet);
    const walletImage = AssetUtil.getWalletImageById(walletButton == null ? void 0 : walletButton.image_id);
    const connectorImage = AssetUtil.getConnectorImage(connector);
    return x$3`
      <cross-wui-wallet-button
        data-testid="apkt-wallet-button-external"
        name=${this.modalLoading ? "Loading..." : o$2(connector.name)}
        @click=${async () => {
      this.loading = true;
      this.error = false;
      await ConnectorUtil.connectExternal(connector).catch(() => this.error = true).finally(() => this.loading = false);
    }}
        .imageSrc=${o$2(walletImage ?? connectorImage)}
        ?disabled=${Boolean(this.caipAddress) || this.loading || this.modalLoading}
        ?loading=${this.loading || this.modalLoading}
        ?error=${this.error}
      ></cross-wui-wallet-button>
    `;
  }
  socialTemplate() {
    return x$3`<cross-wui-wallet-button
      data-testid="apkt-wallet-button-social"
      name=${this.modalLoading ? "Loading..." : this.wallet}
      @click=${async () => {
      this.loading = true;
      this.error = false;
      await ConnectorUtil.connectSocial(this.wallet).catch(() => this.error = true).finally(() => this.loading = false);
    }}
      .icon=${this.wallet}
      ?disabled=${Boolean(this.caipAddress) || this.loading || this.modalLoading}
      ?loading=${this.loading || this.modalLoading}
      ?error=${this.error}
    ></cross-wui-wallet-button>`;
  }
};
__decorate([
  n$3()
], AppKitWalletButton.prototype, "wallet", void 0);
__decorate([
  r$1()
], AppKitWalletButton.prototype, "connectors", void 0);
__decorate([
  r$1()
], AppKitWalletButton.prototype, "caipAddress", void 0);
__decorate([
  r$1()
], AppKitWalletButton.prototype, "loading", void 0);
__decorate([
  r$1()
], AppKitWalletButton.prototype, "error", void 0);
__decorate([
  r$1()
], AppKitWalletButton.prototype, "ready", void 0);
__decorate([
  r$1()
], AppKitWalletButton.prototype, "modalLoading", void 0);
AppKitWalletButton = __decorate([
  customElement("appkit-wallet-button")
], AppKitWalletButton);
function isHex(value, { strict = true } = {}) {
  if (!value)
    return false;
  if (typeof value !== "string")
    return false;
  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
}
function size(value) {
  if (isHex(value, { strict: false }))
    return Math.ceil((value.length - 2) / 2);
  return value.length;
}
const version = "2.38.6";
let errorConfig = {
  getDocsUrl: ({ docsBaseUrl, docsPath = "", docsSlug }) => docsPath ? `${docsBaseUrl ?? "https://viem.sh"}${docsPath}${docsSlug ? `#${docsSlug}` : ""}` : void 0,
  version: `viem@${version}`
};
class BaseError extends Error {
  constructor(shortMessage, args = {}) {
    var _a3;
    const details = (() => {
      var _a4;
      if (args.cause instanceof BaseError)
        return args.cause.details;
      if ((_a4 = args.cause) == null ? void 0 : _a4.message)
        return args.cause.message;
      return args.details;
    })();
    const docsPath = (() => {
      if (args.cause instanceof BaseError)
        return args.cause.docsPath || args.docsPath;
      return args.docsPath;
    })();
    const docsUrl = (_a3 = errorConfig.getDocsUrl) == null ? void 0 : _a3.call(errorConfig, { ...args, docsPath });
    const message = [
      shortMessage || "An error occurred.",
      "",
      ...args.metaMessages ? [...args.metaMessages, ""] : [],
      ...docsUrl ? [`Docs: ${docsUrl}`] : [],
      ...details ? [`Details: ${details}`] : [],
      ...errorConfig.version ? [`Version: ${errorConfig.version}`] : []
    ].join("\n");
    super(message, args.cause ? { cause: args.cause } : void 0);
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "metaMessages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "version", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BaseError"
    });
    this.details = details;
    this.docsPath = docsPath;
    this.metaMessages = args.metaMessages;
    this.name = args.name ?? this.name;
    this.shortMessage = shortMessage;
    this.version = version;
  }
  walk(fn2) {
    return walk(this, fn2);
  }
}
function walk(err, fn2) {
  if (fn2 == null ? void 0 : fn2(err))
    return err;
  if (err && typeof err === "object" && "cause" in err && err.cause !== void 0)
    return walk(err.cause, fn2);
  return fn2 ? null : err;
}
class SizeExceedsPaddingSizeError extends BaseError {
  constructor({ size: size2, targetSize, type: type2 }) {
    super(`${type2.charAt(0).toUpperCase()}${type2.slice(1).toLowerCase()} size (${size2}) exceeds padding size (${targetSize}).`, { name: "SizeExceedsPaddingSizeError" });
  }
}
function pad(hexOrBytes, { dir, size: size2 = 32 } = {}) {
  if (typeof hexOrBytes === "string")
    return padHex(hexOrBytes, { dir, size: size2 });
  return padBytes(hexOrBytes, { dir, size: size2 });
}
function padHex(hex_, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return hex_;
  const hex = hex_.replace("0x", "");
  if (hex.length > size2 * 2)
    throw new SizeExceedsPaddingSizeError({
      size: Math.ceil(hex.length / 2),
      targetSize: size2,
      type: "hex"
    });
  return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size2 * 2, "0")}`;
}
function padBytes(bytes2, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return bytes2;
  if (bytes2.length > size2)
    throw new SizeExceedsPaddingSizeError({
      size: bytes2.length,
      targetSize: size2,
      type: "bytes"
    });
  const paddedBytes = new Uint8Array(size2);
  for (let i4 = 0; i4 < size2; i4++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i4 : size2 - i4 - 1] = bytes2[padEnd ? i4 : bytes2.length - i4 - 1];
  }
  return paddedBytes;
}
class IntegerOutOfRangeError extends BaseError {
  constructor({ max: max2, min: min2, signed: signed2, size: size2, value }) {
    super(`Number "${value}" is not in safe ${size2 ? `${size2 * 8}-bit ${signed2 ? "signed" : "unsigned"} ` : ""}integer range ${max2 ? `(${min2} to ${max2})` : `(above ${min2})`}`, { name: "IntegerOutOfRangeError" });
  }
}
class SizeOverflowError extends BaseError {
  constructor({ givenSize, maxSize }) {
    super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`, { name: "SizeOverflowError" });
  }
}
function assertSize(hexOrBytes, { size: size$12 }) {
  if (size(hexOrBytes) > size$12)
    throw new SizeOverflowError({
      givenSize: size(hexOrBytes),
      maxSize: size$12
    });
}
function hexToBigInt(hex, opts = {}) {
  const { signed: signed2 } = opts;
  if (opts.size)
    assertSize(hex, { size: opts.size });
  const value = BigInt(hex);
  if (!signed2)
    return value;
  const size2 = (hex.length - 2) / 2;
  const max2 = (1n << BigInt(size2) * 8n - 1n) - 1n;
  if (value <= max2)
    return value;
  return value - BigInt(`0x${"f".padStart(size2 * 2, "f")}`) - 1n;
}
function hexToNumber(hex, opts = {}) {
  return Number(hexToBigInt(hex, opts));
}
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_v2, i4) => i4.toString(16).padStart(2, "0"));
function toHex(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToHex(value, opts);
  if (typeof value === "string") {
    return stringToHex(value, opts);
  }
  if (typeof value === "boolean")
    return boolToHex(value, opts);
  return bytesToHex(value, opts);
}
function boolToHex(value, opts = {}) {
  const hex = `0x${Number(value)}`;
  if (typeof opts.size === "number") {
    assertSize(hex, { size: opts.size });
    return pad(hex, { size: opts.size });
  }
  return hex;
}
function bytesToHex(value, opts = {}) {
  let string2 = "";
  for (let i4 = 0; i4 < value.length; i4++) {
    string2 += hexes[value[i4]];
  }
  const hex = `0x${string2}`;
  if (typeof opts.size === "number") {
    assertSize(hex, { size: opts.size });
    return pad(hex, { dir: "right", size: opts.size });
  }
  return hex;
}
function numberToHex(value_, opts = {}) {
  const { signed: signed2, size: size2 } = opts;
  const value = BigInt(value_);
  let maxValue2;
  if (size2) {
    if (signed2)
      maxValue2 = (1n << BigInt(size2) * 8n - 1n) - 1n;
    else
      maxValue2 = 2n ** (BigInt(size2) * 8n) - 1n;
  } else if (typeof value_ === "number") {
    maxValue2 = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue2 === "bigint" && signed2 ? -maxValue2 - 1n : 0;
  if (maxValue2 && value > maxValue2 || value < minValue) {
    const suffix = typeof value_ === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError({
      max: maxValue2 ? `${maxValue2}${suffix}` : void 0,
      min: `${minValue}${suffix}`,
      signed: signed2,
      size: size2,
      value: `${value_}${suffix}`
    });
  }
  const hex = `0x${(signed2 && value < 0 ? (1n << BigInt(size2 * 8)) + BigInt(value) : value).toString(16)}`;
  if (size2)
    return pad(hex, { size: size2 });
  return hex;
}
const encoder$1 = /* @__PURE__ */ new TextEncoder();
function stringToHex(value_, opts = {}) {
  const value = encoder$1.encode(value_);
  return bytesToHex(value, opts);
}
const encoder = /* @__PURE__ */ new TextEncoder();
function toBytes(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToBytes(value, opts);
  if (typeof value === "boolean")
    return boolToBytes(value, opts);
  if (isHex(value))
    return hexToBytes(value, opts);
  return stringToBytes(value, opts);
}
function boolToBytes(value, opts = {}) {
  const bytes2 = new Uint8Array(1);
  bytes2[0] = Number(value);
  if (typeof opts.size === "number") {
    assertSize(bytes2, { size: opts.size });
    return pad(bytes2, { size: opts.size });
  }
  return bytes2;
}
const charCodeMap = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function charCodeToBase16(char) {
  if (char >= charCodeMap.zero && char <= charCodeMap.nine)
    return char - charCodeMap.zero;
  if (char >= charCodeMap.A && char <= charCodeMap.F)
    return char - (charCodeMap.A - 10);
  if (char >= charCodeMap.a && char <= charCodeMap.f)
    return char - (charCodeMap.a - 10);
  return void 0;
}
function hexToBytes(hex_, opts = {}) {
  let hex = hex_;
  if (opts.size) {
    assertSize(hex, { size: opts.size });
    hex = pad(hex, { dir: "right", size: opts.size });
  }
  let hexString = hex.slice(2);
  if (hexString.length % 2)
    hexString = `0${hexString}`;
  const length = hexString.length / 2;
  const bytes2 = new Uint8Array(length);
  for (let index2 = 0, j2 = 0; index2 < length; index2++) {
    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j2++));
    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j2++));
    if (nibbleLeft === void 0 || nibbleRight === void 0) {
      throw new BaseError(`Invalid byte sequence ("${hexString[j2 - 2]}${hexString[j2 - 1]}" in "${hexString}").`);
    }
    bytes2[index2] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes2;
}
function numberToBytes(value, opts) {
  const hex = numberToHex(value, opts);
  return hexToBytes(hex);
}
function stringToBytes(value, opts = {}) {
  const bytes2 = encoder.encode(value);
  if (typeof opts.size === "number") {
    assertSize(bytes2, { size: opts.size });
    return pad(bytes2, { dir: "right", size: opts.size });
  }
  return bytes2;
}
function keccak256(value, to_) {
  const to2 = to_ || "hex";
  const bytes2 = keccak_256$1(isHex(value, { strict: false }) ? toBytes(value) : value);
  if (to2 === "bytes")
    return bytes2;
  return toHex(bytes2);
}
class LruMap extends Map {
  constructor(size2) {
    super();
    Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxSize = size2;
  }
  get(key2) {
    const value = super.get(key2);
    if (super.has(key2) && value !== void 0) {
      this.delete(key2);
      super.set(key2, value);
    }
    return value;
  }
  set(key2, value) {
    super.set(key2, value);
    if (this.maxSize && this.size > this.maxSize) {
      const firstKey = this.keys().next().value;
      if (firstKey)
        this.delete(firstKey);
    }
    return this;
  }
}
const checksumAddressCache = /* @__PURE__ */ new LruMap(8192);
function checksumAddress(address_, chainId) {
  if (checksumAddressCache.has(`${address_}.${chainId}`))
    return checksumAddressCache.get(`${address_}.${chainId}`);
  const hexAddress = address_.substring(2).toLowerCase();
  const hash3 = keccak256(stringToBytes(hexAddress), "bytes");
  const address = hexAddress.split("");
  for (let i4 = 0; i4 < 40; i4 += 2) {
    if (hash3[i4 >> 1] >> 4 >= 8 && address[i4]) {
      address[i4] = address[i4].toUpperCase();
    }
    if ((hash3[i4 >> 1] & 15) >= 8 && address[i4 + 1]) {
      address[i4 + 1] = address[i4 + 1].toUpperCase();
    }
  }
  const result = `0x${address.join("")}`;
  checksumAddressCache.set(`${address_}.${chainId}`, result);
  return result;
}
function publicKeyToAddress(publicKey) {
  const address = keccak256(`0x${publicKey.substring(4)}`).substring(26);
  return checksumAddress(`0x${address}`);
}
async function recoverPublicKey({ hash: hash3, signature: signature2 }) {
  const hashHex = isHex(hash3) ? hash3 : toHex(hash3);
  const { secp256k1: secp256k12 } = await import("./secp256k1-7ladhD05.js");
  const signature_ = (() => {
    if (typeof signature2 === "object" && "r" in signature2 && "s" in signature2) {
      const { r: r3, s: s2, v: v2, yParity } = signature2;
      const yParityOrV2 = Number(yParity ?? v2);
      const recoveryBit2 = toRecoveryBit(yParityOrV2);
      return new secp256k12.Signature(hexToBigInt(r3), hexToBigInt(s2)).addRecoveryBit(recoveryBit2);
    }
    const signatureHex = isHex(signature2) ? signature2 : toHex(signature2);
    if (size(signatureHex) !== 65)
      throw new Error("invalid signature length");
    const yParityOrV = hexToNumber(`0x${signatureHex.slice(130)}`);
    const recoveryBit = toRecoveryBit(yParityOrV);
    return secp256k12.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
  })();
  const publicKey = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);
  return `0x${publicKey}`;
}
function toRecoveryBit(yParityOrV) {
  if (yParityOrV === 0 || yParityOrV === 1)
    return yParityOrV;
  if (yParityOrV === 27)
    return 0;
  if (yParityOrV === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}
async function recoverAddress({ hash: hash3, signature: signature2 }) {
  return publicKeyToAddress(await recoverPublicKey({ hash: hash3, signature: signature2 }));
}
const Pe = ":";
function Ye$1(e3) {
  const [t2, n5] = e3.split(Pe);
  return { namespace: t2, reference: n5 };
}
function Dt$2(e3) {
  const { namespace: t2, reference: n5 } = e3;
  return [t2, n5].join(Pe);
}
function Xe$1(e3) {
  const [t2, n5, r3] = e3.split(Pe);
  return { namespace: t2, reference: n5, address: r3 };
}
function Mt$2(e3) {
  const { namespace: t2, reference: n5, address: r3 } = e3;
  return [t2, n5, r3].join(Pe);
}
function Ze$1(e3, t2) {
  const n5 = [];
  return e3.forEach((r3) => {
    const o3 = t2(r3);
    n5.includes(o3) || n5.push(o3);
  }), n5;
}
function Vt$2(e3) {
  const { address: t2 } = Xe$1(e3);
  return t2;
}
function Ht$2(e3) {
  const { namespace: t2, reference: n5 } = Xe$1(e3);
  return Dt$2({ namespace: t2, reference: n5 });
}
function Mr$2(e3, t2) {
  const { namespace: n5, reference: r3 } = Ye$1(t2);
  return Mt$2({ namespace: n5, reference: r3, address: e3 });
}
function Vr$2(e3) {
  return Ze$1(e3, Vt$2);
}
function Kt$2(e3) {
  return Ze$1(e3, Ht$2);
}
function Hr$2(e3, t2 = []) {
  const n5 = [];
  return Object.keys(e3).forEach((r3) => {
    if (t2.length && !t2.includes(r3)) return;
    const o3 = e3[r3];
    n5.push(...o3.accounts);
  }), n5;
}
function Kr$2(e3, t2 = []) {
  const n5 = [];
  return Object.keys(e3).forEach((r3) => {
    if (t2.length && !t2.includes(r3)) return;
    const o3 = e3[r3];
    n5.push(...Kt$2(o3.accounts));
  }), n5;
}
function Fr$2(e3, t2 = []) {
  const n5 = [];
  return Object.keys(e3).forEach((r3) => {
    if (t2.length && !t2.includes(r3)) return;
    const o3 = e3[r3];
    n5.push(...Le$3(r3, o3));
  }), n5;
}
function Le$3(e3, t2) {
  return e3.includes(":") ? [e3] : t2.chains || [];
}
const Ft$2 = "ReactNative", H$2 = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" }, Be$2 = " ", qr$2 = ":", qt$2 = "/", Qe$1 = 2, Gr$2 = 1e3, Gt$2 = "js";
function et$1() {
  return typeof process$1 < "u" && typeof process$1.versions < "u" && typeof process$1.versions.node < "u";
}
function ne$2() {
  return !getDocument_1() && !!getNavigator_1() && navigator.product === Ft$2;
}
function Wr$2() {
  return ne$2() && typeof global$1 < "u" && typeof (global$1 == null ? void 0 : global$1.Platform) < "u" && (global$1 == null ? void 0 : global$1.Platform.OS) === "android";
}
function zr$2() {
  return ne$2() && typeof global$1 < "u" && typeof (global$1 == null ? void 0 : global$1.Platform) < "u" && (global$1 == null ? void 0 : global$1.Platform.OS) === "ios";
}
function Ae$2() {
  return !et$1() && !!getNavigator_1() && !!getDocument_1();
}
function ue$2() {
  return ne$2() ? H$2.reactNative : et$1() ? H$2.node : Ae$2() ? H$2.browser : H$2.unknown;
}
function Jr$2() {
  var e3;
  try {
    return ne$2() && typeof global$1 < "u" && typeof (global$1 == null ? void 0 : global$1.Application) < "u" ? (e3 = global$1.Application) == null ? void 0 : e3.applicationId : void 0;
  } catch {
    return;
  }
}
function Wt$2(e3, t2) {
  const n5 = new URLSearchParams(e3);
  for (const r3 of Object.keys(t2).sort()) if (t2.hasOwnProperty(r3)) {
    const o3 = t2[r3];
    o3 !== void 0 && n5.set(r3, o3);
  }
  return n5.toString();
}
function Yr$2() {
  return getWindowMetadata_1() || { name: "", description: "", url: "", icons: [""] };
}
function Xr$2(e3, t2) {
  var n5;
  const r3 = ue$2(), o3 = { protocol: e3, version: t2, env: r3 };
  return r3 === "browser" && (o3.host = ((n5 = getLocation_1()) == null ? void 0 : n5.host) || "unknown"), o3;
}
function zt$2() {
  if (ue$2() === H$2.reactNative && typeof global$1 < "u" && typeof (global$1 == null ? void 0 : global$1.Platform) < "u") {
    const { OS: n5, Version: r3 } = global$1.Platform;
    return [n5, r3].join("-");
  }
  const e3 = detect();
  if (e3 === null) return "unknown";
  const t2 = e3.os ? e3.os.replace(" ", "").toLowerCase() : "unknown";
  return e3.type === "browser" ? [t2, e3.name, e3.version].join("-") : [t2, e3.version].join("-");
}
function Jt$2() {
  var e3;
  const t2 = ue$2();
  return t2 === H$2.browser ? [t2, ((e3 = getLocation_1()) == null ? void 0 : e3.host) || "unknown"].join(":") : t2;
}
function Yt$2(e3, t2, n5) {
  const r3 = zt$2(), o3 = Jt$2();
  return [[e3, t2].join("-"), [Gt$2, n5].join("-"), r3, o3].join("/");
}
function Zr$2({ protocol: e3, version: t2, relayUrl: n5, sdkVersion: r3, auth: o3, projectId: s2, useOnCloseEvent: i4, bundleId: c2, packageName: u2 }) {
  const a2 = n5.split("?"), l2 = Yt$2(e3, t2, r3), f6 = { auth: o3, ua: l2, projectId: s2, useOnCloseEvent: i4 || void 0, packageName: u2 || void 0, bundleId: c2 || void 0 }, d4 = Wt$2(a2[1] || "", f6);
  return a2[0] + "?" + d4;
}
function Qr$2(e3) {
  let t2 = (e3.match(/^[^:]+(?=:\/\/)/gi) || [])[0];
  const n5 = typeof t2 < "u" ? e3.split("://")[1] : e3;
  return t2 = t2 === "wss" ? "https" : "http", [t2, n5].join("://");
}
function eo$2(e3, t2, n5) {
  if (!e3[t2] || typeof e3[t2] !== n5) throw new Error(`Missing or invalid "${t2}" param`);
}
function Xt$2(e3, t2 = Qe$1) {
  return Zt$2(e3.split(qt$2), t2);
}
function to$2(e3) {
  return Xt$2(e3).join(Be$2);
}
function re$2(e3, t2) {
  return e3.filter((n5) => t2.includes(n5)).length === e3.length;
}
function Zt$2(e3, t2 = Qe$1) {
  return e3.slice(Math.max(e3.length - t2, 0));
}
function no$2(e3) {
  return Object.fromEntries(e3.entries());
}
function ro$2(e3) {
  return new Map(Object.entries(e3));
}
function oo$2(e3, t2) {
  const n5 = {};
  return Object.keys(e3).forEach((r3) => {
    n5[r3] = t2(e3[r3]);
  }), n5;
}
const so$2 = (e3) => e3;
function Qt$2(e3) {
  return e3.trim().replace(/^\w/, (t2) => t2.toUpperCase());
}
function io$2(e3) {
  return e3.split(Be$2).map((t2) => Qt$2(t2)).join(Be$2);
}
function co$1(e3 = cjs$3.FIVE_MINUTES, t2) {
  const n5 = cjs$3.toMiliseconds(e3 || cjs$3.FIVE_MINUTES);
  let r3, o3, s2, i4;
  return { resolve: (c2) => {
    s2 && r3 && (clearTimeout(s2), r3(c2), i4 = Promise.resolve(c2));
  }, reject: (c2) => {
    s2 && o3 && (clearTimeout(s2), o3(c2));
  }, done: () => new Promise((c2, u2) => {
    if (i4) return c2(i4);
    s2 = setTimeout(() => {
      const a2 = new Error(t2);
      i4 = Promise.reject(a2), u2(a2);
    }, n5), r3 = c2, o3 = u2;
  }) };
}
function ao$2(e3, t2, n5) {
  return new Promise(async (r3, o3) => {
    const s2 = setTimeout(() => o3(new Error(n5)), t2);
    try {
      const i4 = await e3;
      r3(i4);
    } catch (i4) {
      o3(i4);
    }
    clearTimeout(s2);
  });
}
function tt$1(e3, t2) {
  if (typeof t2 == "string" && t2.startsWith(`${e3}:`)) return t2;
  if (e3.toLowerCase() === "topic") {
    if (typeof t2 != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${t2}`;
  } else if (e3.toLowerCase() === "id") {
    if (typeof t2 != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${t2}`;
  }
  throw new Error(`Unknown expirer target type: ${e3}`);
}
function uo$1(e3) {
  return tt$1("topic", e3);
}
function fo$1(e3) {
  return tt$1("id", e3);
}
function lo$1(e3) {
  const [t2, n5] = e3.split(":"), r3 = { id: void 0, topic: void 0 };
  if (t2 === "topic" && typeof n5 == "string") r3.topic = n5;
  else if (t2 === "id" && Number.isInteger(Number(n5))) r3.id = Number(n5);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${t2}:${n5}`);
  return r3;
}
function ho$1(e3, t2) {
  return cjs$3.fromMiliseconds((t2 || Date.now()) + cjs$3.toMiliseconds(e3));
}
function po$1(e3) {
  return Date.now() >= cjs$3.toMiliseconds(e3);
}
function go$1(e3, t2) {
  return `${e3}${t2 ? `:${t2}` : ""}`;
}
function Q$1(e3 = [], t2 = []) {
  return [.../* @__PURE__ */ new Set([...e3, ...t2])];
}
async function yo$1({ id: e3, topic: t2, wcDeepLink: n5 }) {
  var r3;
  try {
    if (!n5) return;
    const o3 = typeof n5 == "string" ? JSON.parse(n5) : n5, s2 = o3 == null ? void 0 : o3.href;
    if (typeof s2 != "string") return;
    const i4 = en$2(s2, e3, t2), c2 = ue$2();
    if (c2 === H$2.browser) {
      if (!((r3 = getDocument_1()) != null && r3.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      tn$2(i4);
    } else c2 === H$2.reactNative && typeof (global$1 == null ? void 0 : global$1.Linking) < "u" && await global$1.Linking.openURL(i4);
  } catch (o3) {
    console.error(o3);
  }
}
function en$2(e3, t2, n5) {
  const r3 = `requestId=${t2}&sessionTopic=${n5}`;
  e3.endsWith("/") && (e3 = e3.slice(0, -1));
  let o3 = `${e3}`;
  if (e3.startsWith("https://t.me")) {
    const s2 = e3.includes("?") ? "&startapp=" : "?startapp=";
    o3 = `${o3}${s2}${on$2(r3, true)}`;
  } else o3 = `${o3}/wc?${r3}`;
  return o3;
}
function tn$2(e3) {
  let t2 = "_self";
  rn$2() ? t2 = "_top" : (nn$2() || e3.startsWith("https://") || e3.startsWith("http://")) && (t2 = "_blank"), window.open(e3, t2, "noreferrer noopener");
}
async function mo$1(e3, t2) {
  let n5 = "";
  try {
    if (Ae$2() && (n5 = localStorage.getItem(t2), n5)) return n5;
    n5 = await e3.getItem(t2);
  } catch (r3) {
    console.error(r3);
  }
  return n5;
}
function nt$1(e3, t2) {
  return e3.filter((n5) => t2.includes(n5));
}
function bo$1(e3, t2) {
  if (!e3.includes(t2)) return null;
  const n5 = e3.split(/([&,?,=])/), r3 = n5.indexOf(t2);
  return n5[r3 + 2];
}
function wo$1() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (e3) => {
    const t2 = Math.random() * 16 | 0;
    return (e3 === "x" ? t2 : t2 & 3 | 8).toString(16);
  });
}
function Eo$1() {
  return typeof process$1 < "u" && process$1.env.IS_VITEST === "true";
}
function nn$2() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function rn$2() {
  try {
    return window.self !== window.top;
  } catch {
    return false;
  }
}
function on$2(e3, t2 = false) {
  const n5 = Buffer.from(e3).toString("base64");
  return t2 ? n5.replace(/[=]/g, "") : n5;
}
function rt$1(e3) {
  return Buffer.from(e3, "base64").toString("utf-8");
}
function vo$1(e3) {
  return new Promise((t2) => setTimeout(t2, e3));
}
function Ne$2(e3) {
  if (!Number.isSafeInteger(e3) || e3 < 0) throw new Error("positive integer expected, got " + e3);
}
function xo$1(e3) {
  return e3 instanceof Uint8Array || ArrayBuffer.isView(e3) && e3.constructor.name === "Uint8Array";
}
function je$2(e3, ...t2) {
  if (!xo$1(e3)) throw new Error("Uint8Array expected");
  if (t2.length > 0 && !t2.includes(e3.length)) throw new Error("Uint8Array expected of length " + t2 + ", got length=" + e3.length);
}
function ot$1(e3) {
  if (typeof e3 != "function" || typeof e3.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Ne$2(e3.outputLen), Ne$2(e3.blockLen);
}
function me(e3, t2 = true) {
  if (e3.destroyed) throw new Error("Hash instance has been destroyed");
  if (t2 && e3.finished) throw new Error("Hash#digest() has already been called");
}
function sn$2(e3, t2) {
  je$2(e3);
  const n5 = t2.outputLen;
  if (e3.length < n5) throw new Error("digestInto() expects output buffer of length at least " + n5);
}
const Ce$1 = BigInt(2 ** 32 - 1), cn$2 = BigInt(32);
function Oo$1(e3, t2 = false) {
  return t2 ? { h: Number(e3 & Ce$1), l: Number(e3 >> cn$2 & Ce$1) } : { h: Number(e3 >> cn$2 & Ce$1) | 0, l: Number(e3 & Ce$1) | 0 };
}
function Io$1(e3, t2 = false) {
  let n5 = new Uint32Array(e3.length), r3 = new Uint32Array(e3.length);
  for (let o3 = 0; o3 < e3.length; o3++) {
    const { h: s2, l: i4 } = Oo$1(e3[o3], t2);
    [n5[o3], r3[o3]] = [s2, i4];
  }
  return [n5, r3];
}
const Ao$1 = (e3, t2, n5) => e3 << n5 | t2 >>> 32 - n5, No$1 = (e3, t2, n5) => t2 << n5 | e3 >>> 32 - n5, So$1 = (e3, t2, n5) => t2 << n5 - 32 | e3 >>> 64 - n5, Uo$1 = (e3, t2, n5) => e3 << n5 - 32 | t2 >>> 64 - n5, be$1 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function _o$1(e3) {
  return new Uint32Array(e3.buffer, e3.byteOffset, Math.floor(e3.byteLength / 4));
}
function st$1(e3) {
  return new DataView(e3.buffer, e3.byteOffset, e3.byteLength);
}
function J$2(e3, t2) {
  return e3 << 32 - t2 | e3 >>> t2;
}
const an$2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function To$1(e3) {
  return e3 << 24 & 4278190080 | e3 << 8 & 16711680 | e3 >>> 8 & 65280 | e3 >>> 24 & 255;
}
function un$2(e3) {
  for (let t2 = 0; t2 < e3.length; t2++) e3[t2] = To$1(e3[t2]);
}
function $o$1(e3) {
  if (typeof e3 != "string") throw new Error("utf8ToBytes expected string, got " + typeof e3);
  return new Uint8Array(new TextEncoder().encode(e3));
}
function we$2(e3) {
  return typeof e3 == "string" && (e3 = $o$1(e3)), je$2(e3), e3;
}
let it$1 = class it3 {
  clone() {
    return this._cloneInto();
  }
};
function fn$2(e3) {
  const t2 = (r3) => e3().update(we$2(r3)).digest(), n5 = e3();
  return t2.outputLen = n5.outputLen, t2.blockLen = n5.blockLen, t2.create = () => e3(), t2;
}
function Se$2(e3 = 32) {
  if (be$1 && typeof be$1.getRandomValues == "function") return be$1.getRandomValues(new Uint8Array(e3));
  if (be$1 && typeof be$1.randomBytes == "function") return be$1.randomBytes(e3);
  throw new Error("crypto.getRandomValues must be defined");
}
const ln$2 = [], dn$2 = [], hn$2 = [], Ro$1 = BigInt(0), Ue$3 = BigInt(1), Po$1 = BigInt(2), Lo$1 = BigInt(7), Bo$1 = BigInt(256), jo$1 = BigInt(113);
for (let e3 = 0, t2 = Ue$3, n5 = 1, r3 = 0; e3 < 24; e3++) {
  [n5, r3] = [r3, (2 * n5 + 3 * r3) % 5], ln$2.push(2 * (5 * r3 + n5)), dn$2.push((e3 + 1) * (e3 + 2) / 2 % 64);
  let o3 = Ro$1;
  for (let s2 = 0; s2 < 7; s2++) t2 = (t2 << Ue$3 ^ (t2 >> Lo$1) * jo$1) % Bo$1, t2 & Po$1 && (o3 ^= Ue$3 << (Ue$3 << BigInt(s2)) - Ue$3);
  hn$2.push(o3);
}
const [Co$1, ko$1] = Io$1(hn$2, true), pn$2 = (e3, t2, n5) => n5 > 32 ? So$1(e3, t2, n5) : Ao$1(e3, t2, n5), gn$2 = (e3, t2, n5) => n5 > 32 ? Uo$1(e3, t2, n5) : No$1(e3, t2, n5);
function Do$1(e3, t2 = 24) {
  const n5 = new Uint32Array(10);
  for (let r3 = 24 - t2; r3 < 24; r3++) {
    for (let i4 = 0; i4 < 10; i4++) n5[i4] = e3[i4] ^ e3[i4 + 10] ^ e3[i4 + 20] ^ e3[i4 + 30] ^ e3[i4 + 40];
    for (let i4 = 0; i4 < 10; i4 += 2) {
      const c2 = (i4 + 8) % 10, u2 = (i4 + 2) % 10, a2 = n5[u2], l2 = n5[u2 + 1], f6 = pn$2(a2, l2, 1) ^ n5[c2], d4 = gn$2(a2, l2, 1) ^ n5[c2 + 1];
      for (let g2 = 0; g2 < 50; g2 += 10) e3[i4 + g2] ^= f6, e3[i4 + g2 + 1] ^= d4;
    }
    let o3 = e3[2], s2 = e3[3];
    for (let i4 = 0; i4 < 24; i4++) {
      const c2 = dn$2[i4], u2 = pn$2(o3, s2, c2), a2 = gn$2(o3, s2, c2), l2 = ln$2[i4];
      o3 = e3[l2], s2 = e3[l2 + 1], e3[l2] = u2, e3[l2 + 1] = a2;
    }
    for (let i4 = 0; i4 < 50; i4 += 10) {
      for (let c2 = 0; c2 < 10; c2++) n5[c2] = e3[i4 + c2];
      for (let c2 = 0; c2 < 10; c2++) e3[i4 + c2] ^= ~n5[(c2 + 2) % 10] & n5[(c2 + 4) % 10];
    }
    e3[0] ^= Co$1[r3], e3[1] ^= ko$1[r3];
  }
  n5.fill(0);
}
let Bt$2 = class Bt3 extends it$1 {
  constructor(t2, n5, r3, o3 = false, s2 = 24) {
    if (super(), this.blockLen = t2, this.suffix = n5, this.outputLen = r3, this.enableXOF = o3, this.rounds = s2, this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, Ne$2(r3), 0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = _o$1(this.state);
  }
  keccak() {
    an$2 || un$2(this.state32), Do$1(this.state32, this.rounds), an$2 || un$2(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(t2) {
    me(this);
    const { blockLen: n5, state: r3 } = this;
    t2 = we$2(t2);
    const o3 = t2.length;
    for (let s2 = 0; s2 < o3; ) {
      const i4 = Math.min(n5 - this.pos, o3 - s2);
      for (let c2 = 0; c2 < i4; c2++) r3[this.pos++] ^= t2[s2++];
      this.pos === n5 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const { state: t2, suffix: n5, pos: r3, blockLen: o3 } = this;
    t2[r3] ^= n5, (n5 & 128) !== 0 && r3 === o3 - 1 && this.keccak(), t2[o3 - 1] ^= 128, this.keccak();
  }
  writeInto(t2) {
    me(this, false), je$2(t2), this.finish();
    const n5 = this.state, { blockLen: r3 } = this;
    for (let o3 = 0, s2 = t2.length; o3 < s2; ) {
      this.posOut >= r3 && this.keccak();
      const i4 = Math.min(r3 - this.posOut, s2 - o3);
      t2.set(n5.subarray(this.posOut, this.posOut + i4), o3), this.posOut += i4, o3 += i4;
    }
    return t2;
  }
  xofInto(t2) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(t2);
  }
  xof(t2) {
    return Ne$2(t2), this.xofInto(new Uint8Array(t2));
  }
  digestInto(t2) {
    if (sn$2(t2, this), this.finished) throw new Error("digest() was already called");
    return this.writeInto(t2), this.destroy(), t2;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, this.state.fill(0);
  }
  _cloneInto(t2) {
    const { blockLen: n5, suffix: r3, outputLen: o3, rounds: s2, enableXOF: i4 } = this;
    return t2 || (t2 = new Bt3(n5, r3, o3, i4, s2)), t2.state32.set(this.state32), t2.pos = this.pos, t2.posOut = this.posOut, t2.finished = this.finished, t2.rounds = s2, t2.suffix = r3, t2.outputLen = o3, t2.enableXOF = i4, t2.destroyed = this.destroyed, t2;
  }
};
const Mo$1 = (e3, t2, n5) => fn$2(() => new Bt$2(t2, e3, n5)), Vo$1 = Mo$1(1, 136, 256 / 8), Ho$1 = "https://rpc.walletconnect.org/v1";
function ct$1(e3) {
  const t2 = `Ethereum Signed Message:
${e3.length}`, n5 = new TextEncoder().encode(t2 + e3);
  return "0x" + Buffer.from(Vo$1(n5)).toString("hex");
}
async function yn$2(e3, t2, n5, r3, o3, s2) {
  switch (n5.t) {
    case "eip191":
      return await mn$2(e3, t2, n5.s);
    case "eip1271":
      return await bn$2(e3, t2, n5.s, r3, o3, s2);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${n5.t}`);
  }
}
async function mn$2(e3, t2, n5) {
  return (await recoverAddress({ hash: ct$1(t2), signature: n5 })).toLowerCase() === e3.toLowerCase();
}
async function bn$2(e3, t2, n5, r3, o3, s2) {
  const i4 = Ye$1(r3);
  if (!i4.namespace || !i4.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r3}`);
  try {
    const c2 = "0x1626ba7e", u2 = "0000000000000000000000000000000000000000000000000000000000000040", a2 = "0000000000000000000000000000000000000000000000000000000000000041", l2 = n5.substring(2), f6 = ct$1(t2).substring(2), d4 = c2 + f6 + u2 + a2 + l2, g2 = await fetch(`${s2 || Ho$1}/?chainId=${r3}&projectId=${o3}`, { method: "POST", body: JSON.stringify({ id: Ko$1(), jsonrpc: "2.0", method: "eth_call", params: [{ to: e3, data: d4 }, "latest"] }) }), { result: y4 } = await g2.json();
    return y4 ? y4.slice(0, c2.length).toLowerCase() === c2.toLowerCase() : false;
  } catch (c2) {
    return console.error("isValidEip1271Signature: ", c2), false;
  }
}
function Ko$1() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
var Fo$1 = Object.defineProperty, qo$1 = Object.defineProperties, Go$1 = Object.getOwnPropertyDescriptors, wn$2 = Object.getOwnPropertySymbols, Wo$1 = Object.prototype.hasOwnProperty, zo$1 = Object.prototype.propertyIsEnumerable, En$2 = (e3, t2, n5) => t2 in e3 ? Fo$1(e3, t2, { enumerable: true, configurable: true, writable: true, value: n5 }) : e3[t2] = n5, at$1 = (e3, t2) => {
  for (var n5 in t2 || (t2 = {})) Wo$1.call(t2, n5) && En$2(e3, n5, t2[n5]);
  if (wn$2) for (var n5 of wn$2(t2)) zo$1.call(t2, n5) && En$2(e3, n5, t2[n5]);
  return e3;
}, vn$2 = (e3, t2) => qo$1(e3, Go$1(t2));
const Jo$1 = "did:pkh:", ke$3 = (e3) => e3 == null ? void 0 : e3.split(":"), xn$2 = (e3) => {
  const t2 = e3 && ke$3(e3);
  if (t2) return e3.includes(Jo$1) ? t2[3] : t2[1];
}, On$2 = (e3) => {
  const t2 = e3 && ke$3(e3);
  if (t2) return t2[2] + ":" + t2[3];
}, ut$2 = (e3) => {
  const t2 = e3 && ke$3(e3);
  if (t2) return t2.pop();
};
async function Yo$1(e3) {
  const { cacao: t2, projectId: n5 } = e3, { s: r3, p: o3 } = t2, s2 = In$2(o3, o3.iss), i4 = ut$2(o3.iss);
  return await yn$2(i4, s2, r3, On$2(o3.iss), n5);
}
const In$2 = (e3, t2) => {
  const n5 = `${e3.domain} wants you to sign in with your Ethereum account:`, r3 = ut$2(t2);
  if (!e3.aud && !e3.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
  let o3 = e3.statement || void 0;
  const s2 = `URI: ${e3.aud || e3.uri}`, i4 = `Version: ${e3.version}`, c2 = `Chain ID: ${xn$2(t2)}`, u2 = `Nonce: ${e3.nonce}`, a2 = `Issued At: ${e3.iat}`, l2 = e3.exp ? `Expiration Time: ${e3.exp}` : void 0, f6 = e3.nbf ? `Not Before: ${e3.nbf}` : void 0, d4 = e3.requestId ? `Request ID: ${e3.requestId}` : void 0, g2 = e3.resources ? `Resources:${e3.resources.map((h5) => `
- ${h5}`).join("")}` : void 0, y4 = Me$3(e3.resources);
  if (y4) {
    const h5 = oe$1(y4);
    o3 = dt$2(o3, h5);
  }
  return [n5, r3, "", o3, "", s2, i4, c2, u2, a2, l2, f6, d4, g2].filter((h5) => h5 != null).join(`
`);
};
function Xo$1(e3, t2, n5) {
  return n5.includes("did:pkh:") || (n5 = `did:pkh:${n5}`), { h: { t: "caip122" }, p: { iss: n5, domain: e3.domain, aud: e3.aud, version: e3.version, nonce: e3.nonce, iat: e3.iat, statement: e3.statement, requestId: e3.requestId, resources: e3.resources, nbf: e3.nbf, exp: e3.exp }, s: t2 };
}
function Zo$1(e3) {
  var t2;
  const { authPayload: n5, chains: r3, methods: o3 } = e3, s2 = n5.statement || "";
  if (!(r3 != null && r3.length)) return n5;
  const i4 = n5.chains, c2 = nt$1(i4, r3);
  if (!(c2 != null && c2.length)) throw new Error("No supported chains");
  const u2 = An$2(n5.resources);
  if (!u2) return n5;
  Y$1(u2);
  const a2 = Nn$2(u2, "eip155");
  let l2 = (n5 == null ? void 0 : n5.resources) || [];
  if (a2 != null && a2.length) {
    const f6 = Sn$2(a2), d4 = nt$1(f6, o3);
    if (!(d4 != null && d4.length)) throw new Error(`Supported methods don't satisfy the requested: ${JSON.stringify(f6)}, supported: ${JSON.stringify(o3)}`);
    const g2 = ft$2("request", d4, { chains: c2 }), y4 = $n$2(u2, "eip155", g2);
    l2 = ((t2 = n5 == null ? void 0 : n5.resources) == null ? void 0 : t2.slice(0, -1)) || [], l2.push(De$2(y4));
  }
  return vn$2(at$1({}, n5), { statement: Pn$2(s2, Me$3(l2)), chains: c2, resources: n5 != null && n5.resources || l2.length > 0 ? l2 : void 0 });
}
function An$2(e3) {
  const t2 = Me$3(e3);
  if (t2 && lt$1(t2)) return oe$1(t2);
}
function Qo$1(e3, t2) {
  var n5;
  return (n5 = e3 == null ? void 0 : e3.att) == null ? void 0 : n5.hasOwnProperty(t2);
}
function Nn$2(e3, t2) {
  var n5, r3;
  return (n5 = e3 == null ? void 0 : e3.att) != null && n5[t2] ? Object.keys((r3 = e3 == null ? void 0 : e3.att) == null ? void 0 : r3[t2]) : [];
}
function es$1(e3) {
  return (e3 == null ? void 0 : e3.map((t2) => Object.keys(t2))) || [];
}
function Sn$2(e3) {
  return (e3 == null ? void 0 : e3.map((t2) => {
    var n5;
    return (n5 = t2.split("/")) == null ? void 0 : n5[1];
  })) || [];
}
function Un$2(e3) {
  return Buffer.from(JSON.stringify(e3)).toString("base64");
}
function _n$2(e3) {
  return JSON.parse(Buffer.from(e3, "base64").toString("utf-8"));
}
function Y$1(e3) {
  if (!e3) throw new Error("No recap provided, value is undefined");
  if (!e3.att) throw new Error("No `att` property found");
  const t2 = Object.keys(e3.att);
  if (!(t2 != null && t2.length)) throw new Error("No resources found in `att` property");
  t2.forEach((n5) => {
    const r3 = e3.att[n5];
    if (Array.isArray(r3)) throw new Error(`Resource must be an object: ${n5}`);
    if (typeof r3 != "object") throw new Error(`Resource must be an object: ${n5}`);
    if (!Object.keys(r3).length) throw new Error(`Resource object is empty: ${n5}`);
    Object.keys(r3).forEach((o3) => {
      const s2 = r3[o3];
      if (!Array.isArray(s2)) throw new Error(`Ability limits ${o3} must be an array of objects, found: ${s2}`);
      if (!s2.length) throw new Error(`Value of ${o3} is empty array, must be an array with objects`);
      s2.forEach((i4) => {
        if (typeof i4 != "object") throw new Error(`Ability limits (${o3}) must be an array of objects, found: ${i4}`);
      });
    });
  });
}
function Tn$2(e3, t2, n5, r3 = {}) {
  return n5 == null ? void 0 : n5.sort((o3, s2) => o3.localeCompare(s2)), { att: { [e3]: ft$2(t2, n5, r3) } };
}
function $n$2(e3, t2, n5) {
  var r3;
  e3.att[t2] = at$1({}, n5);
  const o3 = (r3 = Object.keys(e3.att)) == null ? void 0 : r3.sort((i4, c2) => i4.localeCompare(c2)), s2 = { att: {} };
  return o3.reduce((i4, c2) => (i4.att[c2] = e3.att[c2], i4), s2);
}
function ft$2(e3, t2, n5 = {}) {
  t2 = t2 == null ? void 0 : t2.sort((o3, s2) => o3.localeCompare(s2));
  const r3 = t2.map((o3) => ({ [`${e3}/${o3}`]: [n5] }));
  return Object.assign({}, ...r3);
}
function De$2(e3) {
  return Y$1(e3), `urn:recap:${Un$2(e3).replace(/=/g, "")}`;
}
function oe$1(e3) {
  const t2 = _n$2(e3.replace("urn:recap:", ""));
  return Y$1(t2), t2;
}
function ts$1(e3, t2, n5) {
  const r3 = Tn$2(e3, t2, n5);
  return De$2(r3);
}
function lt$1(e3) {
  return e3 && e3.includes("urn:recap:");
}
function ns$1(e3, t2) {
  const n5 = oe$1(e3), r3 = oe$1(t2), o3 = Rn$2(n5, r3);
  return De$2(o3);
}
function Rn$2(e3, t2) {
  Y$1(e3), Y$1(t2);
  const n5 = Object.keys(e3.att).concat(Object.keys(t2.att)).sort((o3, s2) => o3.localeCompare(s2)), r3 = { att: {} };
  return n5.forEach((o3) => {
    var s2, i4;
    Object.keys(((s2 = e3.att) == null ? void 0 : s2[o3]) || {}).concat(Object.keys(((i4 = t2.att) == null ? void 0 : i4[o3]) || {})).sort((c2, u2) => c2.localeCompare(u2)).forEach((c2) => {
      var u2, a2;
      r3.att[o3] = vn$2(at$1({}, r3.att[o3]), { [c2]: ((u2 = e3.att[o3]) == null ? void 0 : u2[c2]) || ((a2 = t2.att[o3]) == null ? void 0 : a2[c2]) });
    });
  }), r3;
}
function dt$2(e3 = "", t2) {
  Y$1(t2);
  const n5 = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (e3.includes(n5)) return e3;
  const r3 = [];
  let o3 = 0;
  Object.keys(t2.att).forEach((c2) => {
    const u2 = Object.keys(t2.att[c2]).map((f6) => ({ ability: f6.split("/")[0], action: f6.split("/")[1] }));
    u2.sort((f6, d4) => f6.action.localeCompare(d4.action));
    const a2 = {};
    u2.forEach((f6) => {
      a2[f6.ability] || (a2[f6.ability] = []), a2[f6.ability].push(f6.action);
    });
    const l2 = Object.keys(a2).map((f6) => (o3++, `(${o3}) '${f6}': '${a2[f6].join("', '")}' for '${c2}'.`));
    r3.push(l2.join(", ").replace(".,", "."));
  });
  const s2 = r3.join(" "), i4 = `${n5}${s2}`;
  return `${e3 ? e3 + " " : ""}${i4}`;
}
function rs$1(e3) {
  var t2;
  const n5 = oe$1(e3);
  Y$1(n5);
  const r3 = (t2 = n5.att) == null ? void 0 : t2.eip155;
  return r3 ? Object.keys(r3).map((o3) => o3.split("/")[1]) : [];
}
function os$1(e3) {
  const t2 = oe$1(e3);
  Y$1(t2);
  const n5 = [];
  return Object.values(t2.att).forEach((r3) => {
    Object.values(r3).forEach((o3) => {
      var s2;
      (s2 = o3 == null ? void 0 : o3[0]) != null && s2.chains && n5.push(o3[0].chains);
    });
  }), [...new Set(n5.flat())];
}
function Pn$2(e3, t2) {
  if (!t2) return e3;
  const n5 = oe$1(t2);
  return Y$1(n5), dt$2(e3, n5);
}
function Me$3(e3) {
  if (!e3) return;
  const t2 = e3 == null ? void 0 : e3[e3.length - 1];
  return lt$1(t2) ? t2 : void 0;
}
function ht$2(e3) {
  if (!Number.isSafeInteger(e3) || e3 < 0) throw new Error("positive integer expected, got " + e3);
}
function Ln$2(e3) {
  return e3 instanceof Uint8Array || ArrayBuffer.isView(e3) && e3.constructor.name === "Uint8Array";
}
function F$2(e3, ...t2) {
  if (!Ln$2(e3)) throw new Error("Uint8Array expected");
  if (t2.length > 0 && !t2.includes(e3.length)) throw new Error("Uint8Array expected of length " + t2 + ", got length=" + e3.length);
}
function Bn$2(e3, t2 = true) {
  if (e3.destroyed) throw new Error("Hash instance has been destroyed");
  if (t2 && e3.finished) throw new Error("Hash#digest() has already been called");
}
function ss$1(e3, t2) {
  F$2(e3);
  const n5 = t2.outputLen;
  if (e3.length < n5) throw new Error("digestInto() expects output buffer of length at least " + n5);
}
function jn$2(e3) {
  if (typeof e3 != "boolean") throw new Error(`boolean expected, not ${e3}`);
}
const se$2 = (e3) => new Uint32Array(e3.buffer, e3.byteOffset, Math.floor(e3.byteLength / 4)), is$1 = (e3) => new DataView(e3.buffer, e3.byteOffset, e3.byteLength), cs$1 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!cs$1) throw new Error("Non little-endian hardware is not supported");
function as$1(e3) {
  if (typeof e3 != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(e3));
}
function pt$2(e3) {
  if (typeof e3 == "string") e3 = as$1(e3);
  else if (Ln$2(e3)) e3 = gt(e3);
  else throw new Error("Uint8Array expected, got " + typeof e3);
  return e3;
}
function us$1(e3, t2) {
  if (t2 == null || typeof t2 != "object") throw new Error("options must be defined");
  return Object.assign(e3, t2);
}
function fs$2(e3, t2) {
  if (e3.length !== t2.length) return false;
  let n5 = 0;
  for (let r3 = 0; r3 < e3.length; r3++) n5 |= e3[r3] ^ t2[r3];
  return n5 === 0;
}
const ls$1 = (e3, t2) => {
  function n5(r3, ...o3) {
    if (F$2(r3), e3.nonceLength !== void 0) {
      const l2 = o3[0];
      if (!l2) throw new Error("nonce / iv required");
      e3.varSizeNonce ? F$2(l2) : F$2(l2, e3.nonceLength);
    }
    const s2 = e3.tagLength;
    s2 && o3[1] !== void 0 && F$2(o3[1]);
    const i4 = t2(r3, ...o3), c2 = (l2, f6) => {
      if (f6 !== void 0) {
        if (l2 !== 2) throw new Error("cipher output not supported");
        F$2(f6);
      }
    };
    let u2 = false;
    return { encrypt(l2, f6) {
      if (u2) throw new Error("cannot encrypt() twice with same key + nonce");
      return u2 = true, F$2(l2), c2(i4.encrypt.length, f6), i4.encrypt(l2, f6);
    }, decrypt(l2, f6) {
      if (F$2(l2), s2 && l2.length < s2) throw new Error("invalid ciphertext length: smaller than tagLength=" + s2);
      return c2(i4.decrypt.length, f6), i4.decrypt(l2, f6);
    } };
  }
  return Object.assign(n5, e3), n5;
};
function Cn$2(e3, t2, n5 = true) {
  if (t2 === void 0) return new Uint8Array(e3);
  if (t2.length !== e3) throw new Error("invalid output length, expected " + e3 + ", got: " + t2.length);
  if (n5 && !ds$1(t2)) throw new Error("invalid output, must be aligned");
  return t2;
}
function kn$2(e3, t2, n5, r3) {
  if (typeof e3.setBigUint64 == "function") return e3.setBigUint64(t2, n5, r3);
  const o3 = BigInt(32), s2 = BigInt(4294967295), i4 = Number(n5 >> o3 & s2), c2 = Number(n5 & s2), u2 = 4, a2 = 0;
  e3.setUint32(t2 + u2, i4, r3), e3.setUint32(t2 + a2, c2, r3);
}
function ds$1(e3) {
  return e3.byteOffset % 4 === 0;
}
function gt(e3) {
  return Uint8Array.from(e3);
}
function Ee$2(...e3) {
  for (let t2 = 0; t2 < e3.length; t2++) e3[t2].fill(0);
}
const Dn$2 = (e3) => Uint8Array.from(e3.split("").map((t2) => t2.charCodeAt(0))), hs$1 = Dn$2("expand 16-byte k"), ps$1 = Dn$2("expand 32-byte k"), gs$1 = se$2(hs$1), ys$1 = se$2(ps$1);
function x$2(e3, t2) {
  return e3 << t2 | e3 >>> 32 - t2;
}
function yt$1(e3) {
  return e3.byteOffset % 4 === 0;
}
const Ve$2 = 64, ms$1 = 16, Mn$2 = 2 ** 32 - 1, Vn$2 = new Uint32Array();
function bs$2(e3, t2, n5, r3, o3, s2, i4, c2) {
  const u2 = o3.length, a2 = new Uint8Array(Ve$2), l2 = se$2(a2), f6 = yt$1(o3) && yt$1(s2), d4 = f6 ? se$2(o3) : Vn$2, g2 = f6 ? se$2(s2) : Vn$2;
  for (let y4 = 0; y4 < u2; i4++) {
    if (e3(t2, n5, r3, l2, i4, c2), i4 >= Mn$2) throw new Error("arx: counter overflow");
    const h5 = Math.min(Ve$2, u2 - y4);
    if (f6 && h5 === Ve$2) {
      const m4 = y4 / 4;
      if (y4 % 4 !== 0) throw new Error("arx: invalid block position");
      for (let B3 = 0, b2; B3 < ms$1; B3++) b2 = m4 + B3, g2[b2] = d4[b2] ^ l2[B3];
      y4 += Ve$2;
      continue;
    }
    for (let m4 = 0, B3; m4 < h5; m4++) B3 = y4 + m4, s2[B3] = o3[B3] ^ a2[m4];
    y4 += h5;
  }
}
function ws$1(e3, t2) {
  const { allowShortKeys: n5, extendNonceFn: r3, counterLength: o3, counterRight: s2, rounds: i4 } = us$1({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, t2);
  if (typeof e3 != "function") throw new Error("core must be a function");
  return ht$2(o3), ht$2(i4), jn$2(s2), jn$2(n5), (c2, u2, a2, l2, f6 = 0) => {
    F$2(c2), F$2(u2), F$2(a2);
    const d4 = a2.length;
    if (l2 === void 0 && (l2 = new Uint8Array(d4)), F$2(l2), ht$2(f6), f6 < 0 || f6 >= Mn$2) throw new Error("arx: counter overflow");
    if (l2.length < d4) throw new Error(`arx: output (${l2.length}) is shorter than data (${d4})`);
    const g2 = [];
    let y4 = c2.length, h5, m4;
    if (y4 === 32) g2.push(h5 = gt(c2)), m4 = ys$1;
    else if (y4 === 16 && n5) h5 = new Uint8Array(32), h5.set(c2), h5.set(c2, 16), m4 = gs$1, g2.push(h5);
    else throw new Error(`arx: invalid 32-byte key, got length=${y4}`);
    yt$1(u2) || g2.push(u2 = gt(u2));
    const B3 = se$2(h5);
    if (r3) {
      if (u2.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
      r3(m4, B3, se$2(u2.subarray(0, 16)), B3), u2 = u2.subarray(16);
    }
    const b2 = 16 - o3;
    if (b2 !== u2.length) throw new Error(`arx: nonce must be ${b2} or 16 bytes`);
    if (b2 !== 12) {
      const I4 = new Uint8Array(12);
      I4.set(u2, s2 ? 0 : 12 - u2.length), u2 = I4, g2.push(u2);
    }
    const _3 = se$2(u2);
    return bs$2(e3, m4, B3, _3, a2, l2, f6, i4), Ee$2(...g2), l2;
  };
}
const M$2 = (e3, t2) => e3[t2++] & 255 | (e3[t2++] & 255) << 8;
let Es$1 = class Es3 {
  constructor(t2) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, t2 = pt$2(t2), F$2(t2, 32);
    const n5 = M$2(t2, 0), r3 = M$2(t2, 2), o3 = M$2(t2, 4), s2 = M$2(t2, 6), i4 = M$2(t2, 8), c2 = M$2(t2, 10), u2 = M$2(t2, 12), a2 = M$2(t2, 14);
    this.r[0] = n5 & 8191, this.r[1] = (n5 >>> 13 | r3 << 3) & 8191, this.r[2] = (r3 >>> 10 | o3 << 6) & 7939, this.r[3] = (o3 >>> 7 | s2 << 9) & 8191, this.r[4] = (s2 >>> 4 | i4 << 12) & 255, this.r[5] = i4 >>> 1 & 8190, this.r[6] = (i4 >>> 14 | c2 << 2) & 8191, this.r[7] = (c2 >>> 11 | u2 << 5) & 8065, this.r[8] = (u2 >>> 8 | a2 << 8) & 8191, this.r[9] = a2 >>> 5 & 127;
    for (let l2 = 0; l2 < 8; l2++) this.pad[l2] = M$2(t2, 16 + 2 * l2);
  }
  process(t2, n5, r3 = false) {
    const o3 = r3 ? 0 : 2048, { h: s2, r: i4 } = this, c2 = i4[0], u2 = i4[1], a2 = i4[2], l2 = i4[3], f6 = i4[4], d4 = i4[5], g2 = i4[6], y4 = i4[7], h5 = i4[8], m4 = i4[9], B3 = M$2(t2, n5 + 0), b2 = M$2(t2, n5 + 2), _3 = M$2(t2, n5 + 4), I4 = M$2(t2, n5 + 6), k3 = M$2(t2, n5 + 8), E2 = M$2(t2, n5 + 10), L4 = M$2(t2, n5 + 12), j2 = M$2(t2, n5 + 14);
    let v2 = s2[0] + (B3 & 8191), O4 = s2[1] + ((B3 >>> 13 | b2 << 3) & 8191), w2 = s2[2] + ((b2 >>> 10 | _3 << 6) & 8191), R5 = s2[3] + ((_3 >>> 7 | I4 << 9) & 8191), A2 = s2[4] + ((I4 >>> 4 | k3 << 12) & 8191), T2 = s2[5] + (k3 >>> 1 & 8191), N3 = s2[6] + ((k3 >>> 14 | E2 << 2) & 8191), S4 = s2[7] + ((E2 >>> 11 | L4 << 5) & 8191), U = s2[8] + ((L4 >>> 8 | j2 << 8) & 8191), $2 = s2[9] + (j2 >>> 5 | o3), p2 = 0, C2 = p2 + v2 * c2 + O4 * (5 * m4) + w2 * (5 * h5) + R5 * (5 * y4) + A2 * (5 * g2);
    p2 = C2 >>> 13, C2 &= 8191, C2 += T2 * (5 * d4) + N3 * (5 * f6) + S4 * (5 * l2) + U * (5 * a2) + $2 * (5 * u2), p2 += C2 >>> 13, C2 &= 8191;
    let D2 = p2 + v2 * u2 + O4 * c2 + w2 * (5 * m4) + R5 * (5 * h5) + A2 * (5 * y4);
    p2 = D2 >>> 13, D2 &= 8191, D2 += T2 * (5 * g2) + N3 * (5 * d4) + S4 * (5 * f6) + U * (5 * l2) + $2 * (5 * a2), p2 += D2 >>> 13, D2 &= 8191;
    let P3 = p2 + v2 * a2 + O4 * u2 + w2 * c2 + R5 * (5 * m4) + A2 * (5 * h5);
    p2 = P3 >>> 13, P3 &= 8191, P3 += T2 * (5 * y4) + N3 * (5 * g2) + S4 * (5 * d4) + U * (5 * f6) + $2 * (5 * l2), p2 += P3 >>> 13, P3 &= 8191;
    let G2 = p2 + v2 * l2 + O4 * a2 + w2 * u2 + R5 * c2 + A2 * (5 * m4);
    p2 = G2 >>> 13, G2 &= 8191, G2 += T2 * (5 * h5) + N3 * (5 * y4) + S4 * (5 * g2) + U * (5 * d4) + $2 * (5 * f6), p2 += G2 >>> 13, G2 &= 8191;
    let X2 = p2 + v2 * f6 + O4 * l2 + w2 * a2 + R5 * u2 + A2 * c2;
    p2 = X2 >>> 13, X2 &= 8191, X2 += T2 * (5 * m4) + N3 * (5 * h5) + S4 * (5 * y4) + U * (5 * g2) + $2 * (5 * d4), p2 += X2 >>> 13, X2 &= 8191;
    let Z3 = p2 + v2 * d4 + O4 * f6 + w2 * l2 + R5 * a2 + A2 * u2;
    p2 = Z3 >>> 13, Z3 &= 8191, Z3 += T2 * c2 + N3 * (5 * m4) + S4 * (5 * h5) + U * (5 * y4) + $2 * (5 * g2), p2 += Z3 >>> 13, Z3 &= 8191;
    let he2 = p2 + v2 * g2 + O4 * d4 + w2 * f6 + R5 * l2 + A2 * a2;
    p2 = he2 >>> 13, he2 &= 8191, he2 += T2 * u2 + N3 * c2 + S4 * (5 * m4) + U * (5 * h5) + $2 * (5 * y4), p2 += he2 >>> 13, he2 &= 8191;
    let pe2 = p2 + v2 * y4 + O4 * g2 + w2 * d4 + R5 * f6 + A2 * l2;
    p2 = pe2 >>> 13, pe2 &= 8191, pe2 += T2 * a2 + N3 * u2 + S4 * c2 + U * (5 * m4) + $2 * (5 * h5), p2 += pe2 >>> 13, pe2 &= 8191;
    let ge2 = p2 + v2 * h5 + O4 * y4 + w2 * g2 + R5 * d4 + A2 * f6;
    p2 = ge2 >>> 13, ge2 &= 8191, ge2 += T2 * l2 + N3 * a2 + S4 * u2 + U * c2 + $2 * (5 * m4), p2 += ge2 >>> 13, ge2 &= 8191;
    let ye2 = p2 + v2 * m4 + O4 * h5 + w2 * y4 + R5 * g2 + A2 * d4;
    p2 = ye2 >>> 13, ye2 &= 8191, ye2 += T2 * f6 + N3 * l2 + S4 * a2 + U * u2 + $2 * c2, p2 += ye2 >>> 13, ye2 &= 8191, p2 = (p2 << 2) + p2 | 0, p2 = p2 + C2 | 0, C2 = p2 & 8191, p2 = p2 >>> 13, D2 += p2, s2[0] = C2, s2[1] = D2, s2[2] = P3, s2[3] = G2, s2[4] = X2, s2[5] = Z3, s2[6] = he2, s2[7] = pe2, s2[8] = ge2, s2[9] = ye2;
  }
  finalize() {
    const { h: t2, pad: n5 } = this, r3 = new Uint16Array(10);
    let o3 = t2[1] >>> 13;
    t2[1] &= 8191;
    for (let c2 = 2; c2 < 10; c2++) t2[c2] += o3, o3 = t2[c2] >>> 13, t2[c2] &= 8191;
    t2[0] += o3 * 5, o3 = t2[0] >>> 13, t2[0] &= 8191, t2[1] += o3, o3 = t2[1] >>> 13, t2[1] &= 8191, t2[2] += o3, r3[0] = t2[0] + 5, o3 = r3[0] >>> 13, r3[0] &= 8191;
    for (let c2 = 1; c2 < 10; c2++) r3[c2] = t2[c2] + o3, o3 = r3[c2] >>> 13, r3[c2] &= 8191;
    r3[9] -= 8192;
    let s2 = (o3 ^ 1) - 1;
    for (let c2 = 0; c2 < 10; c2++) r3[c2] &= s2;
    s2 = ~s2;
    for (let c2 = 0; c2 < 10; c2++) t2[c2] = t2[c2] & s2 | r3[c2];
    t2[0] = (t2[0] | t2[1] << 13) & 65535, t2[1] = (t2[1] >>> 3 | t2[2] << 10) & 65535, t2[2] = (t2[2] >>> 6 | t2[3] << 7) & 65535, t2[3] = (t2[3] >>> 9 | t2[4] << 4) & 65535, t2[4] = (t2[4] >>> 12 | t2[5] << 1 | t2[6] << 14) & 65535, t2[5] = (t2[6] >>> 2 | t2[7] << 11) & 65535, t2[6] = (t2[7] >>> 5 | t2[8] << 8) & 65535, t2[7] = (t2[8] >>> 8 | t2[9] << 5) & 65535;
    let i4 = t2[0] + n5[0];
    t2[0] = i4 & 65535;
    for (let c2 = 1; c2 < 8; c2++) i4 = (t2[c2] + n5[c2] | 0) + (i4 >>> 16) | 0, t2[c2] = i4 & 65535;
    Ee$2(r3);
  }
  update(t2) {
    Bn$2(this);
    const { buffer: n5, blockLen: r3 } = this;
    t2 = pt$2(t2);
    const o3 = t2.length;
    for (let s2 = 0; s2 < o3; ) {
      const i4 = Math.min(r3 - this.pos, o3 - s2);
      if (i4 === r3) {
        for (; r3 <= o3 - s2; s2 += r3) this.process(t2, s2);
        continue;
      }
      n5.set(t2.subarray(s2, s2 + i4), this.pos), this.pos += i4, s2 += i4, this.pos === r3 && (this.process(n5, 0, false), this.pos = 0);
    }
    return this;
  }
  destroy() {
    Ee$2(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(t2) {
    Bn$2(this), ss$1(t2, this), this.finished = true;
    const { buffer: n5, h: r3 } = this;
    let { pos: o3 } = this;
    if (o3) {
      for (n5[o3++] = 1; o3 < 16; o3++) n5[o3] = 0;
      this.process(n5, 0, true);
    }
    this.finalize();
    let s2 = 0;
    for (let i4 = 0; i4 < 8; i4++) t2[s2++] = r3[i4] >>> 0, t2[s2++] = r3[i4] >>> 8;
    return t2;
  }
  digest() {
    const { buffer: t2, outputLen: n5 } = this;
    this.digestInto(t2);
    const r3 = t2.slice(0, n5);
    return this.destroy(), r3;
  }
};
function vs$2(e3) {
  const t2 = (r3, o3) => e3(o3).update(pt$2(r3)).digest(), n5 = e3(new Uint8Array(32));
  return t2.outputLen = n5.outputLen, t2.blockLen = n5.blockLen, t2.create = (r3) => e3(r3), t2;
}
const xs$2 = vs$2((e3) => new Es$1(e3));
function Os$2(e3, t2, n5, r3, o3, s2 = 20) {
  let i4 = e3[0], c2 = e3[1], u2 = e3[2], a2 = e3[3], l2 = t2[0], f6 = t2[1], d4 = t2[2], g2 = t2[3], y4 = t2[4], h5 = t2[5], m4 = t2[6], B3 = t2[7], b2 = o3, _3 = n5[0], I4 = n5[1], k3 = n5[2], E2 = i4, L4 = c2, j2 = u2, v2 = a2, O4 = l2, w2 = f6, R5 = d4, A2 = g2, T2 = y4, N3 = h5, S4 = m4, U = B3, $2 = b2, p2 = _3, C2 = I4, D2 = k3;
  for (let G2 = 0; G2 < s2; G2 += 2) E2 = E2 + O4 | 0, $2 = x$2($2 ^ E2, 16), T2 = T2 + $2 | 0, O4 = x$2(O4 ^ T2, 12), E2 = E2 + O4 | 0, $2 = x$2($2 ^ E2, 8), T2 = T2 + $2 | 0, O4 = x$2(O4 ^ T2, 7), L4 = L4 + w2 | 0, p2 = x$2(p2 ^ L4, 16), N3 = N3 + p2 | 0, w2 = x$2(w2 ^ N3, 12), L4 = L4 + w2 | 0, p2 = x$2(p2 ^ L4, 8), N3 = N3 + p2 | 0, w2 = x$2(w2 ^ N3, 7), j2 = j2 + R5 | 0, C2 = x$2(C2 ^ j2, 16), S4 = S4 + C2 | 0, R5 = x$2(R5 ^ S4, 12), j2 = j2 + R5 | 0, C2 = x$2(C2 ^ j2, 8), S4 = S4 + C2 | 0, R5 = x$2(R5 ^ S4, 7), v2 = v2 + A2 | 0, D2 = x$2(D2 ^ v2, 16), U = U + D2 | 0, A2 = x$2(A2 ^ U, 12), v2 = v2 + A2 | 0, D2 = x$2(D2 ^ v2, 8), U = U + D2 | 0, A2 = x$2(A2 ^ U, 7), E2 = E2 + w2 | 0, D2 = x$2(D2 ^ E2, 16), S4 = S4 + D2 | 0, w2 = x$2(w2 ^ S4, 12), E2 = E2 + w2 | 0, D2 = x$2(D2 ^ E2, 8), S4 = S4 + D2 | 0, w2 = x$2(w2 ^ S4, 7), L4 = L4 + R5 | 0, $2 = x$2($2 ^ L4, 16), U = U + $2 | 0, R5 = x$2(R5 ^ U, 12), L4 = L4 + R5 | 0, $2 = x$2($2 ^ L4, 8), U = U + $2 | 0, R5 = x$2(R5 ^ U, 7), j2 = j2 + A2 | 0, p2 = x$2(p2 ^ j2, 16), T2 = T2 + p2 | 0, A2 = x$2(A2 ^ T2, 12), j2 = j2 + A2 | 0, p2 = x$2(p2 ^ j2, 8), T2 = T2 + p2 | 0, A2 = x$2(A2 ^ T2, 7), v2 = v2 + O4 | 0, C2 = x$2(C2 ^ v2, 16), N3 = N3 + C2 | 0, O4 = x$2(O4 ^ N3, 12), v2 = v2 + O4 | 0, C2 = x$2(C2 ^ v2, 8), N3 = N3 + C2 | 0, O4 = x$2(O4 ^ N3, 7);
  let P3 = 0;
  r3[P3++] = i4 + E2 | 0, r3[P3++] = c2 + L4 | 0, r3[P3++] = u2 + j2 | 0, r3[P3++] = a2 + v2 | 0, r3[P3++] = l2 + O4 | 0, r3[P3++] = f6 + w2 | 0, r3[P3++] = d4 + R5 | 0, r3[P3++] = g2 + A2 | 0, r3[P3++] = y4 + T2 | 0, r3[P3++] = h5 + N3 | 0, r3[P3++] = m4 + S4 | 0, r3[P3++] = B3 + U | 0, r3[P3++] = b2 + $2 | 0, r3[P3++] = _3 + p2 | 0, r3[P3++] = I4 + C2 | 0, r3[P3++] = k3 + D2 | 0;
}
const Is$2 = ws$1(Os$2, { counterRight: false, counterLength: 4, allowShortKeys: false }), As$2 = new Uint8Array(16), Hn$2 = (e3, t2) => {
  e3.update(t2);
  const n5 = t2.length % 16;
  n5 && e3.update(As$2.subarray(n5));
}, Ns$2 = new Uint8Array(32);
function Kn$2(e3, t2, n5, r3, o3) {
  const s2 = e3(t2, n5, Ns$2), i4 = xs$2.create(s2);
  o3 && Hn$2(i4, o3), Hn$2(i4, r3);
  const c2 = new Uint8Array(16), u2 = is$1(c2);
  kn$2(u2, 0, BigInt(o3 ? o3.length : 0), true), kn$2(u2, 8, BigInt(r3.length), true), i4.update(c2);
  const a2 = i4.digest();
  return Ee$2(s2, c2), a2;
}
const Ss$1 = (e3) => (t2, n5, r3) => ({ encrypt(s2, i4) {
  const c2 = s2.length;
  i4 = Cn$2(c2 + 16, i4, false), i4.set(s2);
  const u2 = i4.subarray(0, -16);
  e3(t2, n5, u2, u2, 1);
  const a2 = Kn$2(e3, t2, n5, u2, r3);
  return i4.set(a2, c2), Ee$2(a2), i4;
}, decrypt(s2, i4) {
  i4 = Cn$2(s2.length - 16, i4, false);
  const c2 = s2.subarray(0, -16), u2 = s2.subarray(-16), a2 = Kn$2(e3, t2, n5, c2, r3);
  if (!fs$2(u2, a2)) throw new Error("invalid tag");
  return i4.set(s2.subarray(0, -16)), e3(t2, n5, i4, i4, 1), Ee$2(a2), i4;
} }), Fn$2 = ls$1({ blockSize: 64, nonceLength: 12, tagLength: 16 }, Ss$1(Is$2));
let qn$2 = class qn3 extends it$1 {
  constructor(t2, n5) {
    super(), this.finished = false, this.destroyed = false, ot$1(t2);
    const r3 = we$2(n5);
    if (this.iHash = t2.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o3 = this.blockLen, s2 = new Uint8Array(o3);
    s2.set(r3.length > o3 ? t2.create().update(r3).digest() : r3);
    for (let i4 = 0; i4 < s2.length; i4++) s2[i4] ^= 54;
    this.iHash.update(s2), this.oHash = t2.create();
    for (let i4 = 0; i4 < s2.length; i4++) s2[i4] ^= 106;
    this.oHash.update(s2), s2.fill(0);
  }
  update(t2) {
    return me(this), this.iHash.update(t2), this;
  }
  digestInto(t2) {
    me(this), je$2(t2, this.outputLen), this.finished = true, this.iHash.digestInto(t2), this.oHash.update(t2), this.oHash.digestInto(t2), this.destroy();
  }
  digest() {
    const t2 = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t2), t2;
  }
  _cloneInto(t2) {
    t2 || (t2 = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n5, iHash: r3, finished: o3, destroyed: s2, blockLen: i4, outputLen: c2 } = this;
    return t2 = t2, t2.finished = o3, t2.destroyed = s2, t2.blockLen = i4, t2.outputLen = c2, t2.oHash = n5._cloneInto(t2.oHash), t2.iHash = r3._cloneInto(t2.iHash), t2;
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
const mt$1 = (e3, t2, n5) => new qn$2(e3, t2).update(n5).digest();
mt$1.create = (e3, t2) => new qn$2(e3, t2);
function Us$1(e3, t2, n5) {
  return ot$1(e3), n5 === void 0 && (n5 = new Uint8Array(e3.outputLen)), mt$1(e3, we$2(n5), we$2(t2));
}
const bt = new Uint8Array([0]), Gn$2 = new Uint8Array();
function _s$1(e3, t2, n5, r3 = 32) {
  if (ot$1(e3), Ne$2(r3), r3 > 255 * e3.outputLen) throw new Error("Length should be <= 255*HashLen");
  const o3 = Math.ceil(r3 / e3.outputLen);
  n5 === void 0 && (n5 = Gn$2);
  const s2 = new Uint8Array(o3 * e3.outputLen), i4 = mt$1.create(e3, t2), c2 = i4._cloneInto(), u2 = new Uint8Array(i4.outputLen);
  for (let a2 = 0; a2 < o3; a2++) bt[0] = a2 + 1, c2.update(a2 === 0 ? Gn$2 : u2).update(n5).update(bt).digestInto(u2), s2.set(u2, e3.outputLen * a2), i4._cloneInto(c2);
  return i4.destroy(), c2.destroy(), u2.fill(0), bt.fill(0), s2.slice(0, r3);
}
const Ts$2 = (e3, t2, n5, r3, o3) => _s$1(e3, Us$1(e3, t2, n5), r3, o3);
function $s$1(e3, t2, n5, r3) {
  if (typeof e3.setBigUint64 == "function") return e3.setBigUint64(t2, n5, r3);
  const o3 = BigInt(32), s2 = BigInt(4294967295), i4 = Number(n5 >> o3 & s2), c2 = Number(n5 & s2), u2 = r3 ? 4 : 0, a2 = r3 ? 0 : 4;
  e3.setUint32(t2 + u2, i4, r3), e3.setUint32(t2 + a2, c2, r3);
}
function Rs$2(e3, t2, n5) {
  return e3 & t2 ^ ~e3 & n5;
}
function Ps$2(e3, t2, n5) {
  return e3 & t2 ^ e3 & n5 ^ t2 & n5;
}
let Ls$2 = class Ls3 extends it$1 {
  constructor(t2, n5, r3, o3) {
    super(), this.blockLen = t2, this.outputLen = n5, this.padOffset = r3, this.isLE = o3, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(t2), this.view = st$1(this.buffer);
  }
  update(t2) {
    me(this);
    const { view: n5, buffer: r3, blockLen: o3 } = this;
    t2 = we$2(t2);
    const s2 = t2.length;
    for (let i4 = 0; i4 < s2; ) {
      const c2 = Math.min(o3 - this.pos, s2 - i4);
      if (c2 === o3) {
        const u2 = st$1(t2);
        for (; o3 <= s2 - i4; i4 += o3) this.process(u2, i4);
        continue;
      }
      r3.set(t2.subarray(i4, i4 + c2), this.pos), this.pos += c2, i4 += c2, this.pos === o3 && (this.process(n5, 0), this.pos = 0);
    }
    return this.length += t2.length, this.roundClean(), this;
  }
  digestInto(t2) {
    me(this), sn$2(t2, this), this.finished = true;
    const { buffer: n5, view: r3, blockLen: o3, isLE: s2 } = this;
    let { pos: i4 } = this;
    n5[i4++] = 128, this.buffer.subarray(i4).fill(0), this.padOffset > o3 - i4 && (this.process(r3, 0), i4 = 0);
    for (let f6 = i4; f6 < o3; f6++) n5[f6] = 0;
    $s$1(r3, o3 - 8, BigInt(this.length * 8), s2), this.process(r3, 0);
    const c2 = st$1(t2), u2 = this.outputLen;
    if (u2 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const a2 = u2 / 4, l2 = this.get();
    if (a2 > l2.length) throw new Error("_sha2: outputLen bigger than state");
    for (let f6 = 0; f6 < a2; f6++) c2.setUint32(4 * f6, l2[f6], s2);
  }
  digest() {
    const { buffer: t2, outputLen: n5 } = this;
    this.digestInto(t2);
    const r3 = t2.slice(0, n5);
    return this.destroy(), r3;
  }
  _cloneInto(t2) {
    t2 || (t2 = new this.constructor()), t2.set(...this.get());
    const { blockLen: n5, buffer: r3, length: o3, finished: s2, destroyed: i4, pos: c2 } = this;
    return t2.length = o3, t2.pos = c2, t2.finished = s2, t2.destroyed = i4, o3 % n5 && t2.buffer.set(r3), t2;
  }
};
const Bs$1 = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]), ie$2 = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]), ce$2 = new Uint32Array(64);
let js$2 = class js3 extends Ls$2 {
  constructor() {
    super(64, 32, 8, false), this.A = ie$2[0] | 0, this.B = ie$2[1] | 0, this.C = ie$2[2] | 0, this.D = ie$2[3] | 0, this.E = ie$2[4] | 0, this.F = ie$2[5] | 0, this.G = ie$2[6] | 0, this.H = ie$2[7] | 0;
  }
  get() {
    const { A: t2, B: n5, C: r3, D: o3, E: s2, F: i4, G: c2, H: u2 } = this;
    return [t2, n5, r3, o3, s2, i4, c2, u2];
  }
  set(t2, n5, r3, o3, s2, i4, c2, u2) {
    this.A = t2 | 0, this.B = n5 | 0, this.C = r3 | 0, this.D = o3 | 0, this.E = s2 | 0, this.F = i4 | 0, this.G = c2 | 0, this.H = u2 | 0;
  }
  process(t2, n5) {
    for (let f6 = 0; f6 < 16; f6++, n5 += 4) ce$2[f6] = t2.getUint32(n5, false);
    for (let f6 = 16; f6 < 64; f6++) {
      const d4 = ce$2[f6 - 15], g2 = ce$2[f6 - 2], y4 = J$2(d4, 7) ^ J$2(d4, 18) ^ d4 >>> 3, h5 = J$2(g2, 17) ^ J$2(g2, 19) ^ g2 >>> 10;
      ce$2[f6] = h5 + ce$2[f6 - 7] + y4 + ce$2[f6 - 16] | 0;
    }
    let { A: r3, B: o3, C: s2, D: i4, E: c2, F: u2, G: a2, H: l2 } = this;
    for (let f6 = 0; f6 < 64; f6++) {
      const d4 = J$2(c2, 6) ^ J$2(c2, 11) ^ J$2(c2, 25), g2 = l2 + d4 + Rs$2(c2, u2, a2) + Bs$1[f6] + ce$2[f6] | 0, h5 = (J$2(r3, 2) ^ J$2(r3, 13) ^ J$2(r3, 22)) + Ps$2(r3, o3, s2) | 0;
      l2 = a2, a2 = u2, u2 = c2, c2 = i4 + g2 | 0, i4 = s2, s2 = o3, o3 = r3, r3 = g2 + h5 | 0;
    }
    r3 = r3 + this.A | 0, o3 = o3 + this.B | 0, s2 = s2 + this.C | 0, i4 = i4 + this.D | 0, c2 = c2 + this.E | 0, u2 = u2 + this.F | 0, a2 = a2 + this.G | 0, l2 = l2 + this.H | 0, this.set(r3, o3, s2, i4, c2, u2, a2, l2);
  }
  roundClean() {
    ce$2.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
const He$2 = fn$2(() => new js$2());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Wn$2 = BigInt(0);
function wt$2(e3) {
  return e3 instanceof Uint8Array || ArrayBuffer.isView(e3) && e3.constructor.name === "Uint8Array";
}
function zn$2(e3) {
  if (!wt$2(e3)) throw new Error("Uint8Array expected");
}
const Cs$2 = Array.from({ length: 256 }, (e3, t2) => t2.toString(16).padStart(2, "0"));
function ks$1(e3) {
  zn$2(e3);
  let t2 = "";
  for (let n5 = 0; n5 < e3.length; n5++) t2 += Cs$2[e3[n5]];
  return t2;
}
function Ds$2(e3) {
  if (typeof e3 != "string") throw new Error("hex string expected, got " + typeof e3);
  return e3 === "" ? Wn$2 : BigInt("0x" + e3);
}
const ee = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Jn$2(e3) {
  if (e3 >= ee._0 && e3 <= ee._9) return e3 - ee._0;
  if (e3 >= ee.A && e3 <= ee.F) return e3 - (ee.A - 10);
  if (e3 >= ee.a && e3 <= ee.f) return e3 - (ee.a - 10);
}
function Yn$2(e3) {
  if (typeof e3 != "string") throw new Error("hex string expected, got " + typeof e3);
  const t2 = e3.length, n5 = t2 / 2;
  if (t2 % 2) throw new Error("hex string expected, got unpadded hex of length " + t2);
  const r3 = new Uint8Array(n5);
  for (let o3 = 0, s2 = 0; o3 < n5; o3++, s2 += 2) {
    const i4 = Jn$2(e3.charCodeAt(s2)), c2 = Jn$2(e3.charCodeAt(s2 + 1));
    if (i4 === void 0 || c2 === void 0) {
      const u2 = e3[s2] + e3[s2 + 1];
      throw new Error('hex string expected, got non-hex character "' + u2 + '" at index ' + s2);
    }
    r3[o3] = i4 * 16 + c2;
  }
  return r3;
}
function Xn$2(e3) {
  return zn$2(e3), Ds$2(ks$1(Uint8Array.from(e3).reverse()));
}
function Ms$1(e3, t2) {
  return Yn$2(e3.toString(16).padStart(t2 * 2, "0"));
}
function Vs$2(e3, t2) {
  return Ms$1(e3, t2).reverse();
}
function Zn$2(e3, t2, n5) {
  let r3;
  if (typeof t2 == "string") try {
    r3 = Yn$2(t2);
  } catch (s2) {
    throw new Error(e3 + " must be hex string or Uint8Array, cause: " + s2);
  }
  else if (wt$2(t2)) r3 = Uint8Array.from(t2);
  else throw new Error(e3 + " must be hex string or Uint8Array");
  const o3 = r3.length;
  if (typeof n5 == "number" && o3 !== n5) throw new Error(e3 + " of length " + n5 + " expected, got " + o3);
  return r3;
}
const Et$3 = (e3) => typeof e3 == "bigint" && Wn$2 <= e3;
function Hs$2(e3, t2, n5) {
  return Et$3(e3) && Et$3(t2) && Et$3(n5) && t2 <= e3 && e3 < n5;
}
function Qn$2(e3, t2, n5, r3) {
  if (!Hs$2(t2, n5, r3)) throw new Error("expected valid " + e3 + ": " + n5 + " <= n < " + r3 + ", got " + t2);
}
const Ks$1 = { bigint: (e3) => typeof e3 == "bigint", function: (e3) => typeof e3 == "function", boolean: (e3) => typeof e3 == "boolean", string: (e3) => typeof e3 == "string", stringOrUint8Array: (e3) => typeof e3 == "string" || wt$2(e3), isSafeInteger: (e3) => Number.isSafeInteger(e3), array: (e3) => Array.isArray(e3), field: (e3, t2) => t2.Fp.isValid(e3), hash: (e3) => typeof e3 == "function" && Number.isSafeInteger(e3.outputLen) };
function Fs$1(e3, t2, n5 = {}) {
  const r3 = (o3, s2, i4) => {
    const c2 = Ks$1[s2];
    if (typeof c2 != "function") throw new Error("invalid validator function");
    const u2 = e3[o3];
    if (!(i4 && u2 === void 0) && !c2(u2, e3)) throw new Error("param " + String(o3) + " is invalid. Expected " + s2 + ", got " + u2);
  };
  for (const [o3, s2] of Object.entries(t2)) r3(o3, s2, false);
  for (const [o3, s2] of Object.entries(n5)) r3(o3, s2, true);
  return e3;
}
const ve$1 = BigInt(0), Ke$3 = BigInt(1);
function er$2(e3, t2) {
  const n5 = e3 % t2;
  return n5 >= ve$1 ? n5 : t2 + n5;
}
function qs$3(e3, t2, n5) {
  if (t2 < ve$1) throw new Error("invalid exponent, negatives unsupported");
  if (n5 <= ve$1) throw new Error("invalid modulus");
  if (n5 === Ke$3) return ve$1;
  let r3 = Ke$3;
  for (; t2 > ve$1; ) t2 & Ke$3 && (r3 = r3 * e3 % n5), e3 = e3 * e3 % n5, t2 >>= Ke$3;
  return r3;
}
function z$3(e3, t2, n5) {
  let r3 = e3;
  for (; t2-- > ve$1; ) r3 *= r3, r3 %= n5;
  return r3;
}
BigInt(0), BigInt(1), BigInt(0), BigInt(1), BigInt(2), BigInt(8);
const xe$2 = BigInt(0), vt$2 = BigInt(1);
function Gs$2(e3) {
  return Fs$1(e3, { a: "bigint" }, { montgomeryBits: "isSafeInteger", nByteLength: "isSafeInteger", adjustScalarBytes: "function", domain: "function", powPminus2: "function", Gu: "bigint" }), Object.freeze({ ...e3 });
}
function Ws$2(e3) {
  const t2 = Gs$2(e3), { P: n5 } = t2, r3 = (b2) => er$2(b2, n5), o3 = t2.montgomeryBits, s2 = Math.ceil(o3 / 8), i4 = t2.nByteLength, c2 = t2.adjustScalarBytes || ((b2) => b2), u2 = t2.powPminus2 || ((b2) => qs$3(b2, n5 - BigInt(2), n5));
  function a2(b2, _3, I4) {
    const k3 = r3(b2 * (_3 - I4));
    return _3 = r3(_3 - k3), I4 = r3(I4 + k3), [_3, I4];
  }
  const l2 = (t2.a - BigInt(2)) / BigInt(4);
  function f6(b2, _3) {
    Qn$2("u", b2, xe$2, n5), Qn$2("scalar", _3, xe$2, n5);
    const I4 = _3, k3 = b2;
    let E2 = vt$2, L4 = xe$2, j2 = b2, v2 = vt$2, O4 = xe$2, w2;
    for (let A2 = BigInt(o3 - 1); A2 >= xe$2; A2--) {
      const T2 = I4 >> A2 & vt$2;
      O4 ^= T2, w2 = a2(O4, E2, j2), E2 = w2[0], j2 = w2[1], w2 = a2(O4, L4, v2), L4 = w2[0], v2 = w2[1], O4 = T2;
      const N3 = E2 + L4, S4 = r3(N3 * N3), U = E2 - L4, $2 = r3(U * U), p2 = S4 - $2, C2 = j2 + v2, D2 = j2 - v2, P3 = r3(D2 * N3), G2 = r3(C2 * U), X2 = P3 + G2, Z3 = P3 - G2;
      j2 = r3(X2 * X2), v2 = r3(k3 * r3(Z3 * Z3)), E2 = r3(S4 * $2), L4 = r3(p2 * (S4 + r3(l2 * p2)));
    }
    w2 = a2(O4, E2, j2), E2 = w2[0], j2 = w2[1], w2 = a2(O4, L4, v2), L4 = w2[0], v2 = w2[1];
    const R5 = u2(L4);
    return r3(E2 * R5);
  }
  function d4(b2) {
    return Vs$2(r3(b2), s2);
  }
  function g2(b2) {
    const _3 = Zn$2("u coordinate", b2, s2);
    return i4 === 32 && (_3[31] &= 127), Xn$2(_3);
  }
  function y4(b2) {
    const _3 = Zn$2("scalar", b2), I4 = _3.length;
    if (I4 !== s2 && I4 !== i4) {
      let k3 = "" + s2 + " or " + i4;
      throw new Error("invalid scalar, expected " + k3 + " bytes, got " + I4);
    }
    return Xn$2(c2(_3));
  }
  function h5(b2, _3) {
    const I4 = g2(_3), k3 = y4(b2), E2 = f6(I4, k3);
    if (E2 === xe$2) throw new Error("invalid private or public key received");
    return d4(E2);
  }
  const m4 = d4(t2.Gu);
  function B3(b2) {
    return h5(b2, m4);
  }
  return { scalarMult: h5, scalarMultBase: B3, getSharedSecret: (b2, _3) => h5(b2, _3), getPublicKey: (b2) => B3(b2), utils: { randomPrivateKey: () => t2.randomBytes(t2.nByteLength) }, GuBytes: m4 };
}
const xt$2 = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
BigInt(0);
const zs$1 = BigInt(1), tr$2 = BigInt(2), Js$2 = BigInt(3), Ys$2 = BigInt(5);
BigInt(8);
function Xs$2(e3) {
  const t2 = BigInt(10), n5 = BigInt(20), r3 = BigInt(40), o3 = BigInt(80), s2 = xt$2, c2 = e3 * e3 % s2 * e3 % s2, u2 = z$3(c2, tr$2, s2) * c2 % s2, a2 = z$3(u2, zs$1, s2) * e3 % s2, l2 = z$3(a2, Ys$2, s2) * a2 % s2, f6 = z$3(l2, t2, s2) * l2 % s2, d4 = z$3(f6, n5, s2) * f6 % s2, g2 = z$3(d4, r3, s2) * d4 % s2, y4 = z$3(g2, o3, s2) * g2 % s2, h5 = z$3(y4, o3, s2) * g2 % s2, m4 = z$3(h5, t2, s2) * l2 % s2;
  return { pow_p_5_8: z$3(m4, tr$2, s2) * e3 % s2, b2: c2 };
}
function Zs$2(e3) {
  return e3[0] &= 248, e3[31] &= 127, e3[31] |= 64, e3;
}
const Ot$2 = Ws$2({ P: xt$2, a: BigInt(486662), montgomeryBits: 255, nByteLength: 32, Gu: BigInt(9), powPminus2: (e3) => {
  const t2 = xt$2, { pow_p_5_8: n5, b2: r3 } = Xs$2(e3);
  return er$2(z$3(n5, Js$2, t2) * r3, t2);
}, adjustScalarBytes: Zs$2, randomBytes: Se$2 }), It$2 = "base10", V$3 = "base16", At$2 = "base64pad", Qs$2 = "base64url", Oe$2 = "utf8", Nt$2 = 0, Ie$1 = 1, _e$3 = 2, ei$2 = 0, nr$2 = 1, Te$1 = 12, St$3 = 32;
function ti$2() {
  const e3 = Ot$2.utils.randomPrivateKey(), t2 = Ot$2.getPublicKey(e3);
  return { privateKey: toString$1(e3, V$3), publicKey: toString$1(t2, V$3) };
}
function ni$2() {
  const e3 = Se$2(St$3);
  return toString$1(e3, V$3);
}
function ri$2(e3, t2) {
  const n5 = Ot$2.getSharedSecret(fromString(e3, V$3), fromString(t2, V$3)), r3 = Ts$2(He$2, n5, void 0, void 0, St$3);
  return toString$1(r3, V$3);
}
function oi$2(e3) {
  const t2 = He$2(fromString(e3, V$3));
  return toString$1(t2, V$3);
}
function si$2(e3) {
  const t2 = He$2(fromString(e3, Oe$2));
  return toString$1(t2, V$3);
}
function Ut$2(e3) {
  return fromString(`${e3}`, It$2);
}
function fe$1(e3) {
  return Number(toString$1(e3, It$2));
}
function ii$2(e3) {
  const t2 = Ut$2(typeof e3.type < "u" ? e3.type : Nt$2);
  if (fe$1(t2) === Ie$1 && typeof e3.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const n5 = typeof e3.senderPublicKey < "u" ? fromString(e3.senderPublicKey, V$3) : void 0, r3 = typeof e3.iv < "u" ? fromString(e3.iv, V$3) : Se$2(Te$1), o3 = fromString(e3.symKey, V$3), s2 = Fn$2(o3, r3).encrypt(fromString(e3.message, Oe$2));
  return _t$3({ type: t2, sealed: s2, iv: r3, senderPublicKey: n5, encoding: e3.encoding });
}
function ci$2(e3) {
  const t2 = fromString(e3.symKey, V$3), { sealed: n5, iv: r3 } = Fe$3(e3), o3 = Fn$2(t2, r3).decrypt(n5);
  if (o3 === null) throw new Error("Failed to decrypt");
  return toString$1(o3, Oe$2);
}
function ai$2(e3, t2) {
  const n5 = Ut$2(_e$3), r3 = Se$2(Te$1), o3 = fromString(e3, Oe$2);
  return _t$3({ type: n5, sealed: o3, iv: r3, encoding: t2 });
}
function ui$2(e3, t2) {
  const { sealed: n5 } = Fe$3({ encoded: e3, encoding: t2 });
  return toString$1(n5, Oe$2);
}
function _t$3(e3) {
  const { encoding: t2 = At$2 } = e3;
  if (fe$1(e3.type) === _e$3) return toString$1(concat$1([e3.type, e3.sealed]), t2);
  if (fe$1(e3.type) === Ie$1) {
    if (typeof e3.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return toString$1(concat$1([e3.type, e3.senderPublicKey, e3.iv, e3.sealed]), t2);
  }
  return toString$1(concat$1([e3.type, e3.iv, e3.sealed]), t2);
}
function Fe$3(e3) {
  const { encoded: t2, encoding: n5 = At$2 } = e3, r3 = fromString(t2, n5), o3 = r3.slice(ei$2, nr$2), s2 = nr$2;
  if (fe$1(o3) === Ie$1) {
    const a2 = s2 + St$3, l2 = a2 + Te$1, f6 = r3.slice(s2, a2), d4 = r3.slice(a2, l2), g2 = r3.slice(l2);
    return { type: o3, sealed: g2, iv: d4, senderPublicKey: f6 };
  }
  if (fe$1(o3) === _e$3) {
    const a2 = r3.slice(s2), l2 = Se$2(Te$1);
    return { type: o3, sealed: a2, iv: l2 };
  }
  const i4 = s2 + Te$1, c2 = r3.slice(s2, i4), u2 = r3.slice(i4);
  return { type: o3, sealed: u2, iv: c2 };
}
function fi$2(e3, t2) {
  const n5 = Fe$3({ encoded: e3, encoding: t2 == null ? void 0 : t2.encoding });
  return rr$2({ type: fe$1(n5.type), senderPublicKey: typeof n5.senderPublicKey < "u" ? toString$1(n5.senderPublicKey, V$3) : void 0, receiverPublicKey: t2 == null ? void 0 : t2.receiverPublicKey });
}
function rr$2(e3) {
  const t2 = (e3 == null ? void 0 : e3.type) || Nt$2;
  if (t2 === Ie$1) {
    if (typeof (e3 == null ? void 0 : e3.senderPublicKey) > "u") throw new Error("missing sender public key");
    if (typeof (e3 == null ? void 0 : e3.receiverPublicKey) > "u") throw new Error("missing receiver public key");
  }
  return { type: t2, senderPublicKey: e3 == null ? void 0 : e3.senderPublicKey, receiverPublicKey: e3 == null ? void 0 : e3.receiverPublicKey };
}
function li$2(e3) {
  return e3.type === Ie$1 && typeof e3.senderPublicKey == "string" && typeof e3.receiverPublicKey == "string";
}
function di$2(e3) {
  return e3.type === _e$3;
}
function or$2(e3) {
  return new ellipticExports.ec("p256").keyFromPublic({ x: Buffer.from(e3.x, "base64").toString("hex"), y: Buffer.from(e3.y, "base64").toString("hex") }, "hex");
}
function hi$2(e3) {
  let t2 = e3.replace(/-/g, "+").replace(/_/g, "/");
  const n5 = t2.length % 4;
  return n5 > 0 && (t2 += "=".repeat(4 - n5)), t2;
}
function pi$2(e3) {
  return Buffer.from(hi$2(e3), "base64");
}
function gi$2(e3, t2) {
  const [n5, r3, o3] = e3.split("."), s2 = pi$2(o3);
  if (s2.length !== 64) throw new Error("Invalid signature length");
  const i4 = s2.slice(0, 32).toString("hex"), c2 = s2.slice(32, 64).toString("hex"), u2 = `${n5}.${r3}`, a2 = He$2(u2), l2 = or$2(t2), f6 = toString$1(a2, V$3);
  if (!l2.verify(f6, { r: i4, s: c2 })) throw new Error("Invalid signature");
  return sn$7(e3).payload;
}
const sr$2 = "irn";
function yi$2(e3) {
  return (e3 == null ? void 0 : e3.relay) || { protocol: sr$2 };
}
function mi$2(e3) {
  const t2 = C$6[e3];
  if (typeof t2 > "u") throw new Error(`Relay Protocol not supported: ${e3}`);
  return t2;
}
function ir$2(e3, t2 = "-") {
  const n5 = {}, r3 = "relay" + t2;
  return Object.keys(e3).forEach((o3) => {
    if (o3.startsWith(r3)) {
      const s2 = o3.replace(r3, ""), i4 = e3[o3];
      n5[s2] = i4;
    }
  }), n5;
}
function bi$2(e3) {
  if (!e3.includes("wc:")) {
    const a2 = rt$1(e3);
    a2 != null && a2.includes("wc:") && (e3 = a2);
  }
  e3 = e3.includes("wc://") ? e3.replace("wc://", "") : e3, e3 = e3.includes("wc:") ? e3.replace("wc:", "") : e3;
  const t2 = e3.indexOf(":"), n5 = e3.indexOf("?") !== -1 ? e3.indexOf("?") : void 0, r3 = e3.substring(0, t2), o3 = e3.substring(t2 + 1, n5).split("@"), s2 = typeof n5 < "u" ? e3.substring(n5) : "", i4 = new URLSearchParams(s2), c2 = {};
  i4.forEach((a2, l2) => {
    c2[l2] = a2;
  });
  const u2 = typeof c2.methods == "string" ? c2.methods.split(",") : void 0;
  return { protocol: r3, topic: cr$2(o3[0]), version: parseInt(o3[1], 10), symKey: c2.symKey, relay: ir$2(c2), methods: u2, expiryTimestamp: c2.expiryTimestamp ? parseInt(c2.expiryTimestamp, 10) : void 0 };
}
function cr$2(e3) {
  return e3.startsWith("//") ? e3.substring(2) : e3;
}
function ar$2(e3, t2 = "-") {
  const n5 = "relay", r3 = {};
  return Object.keys(e3).forEach((o3) => {
    const s2 = o3, i4 = n5 + t2 + s2;
    e3[s2] && (r3[i4] = e3[s2]);
  }), r3;
}
function wi$2(e3) {
  const t2 = new URLSearchParams(), n5 = ar$2(e3.relay);
  Object.keys(n5).sort().forEach((o3) => {
    t2.set(o3, n5[o3]);
  }), t2.set("symKey", e3.symKey), e3.expiryTimestamp && t2.set("expiryTimestamp", e3.expiryTimestamp.toString()), e3.methods && t2.set("methods", e3.methods.join(","));
  const r3 = t2.toString();
  return `${e3.protocol}:${e3.topic}@${e3.version}?${r3}`;
}
function Ei$2(e3, t2, n5) {
  return `${e3}?wc_ev=${n5}&topic=${t2}`;
}
var vi$2 = Object.defineProperty, xi$2 = Object.defineProperties, Oi$2 = Object.getOwnPropertyDescriptors, ur$2 = Object.getOwnPropertySymbols, Ii$2 = Object.prototype.hasOwnProperty, Ai$2 = Object.prototype.propertyIsEnumerable, fr$2 = (e3, t2, n5) => t2 in e3 ? vi$2(e3, t2, { enumerable: true, configurable: true, writable: true, value: n5 }) : e3[t2] = n5, Ni$2 = (e3, t2) => {
  for (var n5 in t2 || (t2 = {})) Ii$2.call(t2, n5) && fr$2(e3, n5, t2[n5]);
  if (ur$2) for (var n5 of ur$2(t2)) Ai$2.call(t2, n5) && fr$2(e3, n5, t2[n5]);
  return e3;
}, Si$2 = (e3, t2) => xi$2(e3, Oi$2(t2));
function le$2(e3) {
  const t2 = [];
  return e3.forEach((n5) => {
    const [r3, o3] = n5.split(":");
    t2.push(`${r3}:${o3}`);
  }), t2;
}
function lr$2(e3) {
  const t2 = [];
  return Object.values(e3).forEach((n5) => {
    t2.push(...le$2(n5.accounts));
  }), t2;
}
function dr$2(e3, t2) {
  const n5 = [];
  return Object.values(e3).forEach((r3) => {
    le$2(r3.accounts).includes(t2) && n5.push(...r3.methods);
  }), n5;
}
function hr$2(e3, t2) {
  const n5 = [];
  return Object.values(e3).forEach((r3) => {
    le$2(r3.accounts).includes(t2) && n5.push(...r3.events);
  }), n5;
}
function Ui$1(e3, t2) {
  const n5 = Ir$2(e3, t2);
  if (n5) throw new Error(n5.message);
  const r3 = {};
  for (const [o3, s2] of Object.entries(e3)) r3[o3] = { methods: s2.methods, events: s2.events, chains: s2.accounts.map((i4) => `${i4.split(":")[0]}:${i4.split(":")[1]}`) };
  return r3;
}
function _i$2(e3) {
  const { proposal: { requiredNamespaces: t2, optionalNamespaces: n5 = {} }, supportedNamespaces: r3 } = e3, o3 = $t$1(t2), s2 = $t$1(n5), i4 = {};
  Object.keys(r3).forEach((a2) => {
    const l2 = r3[a2].chains, f6 = r3[a2].methods, d4 = r3[a2].events, g2 = r3[a2].accounts;
    l2.forEach((y4) => {
      if (!g2.some((h5) => h5.includes(y4))) throw new Error(`No accounts provided for chain ${y4} in namespace ${a2}`);
    }), i4[a2] = { chains: l2, methods: f6, events: d4, accounts: g2 };
  });
  const c2 = Nr$2(t2, i4, "approve()");
  if (c2) throw new Error(c2.message);
  const u2 = {};
  return !Object.keys(t2).length && !Object.keys(n5).length ? i4 : (Object.keys(o3).forEach((a2) => {
    const l2 = r3[a2].chains.filter((y4) => {
      var h5, m4;
      return (m4 = (h5 = o3[a2]) == null ? void 0 : h5.chains) == null ? void 0 : m4.includes(y4);
    }), f6 = r3[a2].methods.filter((y4) => {
      var h5, m4;
      return (m4 = (h5 = o3[a2]) == null ? void 0 : h5.methods) == null ? void 0 : m4.includes(y4);
    }), d4 = r3[a2].events.filter((y4) => {
      var h5, m4;
      return (m4 = (h5 = o3[a2]) == null ? void 0 : h5.events) == null ? void 0 : m4.includes(y4);
    }), g2 = l2.map((y4) => r3[a2].accounts.filter((h5) => h5.includes(`${y4}:`))).flat();
    u2[a2] = { chains: l2, methods: f6, events: d4, accounts: g2 };
  }), Object.keys(s2).forEach((a2) => {
    var l2, f6, d4, g2, y4, h5;
    if (!r3[a2]) return;
    const m4 = (f6 = (l2 = s2[a2]) == null ? void 0 : l2.chains) == null ? void 0 : f6.filter((I4) => r3[a2].chains.includes(I4)), B3 = r3[a2].methods.filter((I4) => {
      var k3, E2;
      return (E2 = (k3 = s2[a2]) == null ? void 0 : k3.methods) == null ? void 0 : E2.includes(I4);
    }), b2 = r3[a2].events.filter((I4) => {
      var k3, E2;
      return (E2 = (k3 = s2[a2]) == null ? void 0 : k3.events) == null ? void 0 : E2.includes(I4);
    }), _3 = m4 == null ? void 0 : m4.map((I4) => r3[a2].accounts.filter((k3) => k3.includes(`${I4}:`))).flat();
    u2[a2] = { chains: Q$1((d4 = u2[a2]) == null ? void 0 : d4.chains, m4), methods: Q$1((g2 = u2[a2]) == null ? void 0 : g2.methods, B3), events: Q$1((y4 = u2[a2]) == null ? void 0 : y4.events, b2), accounts: Q$1((h5 = u2[a2]) == null ? void 0 : h5.accounts, _3) };
  }), u2);
}
function Tt$2(e3) {
  return e3.includes(":");
}
function pr$2(e3) {
  return Tt$2(e3) ? e3.split(":")[0] : e3;
}
function $t$1(e3) {
  var t2, n5, r3;
  const o3 = {};
  if (!qe$2(e3)) return o3;
  for (const [s2, i4] of Object.entries(e3)) {
    const c2 = Tt$2(s2) ? [s2] : i4.chains, u2 = i4.methods || [], a2 = i4.events || [], l2 = pr$2(s2);
    o3[l2] = Si$2(Ni$2({}, o3[l2]), { chains: Q$1(c2, (t2 = o3[l2]) == null ? void 0 : t2.chains), methods: Q$1(u2, (n5 = o3[l2]) == null ? void 0 : n5.methods), events: Q$1(a2, (r3 = o3[l2]) == null ? void 0 : r3.events) });
  }
  return o3;
}
function gr$2(e3) {
  const t2 = {};
  return e3 == null ? void 0 : e3.forEach((n5) => {
    var r3;
    const [o3, s2] = n5.split(":");
    t2[o3] || (t2[o3] = { accounts: [], chains: [], events: [], methods: [] }), t2[o3].accounts.push(n5), (r3 = t2[o3].chains) == null || r3.push(`${o3}:${s2}`);
  }), t2;
}
function Ti$2(e3, t2) {
  t2 = t2.map((r3) => r3.replace("did:pkh:", ""));
  const n5 = gr$2(t2);
  for (const [r3, o3] of Object.entries(n5)) o3.methods ? o3.methods = Q$1(o3.methods, e3) : o3.methods = e3, o3.events = ["chainChanged", "accountsChanged"];
  return n5;
}
const yr$2 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, mr$2 = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function te$1(e3, t2) {
  const { message: n5, code: r3 } = mr$2[e3];
  return { message: t2 ? `${n5} ${t2}` : n5, code: r3 };
}
function de$2(e3, t2) {
  const { message: n5, code: r3 } = yr$2[e3];
  return { message: t2 ? `${n5} ${t2}` : n5, code: r3 };
}
function $e$3(e3, t2) {
  return Array.isArray(e3) ? typeof t2 < "u" && e3.length ? e3.every(t2) : true : false;
}
function qe$2(e3) {
  return Object.getPrototypeOf(e3) === Object.prototype && Object.keys(e3).length;
}
function ae$2(e3) {
  return typeof e3 > "u";
}
function q$2(e3, t2) {
  return t2 && ae$2(e3) ? true : typeof e3 == "string" && !!e3.trim().length;
}
function Ge$2(e3, t2) {
  return t2 && ae$2(e3) ? true : typeof e3 == "number" && !isNaN(e3);
}
function $i$2(e3, t2) {
  const { requiredNamespaces: n5 } = t2, r3 = Object.keys(e3.namespaces), o3 = Object.keys(n5);
  let s2 = true;
  return re$2(o3, r3) ? (r3.forEach((i4) => {
    const { accounts: c2, methods: u2, events: a2 } = e3.namespaces[i4], l2 = le$2(c2), f6 = n5[i4];
    (!re$2(Le$3(i4, f6), l2) || !re$2(f6.methods, u2) || !re$2(f6.events, a2)) && (s2 = false);
  }), s2) : false;
}
function Re$1(e3) {
  return q$2(e3, false) && e3.includes(":") ? e3.split(":").length === 2 : false;
}
function br$2(e3) {
  if (q$2(e3, false) && e3.includes(":")) {
    const t2 = e3.split(":");
    if (t2.length === 3) {
      const n5 = t2[0] + ":" + t2[1];
      return !!t2[2] && Re$1(n5);
    }
  }
  return false;
}
function Ri$2(e3) {
  function t2(n5) {
    try {
      return typeof new URL(n5) < "u";
    } catch {
      return false;
    }
  }
  try {
    if (q$2(e3, false)) {
      if (t2(e3)) return true;
      const n5 = rt$1(e3);
      return t2(n5);
    }
  } catch {
  }
  return false;
}
function Pi$2(e3) {
  var t2;
  return (t2 = e3 == null ? void 0 : e3.proposer) == null ? void 0 : t2.publicKey;
}
function Li$2(e3) {
  return e3 == null ? void 0 : e3.topic;
}
function Bi$1(e3, t2) {
  let n5 = null;
  return q$2(e3 == null ? void 0 : e3.publicKey, false) || (n5 = te$1("MISSING_OR_INVALID", `${t2} controller public key should be a string`)), n5;
}
function Rt$2(e3) {
  let t2 = true;
  return $e$3(e3) ? e3.length && (t2 = e3.every((n5) => q$2(n5, false))) : t2 = false, t2;
}
function wr$2(e3, t2, n5) {
  let r3 = null;
  return $e$3(t2) && t2.length ? t2.forEach((o3) => {
    r3 || Re$1(o3) || (r3 = de$2("UNSUPPORTED_CHAINS", `${n5}, chain ${o3} should be a string and conform to "namespace:chainId" format`));
  }) : Re$1(e3) || (r3 = de$2("UNSUPPORTED_CHAINS", `${n5}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r3;
}
function Er$2(e3, t2, n5) {
  let r3 = null;
  return Object.entries(e3).forEach(([o3, s2]) => {
    if (r3) return;
    const i4 = wr$2(o3, Le$3(o3, s2), `${t2} ${n5}`);
    i4 && (r3 = i4);
  }), r3;
}
function vr$2(e3, t2) {
  let n5 = null;
  return $e$3(e3) ? e3.forEach((r3) => {
    n5 || br$2(r3) || (n5 = de$2("UNSUPPORTED_ACCOUNTS", `${t2}, account ${r3} should be a string and conform to "namespace:chainId:address" format`));
  }) : n5 = de$2("UNSUPPORTED_ACCOUNTS", `${t2}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), n5;
}
function xr$2(e3, t2) {
  let n5 = null;
  return Object.values(e3).forEach((r3) => {
    if (n5) return;
    const o3 = vr$2(r3 == null ? void 0 : r3.accounts, `${t2} namespace`);
    o3 && (n5 = o3);
  }), n5;
}
function Or$2(e3, t2) {
  let n5 = null;
  return Rt$2(e3 == null ? void 0 : e3.methods) ? Rt$2(e3 == null ? void 0 : e3.events) || (n5 = de$2("UNSUPPORTED_EVENTS", `${t2}, events should be an array of strings or empty array for no events`)) : n5 = de$2("UNSUPPORTED_METHODS", `${t2}, methods should be an array of strings or empty array for no methods`), n5;
}
function Pt$1(e3, t2) {
  let n5 = null;
  return Object.values(e3).forEach((r3) => {
    if (n5) return;
    const o3 = Or$2(r3, `${t2}, namespace`);
    o3 && (n5 = o3);
  }), n5;
}
function ji$1(e3, t2, n5) {
  let r3 = null;
  if (e3 && qe$2(e3)) {
    const o3 = Pt$1(e3, t2);
    o3 && (r3 = o3);
    const s2 = Er$2(e3, t2, n5);
    s2 && (r3 = s2);
  } else r3 = te$1("MISSING_OR_INVALID", `${t2}, ${n5} should be an object with data`);
  return r3;
}
function Ir$2(e3, t2) {
  let n5 = null;
  if (e3 && qe$2(e3)) {
    const r3 = Pt$1(e3, t2);
    r3 && (n5 = r3);
    const o3 = xr$2(e3, t2);
    o3 && (n5 = o3);
  } else n5 = te$1("MISSING_OR_INVALID", `${t2}, namespaces should be an object with data`);
  return n5;
}
function Ar$2(e3) {
  return q$2(e3.protocol, true);
}
function Ci$2(e3, t2) {
  let n5 = false;
  return t2 && !e3 ? n5 = true : e3 && $e$3(e3) && e3.length && e3.forEach((r3) => {
    n5 = Ar$2(r3);
  }), n5;
}
function ki$1(e3) {
  return typeof e3 == "number";
}
function Di$2(e3) {
  return typeof e3 < "u" && typeof e3 !== null;
}
function Mi$1(e3) {
  return !(!e3 || typeof e3 != "object" || !e3.code || !Ge$2(e3.code, false) || !e3.message || !q$2(e3.message, false));
}
function Vi$1(e3) {
  return !(ae$2(e3) || !q$2(e3.method, false));
}
function Hi$1(e3) {
  return !(ae$2(e3) || ae$2(e3.result) && ae$2(e3.error) || !Ge$2(e3.id, false) || !q$2(e3.jsonrpc, false));
}
function Ki$1(e3) {
  return !(ae$2(e3) || !q$2(e3.name, false));
}
function Fi$1(e3, t2) {
  return !(!Re$1(t2) || !lr$2(e3).includes(t2));
}
function qi$1(e3, t2, n5) {
  return q$2(n5, false) ? dr$2(e3, t2).includes(n5) : false;
}
function Gi$1(e3, t2, n5) {
  return q$2(n5, false) ? hr$2(e3, t2).includes(n5) : false;
}
function Nr$2(e3, t2, n5) {
  let r3 = null;
  const o3 = Wi$1(e3), s2 = zi$2(t2), i4 = Object.keys(o3), c2 = Object.keys(s2), u2 = Sr$2(Object.keys(e3)), a2 = Sr$2(Object.keys(t2)), l2 = u2.filter((f6) => !a2.includes(f6));
  return l2.length && (r3 = te$1("NON_CONFORMING_NAMESPACES", `${n5} namespaces keys don't satisfy requiredNamespaces.
      Required: ${l2.toString()}
      Received: ${Object.keys(t2).toString()}`)), re$2(i4, c2) || (r3 = te$1("NON_CONFORMING_NAMESPACES", `${n5} namespaces chains don't satisfy required namespaces.
      Required: ${i4.toString()}
      Approved: ${c2.toString()}`)), Object.keys(t2).forEach((f6) => {
    if (!f6.includes(":") || r3) return;
    const d4 = le$2(t2[f6].accounts);
    d4.includes(f6) || (r3 = te$1("NON_CONFORMING_NAMESPACES", `${n5} namespaces accounts don't satisfy namespace accounts for ${f6}
        Required: ${f6}
        Approved: ${d4.toString()}`));
  }), i4.forEach((f6) => {
    r3 || (re$2(o3[f6].methods, s2[f6].methods) ? re$2(o3[f6].events, s2[f6].events) || (r3 = te$1("NON_CONFORMING_NAMESPACES", `${n5} namespaces events don't satisfy namespace events for ${f6}`)) : r3 = te$1("NON_CONFORMING_NAMESPACES", `${n5} namespaces methods don't satisfy namespace methods for ${f6}`));
  }), r3;
}
function Wi$1(e3) {
  const t2 = {};
  return Object.keys(e3).forEach((n5) => {
    var r3;
    n5.includes(":") ? t2[n5] = e3[n5] : (r3 = e3[n5].chains) == null || r3.forEach((o3) => {
      t2[o3] = { methods: e3[n5].methods, events: e3[n5].events };
    });
  }), t2;
}
function Sr$2(e3) {
  return [...new Set(e3.map((t2) => t2.includes(":") ? t2.split(":")[0] : t2))];
}
function zi$2(e3) {
  const t2 = {};
  return Object.keys(e3).forEach((n5) => {
    if (n5.includes(":")) t2[n5] = e3[n5];
    else {
      const r3 = le$2(e3[n5].accounts);
      r3 == null ? void 0 : r3.forEach((o3) => {
        t2[o3] = { accounts: e3[n5].accounts.filter((s2) => s2.includes(`${o3}:`)), methods: e3[n5].methods, events: e3[n5].events };
      });
    }
  }), t2;
}
function Ji$1(e3, t2) {
  return Ge$2(e3, false) && e3 <= t2.max && e3 >= t2.min;
}
function Yi$1() {
  const e3 = ue$2();
  return new Promise((t2) => {
    switch (e3) {
      case H$2.browser:
        t2(Ur$2());
        break;
      case H$2.reactNative:
        t2(_r$2());
        break;
      case H$2.node:
        t2(Tr$2());
        break;
      default:
        t2(true);
    }
  });
}
function Ur$2() {
  return Ae$2() && (navigator == null ? void 0 : navigator.onLine);
}
async function _r$2() {
  if (ne$2() && typeof global$1 < "u" && global$1 != null && global$1.NetInfo) {
    const e3 = await (global$1 == null ? void 0 : global$1.NetInfo.fetch());
    return e3 == null ? void 0 : e3.isConnected;
  }
  return true;
}
function Tr$2() {
  return true;
}
function Xi$1(e3) {
  switch (ue$2()) {
    case H$2.browser:
      $r$2(e3);
      break;
    case H$2.reactNative:
      Rr$2(e3);
      break;
    case H$2.node:
      break;
  }
}
function $r$2(e3) {
  !ne$2() && Ae$2() && (window.addEventListener("online", () => e3(true)), window.addEventListener("offline", () => e3(false)));
}
function Rr$2(e3) {
  ne$2() && typeof global$1 < "u" && global$1 != null && global$1.NetInfo && (global$1 == null ? void 0 : global$1.NetInfo.addEventListener((t2) => e3(t2 == null ? void 0 : t2.isConnected)));
}
const Lt$2 = {};
let Zi$1 = class Zi3 {
  static get(t2) {
    return Lt$2[t2];
  }
  static set(t2, n5) {
    Lt$2[t2] = n5;
  }
  static delete(t2) {
    delete Lt$2[t2];
  }
};
const index_es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BASE10: It$2,
  BASE16: V$3,
  BASE64: At$2,
  BASE64URL: Qs$2,
  COLON: qr$2,
  DEFAULT_DEPTH: Qe$1,
  EMPTY_SPACE: Be$2,
  ENV_MAP: H$2,
  INTERNAL_ERRORS: mr$2,
  MemoryStore: Zi$1,
  ONE_THOUSAND: Gr$2,
  REACT_NATIVE_PRODUCT: Ft$2,
  RELAYER_DEFAULT_PROTOCOL: sr$2,
  SDK_ERRORS: yr$2,
  SDK_TYPE: Gt$2,
  SLASH: qt$2,
  TYPE_0: Nt$2,
  TYPE_1: Ie$1,
  TYPE_2: _e$3,
  UTF8: Oe$2,
  addResourceToRecap: $n$2,
  appendToQueryString: Wt$2,
  assertType: eo$2,
  assignAbilityToActions: ft$2,
  base64Decode: _n$2,
  base64Encode: Un$2,
  buildApprovedNamespaces: _i$2,
  buildAuthObject: Xo$1,
  buildNamespacesFromAuth: Ti$2,
  buildRecapStatement: Pn$2,
  calcExpiry: ho$1,
  capitalize: io$2,
  capitalizeWord: Qt$2,
  createDelayedPromise: co$1,
  createEncodedRecap: ts$1,
  createExpiringPromise: ao$2,
  createRecap: Tn$2,
  decodeRecap: oe$1,
  decodeTypeByte: fe$1,
  decodeTypeTwoEnvelope: ui$2,
  decrypt: ci$2,
  deriveSymKey: ri$2,
  deserialize: Fe$3,
  encodeRecap: De$2,
  encodeTypeByte: Ut$2,
  encodeTypeTwoEnvelope: ai$2,
  encrypt: ii$2,
  engineEvent: go$1,
  enumify: so$2,
  formatAccountId: Mt$2,
  formatAccountWithChain: Mr$2,
  formatChainId: Dt$2,
  formatDeeplinkUrl: en$2,
  formatExpirerTarget: tt$1,
  formatIdTarget: fo$1,
  formatMessage: In$2,
  formatMessageContext: to$2,
  formatRelayParams: ar$2,
  formatRelayRpcUrl: Zr$2,
  formatStatementFromRecap: dt$2,
  formatTopicTarget: uo$1,
  formatUA: Yt$2,
  formatUri: wi$2,
  fromBase64: rt$1,
  generateKeyPair: ti$2,
  generateRandomBytes32: ni$2,
  getAccountsChains: le$2,
  getAccountsFromNamespaces: Hr$2,
  getAddressFromAccount: Vt$2,
  getAddressesFromAccounts: Vr$2,
  getAppId: Jr$2,
  getAppMetadata: Yr$2,
  getBrowserOnlineStatus: Ur$2,
  getChainFromAccount: Ht$2,
  getChainsFromAccounts: Kt$2,
  getChainsFromNamespace: Le$3,
  getChainsFromNamespaces: Kr$2,
  getChainsFromRecap: os$1,
  getChainsFromRequiredNamespaces: Fr$2,
  getCommonValuesInArrays: nt$1,
  getCryptoKeyFromKeyData: or$2,
  getDecodedRecapFromResources: An$2,
  getDeepLink: mo$1,
  getDidAddress: ut$2,
  getDidAddressSegments: ke$3,
  getDidChainId: xn$2,
  getEnvironment: ue$2,
  getHttpUrl: Qr$2,
  getInternalError: te$1,
  getJavascriptID: Jt$2,
  getJavascriptOS: zt$2,
  getLastItems: Zt$2,
  getLinkModeURL: Ei$2,
  getMethodsFromRecap: rs$1,
  getNamespacedDidChainId: On$2,
  getNamespacesChains: lr$2,
  getNamespacesEventsForChainId: hr$2,
  getNamespacesFromAccounts: gr$2,
  getNamespacesMethodsForChainId: dr$2,
  getNodeOnlineStatus: Tr$2,
  getReCapActions: Sn$2,
  getReactNativeOnlineStatus: _r$2,
  getRecapAbilitiesFromResource: es$1,
  getRecapFromResources: Me$3,
  getRecapResource: Nn$2,
  getRelayClientMetadata: Xr$2,
  getRelayProtocolApi: mi$2,
  getRelayProtocolName: yi$2,
  getRequiredNamespacesFromNamespaces: Ui$1,
  getSdkError: de$2,
  getSearchParamFromURL: bo$1,
  getUniqueValues: Ze$1,
  handleDeeplinkRedirect: yo$1,
  hasOverlap: re$2,
  hashEthereumMessage: ct$1,
  hashKey: oi$2,
  hashMessage: si$2,
  isAndroid: Wr$2,
  isBrowser: Ae$2,
  isCaipNamespace: Tt$2,
  isConformingNamespaces: Nr$2,
  isExpired: po$1,
  isIframe: rn$2,
  isIos: zr$2,
  isNode: et$1,
  isOnline: Yi$1,
  isProposalStruct: Pi$2,
  isReactNative: ne$2,
  isRecap: lt$1,
  isSessionCompatible: $i$2,
  isSessionStruct: Li$2,
  isTelegram: nn$2,
  isTestRun: Eo$1,
  isTypeOneEnvelope: li$2,
  isTypeTwoEnvelope: di$2,
  isUndefined: ae$2,
  isValidAccountId: br$2,
  isValidAccounts: vr$2,
  isValidActions: Or$2,
  isValidArray: $e$3,
  isValidChainId: Re$1,
  isValidChains: wr$2,
  isValidController: Bi$1,
  isValidEip1271Signature: bn$2,
  isValidEip191Signature: mn$2,
  isValidErrorReason: Mi$1,
  isValidEvent: Ki$1,
  isValidId: ki$1,
  isValidNamespaceAccounts: xr$2,
  isValidNamespaceActions: Pt$1,
  isValidNamespaceChains: Er$2,
  isValidNamespaceMethodsOrEvents: Rt$2,
  isValidNamespaces: Ir$2,
  isValidNamespacesChainId: Fi$1,
  isValidNamespacesEvent: Gi$1,
  isValidNamespacesRequest: qi$1,
  isValidNumber: Ge$2,
  isValidObject: qe$2,
  isValidParams: Di$2,
  isValidRecap: Y$1,
  isValidRelay: Ar$2,
  isValidRelays: Ci$2,
  isValidRequest: Vi$1,
  isValidRequestExpiry: Ji$1,
  isValidRequiredNamespaces: ji$1,
  isValidResponse: Hi$1,
  isValidString: q$2,
  isValidUrl: Ri$2,
  mapEntries: oo$2,
  mapToObj: no$2,
  mergeArrays: Q$1,
  mergeEncodedRecaps: ns$1,
  mergeRecaps: Rn$2,
  normalizeNamespaces: $t$1,
  objToMap: ro$2,
  openDeeplink: tn$2,
  parseAccountId: Xe$1,
  parseChainId: Ye$1,
  parseContextNames: Xt$2,
  parseExpirerTarget: lo$1,
  parseNamespaceKey: pr$2,
  parseRelayParams: ir$2,
  parseTopic: cr$2,
  parseUri: bi$2,
  populateAuthPayload: Zo$1,
  recapHasResource: Qo$1,
  serialize: _t$3,
  sleep: vo$1,
  subscribeToBrowserNetworkChange: $r$2,
  subscribeToNetworkChange: Xi$1,
  subscribeToReactNativeNetworkChange: Rr$2,
  toBase64: on$2,
  uuidv4: wo$1,
  validateDecoding: fi$2,
  validateEncoding: rr$2,
  validateSignedCacao: Yo$1,
  verifyP256Jwt: gi$2,
  verifySignature: yn$2
}, Symbol.toStringTag, { value: "Module" }));
const Oe$1 = "wc", Ae$1 = 2, le$1 = "core", B$1 = `${Oe$1}@2:${le$1}:`, Dt$1 = { logger: "error" }, ft$1 = { database: ":memory:" }, vt$1 = "crypto", Ne$1 = "client_ed25519_seed", _t$2 = cjs$3.ONE_DAY, Et$2 = "keychain", wt$1 = "0.3", It$1 = "messages", Tt$1 = "0.3", $e$2 = cjs$3.SIX_HOURS, Ct$1 = "publisher", Pt = "irn", St$2 = "error", ze$1 = "wss://dev-cross-relay.crosstoken.io/ws", Rt$1 = "relayer", T$1 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" }, xt$1 = "_subscription", L$1 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" }, Ot$1 = 1, De$1 = "2.19.0", Q = { link_mode: "link_mode", relay: "relay" }, At$1 = "0.3", Nt$1 = "WALLETCONNECT_CLIENT_ID", Le$2 = "WALLETCONNECT_LINK_MODE_APPS", $$2 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" }, $t = "subscription", zt$1 = "0.3", Lt$1 = cjs$3.FIVE_SECONDS * 1e3, kt$1 = "pairing", Ut$1 = "0.3", ie$1 = { wc_pairingDelete: { req: { ttl: cjs$3.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: cjs$3.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: cjs$3.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: cjs$3.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: cjs$3.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: cjs$3.ONE_DAY, prompt: false, tag: 0 } } }, se$1 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" }, F$1 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" }, Ft$1 = "history", Mt$1 = "0.3", Kt$1 = "expirer", M$1 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" }, Bt$1 = "0.3", Vt$1 = "verify-api", jt$1 = "https://dev-cross-verify.crosstoken.io", re$1 = "https://cross-verify.crosstoken.io", qt$1 = `${re$1}`, Gt$1 = [jt$1, re$1], Ht$1 = "echo", Yt$1 = "https://echo.walletconnect.com", q$1 = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" }, J$1 = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" }, js$1 = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" }, qs$2 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" }, Gs$1 = { authenticated_session_approve_started: "authenticated_session_approve_started", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve" }, Hs$1 = { no_internet_connection: "no_internet_connection", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" }, Jt$1 = 0.1, Xt$1 = "event-client", Wt$1 = 86400, Zt$1 = "https://pulse.walletconnect.org/batch";
function Ys$1(n5, e3) {
  if (n5.length >= 255) throw new TypeError("Alphabet too long");
  for (var t2 = new Uint8Array(256), s2 = 0; s2 < t2.length; s2++) t2[s2] = 255;
  for (var i4 = 0; i4 < n5.length; i4++) {
    var r3 = n5.charAt(i4), o3 = r3.charCodeAt(0);
    if (t2[o3] !== 255) throw new TypeError(r3 + " is ambiguous");
    t2[o3] = i4;
  }
  var a2 = n5.length, c2 = n5.charAt(0), h5 = Math.log(a2) / Math.log(256), u2 = Math.log(256) / Math.log(a2);
  function g2(l2) {
    if (l2 instanceof Uint8Array || (ArrayBuffer.isView(l2) ? l2 = new Uint8Array(l2.buffer, l2.byteOffset, l2.byteLength) : Array.isArray(l2) && (l2 = Uint8Array.from(l2))), !(l2 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (l2.length === 0) return "";
    for (var y4 = 0, O4 = 0, w2 = 0, f6 = l2.length; w2 !== f6 && l2[w2] === 0; ) w2++, y4++;
    for (var k3 = (f6 - w2) * u2 + 1 >>> 0, I4 = new Uint8Array(k3); w2 !== f6; ) {
      for (var j2 = l2[w2], X2 = 0, K3 = k3 - 1; (j2 !== 0 || X2 < O4) && K3 !== -1; K3--, X2++) j2 += 256 * I4[K3] >>> 0, I4[K3] = j2 % a2 >>> 0, j2 = j2 / a2 >>> 0;
      if (j2 !== 0) throw new Error("Non-zero carry");
      O4 = X2, w2++;
    }
    for (var Y2 = k3 - O4; Y2 !== k3 && I4[Y2] === 0; ) Y2++;
    for (var ge2 = c2.repeat(y4); Y2 < k3; ++Y2) ge2 += n5.charAt(I4[Y2]);
    return ge2;
  }
  function D2(l2) {
    if (typeof l2 != "string") throw new TypeError("Expected String");
    if (l2.length === 0) return new Uint8Array();
    var y4 = 0;
    if (l2[y4] !== " ") {
      for (var O4 = 0, w2 = 0; l2[y4] === c2; ) O4++, y4++;
      for (var f6 = (l2.length - y4) * h5 + 1 >>> 0, k3 = new Uint8Array(f6); l2[y4]; ) {
        var I4 = t2[l2.charCodeAt(y4)];
        if (I4 === 255) return;
        for (var j2 = 0, X2 = f6 - 1; (I4 !== 0 || j2 < w2) && X2 !== -1; X2--, j2++) I4 += a2 * k3[X2] >>> 0, k3[X2] = I4 % 256 >>> 0, I4 = I4 / 256 >>> 0;
        if (I4 !== 0) throw new Error("Non-zero carry");
        w2 = j2, y4++;
      }
      if (l2[y4] !== " ") {
        for (var K3 = f6 - w2; K3 !== f6 && k3[K3] === 0; ) K3++;
        for (var Y2 = new Uint8Array(O4 + (f6 - K3)), ge2 = O4; K3 !== f6; ) Y2[ge2++] = k3[K3++];
        return Y2;
      }
    }
  }
  function A2(l2) {
    var y4 = D2(l2);
    if (y4) return y4;
    throw new Error(`Non-${e3} character`);
  }
  return { encode: g2, decodeUnsafe: D2, decode: A2 };
}
var Js$1 = Ys$1, Xs$1 = Js$1;
const Qt$1 = (n5) => {
  if (n5 instanceof Uint8Array && n5.constructor.name === "Uint8Array") return n5;
  if (n5 instanceof ArrayBuffer) return new Uint8Array(n5);
  if (ArrayBuffer.isView(n5)) return new Uint8Array(n5.buffer, n5.byteOffset, n5.byteLength);
  throw new Error("Unknown type, must be binary type");
}, Ws$1 = (n5) => new TextEncoder().encode(n5), Zs$1 = (n5) => new TextDecoder().decode(n5);
let Qs$1 = class Qs3 {
  constructor(e3, t2, s2) {
    this.name = e3, this.prefix = t2, this.baseEncode = s2;
  }
  encode(e3) {
    if (e3 instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e3)}`;
    throw Error("Unknown type, must be binary type");
  }
};
let er$1 = class er3 {
  constructor(e3, t2, s2) {
    if (this.name = e3, this.prefix = t2, t2.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t2.codePointAt(0), this.baseDecode = s2;
  }
  decode(e3) {
    if (typeof e3 == "string") {
      if (e3.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e3)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e3.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e3) {
    return ei$1(this, e3);
  }
};
let tr$1 = class tr3 {
  constructor(e3) {
    this.decoders = e3;
  }
  or(e3) {
    return ei$1(this, e3);
  }
  decode(e3) {
    const t2 = e3[0], s2 = this.decoders[t2];
    if (s2) return s2.decode(e3);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e3)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
const ei$1 = (n5, e3) => new tr$1({ ...n5.decoders || { [n5.prefix]: n5 }, ...e3.decoders || { [e3.prefix]: e3 } });
let ir$1 = class ir3 {
  constructor(e3, t2, s2, i4) {
    this.name = e3, this.prefix = t2, this.baseEncode = s2, this.baseDecode = i4, this.encoder = new Qs$1(e3, t2, s2), this.decoder = new er$1(e3, t2, i4);
  }
  encode(e3) {
    return this.encoder.encode(e3);
  }
  decode(e3) {
    return this.decoder.decode(e3);
  }
};
const fe = ({ name: n5, prefix: e3, encode: t2, decode: s2 }) => new ir$1(n5, e3, t2, s2), ue$1 = ({ prefix: n5, name: e3, alphabet: t2 }) => {
  const { encode: s2, decode: i4 } = Xs$1(t2, e3);
  return fe({ prefix: n5, name: e3, encode: s2, decode: (r3) => Qt$1(i4(r3)) });
}, sr$1 = (n5, e3, t2, s2) => {
  const i4 = {};
  for (let u2 = 0; u2 < e3.length; ++u2) i4[e3[u2]] = u2;
  let r3 = n5.length;
  for (; n5[r3 - 1] === "="; ) --r3;
  const o3 = new Uint8Array(r3 * t2 / 8 | 0);
  let a2 = 0, c2 = 0, h5 = 0;
  for (let u2 = 0; u2 < r3; ++u2) {
    const g2 = i4[n5[u2]];
    if (g2 === void 0) throw new SyntaxError(`Non-${s2} character`);
    c2 = c2 << t2 | g2, a2 += t2, a2 >= 8 && (a2 -= 8, o3[h5++] = 255 & c2 >> a2);
  }
  if (a2 >= t2 || 255 & c2 << 8 - a2) throw new SyntaxError("Unexpected end of data");
  return o3;
}, rr$1 = (n5, e3, t2) => {
  const s2 = e3[e3.length - 1] === "=", i4 = (1 << t2) - 1;
  let r3 = "", o3 = 0, a2 = 0;
  for (let c2 = 0; c2 < n5.length; ++c2) for (a2 = a2 << 8 | n5[c2], o3 += 8; o3 > t2; ) o3 -= t2, r3 += e3[i4 & a2 >> o3];
  if (o3 && (r3 += e3[i4 & a2 << t2 - o3]), s2) for (; r3.length * t2 & 7; ) r3 += "=";
  return r3;
}, C$1 = ({ name: n5, prefix: e3, bitsPerChar: t2, alphabet: s2 }) => fe({ prefix: e3, name: n5, encode(i4) {
  return rr$1(i4, s2, t2);
}, decode(i4) {
  return sr$1(i4, s2, t2, n5);
} }), nr$1 = fe({ prefix: "\0", name: "identity", encode: (n5) => Zs$1(n5), decode: (n5) => Ws$1(n5) });
var or$1 = Object.freeze({ __proto__: null, identity: nr$1 });
const ar$1 = C$1({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var cr$1 = Object.freeze({ __proto__: null, base2: ar$1 });
const hr$1 = C$1({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var lr$1 = Object.freeze({ __proto__: null, base8: hr$1 });
const ur$1 = ue$1({ prefix: "9", name: "base10", alphabet: "0123456789" });
var dr$1 = Object.freeze({ __proto__: null, base10: ur$1 });
const pr$1 = C$1({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), gr$1 = C$1({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var yr$1 = Object.freeze({ __proto__: null, base16: pr$1, base16upper: gr$1 });
const mr$1 = C$1({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), br$1 = C$1({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), Dr$1 = C$1({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), fr$1 = C$1({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), vr$1 = C$1({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), _r$1 = C$1({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), Er$1 = C$1({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), wr$1 = C$1({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), Ir$1 = C$1({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Tr$1 = Object.freeze({ __proto__: null, base32: mr$1, base32upper: br$1, base32pad: Dr$1, base32padupper: fr$1, base32hex: vr$1, base32hexupper: _r$1, base32hexpad: Er$1, base32hexpadupper: wr$1, base32z: Ir$1 });
const Cr$1 = ue$1({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), Pr$1 = ue$1({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Sr$1 = Object.freeze({ __proto__: null, base36: Cr$1, base36upper: Pr$1 });
const Rr$1 = ue$1({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), xr$1 = ue$1({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Or$1 = Object.freeze({ __proto__: null, base58btc: Rr$1, base58flickr: xr$1 });
const Ar$1 = C$1({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), Nr$1 = C$1({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), $r$1 = C$1({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), zr$1 = C$1({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Lr$1 = Object.freeze({ __proto__: null, base64: Ar$1, base64pad: Nr$1, base64url: $r$1, base64urlpad: zr$1 });
const ti$1 = Array.from(""), kr$1 = ti$1.reduce((n5, e3, t2) => (n5[t2] = e3, n5), []), Ur$1 = ti$1.reduce((n5, e3, t2) => (n5[e3.codePointAt(0)] = t2, n5), []);
function Fr$1(n5) {
  return n5.reduce((e3, t2) => (e3 += kr$1[t2], e3), "");
}
function Mr$1(n5) {
  const e3 = [];
  for (const t2 of n5) {
    const s2 = Ur$1[t2.codePointAt(0)];
    if (s2 === void 0) throw new Error(`Non-base256emoji character: ${t2}`);
    e3.push(s2);
  }
  return new Uint8Array(e3);
}
const Kr$1 = fe({ prefix: "", name: "base256emoji", encode: Fr$1, decode: Mr$1 });
var Br$1 = Object.freeze({ __proto__: null, base256emoji: Kr$1 }), Vr$1 = si$1, ii$1 = 128, qr$1 = -128, Gr$1 = Math.pow(2, 31);
function si$1(n5, e3, t2) {
  e3 = e3 || [], t2 = t2 || 0;
  for (var s2 = t2; n5 >= Gr$1; ) e3[t2++] = n5 & 255 | ii$1, n5 /= 128;
  for (; n5 & qr$1; ) e3[t2++] = n5 & 255 | ii$1, n5 >>>= 7;
  return e3[t2] = n5 | 0, si$1.bytes = t2 - s2 + 1, e3;
}
var Hr$1 = ke$2, Yr$1 = 128, ri$1 = 127;
function ke$2(n5, s2) {
  var t2 = 0, s2 = s2 || 0, i4 = 0, r3 = s2, o3, a2 = n5.length;
  do {
    if (r3 >= a2) throw ke$2.bytes = 0, new RangeError("Could not decode varint");
    o3 = n5[r3++], t2 += i4 < 28 ? (o3 & ri$1) << i4 : (o3 & ri$1) * Math.pow(2, i4), i4 += 7;
  } while (o3 >= Yr$1);
  return ke$2.bytes = r3 - s2, t2;
}
var Jr$1 = Math.pow(2, 7), Xr$1 = Math.pow(2, 14), Wr$1 = Math.pow(2, 21), Zr$1 = Math.pow(2, 28), Qr$1 = Math.pow(2, 35), en$1 = Math.pow(2, 42), tn$1 = Math.pow(2, 49), sn$1 = Math.pow(2, 56), rn$1 = Math.pow(2, 63), nn$1 = function(n5) {
  return n5 < Jr$1 ? 1 : n5 < Xr$1 ? 2 : n5 < Wr$1 ? 3 : n5 < Zr$1 ? 4 : n5 < Qr$1 ? 5 : n5 < en$1 ? 6 : n5 < tn$1 ? 7 : n5 < sn$1 ? 8 : n5 < rn$1 ? 9 : 10;
}, on$1 = { encode: Vr$1, decode: Hr$1, encodingLength: nn$1 }, ni$1 = on$1;
const oi$1 = (n5, e3, t2 = 0) => (ni$1.encode(n5, e3, t2), e3), ai$1 = (n5) => ni$1.encodingLength(n5), Ue$2 = (n5, e3) => {
  const t2 = e3.byteLength, s2 = ai$1(n5), i4 = s2 + ai$1(t2), r3 = new Uint8Array(i4 + t2);
  return oi$1(n5, r3, 0), oi$1(t2, r3, s2), r3.set(e3, i4), new an$1(n5, t2, e3, r3);
};
let an$1 = class an3 {
  constructor(e3, t2, s2, i4) {
    this.code = e3, this.size = t2, this.digest = s2, this.bytes = i4;
  }
};
const ci$1 = ({ name: n5, code: e3, encode: t2 }) => new cn$1(n5, e3, t2);
let cn$1 = class cn3 {
  constructor(e3, t2, s2) {
    this.name = e3, this.code = t2, this.encode = s2;
  }
  digest(e3) {
    if (e3 instanceof Uint8Array) {
      const t2 = this.encode(e3);
      return t2 instanceof Uint8Array ? Ue$2(this.code, t2) : t2.then((s2) => Ue$2(this.code, s2));
    } else throw Error("Unknown type, must be binary type");
  }
};
const hi$1 = (n5) => async (e3) => new Uint8Array(await crypto.subtle.digest(n5, e3)), hn$1 = ci$1({ name: "sha2-256", code: 18, encode: hi$1("SHA-256") }), ln$1 = ci$1({ name: "sha2-512", code: 19, encode: hi$1("SHA-512") });
var un$1 = Object.freeze({ __proto__: null, sha256: hn$1, sha512: ln$1 });
const li$1 = 0, dn$1 = "identity", ui$1 = Qt$1, pn$1 = (n5) => Ue$2(li$1, ui$1(n5)), gn$1 = { code: li$1, name: dn$1, encode: ui$1, digest: pn$1 };
var yn$1 = Object.freeze({ __proto__: null, identity: gn$1 });
new TextEncoder(), new TextDecoder();
const di$1 = { ...or$1, ...cr$1, ...lr$1, ...dr$1, ...yr$1, ...Tr$1, ...Sr$1, ...Or$1, ...Lr$1, ...Br$1 };
({ ...un$1, ...yn$1 });
function mn$1(n5 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(n5) : new Uint8Array(n5);
}
function pi$1(n5, e3, t2, s2) {
  return { name: n5, prefix: e3, encoder: { name: n5, prefix: e3, encode: t2 }, decoder: { decode: s2 } };
}
const gi$1 = pi$1("utf8", "u", (n5) => "u" + new TextDecoder("utf8").decode(n5), (n5) => new TextEncoder().encode(n5.substring(1))), Fe$2 = pi$1("ascii", "a", (n5) => {
  let e3 = "a";
  for (let t2 = 0; t2 < n5.length; t2++) e3 += String.fromCharCode(n5[t2]);
  return e3;
}, (n5) => {
  n5 = n5.substring(1);
  const e3 = mn$1(n5.length);
  for (let t2 = 0; t2 < n5.length; t2++) e3[t2] = n5.charCodeAt(t2);
  return e3;
}), bn$1 = { utf8: gi$1, "utf-8": gi$1, hex: di$1.base16, latin1: Fe$2, ascii: Fe$2, binary: Fe$2, ...di$1 };
function Dn$1(n5, e3 = "utf8") {
  const t2 = bn$1[e3];
  if (!t2) throw new Error(`Unsupported encoding "${e3}"`);
  return (e3 === "utf8" || e3 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(n5, "utf8") : t2.decoder.decode(`${t2.prefix}${n5}`);
}
var fn$1 = Object.defineProperty, vn$1 = (n5, e3, t2) => e3 in n5 ? fn$1(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, G$1 = (n5, e3, t2) => vn$1(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let yi$1 = class yi3 {
  constructor(e3, t2) {
    this.core = e3, this.logger = t2, G$1(this, "keychain", /* @__PURE__ */ new Map()), G$1(this, "name", Et$2), G$1(this, "version", wt$1), G$1(this, "initialized", false), G$1(this, "storagePrefix", B$1), G$1(this, "init", async () => {
      if (!this.initialized) {
        const s2 = await this.getKeyChain();
        typeof s2 < "u" && (this.keychain = s2), this.initialized = true;
      }
    }), G$1(this, "has", (s2) => (this.isInitialized(), this.keychain.has(s2))), G$1(this, "set", async (s2, i4) => {
      this.isInitialized(), this.keychain.set(s2, i4), await this.persist();
    }), G$1(this, "get", (s2) => {
      this.isInitialized();
      const i4 = this.keychain.get(s2);
      if (typeof i4 > "u") {
        const { message: r3 } = te$1("NO_MATCHING_KEY", `${this.name}: ${s2}`);
        throw new Error(r3);
      }
      return i4;
    }), G$1(this, "del", async (s2) => {
      this.isInitialized(), this.keychain.delete(s2), await this.persist();
    }), this.core = e3, this.logger = E$7(t2, this.name);
  }
  get context() {
    return y$6(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e3) {
    await this.core.storage.setItem(this.storageKey, no$2(e3));
  }
  async getKeyChain() {
    const e3 = await this.core.storage.getItem(this.storageKey);
    return typeof e3 < "u" ? ro$2(e3) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e3 } = te$1("NOT_INITIALIZED", this.name);
      throw new Error(e3);
    }
  }
};
var _n$1 = Object.defineProperty, En$1 = (n5, e3, t2) => e3 in n5 ? _n$1(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, P = (n5, e3, t2) => En$1(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let mi$1 = class mi3 {
  constructor(e3, t2, s2) {
    this.core = e3, this.logger = t2, P(this, "name", vt$1), P(this, "keychain"), P(this, "randomSessionIdentifier", ni$2()), P(this, "initialized", false), P(this, "init", async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }), P(this, "hasKeys", (i4) => (this.isInitialized(), this.keychain.has(i4))), P(this, "getClientId", async () => {
      this.isInitialized();
      const i4 = await this.getClientSeed(), r3 = Po$5(i4);
      return Qe$5(r3.publicKey);
    }), P(this, "generateKeyPair", () => {
      this.isInitialized();
      const i4 = ti$2();
      return this.setPrivateKey(i4.publicKey, i4.privateKey);
    }), P(this, "signJWT", async (i4) => {
      this.isInitialized();
      const r3 = await this.getClientSeed(), o3 = Po$5(r3), a2 = this.randomSessionIdentifier, c2 = _t$2;
      return await Qo$5(a2, i4, c2, o3);
    }), P(this, "generateSharedKey", (i4, r3, o3) => {
      this.isInitialized();
      const a2 = this.getPrivateKey(i4), c2 = ri$2(a2, r3);
      return this.setSymKey(c2, o3);
    }), P(this, "setSymKey", async (i4, r3) => {
      this.isInitialized();
      const o3 = r3 || oi$2(i4);
      return await this.keychain.set(o3, i4), o3;
    }), P(this, "deleteKeyPair", async (i4) => {
      this.isInitialized(), await this.keychain.del(i4);
    }), P(this, "deleteSymKey", async (i4) => {
      this.isInitialized(), await this.keychain.del(i4);
    }), P(this, "encode", async (i4, r3, o3) => {
      this.isInitialized();
      const a2 = rr$2(o3), c2 = safeJsonStringify(r3);
      if (di$2(a2)) return ai$2(c2, o3 == null ? void 0 : o3.encoding);
      if (li$2(a2)) {
        const D2 = a2.senderPublicKey, A2 = a2.receiverPublicKey;
        i4 = await this.generateSharedKey(D2, A2);
      }
      const h5 = this.getSymKey(i4), { type: u2, senderPublicKey: g2 } = a2;
      return ii$2({ type: u2, symKey: h5, message: c2, senderPublicKey: g2, encoding: o3 == null ? void 0 : o3.encoding });
    }), P(this, "decode", async (i4, r3, o3) => {
      this.isInitialized();
      const a2 = fi$2(r3, o3);
      if (di$2(a2)) {
        const c2 = ui$2(r3, o3 == null ? void 0 : o3.encoding);
        return safeJsonParse(c2);
      }
      if (li$2(a2)) {
        const c2 = a2.receiverPublicKey, h5 = a2.senderPublicKey;
        i4 = await this.generateSharedKey(c2, h5);
      }
      try {
        const c2 = this.getSymKey(i4), h5 = ci$2({ symKey: c2, encoded: r3, encoding: o3 == null ? void 0 : o3.encoding });
        return safeJsonParse(h5);
      } catch (c2) {
        this.logger.error(`Failed to decode message from topic: '${i4}', clientId: '${await this.getClientId()}'`), this.logger.error(c2);
      }
    }), P(this, "getPayloadType", (i4, r3 = At$2) => {
      const o3 = Fe$3({ encoded: i4, encoding: r3 });
      return fe$1(o3.type);
    }), P(this, "getPayloadSenderPublicKey", (i4, r3 = At$2) => {
      const o3 = Fe$3({ encoded: i4, encoding: r3 });
      return o3.senderPublicKey ? toString$1(o3.senderPublicKey, V$3) : void 0;
    }), this.core = e3, this.logger = E$7(t2, this.name), this.keychain = s2 || new yi$1(this.core, this.logger);
  }
  get context() {
    return y$6(this.logger);
  }
  async setPrivateKey(e3, t2) {
    return await this.keychain.set(e3, t2), e3;
  }
  getPrivateKey(e3) {
    return this.keychain.get(e3);
  }
  async getClientSeed() {
    let e3 = "";
    try {
      e3 = this.keychain.get(Ne$1);
    } catch {
      e3 = ni$2(), await this.keychain.set(Ne$1, e3);
    }
    return Dn$1(e3, "base16");
  }
  getSymKey(e3) {
    return this.keychain.get(e3);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e3 } = te$1("NOT_INITIALIZED", this.name);
      throw new Error(e3);
    }
  }
};
var wn$1 = Object.defineProperty, In$1 = (n5, e3, t2) => e3 in n5 ? wn$1(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, H$1 = (n5, e3, t2) => In$1(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let bi$1 = class bi3 extends y$4 {
  constructor(e3, t2) {
    super(e3, t2), this.logger = e3, this.core = t2, H$1(this, "messages", /* @__PURE__ */ new Map()), H$1(this, "name", It$1), H$1(this, "version", Tt$1), H$1(this, "initialized", false), H$1(this, "storagePrefix", B$1), H$1(this, "init", async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const s2 = await this.getRelayerMessages();
          typeof s2 < "u" && (this.messages = s2), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (s2) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(s2);
        } finally {
          this.initialized = true;
        }
      }
    }), H$1(this, "set", async (s2, i4) => {
      this.isInitialized();
      const r3 = si$2(i4);
      let o3 = this.messages.get(s2);
      return typeof o3 > "u" && (o3 = {}), typeof o3[r3] < "u" || (o3[r3] = i4, this.messages.set(s2, o3), await this.persist()), r3;
    }), H$1(this, "get", (s2) => {
      this.isInitialized();
      let i4 = this.messages.get(s2);
      return typeof i4 > "u" && (i4 = {}), i4;
    }), H$1(this, "has", (s2, i4) => {
      this.isInitialized();
      const r3 = this.get(s2), o3 = si$2(i4);
      return typeof r3[o3] < "u";
    }), H$1(this, "del", async (s2) => {
      this.isInitialized(), this.messages.delete(s2), await this.persist();
    }), this.logger = E$7(e3, this.name), this.core = t2;
  }
  get context() {
    return y$6(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e3) {
    await this.core.storage.setItem(this.storageKey, no$2(e3));
  }
  async getRelayerMessages() {
    const e3 = await this.core.storage.getItem(this.storageKey);
    return typeof e3 < "u" ? ro$2(e3) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e3 } = te$1("NOT_INITIALIZED", this.name);
      throw new Error(e3);
    }
  }
};
var Tn$1 = Object.defineProperty, Cn$1 = Object.defineProperties, Pn$1 = Object.getOwnPropertyDescriptors, Di$1 = Object.getOwnPropertySymbols, Sn$1 = Object.prototype.hasOwnProperty, Rn$1 = Object.prototype.propertyIsEnumerable, Me$2 = (n5, e3, t2) => e3 in n5 ? Tn$1(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, ve = (n5, e3) => {
  for (var t2 in e3 || (e3 = {})) Sn$1.call(e3, t2) && Me$2(n5, t2, e3[t2]);
  if (Di$1) for (var t2 of Di$1(e3)) Rn$1.call(e3, t2) && Me$2(n5, t2, e3[t2]);
  return n5;
}, Ke$2 = (n5, e3) => Cn$1(n5, Pn$1(e3)), V$2 = (n5, e3, t2) => Me$2(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let xn$1 = class xn4 extends m$1 {
  constructor(e3, t2) {
    super(e3, t2), this.relayer = e3, this.logger = t2, V$2(this, "events", new eventsExports.EventEmitter()), V$2(this, "name", Ct$1), V$2(this, "queue", /* @__PURE__ */ new Map()), V$2(this, "publishTimeout", cjs$3.toMiliseconds(cjs$3.ONE_MINUTE)), V$2(this, "initialPublishTimeout", cjs$3.toMiliseconds(cjs$3.ONE_SECOND * 15)), V$2(this, "needsTransportRestart", false), V$2(this, "publish", async (s2, i4, r3) => {
      var o3;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: s2, message: i4, opts: r3 } });
      const a2 = (r3 == null ? void 0 : r3.ttl) || $e$2, c2 = yi$2(r3), h5 = (r3 == null ? void 0 : r3.prompt) || false, u2 = (r3 == null ? void 0 : r3.tag) || 0, g2 = (r3 == null ? void 0 : r3.id) || getBigIntRpcId().toString(), D2 = { topic: s2, message: i4, opts: { ttl: a2, relay: c2, prompt: h5, tag: u2, id: g2, attestation: r3 == null ? void 0 : r3.attestation, tvf: r3 == null ? void 0 : r3.tvf } }, A2 = `Failed to publish payload, please try again. id:${g2} tag:${u2}`;
      try {
        const l2 = new Promise(async (y4) => {
          const O4 = ({ id: f6 }) => {
            D2.opts.id === f6 && (this.removeRequestFromQueue(f6), this.relayer.events.removeListener(T$1.publish, O4), y4(D2));
          };
          this.relayer.events.on(T$1.publish, O4);
          const w2 = ao$2(new Promise((f6, k3) => {
            this.rpcPublish({ topic: s2, message: i4, ttl: a2, prompt: h5, tag: u2, id: g2, attestation: r3 == null ? void 0 : r3.attestation, tvf: r3 == null ? void 0 : r3.tvf }).then(f6).catch((I4) => {
              this.logger.warn(I4, I4 == null ? void 0 : I4.message), k3(I4);
            });
          }), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${g2} tag:${u2}`);
          try {
            await w2, this.events.removeListener(T$1.publish, O4);
          } catch (f6) {
            this.queue.set(g2, Ke$2(ve({}, D2), { attempt: 1 })), this.logger.warn(f6, f6 == null ? void 0 : f6.message);
          }
        });
        this.logger.trace({ type: "method", method: "publish", params: { id: g2, topic: s2, message: i4, opts: r3 } }), await ao$2(l2, this.publishTimeout, A2);
      } catch (l2) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(l2), (o3 = r3 == null ? void 0 : r3.internal) != null && o3.throwOnFailedPublish) throw l2;
      } finally {
        this.queue.delete(g2);
      }
    }), V$2(this, "on", (s2, i4) => {
      this.events.on(s2, i4);
    }), V$2(this, "once", (s2, i4) => {
      this.events.once(s2, i4);
    }), V$2(this, "off", (s2, i4) => {
      this.events.off(s2, i4);
    }), V$2(this, "removeListener", (s2, i4) => {
      this.events.removeListener(s2, i4);
    }), this.relayer = e3, this.logger = E$7(t2, this.name), this.registerEventListeners();
  }
  get context() {
    return y$6(this.logger);
  }
  async rpcPublish(e3) {
    var t2, s2, i4, r3;
    const { topic: o3, message: a2, ttl: c2 = $e$2, prompt: h5, tag: u2, id: g2, attestation: D2, tvf: A2 } = e3, l2 = { method: mi$2(yi$2().protocol).publish, params: ve({ topic: o3, message: a2, ttl: c2, prompt: h5, tag: u2, attestation: D2 }, A2), id: g2 };
    ae$2((t2 = l2.params) == null ? void 0 : t2.prompt) && ((s2 = l2.params) == null || delete s2.prompt), ae$2((i4 = l2.params) == null ? void 0 : i4.tag) && ((r3 = l2.params) == null || delete r3.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: l2 });
    const y4 = await this.relayer.request(l2);
    return this.relayer.events.emit(T$1.publish, e3), this.logger.debug("Successfully Published Payload"), y4;
  }
  removeRequestFromQueue(e3) {
    this.queue.delete(e3);
  }
  checkQueue() {
    this.queue.forEach(async (e3, t2) => {
      const s2 = e3.attempt + 1;
      this.queue.set(t2, Ke$2(ve({}, e3), { attempt: s2 }));
      const { topic: i4, message: r3, opts: o3, attestation: a2 } = e3;
      this.logger.warn({}, `Publisher: queue->publishing: ${e3.opts.id}, tag: ${e3.opts.tag}, attempt: ${s2}`), await this.rpcPublish(Ke$2(ve({}, e3), { topic: i4, message: r3, ttl: o3.ttl, prompt: o3.prompt, tag: o3.tag, id: o3.id, attestation: a2, tvf: o3.tvf })), this.logger.warn({}, `Publisher: queue->published: ${e3.opts.id}`);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r$8.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(T$1.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(T$1.message_ack, (e3) => {
      this.removeRequestFromQueue(e3.id.toString());
    });
  }
};
var On$1 = Object.defineProperty, An$1 = (n5, e3, t2) => e3 in n5 ? On$1(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, ne$1 = (n5, e3, t2) => An$1(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let Nn$1 = class Nn3 {
  constructor() {
    ne$1(this, "map", /* @__PURE__ */ new Map()), ne$1(this, "set", (e3, t2) => {
      const s2 = this.get(e3);
      this.exists(e3, t2) || this.map.set(e3, [...s2, t2]);
    }), ne$1(this, "get", (e3) => this.map.get(e3) || []), ne$1(this, "exists", (e3, t2) => this.get(e3).includes(t2)), ne$1(this, "delete", (e3, t2) => {
      if (typeof t2 > "u") {
        this.map.delete(e3);
        return;
      }
      if (!this.map.has(e3)) return;
      const s2 = this.get(e3);
      if (!this.exists(e3, t2)) return;
      const i4 = s2.filter((r3) => r3 !== t2);
      if (!i4.length) {
        this.map.delete(e3);
        return;
      }
      this.map.set(e3, i4);
    }), ne$1(this, "clear", () => {
      this.map.clear();
    });
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var $n$1 = Object.defineProperty, zn$1 = Object.defineProperties, Ln$1 = Object.getOwnPropertyDescriptors, fi$1 = Object.getOwnPropertySymbols, kn$1 = Object.prototype.hasOwnProperty, Un$1 = Object.prototype.propertyIsEnumerable, Be$1 = (n5, e3, t2) => e3 in n5 ? $n$1(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, de$1 = (n5, e3) => {
  for (var t2 in e3 || (e3 = {})) kn$1.call(e3, t2) && Be$1(n5, t2, e3[t2]);
  if (fi$1) for (var t2 of fi$1(e3)) Un$1.call(e3, t2) && Be$1(n5, t2, e3[t2]);
  return n5;
}, Ve$1 = (n5, e3) => zn$1(n5, Ln$1(e3)), b = (n5, e3, t2) => Be$1(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let vi$1 = class vi3 extends P$5 {
  constructor(e3, t2) {
    super(e3, t2), this.relayer = e3, this.logger = t2, b(this, "subscriptions", /* @__PURE__ */ new Map()), b(this, "topicMap", new Nn$1()), b(this, "events", new eventsExports.EventEmitter()), b(this, "name", $t), b(this, "version", zt$1), b(this, "pending", /* @__PURE__ */ new Map()), b(this, "cached", []), b(this, "initialized", false), b(this, "pendingSubscriptionWatchLabel", "pending_sub_watch_label"), b(this, "pollingInterval", 20), b(this, "storagePrefix", B$1), b(this, "subscribeTimeout", cjs$3.toMiliseconds(cjs$3.ONE_MINUTE)), b(this, "initialSubscribeTimeout", cjs$3.toMiliseconds(cjs$3.ONE_SECOND * 15)), b(this, "clientId"), b(this, "batchSubscribeTopicsLimit", 500), b(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), await this.restore()), this.initialized = true;
    }), b(this, "subscribe", async (s2, i4) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s2, opts: i4 } });
      try {
        const r3 = yi$2(i4), o3 = { topic: s2, relay: r3, transportType: i4 == null ? void 0 : i4.transportType };
        this.pending.set(s2, o3);
        const a2 = await this.rpcSubscribe(s2, r3, i4);
        return typeof a2 == "string" && (this.onSubscribe(a2, o3), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s2, opts: i4 } })), a2;
      } catch (r3) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(r3), r3;
      }
    }), b(this, "unsubscribe", async (s2, i4) => {
      this.isInitialized(), typeof (i4 == null ? void 0 : i4.id) < "u" ? await this.unsubscribeById(s2, i4.id, i4) : await this.unsubscribeByTopic(s2, i4);
    }), b(this, "isSubscribed", async (s2) => {
      if (this.topics.includes(s2)) return true;
      const i4 = `${this.pendingSubscriptionWatchLabel}_${s2}`;
      return await new Promise((r3, o3) => {
        const a2 = new cjs$3.Watch();
        a2.start(i4);
        const c2 = setInterval(() => {
          (!this.pending.has(s2) && this.topics.includes(s2) || this.cached.some((h5) => h5.topic === s2)) && (clearInterval(c2), a2.stop(i4), r3(true)), a2.elapsed(i4) >= Lt$1 && (clearInterval(c2), a2.stop(i4), o3(new Error("Subscription resolution timeout")));
        }, this.pollingInterval);
      }).catch(() => false);
    }), b(this, "on", (s2, i4) => {
      this.events.on(s2, i4);
    }), b(this, "once", (s2, i4) => {
      this.events.once(s2, i4);
    }), b(this, "off", (s2, i4) => {
      this.events.off(s2, i4);
    }), b(this, "removeListener", (s2, i4) => {
      this.events.removeListener(s2, i4);
    }), b(this, "start", async () => {
      await this.onConnect();
    }), b(this, "stop", async () => {
      await this.onDisconnect();
    }), b(this, "restart", async () => {
      await this.restore(), await this.onRestart();
    }), b(this, "checkPending", async () => {
      if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) return;
      const s2 = [];
      this.pending.forEach((i4) => {
        s2.push(i4);
      }), await this.batchSubscribe(s2);
    }), b(this, "registerEventListeners", () => {
      this.relayer.core.heartbeat.on(r$8.pulse, async () => {
        await this.checkPending();
      }), this.events.on($$2.created, async (s2) => {
        const i4 = $$2.created;
        this.logger.info(`Emitting ${i4}`), this.logger.debug({ type: "event", event: i4, data: s2 }), await this.persist();
      }), this.events.on($$2.deleted, async (s2) => {
        const i4 = $$2.deleted;
        this.logger.info(`Emitting ${i4}`), this.logger.debug({ type: "event", event: i4, data: s2 }), await this.persist();
      });
    }), this.relayer = e3, this.logger = E$7(t2, this.name), this.clientId = "";
  }
  get context() {
    return y$6(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  get hasAnyTopics() {
    return this.topicMap.topics.length > 0 || this.pending.size > 0 || this.cached.length > 0 || this.subscriptions.size > 0;
  }
  hasSubscription(e3, t2) {
    let s2 = false;
    try {
      s2 = this.getSubscription(e3).topic === t2;
    } catch {
    }
    return s2;
  }
  reset() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e3, t2) {
    const s2 = this.topicMap.get(e3);
    await Promise.all(s2.map(async (i4) => await this.unsubscribeById(e3, i4, t2)));
  }
  async unsubscribeById(e3, t2, s2) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e3, id: t2, opts: s2 } });
    try {
      const i4 = yi$2(s2);
      await this.restartToComplete({ topic: e3, id: t2, relay: i4 }), await this.rpcUnsubscribe(e3, t2, i4);
      const r3 = de$2("USER_DISCONNECTED", `${this.name}, ${e3}`);
      await this.onUnsubscribe(e3, t2, r3), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e3, id: t2, opts: s2 } });
    } catch (i4) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(i4), i4;
    }
  }
  async rpcSubscribe(e3, t2, s2) {
    var i4;
    (!s2 || (s2 == null ? void 0 : s2.transportType) === Q.relay) && await this.restartToComplete({ topic: e3, id: e3, relay: t2 });
    const r3 = { method: mi$2(t2.protocol).subscribe, params: { topic: e3 } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: r3 });
    const o3 = (i4 = s2 == null ? void 0 : s2.internal) == null ? void 0 : i4.throwOnFailedPublish;
    try {
      const a2 = await this.getSubscriptionId(e3);
      if ((s2 == null ? void 0 : s2.transportType) === Q.link_mode) return setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(r3).catch((u2) => this.logger.warn(u2));
      }, cjs$3.toMiliseconds(cjs$3.ONE_SECOND)), a2;
      const c2 = new Promise(async (u2) => {
        const g2 = (D2) => {
          D2.topic === e3 && (this.events.removeListener($$2.created, g2), u2(D2.id));
        };
        this.events.on($$2.created, g2);
        try {
          const D2 = await ao$2(new Promise((A2, l2) => {
            this.relayer.request(r3).catch((y4) => {
              this.logger.warn(y4, y4 == null ? void 0 : y4.message), l2(y4);
            }).then(A2);
          }), this.initialSubscribeTimeout, `Subscribing to ${e3} failed, please try again`);
          this.events.removeListener($$2.created, g2), u2(D2);
        } catch {
        }
      }), h5 = await ao$2(c2, this.subscribeTimeout, `Subscribing to ${e3} failed, please try again`);
      if (!h5 && o3) throw new Error(`Subscribing to ${e3} failed, please try again`);
      return h5 ? a2 : null;
    } catch (a2) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(T$1.connection_stalled), o3) throw a2;
    }
    return null;
  }
  async rpcBatchSubscribe(e3) {
    if (!e3.length) return;
    const t2 = e3[0].relay, s2 = { method: mi$2(t2.protocol).batchSubscribe, params: { topics: e3.map((i4) => i4.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 });
    try {
      await await ao$2(new Promise((i4) => {
        this.relayer.request(s2).catch((r3) => this.logger.warn(r3)).then(i4);
      }), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again");
    } catch {
      this.relayer.events.emit(T$1.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e3) {
    if (!e3.length) return;
    const t2 = e3[0].relay, s2 = { method: mi$2(t2.protocol).batchFetchMessages, params: { topics: e3.map((r3) => r3.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 });
    let i4;
    try {
      i4 = await await ao$2(new Promise((r3, o3) => {
        this.relayer.request(s2).catch((a2) => {
          this.logger.warn(a2), o3(a2);
        }).then(r3);
      }), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again");
    } catch {
      this.relayer.events.emit(T$1.connection_stalled);
    }
    return i4;
  }
  rpcUnsubscribe(e3, t2, s2) {
    const i4 = { method: mi$2(s2.protocol).unsubscribe, params: { topic: e3, id: t2 } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i4 }), this.relayer.request(i4);
  }
  onSubscribe(e3, t2) {
    this.setSubscription(e3, Ve$1(de$1({}, t2), { id: e3 })), this.pending.delete(t2.topic);
  }
  onBatchSubscribe(e3) {
    e3.length && e3.forEach((t2) => {
      this.setSubscription(t2.id, de$1({}, t2)), this.pending.delete(t2.topic);
    });
  }
  async onUnsubscribe(e3, t2, s2) {
    this.events.removeAllListeners(t2), this.hasSubscription(t2, e3) && this.deleteSubscription(t2, s2), await this.relayer.messages.del(e3);
  }
  async setRelayerSubscriptions(e3) {
    await this.relayer.core.storage.setItem(this.storageKey, e3);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e3, t2) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e3, subscription: t2 }), this.addSubscription(e3, t2);
  }
  addSubscription(e3, t2) {
    this.subscriptions.set(e3, de$1({}, t2)), this.topicMap.set(t2.topic, e3), this.events.emit($$2.created, t2);
  }
  getSubscription(e3) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e3 });
    const t2 = this.subscriptions.get(e3);
    if (!t2) {
      const { message: s2 } = te$1("NO_MATCHING_KEY", `${this.name}: ${e3}`);
      throw new Error(s2);
    }
    return t2;
  }
  deleteSubscription(e3, t2) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e3, reason: t2 });
    const s2 = this.getSubscription(e3);
    this.subscriptions.delete(e3), this.topicMap.delete(s2.topic, e3), this.events.emit($$2.deleted, Ve$1(de$1({}, s2), { reason: t2 }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit($$2.sync);
  }
  async onRestart() {
    if (this.cached.length) {
      const e3 = [...this.cached], t2 = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let s2 = 0; s2 < t2; s2++) {
        const i4 = e3.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(i4);
      }
    }
    this.events.emit($$2.resubscribed);
  }
  async restore() {
    try {
      const e3 = await this.getRelayerSubscriptions();
      if (typeof e3 > "u" || !e3.length) return;
      if (this.subscriptions.size) {
        const { message: t2 } = te$1("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t2), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t2);
      }
      this.cached = e3, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e3) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e3);
    }
  }
  async batchSubscribe(e3) {
    e3.length && (await this.rpcBatchSubscribe(e3), this.onBatchSubscribe(await Promise.all(e3.map(async (t2) => Ve$1(de$1({}, t2), { id: await this.getSubscriptionId(t2.topic) })))));
  }
  async batchFetchMessages(e3) {
    if (!e3.length) return;
    this.logger.trace(`Fetching batch messages for ${e3.length} subscriptions`);
    const t2 = await this.rpcBatchFetchMessages(e3);
    t2 && t2.messages && (await vo$1(cjs$3.toMiliseconds(cjs$3.ONE_SECOND)), await this.relayer.handleBatchMessageEvents(t2.messages));
  }
  async onConnect() {
    await this.restart(), this.reset();
  }
  onDisconnect() {
    this.onDisable();
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e3 } = te$1("NOT_INITIALIZED", this.name);
      throw new Error(e3);
    }
  }
  async restartToComplete(e3) {
    if (!this.relayer.connected && !this.relayer.connecting) {
      this.cached.push(e3);
      try {
        if (!await (async () => await Promise.resolve().then(() => index_es)).then((t2) => t2.isOnline())) return;
      } catch {
      }
      await this.relayer.transportOpen();
    }
  }
  async getClientId() {
    return this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()), this.clientId;
  }
  async getSubscriptionId(e3) {
    return si$2(e3 + await this.getClientId());
  }
};
var Fn$1 = Object.defineProperty, _i$1 = Object.getOwnPropertySymbols, Mn$1 = Object.prototype.hasOwnProperty, Kn$1 = Object.prototype.propertyIsEnumerable, je$1 = (n5, e3, t2) => e3 in n5 ? Fn$1(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, Ei$1 = (n5, e3) => {
  for (var t2 in e3 || (e3 = {})) Mn$1.call(e3, t2) && je$1(n5, t2, e3[t2]);
  if (_i$1) for (var t2 of _i$1(e3)) Kn$1.call(e3, t2) && je$1(n5, t2, e3[t2]);
  return n5;
}, p$1 = (n5, e3, t2) => je$1(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let wi$1 = class wi3 extends d$6 {
  constructor(e3) {
    super(e3), p$1(this, "protocol", "wc"), p$1(this, "version", 2), p$1(this, "core"), p$1(this, "logger"), p$1(this, "events", new eventsExports.EventEmitter()), p$1(this, "provider"), p$1(this, "messages"), p$1(this, "subscriber"), p$1(this, "publisher"), p$1(this, "name", Rt$1), p$1(this, "transportExplicitlyClosed", false), p$1(this, "initialized", false), p$1(this, "connectionAttemptInProgress", false), p$1(this, "relayUrl"), p$1(this, "projectId"), p$1(this, "packageName"), p$1(this, "bundleId"), p$1(this, "hasExperiencedNetworkDisruption", false), p$1(this, "pingTimeout"), p$1(this, "heartBeatTimeout", cjs$3.toMiliseconds(cjs$3.THIRTY_SECONDS + cjs$3.FIVE_SECONDS)), p$1(this, "reconnectTimeout"), p$1(this, "connectPromise"), p$1(this, "reconnectInProgress", false), p$1(this, "requestsInFlight", []), p$1(this, "connectTimeout", cjs$3.toMiliseconds(cjs$3.ONE_SECOND * 15)), p$1(this, "request", async (t2) => {
      var s2, i4;
      this.logger.debug("Publishing Request Payload");
      const r3 = t2.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        this.logger.trace({ id: r3, method: t2.method, topic: (s2 = t2.params) == null ? void 0 : s2.topic }, "relayer.request - publishing...");
        const o3 = `${r3}:${((i4 = t2.params) == null ? void 0 : i4.tag) || ""}`;
        this.requestsInFlight.push(o3);
        const a2 = await this.provider.request(t2);
        return this.requestsInFlight = this.requestsInFlight.filter((c2) => c2 !== o3), a2;
      } catch (o3) {
        throw this.logger.debug(`Failed to Publish Request: ${r3}`), o3;
      }
    }), p$1(this, "resetPingTimeout", () => {
      if (et$1()) try {
        clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
          var t2, s2, i4;
          this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."), (i4 = (s2 = (t2 = this.provider) == null ? void 0 : t2.connection) == null ? void 0 : s2.socket) == null || i4.terminate();
        }, this.heartBeatTimeout);
      } catch (t2) {
        this.logger.warn(t2, t2 == null ? void 0 : t2.message);
      }
    }), p$1(this, "onPayloadHandler", (t2) => {
      this.onProviderPayload(t2), this.resetPingTimeout();
    }), p$1(this, "onConnectHandler", () => {
      this.logger.warn({}, "Relayer connected "), this.startPingTimeout(), this.events.emit(T$1.connect);
    }), p$1(this, "onDisconnectHandler", () => {
      this.logger.warn({}, "Relayer disconnected "), this.requestsInFlight = [], this.onProviderDisconnect();
    }), p$1(this, "onProviderErrorHandler", (t2) => {
      this.logger.fatal(`Fatal socket error: ${t2.message}`), this.events.emit(T$1.error, t2), this.logger.fatal("Fatal socket error received, closing transport"), this.transportClose();
    }), p$1(this, "registerProviderListeners", () => {
      this.provider.on(L$1.payload, this.onPayloadHandler), this.provider.on(L$1.connect, this.onConnectHandler), this.provider.on(L$1.disconnect, this.onDisconnectHandler), this.provider.on(L$1.error, this.onProviderErrorHandler);
    }), this.core = e3.core, this.logger = typeof e3.logger < "u" && typeof e3.logger != "string" ? E$7(e3.logger, this.name) : gt$3(k$7({ level: e3.logger || St$2 })), this.messages = new bi$1(this.logger, e3.core), this.subscriber = new vi$1(this, this.logger), this.publisher = new xn$1(this, this.logger), this.relayUrl = (e3 == null ? void 0 : e3.relayUrl) || ze$1, this.projectId = e3.projectId, Wr$2() ? this.packageName = Jr$2() : zr$2() && (this.bundleId = Jr$2()), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = true, this.subscriber.hasAnyTopics) try {
      await this.transportOpen();
    } catch (e3) {
      this.logger.warn(e3, e3 == null ? void 0 : e3.message);
    }
  }
  get context() {
    return y$6(this.logger);
  }
  get connected() {
    var e3, t2, s2;
    return ((s2 = (t2 = (e3 = this.provider) == null ? void 0 : e3.connection) == null ? void 0 : t2.socket) == null ? void 0 : s2.readyState) === 1 || false;
  }
  get connecting() {
    var e3, t2, s2;
    return ((s2 = (t2 = (e3 = this.provider) == null ? void 0 : e3.connection) == null ? void 0 : t2.socket) == null ? void 0 : s2.readyState) === 0 || this.connectPromise !== void 0 || this.connectionAttemptInProgress === true || false;
  }
  async publish(e3, t2, s2) {
    this.isInitialized(), await this.publisher.publish(e3, t2, s2), await this.recordMessageEvent({ topic: e3, message: t2, publishedAt: Date.now(), transportType: Q.relay });
  }
  async subscribe(e3, t2) {
    var s2, i4, r3;
    this.isInitialized(), (!(t2 != null && t2.transportType) || (t2 == null ? void 0 : t2.transportType) === "relay") && await this.toEstablishConnection();
    const o3 = typeof ((s2 = t2 == null ? void 0 : t2.internal) == null ? void 0 : s2.throwOnFailedPublish) > "u" ? true : (i4 = t2 == null ? void 0 : t2.internal) == null ? void 0 : i4.throwOnFailedPublish;
    let a2 = ((r3 = this.subscriber.topicMap.get(e3)) == null ? void 0 : r3[0]) || "", c2;
    const h5 = (u2) => {
      u2.topic === e3 && (this.subscriber.off($$2.created, h5), c2());
    };
    return await Promise.all([new Promise((u2) => {
      c2 = u2, this.subscriber.on($$2.created, h5);
    }), new Promise(async (u2, g2) => {
      a2 = await this.subscriber.subscribe(e3, Ei$1({ internal: { throwOnFailedPublish: o3 } }, t2)).catch((D2) => {
        o3 && g2(D2);
      }) || a2, u2();
    })]), a2;
  }
  async unsubscribe(e3, t2) {
    this.isInitialized(), await this.subscriber.unsubscribe(e3, t2);
  }
  on(e3, t2) {
    this.events.on(e3, t2);
  }
  once(e3, t2) {
    this.events.once(e3, t2);
  }
  off(e3, t2) {
    this.events.off(e3, t2);
  }
  removeListener(e3, t2) {
    this.events.removeListener(e3, t2);
  }
  async transportDisconnect() {
    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await ao$2(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, await this.transportDisconnect();
  }
  async transportOpen(e3) {
    if (!this.subscriber.hasAnyTopics) {
      this.logger.warn("Starting WS connection skipped because the client has no topics to work with.");
      return;
    }
    if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."), await this.connectPromise, this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise(async (t2, s2) => {
      await this.connect(e3).then(t2).catch(s2).finally(() => {
        this.connectPromise = void 0;
      });
    }), await this.connectPromise), !this.connected) throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);
  }
  async restartTransport(e3) {
    this.logger.debug({}, "Restarting transport..."), !this.connectionAttemptInProgress && (this.relayUrl = e3 || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await Yi$1()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e3) {
    if ((e3 == null ? void 0 : e3.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const t2 = e3.sort((s2, i4) => s2.publishedAt - i4.publishedAt);
    this.logger.debug(`Batch of ${t2.length} message events sorted`);
    for (const s2 of t2) try {
      await this.onMessageEvent(s2);
    } catch (i4) {
      this.logger.warn(i4, "Error while processing batch message event: " + (i4 == null ? void 0 : i4.message));
    }
    this.logger.trace(`Batch of ${t2.length} message events processed`);
  }
  async onLinkMessageEvent(e3, t2) {
    const { topic: s2 } = e3;
    if (!t2.sessionExists) {
      const i4 = ho$1(cjs$3.FIVE_MINUTES), r3 = { topic: s2, expiry: i4, relay: { protocol: "irn" }, active: false };
      await this.core.pairing.pairings.set(s2, r3);
    }
    this.events.emit(T$1.message, e3), await this.recordMessageEvent(e3);
  }
  async connect(e3) {
    await this.confirmOnlineStateOrThrow(), e3 && e3 !== this.relayUrl && (this.relayUrl = e3, await this.transportDisconnect()), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
    let t2 = 1;
    for (; t2 < 6; ) {
      try {
        if (this.transportExplicitlyClosed) break;
        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t2}...`), await this.createProvider(), await new Promise(async (s2, i4) => {
          const r3 = () => {
            i4(new Error("Connection interrupted while trying to subscribe"));
          };
          this.provider.once(L$1.disconnect, r3), await ao$2(new Promise((o3, a2) => {
            this.provider.connect().then(o3).catch(a2);
          }), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch((o3) => {
            i4(o3);
          }).finally(() => {
            this.provider.off(L$1.disconnect, r3), clearTimeout(this.reconnectTimeout);
          }), await new Promise(async (o3, a2) => {
            const c2 = () => {
              a2(new Error("Connection interrupted while trying to subscribe"));
            };
            this.provider.once(L$1.disconnect, c2), await this.subscriber.start().then(o3).catch(a2).finally(() => {
              this.provider.off(L$1.disconnect, c2);
            });
          }), this.hasExperiencedNetworkDisruption = false, s2();
        });
      } catch (s2) {
        await this.subscriber.stop();
        const i4 = s2;
        this.logger.warn({}, i4.message), this.hasExperiencedNetworkDisruption = true;
      } finally {
        this.connectionAttemptInProgress = false;
      }
      if (this.connected) {
        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t2}`);
        break;
      }
      await new Promise((s2) => setTimeout(s2, cjs$3.toMiliseconds(t2 * 1))), t2++;
    }
  }
  startPingTimeout() {
    var e3, t2, s2, i4, r3;
    if (et$1()) try {
      (t2 = (e3 = this.provider) == null ? void 0 : e3.connection) != null && t2.socket && ((r3 = (i4 = (s2 = this.provider) == null ? void 0 : s2.connection) == null ? void 0 : i4.socket) == null || r3.on("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (o3) {
      this.logger.warn(o3, o3 == null ? void 0 : o3.message);
    }
  }
  async createProvider() {
    try {
      this.provider.connection && this.unregisterProviderListeners();
      const e3 = await this.core.crypto.signJWT(this.relayUrl), t2 = Zr$2({ sdkVersion: De$1, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e3, useOnCloseEvent: true, bundleId: this.bundleId, packageName: this.packageName });
      console.log("[Relayer] WS connect URL:", t2);
      const s2 = new f$7(t2);
      this.provider = new o$9(s2), this.registerProviderListeners();
    } catch (e3) {
      throw this.logger.error(`error on ws connection: ${e3 == null ? void 0 : e3.message}`), e3;
    }
  }
  async recordMessageEvent(e3) {
    const { topic: t2, message: s2 } = e3;
    await this.messages.set(t2, s2);
  }
  async shouldIgnoreMessageEvent(e3) {
    const { topic: t2, message: s2 } = e3;
    if (!s2 || s2.length === 0) return this.logger.warn(`Ignoring invalid/empty message: ${s2}`), true;
    if (!await this.subscriber.isSubscribed(t2)) return this.logger.warn(`Ignoring message for non-subscribed topic ${t2}`), true;
    const i4 = this.messages.has(t2, s2);
    return i4 && this.logger.warn(`Ignoring duplicate message: ${s2}`), i4;
  }
  async onProviderPayload(e3) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e3 }), isJsonRpcRequest(e3)) {
      if (!e3.method.endsWith(xt$1)) return;
      const t2 = e3.params, { topic: s2, message: i4, publishedAt: r3, attestation: o3 } = t2.data, a2 = { topic: s2, message: i4, publishedAt: r3, transportType: Q.relay, attestation: o3 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Ei$1({ type: "event", event: t2.id }, a2)), this.events.emit(t2.id, a2), await this.acknowledgePayload(e3), await this.onMessageEvent(a2);
    } else isJsonRpcResponse(e3) && this.events.emit(T$1.message_ack, e3);
  }
  async onMessageEvent(e3) {
    await this.shouldIgnoreMessageEvent(e3) || (this.events.emit(T$1.message, e3), await this.recordMessageEvent(e3));
  }
  async acknowledgePayload(e3) {
    const t2 = formatJsonRpcResult(e3.id, true);
    await this.provider.connection.send(t2);
  }
  unregisterProviderListeners() {
    this.provider.off(L$1.payload, this.onPayloadHandler), this.provider.off(L$1.connect, this.onConnectHandler), this.provider.off(L$1.disconnect, this.onDisconnectHandler), this.provider.off(L$1.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e3 = await Yi$1();
    Xi$1(async (t2) => {
      if (e3 !== t2) if (e3 = t2, !t2) this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false, clearTimeout(this.reconnectTimeout), this.reconnectTimeout = void 0, this.reconnectInProgress = false;
      else {
        if (this.connecting || this.reconnectInProgress || this.connectPromise) return;
        await this.transportOpen().catch((s2) => this.logger.error(s2, s2 == null ? void 0 : s2.message));
      }
    });
  }
  async onProviderDisconnect() {
    if (clearTimeout(this.pingTimeout), this.events.emit(T$1.disconnect), this.connectionAttemptInProgress = false, !this.reconnectInProgress && (this.reconnectInProgress = true, await this.subscriber.stop(), !!this.subscriber.hasAnyTopics && !this.transportExplicitlyClosed)) {
      try {
        if (!await Yi$1()) {
          clearTimeout(this.reconnectTimeout), this.reconnectTimeout = void 0, this.reconnectInProgress = false;
          return;
        }
      } catch {
      }
      this.reconnectTimeout = setTimeout(async () => {
        await this.transportOpen().catch((e3) => this.logger.error(e3, e3 == null ? void 0 : e3.message)), this.reconnectTimeout = void 0, this.reconnectInProgress = false;
      }, cjs$3.toMiliseconds(Ot$1));
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e3 } = te$1("NOT_INITIALIZED", this.name);
      throw new Error(e3);
    }
  }
  async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow(), !this.connected && (this.connecting || this.reconnectInProgress || this.connectPromise || await this.transportOpen());
  }
};
var Bn$1 = Object.defineProperty, Ii$1 = Object.getOwnPropertySymbols, Vn$1 = Object.prototype.hasOwnProperty, jn$1 = Object.prototype.propertyIsEnumerable, qe$1 = (n5, e3, t2) => e3 in n5 ? Bn$1(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, Ti$1 = (n5, e3) => {
  for (var t2 in e3 || (e3 = {})) Vn$1.call(e3, t2) && qe$1(n5, t2, e3[t2]);
  if (Ii$1) for (var t2 of Ii$1(e3)) jn$1.call(e3, t2) && qe$1(n5, t2, e3[t2]);
  return n5;
}, z$2 = (n5, e3, t2) => qe$1(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let Ci$1 = class Ci3 extends f$9 {
  constructor(e3, t2, s2, i4 = B$1, r3 = void 0) {
    super(e3, t2, s2, i4), this.core = e3, this.logger = t2, this.name = s2, z$2(this, "map", /* @__PURE__ */ new Map()), z$2(this, "version", At$1), z$2(this, "cached", []), z$2(this, "initialized", false), z$2(this, "getKey"), z$2(this, "storagePrefix", B$1), z$2(this, "recentlyDeleted", []), z$2(this, "recentlyDeletedLimit", 200), z$2(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o3) => {
        this.getKey && o3 !== null && !ae$2(o3) ? this.map.set(this.getKey(o3), o3) : Pi$2(o3) ? this.map.set(o3.id, o3) : Li$2(o3) && this.map.set(o3.topic, o3);
      }), this.cached = [], this.initialized = true);
    }), z$2(this, "set", async (o3, a2) => {
      this.isInitialized(), this.map.has(o3) ? await this.update(o3, a2) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o3, value: a2 }), this.map.set(o3, a2), await this.persist());
    }), z$2(this, "get", (o3) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o3 }), this.getData(o3))), z$2(this, "getAll", (o3) => (this.isInitialized(), o3 ? this.values.filter((a2) => Object.keys(o3).every((c2) => Ls$6(a2[c2], o3[c2]))) : this.values)), z$2(this, "update", async (o3, a2) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o3, update: a2 });
      const c2 = Ti$1(Ti$1({}, this.getData(o3)), a2);
      this.map.set(o3, c2), await this.persist();
    }), z$2(this, "delete", async (o3, a2) => {
      this.isInitialized(), this.map.has(o3) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o3, reason: a2 }), this.map.delete(o3), this.addToRecentlyDeleted(o3), await this.persist());
    }), this.logger = E$7(t2, this.name), this.storagePrefix = i4, this.getKey = r3;
  }
  get context() {
    return y$6(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e3) {
    this.recentlyDeleted.push(e3), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e3) {
    await this.core.storage.setItem(this.storageKey, e3);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e3) {
    const t2 = this.map.get(e3);
    if (!t2) {
      if (this.recentlyDeleted.includes(e3)) {
        const { message: i4 } = te$1("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e3}`);
        throw this.logger.error(i4), new Error(i4);
      }
      const { message: s2 } = te$1("NO_MATCHING_KEY", `${this.name}: ${e3}`);
      throw this.logger.error(s2), new Error(s2);
    }
    return t2;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e3 = await this.getDataStore();
      if (typeof e3 > "u" || !e3.length) return;
      if (this.map.size) {
        const { message: t2 } = te$1("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t2), new Error(t2);
      }
      this.cached = e3, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e3) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e3);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e3 } = te$1("NOT_INITIALIZED", this.name);
      throw new Error(e3);
    }
  }
};
var qn$1 = Object.defineProperty, Gn$1 = (n5, e3, t2) => e3 in n5 ? qn$1(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, d = (n5, e3, t2) => Gn$1(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let Pi$1 = class Pi3 {
  constructor(e3, t2) {
    this.core = e3, this.logger = t2, d(this, "name", kt$1), d(this, "version", Ut$1), d(this, "events", new wt$7()), d(this, "pairings"), d(this, "initialized", false), d(this, "storagePrefix", B$1), d(this, "ignoredPayloadTypes", [Ie$1]), d(this, "registeredMethods", []), d(this, "init", async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }), d(this, "register", ({ methods: s2 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...s2])];
    }), d(this, "create", async (s2) => {
      this.isInitialized();
      const i4 = ni$2(), r3 = await this.core.crypto.setSymKey(i4), o3 = ho$1(cjs$3.FIVE_MINUTES), a2 = { protocol: Pt }, c2 = { topic: r3, expiry: o3, relay: a2, active: false, methods: s2 == null ? void 0 : s2.methods }, h5 = wi$2({ protocol: this.core.protocol, version: this.core.version, topic: r3, symKey: i4, relay: a2, expiryTimestamp: o3, methods: s2 == null ? void 0 : s2.methods });
      return this.events.emit(se$1.create, c2), this.core.expirer.set(r3, o3), await this.pairings.set(r3, c2), await this.core.relayer.subscribe(r3, { transportType: s2 == null ? void 0 : s2.transportType }), { topic: r3, uri: h5 };
    }), d(this, "pair", async (s2) => {
      this.isInitialized();
      const i4 = this.core.eventClient.createEvent({ properties: { topic: s2 == null ? void 0 : s2.uri, trace: [q$1.pairing_started] } });
      this.isValidPair(s2, i4);
      const { topic: r3, symKey: o3, relay: a2, expiryTimestamp: c2, methods: h5 } = bi$2(s2.uri);
      i4.props.properties.topic = r3, i4.addTrace(q$1.pairing_uri_validation_success), i4.addTrace(q$1.pairing_uri_not_expired);
      let u2;
      if (this.pairings.keys.includes(r3)) {
        if (u2 = this.pairings.get(r3), i4.addTrace(q$1.existing_pairing), u2.active) throw i4.setError(J$1.active_pairing_already_exists), new Error(`Pairing already exists: ${r3}. Please try again with a new connection URI.`);
        i4.addTrace(q$1.pairing_not_expired);
      }
      const g2 = c2 || ho$1(cjs$3.FIVE_MINUTES), D2 = { topic: r3, relay: a2, expiry: g2, active: false, methods: h5 };
      this.core.expirer.set(r3, g2), await this.pairings.set(r3, D2), i4.addTrace(q$1.store_new_pairing), s2.activatePairing && await this.activate({ topic: r3 }), this.events.emit(se$1.create, D2), i4.addTrace(q$1.emit_inactive_pairing), this.core.crypto.keychain.has(r3) || await this.core.crypto.setSymKey(o3, r3), i4.addTrace(q$1.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        i4.setError(J$1.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(r3, { relay: a2 });
      } catch (A2) {
        throw i4.setError(J$1.subscribe_pairing_topic_failure), A2;
      }
      return i4.addTrace(q$1.subscribe_pairing_topic_success), D2;
    }), d(this, "activate", async ({ topic: s2 }) => {
      this.isInitialized();
      const i4 = ho$1(cjs$3.FIVE_MINUTES);
      this.core.expirer.set(s2, i4), await this.pairings.update(s2, { active: true, expiry: i4 });
    }), d(this, "ping", async (s2) => {
      this.isInitialized(), await this.isValidPing(s2), this.logger.warn("ping() is deprecated and will be removed in the next major release.");
      const { topic: i4 } = s2;
      if (this.pairings.keys.includes(i4)) {
        const r3 = await this.sendRequest(i4, "wc_pairingPing", {}), { done: o3, resolve: a2, reject: c2 } = co$1();
        this.events.once(go$1("pairing_ping", r3), ({ error: h5 }) => {
          h5 ? c2(h5) : a2();
        }), await o3();
      }
    }), d(this, "updateExpiry", async ({ topic: s2, expiry: i4 }) => {
      this.isInitialized(), await this.pairings.update(s2, { expiry: i4 });
    }), d(this, "updateMetadata", async ({ topic: s2, metadata: i4 }) => {
      this.isInitialized(), await this.pairings.update(s2, { peerMetadata: i4 });
    }), d(this, "getPairings", () => (this.isInitialized(), this.pairings.values)), d(this, "disconnect", async (s2) => {
      this.isInitialized(), await this.isValidDisconnect(s2);
      const { topic: i4 } = s2;
      this.pairings.keys.includes(i4) && (await this.sendRequest(i4, "wc_pairingDelete", de$2("USER_DISCONNECTED")), await this.deletePairing(i4));
    }), d(this, "formatUriFromPairing", (s2) => {
      this.isInitialized();
      const { topic: i4, relay: r3, expiry: o3, methods: a2 } = s2, c2 = this.core.crypto.keychain.get(i4);
      return wi$2({ protocol: this.core.protocol, version: this.core.version, topic: i4, symKey: c2, relay: r3, expiryTimestamp: o3, methods: a2 });
    }), d(this, "sendRequest", async (s2, i4, r3) => {
      const o3 = formatJsonRpcRequest(i4, r3), a2 = await this.core.crypto.encode(s2, o3), c2 = ie$1[i4].req;
      return this.core.history.set(s2, o3), this.core.relayer.publish(s2, a2, c2), o3.id;
    }), d(this, "sendResult", async (s2, i4, r3) => {
      const o3 = formatJsonRpcResult(s2, r3), a2 = await this.core.crypto.encode(i4, o3), c2 = (await this.core.history.get(i4, s2)).request.method, h5 = ie$1[c2].res;
      await this.core.relayer.publish(i4, a2, h5), await this.core.history.resolve(o3);
    }), d(this, "sendError", async (s2, i4, r3) => {
      const o3 = formatJsonRpcError(s2, r3), a2 = await this.core.crypto.encode(i4, o3), c2 = (await this.core.history.get(i4, s2)).request.method, h5 = ie$1[c2] ? ie$1[c2].res : ie$1.unregistered_method.res;
      await this.core.relayer.publish(i4, a2, h5), await this.core.history.resolve(o3);
    }), d(this, "deletePairing", async (s2, i4) => {
      await this.core.relayer.unsubscribe(s2), await Promise.all([this.pairings.delete(s2, de$2("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(s2), i4 ? Promise.resolve() : this.core.expirer.del(s2)]);
    }), d(this, "cleanup", async () => {
      const s2 = this.pairings.getAll().filter((i4) => po$1(i4.expiry));
      await Promise.all(s2.map((i4) => this.deletePairing(i4.topic)));
    }), d(this, "onRelayEventRequest", (s2) => {
      const { topic: i4, payload: r3 } = s2;
      switch (r3.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(i4, r3);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(i4, r3);
        default:
          return this.onUnknownRpcMethodRequest(i4, r3);
      }
    }), d(this, "onRelayEventResponse", async (s2) => {
      const { topic: i4, payload: r3 } = s2, o3 = (await this.core.history.get(i4, r3.id)).request.method;
      switch (o3) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(i4, r3);
        default:
          return this.onUnknownRpcMethodResponse(o3);
      }
    }), d(this, "onPairingPingRequest", async (s2, i4) => {
      const { id: r3 } = i4;
      try {
        this.isValidPing({ topic: s2 }), await this.sendResult(r3, s2, true), this.events.emit(se$1.ping, { id: r3, topic: s2 });
      } catch (o3) {
        await this.sendError(r3, s2, o3), this.logger.error(o3);
      }
    }), d(this, "onPairingPingResponse", (s2, i4) => {
      const { id: r3 } = i4;
      setTimeout(() => {
        isJsonRpcResult(i4) ? this.events.emit(go$1("pairing_ping", r3), {}) : isJsonRpcError(i4) && this.events.emit(go$1("pairing_ping", r3), { error: i4.error });
      }, 500);
    }), d(this, "onPairingDeleteRequest", async (s2, i4) => {
      const { id: r3 } = i4;
      try {
        this.isValidDisconnect({ topic: s2 }), await this.deletePairing(s2), this.events.emit(se$1.delete, { id: r3, topic: s2 });
      } catch (o3) {
        await this.sendError(r3, s2, o3), this.logger.error(o3);
      }
    }), d(this, "onUnknownRpcMethodRequest", async (s2, i4) => {
      const { id: r3, method: o3 } = i4;
      try {
        if (this.registeredMethods.includes(o3)) return;
        const a2 = de$2("WC_METHOD_UNSUPPORTED", o3);
        await this.sendError(r3, s2, a2), this.logger.error(a2);
      } catch (a2) {
        await this.sendError(r3, s2, a2), this.logger.error(a2);
      }
    }), d(this, "onUnknownRpcMethodResponse", (s2) => {
      this.registeredMethods.includes(s2) || this.logger.error(de$2("WC_METHOD_UNSUPPORTED", s2));
    }), d(this, "isValidPair", (s2, i4) => {
      var r3;
      if (!Di$2(s2)) {
        const { message: a2 } = te$1("MISSING_OR_INVALID", `pair() params: ${s2}`);
        throw i4.setError(J$1.malformed_pairing_uri), new Error(a2);
      }
      if (!Ri$2(s2.uri)) {
        const { message: a2 } = te$1("MISSING_OR_INVALID", `pair() uri: ${s2.uri}`);
        throw i4.setError(J$1.malformed_pairing_uri), new Error(a2);
      }
      const o3 = bi$2(s2 == null ? void 0 : s2.uri);
      if (!((r3 = o3 == null ? void 0 : o3.relay) != null && r3.protocol)) {
        const { message: a2 } = te$1("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw i4.setError(J$1.malformed_pairing_uri), new Error(a2);
      }
      if (!(o3 != null && o3.symKey)) {
        const { message: a2 } = te$1("MISSING_OR_INVALID", "pair() uri#symKey");
        throw i4.setError(J$1.malformed_pairing_uri), new Error(a2);
      }
      if (o3 != null && o3.expiryTimestamp && cjs$3.toMiliseconds(o3 == null ? void 0 : o3.expiryTimestamp) < Date.now()) {
        i4.setError(J$1.pairing_expired);
        const { message: a2 } = te$1("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a2);
      }
    }), d(this, "isValidPing", async (s2) => {
      if (!Di$2(s2)) {
        const { message: r3 } = te$1("MISSING_OR_INVALID", `ping() params: ${s2}`);
        throw new Error(r3);
      }
      const { topic: i4 } = s2;
      await this.isValidPairingTopic(i4);
    }), d(this, "isValidDisconnect", async (s2) => {
      if (!Di$2(s2)) {
        const { message: r3 } = te$1("MISSING_OR_INVALID", `disconnect() params: ${s2}`);
        throw new Error(r3);
      }
      const { topic: i4 } = s2;
      await this.isValidPairingTopic(i4);
    }), d(this, "isValidPairingTopic", async (s2) => {
      if (!q$2(s2, false)) {
        const { message: i4 } = te$1("MISSING_OR_INVALID", `pairing topic should be a string: ${s2}`);
        throw new Error(i4);
      }
      if (!this.pairings.keys.includes(s2)) {
        const { message: i4 } = te$1("NO_MATCHING_KEY", `pairing topic doesn't exist: ${s2}`);
        throw new Error(i4);
      }
      if (po$1(this.pairings.get(s2).expiry)) {
        await this.deletePairing(s2);
        const { message: i4 } = te$1("EXPIRED", `pairing topic: ${s2}`);
        throw new Error(i4);
      }
    }), this.core = e3, this.logger = E$7(t2, this.name), this.pairings = new Ci$1(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y$6(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e3 } = te$1("NOT_INITIALIZED", this.name);
      throw new Error(e3);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(T$1.message, async (e3) => {
      const { topic: t2, message: s2, transportType: i4 } = e3;
      if (!this.pairings.keys.includes(t2) || i4 === Q.link_mode || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s2))) return;
      const r3 = await this.core.crypto.decode(t2, s2);
      try {
        isJsonRpcRequest(r3) ? (this.core.history.set(t2, r3), this.onRelayEventRequest({ topic: t2, payload: r3 })) : isJsonRpcResponse(r3) && (await this.core.history.resolve(r3), await this.onRelayEventResponse({ topic: t2, payload: r3 }), this.core.history.delete(t2, r3.id));
      } catch (o3) {
        this.logger.error(o3);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(M$1.expired, async (e3) => {
      const { topic: t2 } = lo$1(e3.target);
      t2 && this.pairings.keys.includes(t2) && (await this.deletePairing(t2, true), this.events.emit(se$1.expire, { topic: t2 }));
    });
  }
};
var Hn$1 = Object.defineProperty, Yn$1 = (n5, e3, t2) => e3 in n5 ? Hn$1(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, S$1 = (n5, e3, t2) => Yn$1(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let Si$1 = class Si3 extends I$4 {
  constructor(e3, t2) {
    super(e3, t2), this.core = e3, this.logger = t2, S$1(this, "records", /* @__PURE__ */ new Map()), S$1(this, "events", new eventsExports.EventEmitter()), S$1(this, "name", Ft$1), S$1(this, "version", Mt$1), S$1(this, "cached", []), S$1(this, "initialized", false), S$1(this, "storagePrefix", B$1), S$1(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s2) => this.records.set(s2.id, s2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), S$1(this, "set", (s2, i4, r3) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: s2, request: i4, chainId: r3 }), this.records.has(i4.id)) return;
      const o3 = { id: i4.id, topic: s2, request: { method: i4.method, params: i4.params || null }, chainId: r3, expiry: ho$1(cjs$3.THIRTY_DAYS) };
      this.records.set(o3.id, o3), this.persist(), this.events.emit(F$1.created, o3);
    }), S$1(this, "resolve", async (s2) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: s2 }), !this.records.has(s2.id)) return;
      const i4 = await this.getRecord(s2.id);
      typeof i4.response > "u" && (i4.response = isJsonRpcError(s2) ? { error: s2.error } : { result: s2.result }, this.records.set(i4.id, i4), this.persist(), this.events.emit(F$1.updated, i4));
    }), S$1(this, "get", async (s2, i4) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: s2, id: i4 }), await this.getRecord(i4))), S$1(this, "delete", (s2, i4) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: i4 }), this.values.forEach((r3) => {
        if (r3.topic === s2) {
          if (typeof i4 < "u" && r3.id !== i4) return;
          this.records.delete(r3.id), this.events.emit(F$1.deleted, r3);
        }
      }), this.persist();
    }), S$1(this, "exists", async (s2, i4) => (this.isInitialized(), this.records.has(i4) ? (await this.getRecord(i4)).topic === s2 : false)), S$1(this, "on", (s2, i4) => {
      this.events.on(s2, i4);
    }), S$1(this, "once", (s2, i4) => {
      this.events.once(s2, i4);
    }), S$1(this, "off", (s2, i4) => {
      this.events.off(s2, i4);
    }), S$1(this, "removeListener", (s2, i4) => {
      this.events.removeListener(s2, i4);
    }), this.logger = E$7(t2, this.name);
  }
  get context() {
    return y$6(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e3 = [];
    return this.values.forEach((t2) => {
      if (typeof t2.response < "u") return;
      const s2 = { topic: t2.topic, request: formatJsonRpcRequest(t2.request.method, t2.request.params, t2.id), chainId: t2.chainId };
      return e3.push(s2);
    }), e3;
  }
  async setJsonRpcRecords(e3) {
    await this.core.storage.setItem(this.storageKey, e3);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e3) {
    this.isInitialized();
    const t2 = this.records.get(e3);
    if (!t2) {
      const { message: s2 } = te$1("NO_MATCHING_KEY", `${this.name}: ${e3}`);
      throw new Error(s2);
    }
    return t2;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(F$1.sync);
  }
  async restore() {
    try {
      const e3 = await this.getJsonRpcRecords();
      if (typeof e3 > "u" || !e3.length) return;
      if (this.records.size) {
        const { message: t2 } = te$1("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t2), new Error(t2);
      }
      this.cached = e3, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e3) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e3);
    }
  }
  registerEventListeners() {
    this.events.on(F$1.created, (e3) => {
      const t2 = F$1.created;
      this.logger.info(`Emitting ${t2}`), this.logger.debug({ type: "event", event: t2, record: e3 });
    }), this.events.on(F$1.updated, (e3) => {
      const t2 = F$1.updated;
      this.logger.info(`Emitting ${t2}`), this.logger.debug({ type: "event", event: t2, record: e3 });
    }), this.events.on(F$1.deleted, (e3) => {
      const t2 = F$1.deleted;
      this.logger.info(`Emitting ${t2}`), this.logger.debug({ type: "event", event: t2, record: e3 });
    }), this.core.heartbeat.on(r$8.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e3 = false;
      this.records.forEach((t2) => {
        cjs$3.toMiliseconds(t2.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t2.id}`), this.records.delete(t2.id), this.events.emit(F$1.deleted, t2, false), e3 = true);
      }), e3 && this.persist();
    } catch (e3) {
      this.logger.warn(e3);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e3 } = te$1("NOT_INITIALIZED", this.name);
      throw new Error(e3);
    }
  }
};
var Jn$1 = Object.defineProperty, Xn$1 = (n5, e3, t2) => e3 in n5 ? Jn$1(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, x$1 = (n5, e3, t2) => Xn$1(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let Ri$1 = class Ri3 extends S$6 {
  constructor(e3, t2) {
    super(e3, t2), this.core = e3, this.logger = t2, x$1(this, "expirations", /* @__PURE__ */ new Map()), x$1(this, "events", new eventsExports.EventEmitter()), x$1(this, "name", Kt$1), x$1(this, "version", Bt$1), x$1(this, "cached", []), x$1(this, "initialized", false), x$1(this, "storagePrefix", B$1), x$1(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s2) => this.expirations.set(s2.target, s2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), x$1(this, "has", (s2) => {
      try {
        const i4 = this.formatTarget(s2);
        return typeof this.getExpiration(i4) < "u";
      } catch {
        return false;
      }
    }), x$1(this, "set", (s2, i4) => {
      this.isInitialized();
      const r3 = this.formatTarget(s2), o3 = { target: r3, expiry: i4 };
      this.expirations.set(r3, o3), this.checkExpiry(r3, o3), this.events.emit(M$1.created, { target: r3, expiration: o3 });
    }), x$1(this, "get", (s2) => {
      this.isInitialized();
      const i4 = this.formatTarget(s2);
      return this.getExpiration(i4);
    }), x$1(this, "del", (s2) => {
      if (this.isInitialized(), this.has(s2)) {
        const i4 = this.formatTarget(s2), r3 = this.getExpiration(i4);
        this.expirations.delete(i4), this.events.emit(M$1.deleted, { target: i4, expiration: r3 });
      }
    }), x$1(this, "on", (s2, i4) => {
      this.events.on(s2, i4);
    }), x$1(this, "once", (s2, i4) => {
      this.events.once(s2, i4);
    }), x$1(this, "off", (s2, i4) => {
      this.events.off(s2, i4);
    }), x$1(this, "removeListener", (s2, i4) => {
      this.events.removeListener(s2, i4);
    }), this.logger = E$7(t2, this.name);
  }
  get context() {
    return y$6(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e3) {
    if (typeof e3 == "string") return uo$1(e3);
    if (typeof e3 == "number") return fo$1(e3);
    const { message: t2 } = te$1("UNKNOWN_TYPE", `Target type: ${typeof e3}`);
    throw new Error(t2);
  }
  async setExpirations(e3) {
    await this.core.storage.setItem(this.storageKey, e3);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(M$1.sync);
  }
  async restore() {
    try {
      const e3 = await this.getExpirations();
      if (typeof e3 > "u" || !e3.length) return;
      if (this.expirations.size) {
        const { message: t2 } = te$1("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t2), new Error(t2);
      }
      this.cached = e3, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e3) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e3);
    }
  }
  getExpiration(e3) {
    const t2 = this.expirations.get(e3);
    if (!t2) {
      const { message: s2 } = te$1("NO_MATCHING_KEY", `${this.name}: ${e3}`);
      throw this.logger.warn(s2), new Error(s2);
    }
    return t2;
  }
  checkExpiry(e3, t2) {
    const { expiry: s2 } = t2;
    cjs$3.toMiliseconds(s2) - Date.now() <= 0 && this.expire(e3, t2);
  }
  expire(e3, t2) {
    this.expirations.delete(e3), this.events.emit(M$1.expired, { target: e3, expiration: t2 });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e3, t2) => this.checkExpiry(t2, e3));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r$8.pulse, () => this.checkExpirations()), this.events.on(M$1.created, (e3) => {
      const t2 = M$1.created;
      this.logger.info(`Emitting ${t2}`), this.logger.debug({ type: "event", event: t2, data: e3 }), this.persist();
    }), this.events.on(M$1.expired, (e3) => {
      const t2 = M$1.expired;
      this.logger.info(`Emitting ${t2}`), this.logger.debug({ type: "event", event: t2, data: e3 }), this.persist();
    }), this.events.on(M$1.deleted, (e3) => {
      const t2 = M$1.deleted;
      this.logger.info(`Emitting ${t2}`), this.logger.debug({ type: "event", event: t2, data: e3 }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e3 } = te$1("NOT_INITIALIZED", this.name);
      throw new Error(e3);
    }
  }
};
var Wn$1 = Object.defineProperty, Zn$1 = (n5, e3, t2) => e3 in n5 ? Wn$1(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, _$2 = (n5, e3, t2) => Zn$1(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let xi$1 = class xi3 extends M$9 {
  constructor(e3, t2, s2) {
    super(e3, t2, s2), this.core = e3, this.logger = t2, this.store = s2, _$2(this, "name", Vt$1), _$2(this, "abortController"), _$2(this, "isDevEnv"), _$2(this, "verifyUrlV3", qt$1), _$2(this, "storagePrefix", B$1), _$2(this, "version", Ae$1), _$2(this, "publicKey"), _$2(this, "fetchPromise"), _$2(this, "init", async () => {
      var i4;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && cjs$3.toMiliseconds((i4 = this.publicKey) == null ? void 0 : i4.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }), _$2(this, "register", async (i4) => {
      if (!Ae$2() || this.isDevEnv) return;
      const r3 = window.location.origin, { id: o3, decryptedId: a2 } = i4, c2 = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${r3}&id=${o3}&decryptedId=${a2}`;
      try {
        const h5 = getDocument_1(), u2 = this.startAbortTimer(cjs$3.ONE_SECOND * 5), g2 = await new Promise((D2, A2) => {
          const l2 = () => {
            window.removeEventListener("message", O4), h5.body.removeChild(y4), A2("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", l2);
          const y4 = h5.createElement("iframe");
          y4.src = c2, y4.style.display = "none", y4.addEventListener("error", l2, { signal: this.abortController.signal });
          const O4 = (w2) => {
            if (w2.data && typeof w2.data == "string") try {
              const f6 = JSON.parse(w2.data);
              if (f6.type === "verify_attestation") {
                if (sn$7(f6.attestation).payload.id !== o3) return;
                clearInterval(u2), h5.body.removeChild(y4), this.abortController.signal.removeEventListener("abort", l2), window.removeEventListener("message", O4), D2(f6.attestation === null ? "" : f6.attestation);
              }
            } catch (f6) {
              this.logger.warn(f6);
            }
          };
          h5.body.appendChild(y4), window.addEventListener("message", O4, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", g2), g2;
      } catch (h5) {
        this.logger.warn(h5);
      }
      return "";
    }), _$2(this, "resolve", async (i4) => {
      if (this.isDevEnv) return "";
      const { attestationId: r3, hash: o3, encryptedId: a2 } = i4;
      if (r3 === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (r3) {
        if (sn$7(r3).payload.id !== a2) return;
        const h5 = await this.isValidJwtAttestation(r3);
        if (h5) {
          if (!h5.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return h5;
        }
      }
      if (!o3) return;
      const c2 = this.getVerifyUrl(i4 == null ? void 0 : i4.verifyUrl);
      return this.fetchAttestation(o3, c2);
    }), _$2(this, "fetchAttestation", async (i4, r3) => {
      this.logger.debug(`resolving attestation: ${i4} from url: ${r3}`);
      const o3 = this.startAbortTimer(cjs$3.ONE_SECOND * 5), a2 = await fetch(`${r3}/attestation/${i4}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(o3), a2.status === 200 ? await a2.json() : void 0;
    }), _$2(this, "getVerifyUrl", (i4) => {
      let r3 = i4 || re$1;
      return Gt$1.includes(r3) || (this.logger.info(`verify url: ${r3}, not included in trusted list, assigning default: ${re$1}`), r3 = re$1), r3;
    }), _$2(this, "fetchPublicKey", async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const i4 = this.startAbortTimer(cjs$3.FIVE_SECONDS), r3 = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(i4), await r3.json();
      } catch (i4) {
        this.logger.warn(i4);
      }
    }), _$2(this, "persistPublicKey", async (i4) => {
      this.logger.debug("persisting public key to local storage", i4), await this.store.setItem(this.storeKey, i4), this.publicKey = i4;
    }), _$2(this, "removePublicKey", async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }), _$2(this, "isValidJwtAttestation", async (i4) => {
      const r3 = await this.getPublicKey();
      try {
        if (r3) return this.validateAttestation(i4, r3);
      } catch (a2) {
        this.logger.error(a2), this.logger.warn("error validating attestation");
      }
      const o3 = await this.fetchAndPersistPublicKey();
      try {
        if (o3) return this.validateAttestation(i4, o3);
      } catch (a2) {
        this.logger.error(a2), this.logger.warn("error validating attestation");
      }
    }), _$2(this, "getPublicKey", async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()), _$2(this, "fetchAndPersistPublicKey", async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (r3) => {
        const o3 = await this.fetchPublicKey();
        o3 && (await this.persistPublicKey(o3), r3(o3));
      });
      const i4 = await this.fetchPromise;
      return this.fetchPromise = void 0, i4;
    }), _$2(this, "validateAttestation", (i4, r3) => {
      const o3 = gi$2(i4, r3.publicKey), a2 = { hasExpired: cjs$3.toMiliseconds(o3.exp) < Date.now(), payload: o3 };
      if (a2.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a2.payload.origin, isScam: a2.payload.isScam, isVerified: a2.payload.isVerified };
    }), this.logger = E$7(t2, this.name), this.abortController = new AbortController(), this.isDevEnv = Eo$1(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y$6(this.logger);
  }
  startAbortTimer(e3) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), cjs$3.toMiliseconds(e3));
  }
};
var Qn$1 = Object.defineProperty, eo$1 = (n5, e3, t2) => e3 in n5 ? Qn$1(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, Oi$1 = (n5, e3, t2) => eo$1(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let Ai$1 = class Ai3 extends O$4 {
  constructor(e3, t2) {
    super(e3, t2), this.projectId = e3, this.logger = t2, Oi$1(this, "context", Ht$1), Oi$1(this, "registerDeviceToken", async (s2) => {
      const { clientId: i4, token: r3, notificationType: o3, enableEncrypted: a2 = false } = s2, c2 = `${Yt$1}/${this.projectId}/clients`;
      await fetch(c2, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: i4, type: o3, token: r3, always_raw: a2 }) });
    }), this.logger = E$7(t2, this.context);
  }
};
var to$1 = Object.defineProperty, Ni$1 = Object.getOwnPropertySymbols, io$1 = Object.prototype.hasOwnProperty, so$1 = Object.prototype.propertyIsEnumerable, Ge$1 = (n5, e3, t2) => e3 in n5 ? to$1(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, pe$1 = (n5, e3) => {
  for (var t2 in e3 || (e3 = {})) io$1.call(e3, t2) && Ge$1(n5, t2, e3[t2]);
  if (Ni$1) for (var t2 of Ni$1(e3)) so$1.call(e3, t2) && Ge$1(n5, t2, e3[t2]);
  return n5;
}, E$1 = (n5, e3, t2) => Ge$1(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let $i$1 = class $i3 extends R$5 {
  constructor(e3, t2, s2 = true) {
    super(e3, t2, s2), this.core = e3, this.logger = t2, E$1(this, "context", Xt$1), E$1(this, "storagePrefix", B$1), E$1(this, "storageVersion", Jt$1), E$1(this, "events", /* @__PURE__ */ new Map()), E$1(this, "shouldPersist", false), E$1(this, "init", async () => {
      if (!Eo$1()) try {
        const i4 = { eventId: wo$1(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: Yt$2(this.core.relayer.protocol, this.core.relayer.version, De$1) } } };
        await this.sendEvent([i4]);
      } catch (i4) {
        this.logger.warn(i4);
      }
    }), E$1(this, "createEvent", (i4) => {
      const { event: r3 = "ERROR", type: o3 = "", properties: { topic: a2, trace: c2 } } = i4, h5 = wo$1(), u2 = this.core.projectId || "", g2 = Date.now(), D2 = pe$1({ eventId: h5, timestamp: g2, props: { event: r3, type: o3, properties: { topic: a2, trace: c2 } }, bundleId: u2, domain: this.getAppDomain() }, this.setMethods(h5));
      return this.telemetryEnabled && (this.events.set(h5, D2), this.shouldPersist = true), D2;
    }), E$1(this, "getEvent", (i4) => {
      const { eventId: r3, topic: o3 } = i4;
      if (r3) return this.events.get(r3);
      const a2 = Array.from(this.events.values()).find((c2) => c2.props.properties.topic === o3);
      if (a2) return pe$1(pe$1({}, a2), this.setMethods(a2.eventId));
    }), E$1(this, "deleteEvent", (i4) => {
      const { eventId: r3 } = i4;
      this.events.delete(r3), this.shouldPersist = true;
    }), E$1(this, "setEventListeners", () => {
      this.core.heartbeat.on(r$8.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((i4) => {
          cjs$3.fromMiliseconds(Date.now()) - cjs$3.fromMiliseconds(i4.timestamp) > Wt$1 && (this.events.delete(i4.eventId), this.shouldPersist = true);
        });
      });
    }), E$1(this, "setMethods", (i4) => ({ addTrace: (r3) => this.addTrace(i4, r3), setError: (r3) => this.setError(i4, r3) })), E$1(this, "addTrace", (i4, r3) => {
      const o3 = this.events.get(i4);
      o3 && (o3.props.properties.trace.push(r3), this.events.set(i4, o3), this.shouldPersist = true);
    }), E$1(this, "setError", (i4, r3) => {
      const o3 = this.events.get(i4);
      o3 && (o3.props.type = r3, o3.timestamp = Date.now(), this.events.set(i4, o3), this.shouldPersist = true);
    }), E$1(this, "persist", async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = false;
    }), E$1(this, "restore", async () => {
      try {
        const i4 = await this.core.storage.getItem(this.storageKey) || [];
        if (!i4.length) return;
        i4.forEach((r3) => {
          this.events.set(r3.eventId, pe$1(pe$1({}, r3), this.setMethods(r3.eventId)));
        });
      } catch (i4) {
        this.logger.warn(i4);
      }
    }), E$1(this, "submit", async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const i4 = [];
      for (const [r3, o3] of this.events) o3.props.type && i4.push(o3);
      if (i4.length !== 0) try {
        if ((await this.sendEvent(i4)).ok) for (const r3 of i4) this.events.delete(r3.eventId), this.shouldPersist = true;
      } catch (r3) {
        this.logger.warn(r3);
      }
    }), E$1(this, "sendEvent", async (i4) => {
      const r3 = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${Zt$1}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${De$1}${r3}`, { method: "POST", body: JSON.stringify(i4) });
    }), E$1(this, "getAppDomain", () => Yr$2().url), this.logger = E$7(t2, this.context), this.telemetryEnabled = s2, s2 ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
};
var ro$1 = Object.defineProperty, zi$1 = Object.getOwnPropertySymbols, no$1 = Object.prototype.hasOwnProperty, oo$1 = Object.prototype.propertyIsEnumerable, He$1 = (n5, e3, t2) => e3 in n5 ? ro$1(n5, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : n5[e3] = t2, Li$1 = (n5, e3) => {
  for (var t2 in e3 || (e3 = {})) no$1.call(e3, t2) && He$1(n5, t2, e3[t2]);
  if (zi$1) for (var t2 of zi$1(e3)) oo$1.call(e3, t2) && He$1(n5, t2, e3[t2]);
  return n5;
}, v$1 = (n5, e3, t2) => He$1(n5, typeof e3 != "symbol" ? e3 + "" : e3, t2);
let _e$2 = class _e3 extends h$7 {
  constructor(e3) {
    var t2;
    super(e3), v$1(this, "protocol", Oe$1), v$1(this, "version", Ae$1), v$1(this, "name", le$1), v$1(this, "relayUrl"), v$1(this, "projectId"), v$1(this, "customStoragePrefix"), v$1(this, "events", new eventsExports.EventEmitter()), v$1(this, "logger"), v$1(this, "heartbeat"), v$1(this, "relayer"), v$1(this, "crypto"), v$1(this, "storage"), v$1(this, "history"), v$1(this, "expirer"), v$1(this, "pairing"), v$1(this, "verify"), v$1(this, "echoClient"), v$1(this, "linkModeSupportedApps"), v$1(this, "eventClient"), v$1(this, "initialized", false), v$1(this, "logChunkController"), v$1(this, "on", (o3, a2) => this.events.on(o3, a2)), v$1(this, "once", (o3, a2) => this.events.once(o3, a2)), v$1(this, "off", (o3, a2) => this.events.off(o3, a2)), v$1(this, "removeListener", (o3, a2) => this.events.removeListener(o3, a2)), v$1(this, "dispatchEnvelope", ({ topic: o3, message: a2, sessionExists: c2 }) => {
      if (!o3 || !a2) return;
      const h5 = { topic: o3, message: a2, publishedAt: Date.now(), transportType: Q.link_mode };
      this.relayer.onLinkMessageEvent(h5, { sessionExists: c2 });
    }), this.projectId = e3 == null ? void 0 : e3.projectId, this.relayUrl = (e3 == null ? void 0 : e3.relayUrl) || ze$1, this.customStoragePrefix = e3 != null && e3.customStoragePrefix ? `:${e3.customStoragePrefix}` : "";
    const s2 = k$7({ level: typeof (e3 == null ? void 0 : e3.logger) == "string" && e3.logger ? e3.logger : Dt$1.logger, name: le$1 }), { logger: i4, chunkLoggerController: r3 } = A$4({ opts: s2, maxSizeInBytes: e3 == null ? void 0 : e3.maxLogBlobSizeInBytes, loggerOverride: e3 == null ? void 0 : e3.logger });
    this.logChunkController = r3, (t2 = this.logChunkController) != null && t2.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var o3, a2;
      (o3 = this.logChunkController) != null && o3.downloadLogsBlobInBrowser && ((a2 = this.logChunkController) == null || a2.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E$7(i4, this.name), this.heartbeat = new i$6(), this.crypto = new mi$1(this, this.logger, e3 == null ? void 0 : e3.keychain), this.history = new Si$1(this, this.logger), this.expirer = new Ri$1(this, this.logger), this.storage = e3 != null && e3.storage ? e3.storage : new h$8(Li$1(Li$1({}, ft$1), e3 == null ? void 0 : e3.storageOptions)), this.relayer = new wi$1({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Pi$1(this, this.logger), this.verify = new xi$1(this, this.logger, this.storage), this.echoClient = new Ai$1(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new $i$1(this, this.logger, e3 == null ? void 0 : e3.telemetryEnabled);
  }
  static async init(e3) {
    const t2 = new _e3(e3);
    await t2.initialize();
    const s2 = await t2.crypto.getClientId();
    return await t2.storage.setItem(Nt$1, s2), t2;
  }
  get context() {
    return y$6(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e3;
    return (e3 = this.logChunkController) == null ? void 0 : e3.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e3) {
    this.linkModeSupportedApps.includes(e3) || (this.linkModeSupportedApps.push(e3), await this.storage.setItem(Le$2, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.linkModeSupportedApps = await this.storage.getItem(Le$2) || [], this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e3) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e3), this.logger.error(e3.message), e3;
    }
  }
};
const ao$1 = _e$2;
const xe$1 = "wc", Le$1 = 2, ke$1 = "client", we$1 = `${xe$1}@${Le$1}:${ke$1}:`, _e$1 = { name: ke$1, logger: "error" }, Me$1 = "WALLETCONNECT_DEEPLINK_CHOICE", pt$1 = "proposal", $e$1 = "Proposal expired", ht$1 = "session", z$1 = cjs$3.SEVEN_DAYS, dt$1 = "engine", N$1 = { wc_sessionPropose: { req: { ttl: cjs$3.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: cjs$3.FIVE_MINUTES, prompt: false, tag: 1101 }, reject: { ttl: cjs$3.FIVE_MINUTES, prompt: false, tag: 1120 }, autoReject: { ttl: cjs$3.FIVE_MINUTES, prompt: false, tag: 1121 } }, wc_sessionSettle: { req: { ttl: cjs$3.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: cjs$3.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: cjs$3.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: cjs$3.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: cjs$3.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: cjs$3.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: cjs$3.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: cjs$3.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: cjs$3.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: cjs$3.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: cjs$3.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: cjs$3.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: cjs$3.ONE_DAY, prompt: false, tag: 1114 }, res: { ttl: cjs$3.ONE_DAY, prompt: false, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: cjs$3.ONE_HOUR, prompt: true, tag: 1116 }, res: { ttl: cjs$3.ONE_HOUR, prompt: false, tag: 1117 }, reject: { ttl: cjs$3.FIVE_MINUTES, prompt: false, tag: 1118 }, autoReject: { ttl: cjs$3.FIVE_MINUTES, prompt: false, tag: 1119 } } }, Se$1 = { min: cjs$3.FIVE_MINUTES, max: cjs$3.SEVEN_DAYS }, $$1 = { idle: "IDLE", active: "ACTIVE" }, Fe$1 = { eth_sendTransaction: { key: "" }, eth_sendRawTransaction: { key: "" }, wallet_sendCalls: { key: "" }, solana_signTransaction: { key: "signature" }, solana_signAllTransactions: { key: "transactions" }, solana_signAndSendTransaction: { key: "signature" } }, ut$1 = "request", yt = "wc", mt = "auth", wt = "authKeys", _t$1 = "pairingTopics", St$1 = "requests", ae$1 = `${yt}@${1.5}:${mt}:`, ce$1 = `${ae$1}:PUB_KEY`;
var fs$1 = Object.defineProperty, vs$1 = Object.defineProperties, Is$1 = Object.getOwnPropertyDescriptors, Et$1 = Object.getOwnPropertySymbols, Rs$1 = Object.prototype.hasOwnProperty, Ts$1 = Object.prototype.propertyIsEnumerable, Ue$1 = (E2, r3, e3) => r3 in E2 ? fs$1(E2, r3, { enumerable: true, configurable: true, writable: true, value: e3 }) : E2[r3] = e3, R$1 = (E2, r3) => {
  for (var e3 in r3 || (r3 = {})) Rs$1.call(r3, e3) && Ue$1(E2, e3, r3[e3]);
  if (Et$1) for (var e3 of Et$1(r3)) Ts$1.call(r3, e3) && Ue$1(E2, e3, r3[e3]);
  return E2;
}, V$1 = (E2, r3) => vs$1(E2, Is$1(r3)), c = (E2, r3, e3) => Ue$1(E2, typeof r3 != "symbol" ? r3 + "" : r3, e3);
let qs$1 = class qs3 extends V$a {
  constructor(r3) {
    super(r3), c(this, "name", dt$1), c(this, "events", new wt$7()), c(this, "initialized", false), c(this, "requestQueue", { state: $$1.idle, queue: [] }), c(this, "sessionRequestQueue", { state: $$1.idle, queue: [] }), c(this, "requestQueueDelay", cjs$3.ONE_SECOND), c(this, "expectedPairingMethodMap", /* @__PURE__ */ new Map()), c(this, "recentlyDeletedMap", /* @__PURE__ */ new Map()), c(this, "recentlyDeletedLimit", 200), c(this, "relayMessageCache", []), c(this, "pendingSessions", /* @__PURE__ */ new Map()), c(this, "lastSessionCheckTime"), c(this, "isCheckingSession", false), c(this, "sessionCreationTimes", /* @__PURE__ */ new Map()), c(this, "firstDAppEntryAfterSession", /* @__PURE__ */ new Map()), c(this, "init", async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(N$1) }), this.initializeMobileSessionDetection(), this.initialized = true, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, cjs$3.toMiliseconds(this.requestQueueDelay)));
    }), c(this, "connect", async (e3) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const t2 = V$1(R$1({}, e3), { requiredNamespaces: e3.requiredNamespaces || {}, optionalNamespaces: e3.optionalNamespaces || {} });
      await this.isValidConnect(t2);
      const { pairingTopic: s2, requiredNamespaces: i4, optionalNamespaces: n5, sessionProperties: o3, relays: a2 } = t2;
      let l2 = s2, h5, g2 = false;
      try {
        if (l2) {
          const f6 = this.client.core.pairing.pairings.get(l2);
          this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."), g2 = f6.active;
        }
      } catch (f6) {
        throw this.client.logger.error(`connect() -> pairing.get(${l2}) failed`), f6;
      }
      if (!l2 || !g2) {
        const { topic: f6, uri: x2 } = await this.client.core.pairing.create();
        l2 = f6, h5 = x2;
      }
      if (!l2) {
        const { message: f6 } = te$1("NO_MATCHING_KEY", `connect() pairing topic: ${l2}`);
        throw new Error(f6);
      }
      const d4 = await this.client.core.crypto.generateKeyPair(), u2 = N$1.wc_sessionPropose.req.ttl || cjs$3.FIVE_MINUTES, y4 = ho$1(u2), w2 = V$1(R$1({ requiredNamespaces: i4, optionalNamespaces: n5, relays: a2 ?? [{ protocol: Pt }], proposer: { publicKey: d4, metadata: this.client.metadata }, expiryTimestamp: y4, pairingTopic: l2 }, o3 && { sessionProperties: o3 }), { id: payloadId() }), I4 = go$1("session_connect", w2.id), { reject: p2, resolve: S4, done: D2 } = co$1(u2, $e$1), T2 = ({ id: f6 }) => {
        f6 === w2.id && (this.client.events.off("proposal_expire", T2), this.pendingSessions.delete(w2.id), this.events.emit(I4, { error: { message: $e$1, code: 0 } }));
      };
      return this.client.events.on("proposal_expire", T2), this.events.once(I4, ({ error: f6, session: x2 }) => {
        this.client.events.off("proposal_expire", T2), f6 ? p2(f6) : x2 && S4(x2);
      }), await this.sendRequest({ topic: l2, method: "wc_sessionPropose", params: w2, throwOnFailedPublish: true, clientRpcId: w2.id }), await this.setProposal(w2.id, w2), { uri: h5, approval: D2 };
    }), c(this, "pair", async (e3) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(e3);
      } catch (t2) {
        throw this.client.logger.error("pair() failed"), t2;
      }
    }), c(this, "approve", async (e3) => {
      var t2, s2, i4;
      const n5 = this.client.core.eventClient.createEvent({ properties: { topic: (t2 = e3 == null ? void 0 : e3.id) == null ? void 0 : t2.toString(), trace: [js$1.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (P3) {
        throw n5.setError(qs$2.no_internet_connection), P3;
      }
      try {
        await this.isValidProposalId(e3 == null ? void 0 : e3.id);
      } catch (P3) {
        throw this.client.logger.error(`approve() -> proposal.get(${e3 == null ? void 0 : e3.id}) failed`), n5.setError(qs$2.proposal_not_found), P3;
      }
      try {
        await this.isValidApprove(e3);
      } catch (P3) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), n5.setError(qs$2.session_approve_namespace_validation_failure), P3;
      }
      const { id: o3, relayProtocol: a2, namespaces: l2, sessionProperties: h5, sessionConfig: g2 } = e3, d4 = this.client.proposal.get(o3);
      this.client.core.eventClient.deleteEvent({ eventId: n5.eventId });
      const { pairingTopic: u2, proposer: y4, requiredNamespaces: w2, optionalNamespaces: I4 } = d4;
      let p2 = (s2 = this.client.core.eventClient) == null ? void 0 : s2.getEvent({ topic: u2 });
      p2 || (p2 = (i4 = this.client.core.eventClient) == null ? void 0 : i4.createEvent({ type: js$1.session_approve_started, properties: { topic: u2, trace: [js$1.session_approve_started, js$1.session_namespaces_validation_success] } }));
      const S4 = await this.client.core.crypto.generateKeyPair(), D2 = y4.publicKey, T2 = await this.client.core.crypto.generateSharedKey(S4, D2), f6 = R$1(R$1({ relay: { protocol: a2 ?? "irn" }, namespaces: l2, controller: { publicKey: S4, metadata: this.client.metadata }, expiry: ho$1(z$1) }, h5 && { sessionProperties: h5 }), g2 && { sessionConfig: g2 }), x2 = Q.relay;
      p2.addTrace(js$1.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(T2, { transportType: x2 });
      } catch (P3) {
        throw p2.setError(qs$2.subscribe_session_topic_failure), P3;
      }
      p2.addTrace(js$1.subscribe_session_topic_success);
      const Z3 = V$1(R$1({}, f6), { topic: T2, requiredNamespaces: w2, optionalNamespaces: I4, pairingTopic: u2, acknowledged: false, self: f6.controller, peer: { publicKey: y4.publicKey, metadata: y4.metadata }, controller: S4, transportType: Q.relay });
      await this.client.session.set(T2, Z3), p2.addTrace(js$1.store_session);
      try {
        p2.addTrace(js$1.publishing_session_settle), await this.sendRequest({ topic: T2, method: "wc_sessionSettle", params: f6, throwOnFailedPublish: true }).catch((P3) => {
          throw p2 == null ? void 0 : p2.setError(qs$2.session_settle_publish_failure), P3;
        }), p2.addTrace(js$1.session_settle_publish_success), p2.addTrace(js$1.publishing_session_approve), await this.sendResult({ id: o3, topic: u2, result: { relay: { protocol: a2 ?? "irn" }, responderPublicKey: S4 }, throwOnFailedPublish: true }).catch((P3) => {
          throw p2 == null ? void 0 : p2.setError(qs$2.session_approve_publish_failure), P3;
        }), p2.addTrace(js$1.session_approve_publish_success);
      } catch (P3) {
        throw this.client.logger.error(P3), this.client.session.delete(T2, de$2("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(T2), P3;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: p2.eventId }), await this.client.core.pairing.updateMetadata({ topic: u2, metadata: y4.metadata }), await this.client.proposal.delete(o3, de$2("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: u2 }), await this.setExpiry(T2, ho$1(z$1)), { topic: T2, acknowledged: () => Promise.resolve(this.client.session.get(T2)) };
    }), c(this, "reject", async (e3) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(e3);
      } catch (n5) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), n5;
      }
      const { id: t2, reason: s2 } = e3;
      let i4;
      try {
        i4 = this.client.proposal.get(t2).pairingTopic;
      } catch (n5) {
        throw this.client.logger.error(`reject() -> proposal.get(${t2}) failed`), n5;
      }
      i4 && (await this.sendError({ id: t2, topic: i4, error: s2, rpcOpts: N$1.wc_sessionPropose.reject }), await this.client.proposal.delete(t2, de$2("USER_DISCONNECTED")));
    }), c(this, "update", async (e3) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(e3);
      } catch (g2) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), g2;
      }
      const { topic: t2, namespaces: s2 } = e3, { done: i4, resolve: n5, reject: o3 } = co$1(), a2 = payloadId(), l2 = getBigIntRpcId().toString(), h5 = this.client.session.get(t2).namespaces;
      return this.events.once(go$1("session_update", a2), ({ error: g2 }) => {
        g2 ? o3(g2) : n5();
      }), await this.client.session.update(t2, { namespaces: s2 }), await this.sendRequest({ topic: t2, method: "wc_sessionUpdate", params: { namespaces: s2 }, throwOnFailedPublish: true, clientRpcId: a2, relayRpcId: l2 }).catch((g2) => {
        this.client.logger.error(g2), this.client.session.update(t2, { namespaces: h5 }), o3(g2);
      }), { acknowledged: i4 };
    }), c(this, "extend", async (e3) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(e3);
      } catch (a2) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), a2;
      }
      const { topic: t2 } = e3, s2 = payloadId(), { done: i4, resolve: n5, reject: o3 } = co$1();
      return this.events.once(go$1("session_extend", s2), ({ error: a2 }) => {
        a2 ? o3(a2) : n5();
      }), await this.setExpiry(t2, ho$1(z$1)), this.sendRequest({ topic: t2, method: "wc_sessionExtend", params: {}, clientRpcId: s2, throwOnFailedPublish: true }).catch((a2) => {
        o3(a2);
      }), { acknowledged: i4 };
    }), c(this, "request", async (e3) => {
      this.isInitialized();
      try {
        await this.isValidRequest(e3);
      } catch (p2) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), p2;
      }
      const { chainId: t2, request: s2, topic: i4, expiry: n5 = N$1.wc_sessionRequest.req.ttl } = e3, o3 = this.client.session.get(i4);
      (o3 == null ? void 0 : o3.transportType) === Q.relay && await this.confirmOnlineStateOrThrow();
      const a2 = payloadId(), l2 = getBigIntRpcId().toString(), { done: h5, resolve: g2, reject: d4 } = co$1(n5, "Request expired. Please try again.");
      this.events.once(go$1("session_request", a2), ({ error: p2, result: S4 }) => {
        p2 ? d4(p2) : g2(S4);
      });
      const u2 = "wc_sessionRequest", y4 = this.getAppLinkIfEnabled(o3.peer.metadata, o3.transportType);
      if (y4) return await this.sendRequest({ clientRpcId: a2, relayRpcId: l2, topic: i4, method: u2, params: { request: V$1(R$1({}, s2), { expiryTimestamp: ho$1(n5) }), chainId: t2 }, expiry: n5, throwOnFailedPublish: true, appLink: y4 }).catch((p2) => d4(p2)), this.client.events.emit("session_request_sent", { topic: i4, request: s2, chainId: t2, id: a2 }), await h5();
      const w2 = { request: V$1(R$1({}, s2), { expiryTimestamp: ho$1(n5) }), chainId: t2 }, I4 = this.shouldSetTVF(u2, w2);
      return await Promise.all([new Promise(async (p2) => {
        await this.sendRequest(R$1({ clientRpcId: a2, relayRpcId: l2, topic: i4, method: u2, params: w2, expiry: n5, throwOnFailedPublish: true }, I4 && { tvf: this.getTVFParams(a2, w2) })).catch((S4) => d4(S4)), this.client.events.emit("session_request_sent", { topic: i4, request: s2, chainId: t2, id: a2 }), p2();
      }), new Promise(async (p2) => {
        var S4;
        if (!((S4 = o3.sessionConfig) != null && S4.disableDeepLink)) {
          const D2 = await mo$1(this.client.core.storage, Me$1);
          await yo$1({ id: a2, topic: i4, wcDeepLink: D2 });
        }
        p2();
      }), h5()]).then((p2) => p2[2]);
    }), c(this, "respond", async (e3) => {
      this.isInitialized(), await this.isValidRespond(e3);
      const { topic: t2, response: s2 } = e3, { id: i4 } = s2, n5 = this.client.session.get(t2);
      n5.transportType === Q.relay && await this.confirmOnlineStateOrThrow();
      const o3 = this.getAppLinkIfEnabled(n5.peer.metadata, n5.transportType);
      isJsonRpcResult(s2) ? await this.sendResult({ id: i4, topic: t2, result: s2.result, throwOnFailedPublish: true, appLink: o3 }) : isJsonRpcError(s2) && await this.sendError({ id: i4, topic: t2, error: s2.error, appLink: o3 }), this.cleanupAfterResponse(e3);
    }), c(this, "ping", async (e3) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(e3);
      } catch (s2) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), s2;
      }
      const { topic: t2 } = e3;
      if (this.client.session.keys.includes(t2)) {
        const s2 = payloadId(), i4 = getBigIntRpcId().toString(), { done: n5, resolve: o3, reject: a2 } = co$1();
        this.events.once(go$1("session_ping", s2), ({ error: l2 }) => {
          l2 ? a2(l2) : o3();
        }), await Promise.all([this.sendRequest({ topic: t2, method: "wc_sessionPing", params: {}, throwOnFailedPublish: true, clientRpcId: s2, relayRpcId: i4 }), n5()]);
      } else this.client.core.pairing.pairings.keys.includes(t2) && (this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."), await this.client.core.pairing.ping({ topic: t2 }));
    }), c(this, "emit", async (e3) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(e3);
      const { topic: t2, event: s2, chainId: i4 } = e3, n5 = getBigIntRpcId().toString(), o3 = payloadId();
      await this.sendRequest({ topic: t2, method: "wc_sessionEvent", params: { event: s2, chainId: i4 }, throwOnFailedPublish: true, relayRpcId: n5, clientRpcId: o3 });
    }), c(this, "disconnect", async (e3) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(e3);
      const { topic: t2 } = e3;
      if (this.client.session.keys.includes(t2)) await this.sendRequest({ topic: t2, method: "wc_sessionDelete", params: de$2("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession({ topic: t2, emitEvent: false });
      else if (this.client.core.pairing.pairings.keys.includes(t2)) await this.client.core.pairing.disconnect({ topic: t2 });
      else {
        const { message: s2 } = te$1("MISMATCHED_TOPIC", `Session or pairing topic not found: ${t2}`);
        throw new Error(s2);
      }
    }), c(this, "find", (e3) => (this.isInitialized(), this.client.session.getAll().filter((t2) => $i$2(t2, e3)))), c(this, "getPendingSessionRequests", () => this.client.pendingRequest.getAll()), c(this, "authenticate", async (e3, t2) => {
      var s2;
      this.isInitialized(), this.isValidAuthenticate(e3);
      const i4 = t2 && this.client.core.linkModeSupportedApps.includes(t2) && ((s2 = this.client.metadata.redirect) == null ? void 0 : s2.linkMode), n5 = i4 ? Q.link_mode : Q.relay;
      n5 === Q.relay && await this.confirmOnlineStateOrThrow();
      const { chains: o3, statement: a2 = "", uri: l2, domain: h5, nonce: g2, type: d4, exp: u2, nbf: y4, methods: w2 = [], expiry: I4 } = e3, p2 = [...e3.resources || []], { topic: S4, uri: D2 } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: n5 });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: S4, uri: D2 } });
      const T2 = await this.client.core.crypto.generateKeyPair(), f6 = oi$2(T2);
      if (await Promise.all([this.client.auth.authKeys.set(ce$1, { responseTopic: f6, publicKey: T2 }), this.client.auth.pairingTopics.set(f6, { topic: f6, pairingTopic: S4 })]), await this.client.core.relayer.subscribe(f6, { transportType: n5 }), this.client.logger.info(`sending request to new pairing topic: ${S4}`), w2.length > 0) {
        const { namespace: A2 } = Ye$1(o3[0]);
        let L4 = ts$1(A2, "request", w2);
        Me$3(p2) && (L4 = ns$1(L4, p2.pop())), p2.push(L4);
      }
      const x2 = I4 && I4 > N$1.wc_sessionAuthenticate.req.ttl ? I4 : N$1.wc_sessionAuthenticate.req.ttl, Z3 = { authPayload: { type: d4 ?? "caip122", chains: o3, statement: a2, aud: l2, domain: h5, version: "1", nonce: g2, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: u2, nbf: y4, resources: p2 }, requester: { publicKey: T2, metadata: this.client.metadata }, expiryTimestamp: ho$1(x2) }, P3 = { eip155: { chains: o3, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...w2])], events: ["chainChanged", "accountsChanged"] } }, X2 = { requiredNamespaces: {}, optionalNamespaces: P3, relays: [{ protocol: "irn" }], pairingTopic: S4, proposer: { publicKey: T2, metadata: this.client.metadata }, expiryTimestamp: ho$1(N$1.wc_sessionPropose.req.ttl), id: payloadId() }, { done: vt2, resolve: Ge2, reject: fe2 } = co$1(x2, "Request expired"), ee2 = payloadId(), le2 = go$1("session_connect", X2.id), ve2 = go$1("session_request", ee2), pe2 = async ({ error: A2, session: L4 }) => {
        this.events.off(ve2, Ie2), A2 ? fe2(A2) : L4 && Ge2({ session: L4 });
      }, Ie2 = async (A2) => {
        var L4, je2, Qe2;
        if (await this.deletePendingAuthRequest(ee2, { message: "fulfilled", code: 0 }), A2.error) {
          const se2 = de$2("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return A2.error.code === se2.code ? void 0 : (this.events.off(le2, pe2), fe2(A2.error.message));
        }
        await this.deleteProposal(X2.id), this.events.off(le2, pe2);
        const { cacaos: Ye2, responder: Q$12 } = A2.result, Te2 = [], He2 = [];
        for (const se2 of Ye2) {
          await Yo$1({ cacao: se2, projectId: this.client.core.projectId }) || (this.client.logger.error(se2, "Signature verification failed"), fe2(de$2("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: qe2 } = se2, Ne2 = Me$3(qe2.resources), ze2 = [On$2(qe2.iss)], It2 = ut$2(qe2.iss);
          if (Ne2) {
            const Pe2 = rs$1(Ne2), Rt2 = os$1(Ne2);
            Te2.push(...Pe2), ze2.push(...Rt2);
          }
          for (const Pe2 of ze2) He2.push(`${Pe2}:${It2}`);
        }
        const te2 = await this.client.core.crypto.generateSharedKey(T2, Q$12.publicKey);
        let he2;
        Te2.length > 0 && (he2 = { topic: te2, acknowledged: true, self: { publicKey: T2, metadata: this.client.metadata }, peer: Q$12, controller: Q$12.publicKey, expiry: ho$1(z$1), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: S4, namespaces: Ti$2([...new Set(Te2)], [...new Set(He2)]), transportType: n5 }, await this.client.core.relayer.subscribe(te2, { transportType: n5 }), await this.client.session.set(te2, he2), S4 && await this.client.core.pairing.updateMetadata({ topic: S4, metadata: Q$12.metadata }), he2 = this.client.session.get(te2)), (L4 = this.client.metadata.redirect) != null && L4.linkMode && (je2 = Q$12.metadata.redirect) != null && je2.linkMode && (Qe2 = Q$12.metadata.redirect) != null && Qe2.universal && t2 && (this.client.core.addLinkModeSupportedApp(Q$12.metadata.redirect.universal), this.client.session.update(te2, { transportType: Q.link_mode })), Ge2({ auths: Ye2, session: he2 });
      };
      this.events.once(le2, pe2), this.events.once(ve2, Ie2);
      let Re2;
      try {
        if (i4) {
          const A2 = formatJsonRpcRequest("wc_sessionAuthenticate", Z3, ee2);
          this.client.core.history.set(S4, A2);
          const L4 = await this.client.core.crypto.encode("", A2, { type: _e$3, encoding: Qs$2 });
          Re2 = Ei$2(t2, S4, L4);
        } else await Promise.all([this.sendRequest({ topic: S4, method: "wc_sessionAuthenticate", params: Z3, expiry: e3.expiry, throwOnFailedPublish: true, clientRpcId: ee2 }), this.sendRequest({ topic: S4, method: "wc_sessionPropose", params: X2, expiry: N$1.wc_sessionPropose.req.ttl, throwOnFailedPublish: true, clientRpcId: X2.id })]);
      } catch (A2) {
        throw this.events.off(le2, pe2), this.events.off(ve2, Ie2), A2;
      }
      return await this.setProposal(X2.id, X2), await this.setAuthRequest(ee2, { request: V$1(R$1({}, Z3), { verifyContext: {} }), pairingTopic: S4, transportType: n5 }), { uri: Re2 ?? D2, response: vt2 };
    }), c(this, "approveSessionAuthenticate", async (e3) => {
      const { id: t2, auths: s2 } = e3, i4 = this.client.core.eventClient.createEvent({ properties: { topic: t2.toString(), trace: [Gs$1.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (I4) {
        throw i4.setError(Hs$1.no_internet_connection), I4;
      }
      const n5 = this.getPendingAuthRequest(t2);
      if (!n5) throw i4.setError(Hs$1.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${t2}`);
      const o3 = n5.transportType || Q.relay;
      o3 === Q.relay && await this.confirmOnlineStateOrThrow();
      const a2 = n5.requester.publicKey, l2 = await this.client.core.crypto.generateKeyPair(), h5 = oi$2(a2), g2 = { type: Ie$1, receiverPublicKey: a2, senderPublicKey: l2 }, d4 = [], u2 = [];
      for (const I4 of s2) {
        if (!await Yo$1({ cacao: I4, projectId: this.client.core.projectId })) {
          i4.setError(Hs$1.invalid_cacao);
          const f6 = de$2("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: t2, topic: h5, error: f6, encodeOpts: g2 }), new Error(f6.message);
        }
        i4.addTrace(Gs$1.cacaos_verified);
        const { p: p2 } = I4, S4 = Me$3(p2.resources), D2 = [On$2(p2.iss)], T2 = ut$2(p2.iss);
        if (S4) {
          const f6 = rs$1(S4), x2 = os$1(S4);
          d4.push(...f6), D2.push(...x2);
        }
        for (const f6 of D2) u2.push(`${f6}:${T2}`);
      }
      const y4 = await this.client.core.crypto.generateSharedKey(l2, a2);
      i4.addTrace(Gs$1.create_authenticated_session_topic);
      let w2;
      if ((d4 == null ? void 0 : d4.length) > 0) {
        w2 = { topic: y4, acknowledged: true, self: { publicKey: l2, metadata: this.client.metadata }, peer: { publicKey: a2, metadata: n5.requester.metadata }, controller: a2, expiry: ho$1(z$1), authentication: s2, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: n5.pairingTopic, namespaces: Ti$2([...new Set(d4)], [...new Set(u2)]), transportType: o3 }, i4.addTrace(Gs$1.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(y4, { transportType: o3 });
        } catch (I4) {
          throw i4.setError(Hs$1.subscribe_authenticated_session_topic_failure), I4;
        }
        i4.addTrace(Gs$1.subscribe_authenticated_session_topic_success), await this.client.session.set(y4, w2), i4.addTrace(Gs$1.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: n5.pairingTopic, metadata: n5.requester.metadata });
      }
      i4.addTrace(Gs$1.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: h5, id: t2, result: { cacaos: s2, responder: { publicKey: l2, metadata: this.client.metadata } }, encodeOpts: g2, throwOnFailedPublish: true, appLink: this.getAppLinkIfEnabled(n5.requester.metadata, o3) });
      } catch (I4) {
        throw i4.setError(Hs$1.authenticated_session_approve_publish_failure), I4;
      }
      return await this.client.auth.requests.delete(t2, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: n5.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: i4.eventId }), { session: w2 };
    }), c(this, "rejectSessionAuthenticate", async (e3) => {
      this.isInitialized();
      const { id: t2, reason: s2 } = e3, i4 = this.getPendingAuthRequest(t2);
      if (!i4) throw new Error(`Could not find pending auth request with id ${t2}`);
      i4.transportType === Q.relay && await this.confirmOnlineStateOrThrow();
      const n5 = i4.requester.publicKey, o3 = await this.client.core.crypto.generateKeyPair(), a2 = oi$2(n5), l2 = { type: Ie$1, receiverPublicKey: n5, senderPublicKey: o3 };
      await this.sendError({ id: t2, topic: a2, error: s2, encodeOpts: l2, rpcOpts: N$1.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(i4.requester.metadata, i4.transportType) }), await this.client.auth.requests.delete(t2, { message: "rejected", code: 0 }), await this.client.proposal.delete(t2, de$2("USER_DISCONNECTED"));
    }), c(this, "formatAuthMessage", (e3) => {
      this.isInitialized();
      const { request: t2, iss: s2 } = e3;
      return In$2(t2, s2);
    }), c(this, "processRelayMessageCache", () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
          const e3 = this.relayMessageCache.shift();
          e3 && await this.onRelayMessage(e3);
        } catch (e3) {
          this.client.logger.error(e3);
        }
      }, 50);
    }), c(this, "cleanupDuplicatePairings", async (e3) => {
      if (e3.pairingTopic) try {
        const t2 = this.client.core.pairing.pairings.get(e3.pairingTopic), s2 = this.client.core.pairing.pairings.getAll().filter((i4) => {
          var n5, o3;
          return ((n5 = i4.peerMetadata) == null ? void 0 : n5.url) && ((o3 = i4.peerMetadata) == null ? void 0 : o3.url) === e3.peer.metadata.url && i4.topic && i4.topic !== t2.topic;
        });
        if (s2.length === 0) return;
        this.client.logger.info(`Cleaning up ${s2.length} duplicate pairing(s)`), await Promise.all(s2.map((i4) => this.client.core.pairing.disconnect({ topic: i4.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (t2) {
        this.client.logger.error(t2);
      }
    }), c(this, "deleteSession", async (e3) => {
      var t2;
      const { topic: s2, expirerHasDeleted: i4 = false, emitEvent: n5 = true, id: o3 = 0 } = e3, { self: a2 } = this.client.session.get(s2);
      await this.client.core.relayer.unsubscribe(s2), await this.client.session.delete(s2, de$2("USER_DISCONNECTED")), this.cleanupSessionActivity(s2), this.addToRecentlyDeleted(s2, "session"), this.client.core.crypto.keychain.has(a2.publicKey) && await this.client.core.crypto.deleteKeyPair(a2.publicKey), this.client.core.crypto.keychain.has(s2) && await this.client.core.crypto.deleteSymKey(s2), i4 || this.client.core.expirer.del(s2), this.client.core.storage.removeItem(Me$1).catch((l2) => this.client.logger.warn(l2)), this.getPendingSessionRequests().forEach((l2) => {
        l2.topic === s2 && this.deletePendingSessionRequest(l2.id, de$2("USER_DISCONNECTED"));
      }), s2 === ((t2 = this.sessionRequestQueue.queue[0]) == null ? void 0 : t2.topic) && (this.sessionRequestQueue.state = $$1.idle), n5 && this.client.events.emit("session_delete", { id: o3, topic: s2 });
    }), c(this, "deleteProposal", async (e3, t2) => {
      if (t2) try {
        const s2 = this.client.proposal.get(e3), i4 = this.client.core.eventClient.getEvent({ topic: s2.pairingTopic });
        i4 == null ? void 0 : i4.setError(qs$2.proposal_expired);
      } catch {
      }
      await Promise.all([this.client.proposal.delete(e3, de$2("USER_DISCONNECTED")), t2 ? Promise.resolve() : this.client.core.expirer.del(e3)]), this.addToRecentlyDeleted(e3, "proposal");
    }), c(this, "deletePendingSessionRequest", async (e3, t2, s2 = false) => {
      await Promise.all([this.client.pendingRequest.delete(e3, t2), s2 ? Promise.resolve() : this.client.core.expirer.del(e3)]), this.addToRecentlyDeleted(e3, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i4) => i4.id !== e3), s2 && (this.sessionRequestQueue.state = $$1.idle, this.client.events.emit("session_request_expire", { id: e3 }));
    }), c(this, "deletePendingAuthRequest", async (e3, t2, s2 = false) => {
      await Promise.all([this.client.auth.requests.delete(e3, t2), s2 ? Promise.resolve() : this.client.core.expirer.del(e3)]);
    }), c(this, "setExpiry", async (e3, t2) => {
      this.client.session.keys.includes(e3) && (this.client.core.expirer.set(e3, t2), await this.client.session.update(e3, { expiry: t2 }));
    }), c(this, "setProposal", async (e3, t2) => {
      this.client.core.expirer.set(e3, ho$1(N$1.wc_sessionPropose.req.ttl)), await this.client.proposal.set(e3, t2);
    }), c(this, "setAuthRequest", async (e3, t2) => {
      const { request: s2, pairingTopic: i4, transportType: n5 = Q.relay } = t2;
      this.client.core.expirer.set(e3, s2.expiryTimestamp), await this.client.auth.requests.set(e3, { authPayload: s2.authPayload, requester: s2.requester, expiryTimestamp: s2.expiryTimestamp, id: e3, pairingTopic: i4, verifyContext: s2.verifyContext, transportType: n5 });
    }), c(this, "setPendingSessionRequest", async (e3) => {
      const { id: t2, topic: s2, params: i4, verifyContext: n5 } = e3, o3 = i4.request.expiryTimestamp || ho$1(N$1.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(t2, o3), await this.client.pendingRequest.set(t2, { id: t2, topic: s2, params: i4, verifyContext: n5 });
    }), c(this, "sendRequest", async (e3) => {
      const { topic: t2, method: s2, params: i4, expiry: n5, relayRpcId: o3, clientRpcId: a2, throwOnFailedPublish: l2, appLink: h5, tvf: g2 } = e3, d4 = formatJsonRpcRequest(s2, i4, a2);
      let u2;
      const y4 = !!h5;
      try {
        const p2 = y4 ? Qs$2 : At$2;
        u2 = await this.client.core.crypto.encode(t2, d4, { encoding: p2 });
      } catch (p2) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t2} failed`), p2;
      }
      let w2;
      const I4 = N$1[s2].req;
      if (I4.attestation = w2, n5 && (I4.ttl = n5), o3 && (I4.id = o3), this.client.core.history.set(t2, d4), y4) {
        if (t2 && h5) {
          const p2 = Ei$2(h5, t2, u2);
          await global$1.Linking.openURL(p2, this.client.name);
        }
      } else {
        const p2 = N$1[s2].req;
        n5 && (p2.ttl = n5), o3 && (p2.id = o3), p2.tvf = V$1(R$1({}, g2), { correlationId: d4.id }), l2 ? (p2.internal = V$1(R$1({}, p2.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(t2, u2, p2)) : this.client.core.relayer.publish(t2, u2, p2).catch((S4) => this.client.logger.error(S4));
      }
      return d4.id;
    }), c(this, "sendResult", async (e3) => {
      const { id: t2, topic: s2, result: i4, throwOnFailedPublish: n5, encodeOpts: o3, appLink: a2 } = e3, l2 = formatJsonRpcResult(t2, i4);
      let h5;
      const g2 = a2 && typeof (global$1 == null ? void 0 : global$1.Linking) < "u";
      try {
        const y4 = g2 ? Qs$2 : At$2;
        h5 = await this.client.core.crypto.encode(s2, l2, V$1(R$1({}, o3 || {}), { encoding: y4 }));
      } catch (y4) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s2} failed`), y4;
      }
      let d4, u2;
      try {
        d4 = await this.client.core.history.get(s2, t2);
        const y4 = d4.request;
        try {
          this.shouldSetTVF(y4.method, y4.params) && (u2 = this.getTVFParams(t2, y4.params, i4));
        } catch (w2) {
          this.client.logger.warn("sendResult() -> getTVFParams() failed", w2);
        }
      } catch (y4) {
        throw this.client.logger.error(`sendResult() -> history.get(${s2}, ${t2}) failed`), y4;
      }
      if (g2) {
        if (s2 && a2) {
          const y4 = Ei$2(a2, s2, h5);
          await global$1.Linking.openURL(y4, this.client.name);
        }
      } else {
        const y4 = d4.request.method, w2 = N$1[y4].res;
        w2.tvf = V$1(R$1({}, u2), { correlationId: t2 }), n5 ? (w2.internal = V$1(R$1({}, w2.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s2, h5, w2)) : this.client.core.relayer.publish(s2, h5, w2).catch((I4) => this.client.logger.error(I4));
      }
      await this.client.core.history.resolve(l2);
    }), c(this, "sendError", async (e3) => {
      const { id: t2, topic: s2, error: i4, encodeOpts: n5, rpcOpts: o3, appLink: a2 } = e3, l2 = formatJsonRpcError(t2, i4);
      let h5;
      const g2 = a2 && typeof (global$1 == null ? void 0 : global$1.Linking) < "u";
      try {
        const u2 = g2 ? Qs$2 : At$2;
        h5 = await this.client.core.crypto.encode(s2, l2, V$1(R$1({}, n5 || {}), { encoding: u2 }));
      } catch (u2) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s2} failed`), u2;
      }
      let d4;
      try {
        d4 = await this.client.core.history.get(s2, t2);
      } catch (u2) {
        throw this.client.logger.error(`sendError() -> history.get(${s2}, ${t2}) failed`), u2;
      }
      if (g2) {
        if (s2 && a2) {
          const u2 = Ei$2(a2, s2, h5);
          await global$1.Linking.openURL(u2, this.client.name);
        }
      } else {
        const u2 = d4.request.method, y4 = o3 || N$1[u2].res;
        this.client.core.relayer.publish(s2, h5, y4);
      }
      await this.client.core.history.resolve(l2);
    }), c(this, "cleanup", async () => {
      const e3 = [], t2 = [], s2 = this.client.session.getAll();
      for (const i4 of s2) {
        let n5 = false;
        po$1(i4.expiry) && (n5 = true, this.client.logger.info(`Session ${i4.topic} expired`)), this.client.core.crypto.keychain.has(i4.topic) || (n5 = true, this.client.logger.info(`Session ${i4.topic} missing crypto keys`)), n5 ? e3.push(i4.topic) : console.log(` [ENGINE] Session ${i4.topic.substring(0, 8)}... passed all validations`);
      }
      this.client.proposal.getAll().forEach((i4) => {
        po$1(i4.expiryTimestamp) && t2.push(i4.id);
      }), e3.length > 0 && (this.client.logger.info(`Cleaning up ${e3.length} invalid sessions`), await Promise.all([...e3.map((i4) => this.deleteSession({ topic: i4 })), ...t2.map((i4) => this.deleteProposal(i4))]));
    }), c(this, "onRelayEventRequest", async (e3) => {
      this.requestQueue.queue.push(e3), await this.processRequestsQueue();
    }), c(this, "processRequestsQueue", async () => {
      if (this.requestQueue.state === $$1.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = $$1.active;
        const e3 = this.requestQueue.queue.shift();
        if (e3) try {
          await this.processRequest(e3), console.log("Processing request done, now iterate");
        } catch (t2) {
          this.client.logger.warn(`Error processing request: ${t2}`);
        }
      }
      this.requestQueue.state = $$1.idle, console.log(`Processing request queue finised, state; ${this.requestQueue.state}`);
    }), c(this, "processRequest", async (e3) => {
      const { topic: t2, payload: s2, attestation: i4, transportType: n5, encryptedId: o3 } = e3, a2 = s2.method;
      if (!this.shouldIgnorePairingRequest({ topic: t2, requestMethod: a2 })) switch (a2) {
        case "wc_sessionPropose":
          return await this.onSessionProposeRequest({ topic: t2, payload: s2, attestation: i4, encryptedId: o3 });
        case "wc_sessionSettle":
          return await this.onSessionSettleRequest(t2, s2);
        case "wc_sessionUpdate":
          return await this.onSessionUpdateRequest(t2, s2);
        case "wc_sessionExtend":
          return await this.onSessionExtendRequest(t2, s2);
        case "wc_sessionPing":
          return await this.onSessionPingRequest(t2, s2);
        case "wc_sessionDelete":
          return await this.onSessionDeleteRequest(t2, s2);
        case "wc_sessionRequest":
          return await this.onSessionRequest({ topic: t2, payload: s2, attestation: i4, encryptedId: o3, transportType: n5 });
        case "wc_sessionEvent":
          return await this.onSessionEventRequest(t2, s2);
        case "wc_sessionAuthenticate":
          return await this.onSessionAuthenticateRequest({ topic: t2, payload: s2, attestation: i4, encryptedId: o3, transportType: n5 });
        default:
          return this.client.logger.info(`Unsupported request method ${a2}`);
      }
    }), c(this, "onRelayEventResponse", async (e3) => {
      const { topic: t2, payload: s2, transportType: i4 } = e3, n5 = (await this.client.core.history.get(t2, s2.id)).request.method;
      switch (n5) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(t2, s2, i4);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(t2, s2);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(t2, s2);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(t2, s2);
        case "wc_sessionPing":
          return this.onSessionPingResponse(t2, s2);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(t2, s2);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(t2, s2);
        default:
          return this.client.logger.info(`Unsupported response method ${n5}`);
      }
    }), c(this, "onRelayEventUnknownPayload", (e3) => {
      const { topic: t2 } = e3, { message: s2 } = te$1("MISSING_OR_INVALID", `Decoded payload on topic ${t2} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(s2);
    }), c(this, "shouldIgnorePairingRequest", (e3) => {
      const { topic: t2, requestMethod: s2 } = e3, i4 = this.expectedPairingMethodMap.get(t2);
      return !i4 || i4.includes(s2) ? false : !!(i4.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }), c(this, "onSessionProposeRequest", async (e3) => {
      const { topic: t2, payload: s2, attestation: i4, encryptedId: n5 } = e3, { params: o3, id: a2 } = s2;
      try {
        const l2 = this.client.core.eventClient.getEvent({ topic: t2 });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), l2 == null ? void 0 : l2.setError(J$1.proposal_listener_not_found)), this.isValidConnect(R$1({}, s2.params));
        const h5 = o3.expiryTimestamp || ho$1(N$1.wc_sessionPropose.req.ttl), g2 = R$1({ id: a2, pairingTopic: t2, expiryTimestamp: h5 }, o3);
        await this.setProposal(a2, g2);
        const d4 = await this.getVerifyContext({ attestationId: i4, hash: si$2(JSON.stringify(s2)), encryptedId: n5, metadata: g2.proposer.metadata });
        l2 == null ? void 0 : l2.addTrace(q$1.emit_session_proposal), this.client.events.emit("session_proposal", { id: a2, params: g2, verifyContext: d4 });
      } catch (l2) {
        await this.sendError({ id: a2, topic: t2, error: l2, rpcOpts: N$1.wc_sessionPropose.autoReject }), this.client.logger.error(l2);
      }
    }), c(this, "onSessionProposeResponse", async (e3, t2, s2) => {
      const { id: i4 } = t2;
      if (isJsonRpcResult(t2)) {
        const { result: n5 } = t2;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: n5 });
        const o3 = this.client.proposal.get(i4);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: o3 });
        const a2 = o3.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: a2 });
        const l2 = n5.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: l2 });
        const h5 = await this.client.core.crypto.generateSharedKey(a2, l2);
        this.pendingSessions.set(i4, { sessionTopic: h5, pairingTopic: e3, proposalId: i4, publicKey: a2 });
        const g2 = await this.client.core.relayer.subscribe(h5, { transportType: s2 });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: g2 }), await this.client.core.pairing.activate({ topic: e3 });
      } else if (isJsonRpcError(t2)) {
        await this.client.proposal.delete(i4, de$2("USER_DISCONNECTED"));
        const n5 = go$1("session_connect", i4);
        if (this.events.listenerCount(n5) === 0) throw new Error(`emitting ${n5} without any listeners, 954`);
        this.events.emit(n5, { error: t2.error });
      }
    }), c(this, "onSessionSettleRequest", async (e3, t2) => {
      const { id: s2, params: i4 } = t2;
      try {
        this.isValidSessionSettleRequest(i4);
        const { relay: n5, controller: o3, expiry: a2, namespaces: l2, sessionProperties: h5, sessionConfig: g2 } = t2.params, d4 = [...this.pendingSessions.values()].find((w2) => w2.sessionTopic === e3);
        if (!d4) return this.client.logger.error(`Pending session not found for topic ${e3}`);
        const u2 = this.client.proposal.get(d4.proposalId), y4 = V$1(R$1(R$1({ topic: e3, relay: n5, expiry: a2, namespaces: l2, acknowledged: true, pairingTopic: d4.pairingTopic, requiredNamespaces: u2.requiredNamespaces, optionalNamespaces: u2.optionalNamespaces, controller: o3.publicKey, self: { publicKey: d4.publicKey, metadata: this.client.metadata }, peer: { publicKey: o3.publicKey, metadata: o3.metadata } }, h5 && { sessionProperties: h5 }), g2 && { sessionConfig: g2 }), { transportType: Q.relay });
        await this.client.session.set(y4.topic, y4), await this.setExpiry(y4.topic, y4.expiry), await this.client.core.pairing.updateMetadata({ topic: d4.pairingTopic, metadata: y4.peer.metadata }), this.client.events.emit("session_connect", { session: y4 }), this.events.emit(go$1("session_connect", d4.proposalId), { session: y4 }), this.updateSessionActivity(y4.topic), this.pendingSessions.delete(d4.proposalId), this.deleteProposal(d4.proposalId, false), this.cleanupDuplicatePairings(y4), await this.sendResult({ id: t2.id, topic: e3, result: true, throwOnFailedPublish: true });
      } catch (n5) {
        await this.sendError({ id: s2, topic: e3, error: n5 }), this.client.logger.error(n5);
      }
    }), c(this, "onSessionSettleResponse", async (e3, t2) => {
      const { id: s2 } = t2;
      isJsonRpcResult(t2) ? (await this.client.session.update(e3, { acknowledged: true }), this.sessionCreationTimes.set(e3, Date.now()), this.firstDAppEntryAfterSession.set(e3, true), this.events.emit(go$1("session_approve", s2), {})) : isJsonRpcError(t2) && (await this.client.session.delete(e3, de$2("USER_DISCONNECTED")), this.events.emit(go$1("session_approve", s2), { error: t2.error }));
    }), c(this, "onSessionUpdateRequest", async (e3, t2) => {
      const { params: s2, id: i4 } = t2;
      try {
        const n5 = `${e3}_session_update`, o3 = Zi$1.get(n5);
        if (o3 && this.isRequestOutOfSync(o3, i4)) {
          this.client.logger.warn(`Discarding out of sync request - ${i4}`), this.sendError({ id: i4, topic: e3, error: de$2("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(R$1({ topic: e3 }, s2));
        try {
          Zi$1.set(n5, i4), await this.client.session.update(e3, { namespaces: s2.namespaces }), await this.sendResult({ id: i4, topic: e3, result: true, throwOnFailedPublish: true });
        } catch (a2) {
          throw Zi$1.delete(n5), a2;
        }
        this.client.events.emit("session_update", { id: i4, topic: e3, params: s2 });
      } catch (n5) {
        await this.sendError({ id: i4, topic: e3, error: n5 }), this.client.logger.error(n5);
      }
    }), c(this, "isRequestOutOfSync", (e3, t2) => t2.toString().slice(0, -3) < e3.toString().slice(0, -3)), c(this, "onSessionUpdateResponse", (e3, t2) => {
      const { id: s2 } = t2, i4 = go$1("session_update", s2);
      if (this.events.listenerCount(i4) === 0) throw new Error(`emitting ${i4} without any listeners`);
      isJsonRpcResult(t2) ? this.events.emit(go$1("session_update", s2), {}) : isJsonRpcError(t2) && this.events.emit(go$1("session_update", s2), { error: t2.error });
    }), c(this, "onSessionExtendRequest", async (e3, t2) => {
      const { id: s2 } = t2;
      try {
        this.isValidExtend({ topic: e3 }), await this.setExpiry(e3, ho$1(z$1)), await this.sendResult({ id: s2, topic: e3, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_extend", { id: s2, topic: e3 });
      } catch (i4) {
        await this.sendError({ id: s2, topic: e3, error: i4 }), this.client.logger.error(i4);
      }
    }), c(this, "onSessionExtendResponse", (e3, t2) => {
      const { id: s2 } = t2, i4 = go$1("session_extend", s2);
      if (this.events.listenerCount(i4) === 0) throw new Error(`emitting ${i4} without any listeners`);
      isJsonRpcResult(t2) ? this.events.emit(go$1("session_extend", s2), {}) : isJsonRpcError(t2) && this.events.emit(go$1("session_extend", s2), { error: t2.error });
    }), c(this, "onSessionPingRequest", async (e3, t2) => {
      const { id: s2 } = t2;
      try {
        this.isValidPing({ topic: e3 }), await this.sendResult({ id: s2, topic: e3, result: true, throwOnFailedPublish: true }), this.updateSessionActivity(e3), this.client.events.emit("session_ping", { id: s2, topic: e3 });
      } catch (i4) {
        await this.sendError({ id: s2, topic: e3, error: i4 }), this.client.logger.error(i4);
      }
    }), c(this, "onSessionPingResponse", (e3, t2) => {
      const { id: s2 } = t2, i4 = go$1("session_ping", s2);
      if (this.events.listenerCount(i4) === 0) throw new Error(`emitting ${i4} without any listeners`);
      setTimeout(() => {
        isJsonRpcResult(t2) ? this.events.emit(go$1("session_ping", s2), {}) : isJsonRpcError(t2) && this.events.emit(go$1("session_ping", s2), { error: t2.error });
      }, 500);
    }), c(this, "onSessionDeleteRequest", async (e3, t2) => {
      const { id: s2 } = t2;
      try {
        this.isValidDisconnect({ topic: e3, reason: t2.params }), await Promise.all([new Promise((i4) => {
          this.client.core.relayer.once(T$1.publish, async () => {
            await this.deleteSession({ topic: e3, id: s2, emitEvent: false }), this.sessionCreationTimes.delete(e3), this.firstDAppEntryAfterSession.delete(e3), this.events.emit("session_disconnected", { error: void 0, result: { topic: e3, reason: "wallet_disconnect", timestamp: Date.now() } }), i4(true);
          });
        }), this.sendResult({ id: s2, topic: e3, result: true, throwOnFailedPublish: true }), this.cleanupPendingSentRequestsForTopic({ topic: e3, error: de$2("USER_DISCONNECTED") })]).catch((i4) => this.client.logger.error(i4));
      } catch (i4) {
        this.client.logger.error(i4);
      }
    }), c(this, "onSessionRequest", async (e3) => {
      var t2, s2, i4;
      const { topic: n5, payload: o3, attestation: a2, encryptedId: l2, transportType: h5 } = e3, { id: g2, params: d4 } = o3;
      try {
        await this.isValidRequest(R$1({ topic: n5 }, d4));
        const u2 = this.client.session.get(n5), y4 = await this.getVerifyContext({ attestationId: a2, hash: si$2(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", d4, g2))), encryptedId: l2, metadata: u2.peer.metadata, transportType: h5 }), w2 = { id: g2, topic: n5, params: d4, verifyContext: y4 };
        await this.setPendingSessionRequest(w2), h5 === Q.link_mode && (t2 = u2.peer.metadata.redirect) != null && t2.universal && this.client.core.addLinkModeSupportedApp((s2 = u2.peer.metadata.redirect) == null ? void 0 : s2.universal), this.updateSessionActivity(n5), (i4 = this.client.signConfig) != null && i4.disableRequestQueue ? this.emitSessionRequest(w2) : (this.addSessionRequestToSessionRequestQueue(w2), this.processSessionRequestQueue());
      } catch (u2) {
        await this.sendError({ id: g2, topic: n5, error: u2 }), this.client.logger.error(u2);
      }
    }), c(this, "onSessionRequestResponse", (e3, t2) => {
      const { id: s2 } = t2, i4 = go$1("session_request", s2);
      if (this.events.listenerCount(i4) === 0) throw new Error(`emitting ${i4} without any listeners`);
      isJsonRpcResult(t2) ? this.events.emit(go$1("session_request", s2), { result: t2.result }) : isJsonRpcError(t2) && this.events.emit(go$1("session_request", s2), { error: t2.error });
    }), c(this, "onSessionEventRequest", async (e3, t2) => {
      const { id: s2, params: i4 } = t2;
      try {
        const n5 = `${e3}_session_event_${i4.event.name}`, o3 = Zi$1.get(n5);
        if (o3 && this.isRequestOutOfSync(o3, s2)) {
          this.client.logger.info(`Discarding out of sync request - ${s2}`);
          return;
        }
        this.isValidEmit(R$1({ topic: e3 }, i4)), this.client.events.emit("session_event", { id: s2, topic: e3, params: i4 }), Zi$1.set(n5, s2);
      } catch (n5) {
        await this.sendError({ id: s2, topic: e3, error: n5 }), this.client.logger.error(n5);
      }
    }), c(this, "onSessionAuthenticateResponse", (e3, t2) => {
      const { id: s2 } = t2;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: e3, payload: t2 }), isJsonRpcResult(t2) ? this.events.emit(go$1("session_request", s2), { result: t2.result }) : isJsonRpcError(t2) && this.events.emit(go$1("session_request", s2), { error: t2.error });
    }), c(this, "onSessionAuthenticateRequest", async (e3) => {
      var t2;
      const { topic: s2, payload: i4, attestation: n5, encryptedId: o3, transportType: a2 } = e3;
      try {
        const { requester: l2, authPayload: h5, expiryTimestamp: g2 } = i4.params, d4 = await this.getVerifyContext({ attestationId: n5, hash: si$2(JSON.stringify(i4)), encryptedId: o3, metadata: l2.metadata, transportType: a2 }), u2 = { requester: l2, pairingTopic: s2, id: i4.id, authPayload: h5, verifyContext: d4, expiryTimestamp: g2 };
        await this.setAuthRequest(i4.id, { request: u2, pairingTopic: s2, transportType: a2 }), a2 === Q.link_mode && (t2 = l2.metadata.redirect) != null && t2.universal && this.client.core.addLinkModeSupportedApp(l2.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: s2, params: i4.params, id: i4.id, verifyContext: d4 });
      } catch (l2) {
        this.client.logger.error(l2);
        const h5 = i4.params.requester.publicKey, g2 = await this.client.core.crypto.generateKeyPair(), d4 = this.getAppLinkIfEnabled(i4.params.requester.metadata, a2), u2 = { type: Ie$1, receiverPublicKey: h5, senderPublicKey: g2 };
        await this.sendError({ id: i4.id, topic: s2, error: l2, encodeOpts: u2, rpcOpts: N$1.wc_sessionAuthenticate.autoReject, appLink: d4 });
      }
    }), c(this, "addSessionRequestToSessionRequestQueue", (e3) => {
      this.sessionRequestQueue.queue.push(e3);
    }), c(this, "cleanupAfterResponse", (e3) => {
      this.deletePendingSessionRequest(e3.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = $$1.idle, this.processSessionRequestQueue();
      }, cjs$3.toMiliseconds(this.requestQueueDelay));
    }), c(this, "cleanupPendingSentRequestsForTopic", ({ topic: e3, error: t2 }) => {
      const s2 = this.client.core.history.pending;
      s2.length > 0 && s2.filter((i4) => i4.topic === e3 && i4.request.method === "wc_sessionRequest").forEach((i4) => {
        const n5 = i4.request.id, o3 = go$1("session_request", n5);
        if (this.events.listenerCount(o3) === 0) throw new Error(`emitting ${o3} without any listeners`);
        this.events.emit(go$1("session_request", i4.request.id), { error: t2 });
      });
    }), c(this, "processSessionRequestQueue", () => {
      if (this.sessionRequestQueue.state === $$1.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const e3 = this.sessionRequestQueue.queue[0];
      if (!e3) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = $$1.active, this.emitSessionRequest(e3);
      } catch (t2) {
        this.client.logger.error(t2);
      }
    }), c(this, "emitSessionRequest", (e3) => {
      this.client.events.emit("session_request", e3);
    }), c(this, "onPairingCreated", (e3) => {
      if (e3.methods && this.expectedPairingMethodMap.set(e3.topic, e3.methods), e3.active) return;
      const t2 = this.client.proposal.getAll().find((s2) => s2.pairingTopic === e3.topic);
      t2 && this.onSessionProposeRequest({ topic: e3.topic, payload: formatJsonRpcRequest("wc_sessionPropose", { requiredNamespaces: t2.requiredNamespaces, optionalNamespaces: t2.optionalNamespaces, relays: t2.relays, proposer: t2.proposer, sessionProperties: t2.sessionProperties }, t2.id) });
    }), c(this, "isValidConnect", async (e3) => {
      if (!Di$2(e3)) {
        const { message: a2 } = te$1("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e3)}`);
        throw new Error(a2);
      }
      const { pairingTopic: t2, requiredNamespaces: s2, optionalNamespaces: i4, sessionProperties: n5, relays: o3 } = e3;
      if (ae$2(t2) || await this.isValidPairingTopic(t2), !Ci$2(o3, true)) {
        const { message: a2 } = te$1("MISSING_OR_INVALID", `connect() relays: ${o3}`);
        throw new Error(a2);
      }
      !ae$2(s2) && qe$2(s2) !== 0 && this.validateNamespaces(s2, "requiredNamespaces"), !ae$2(i4) && qe$2(i4) !== 0 && this.validateNamespaces(i4, "optionalNamespaces"), ae$2(n5) || this.validateSessionProps(n5, "sessionProperties");
    }), c(this, "validateNamespaces", (e3, t2) => {
      const s2 = ji$1(e3, "connect()", t2);
      if (s2) throw new Error(s2.message);
    }), c(this, "isValidApprove", async (e3) => {
      if (!Di$2(e3)) throw new Error(te$1("MISSING_OR_INVALID", `approve() params: ${e3}`).message);
      const { id: t2, namespaces: s2, relayProtocol: i4, sessionProperties: n5 } = e3;
      this.checkRecentlyDeleted(t2), await this.isValidProposalId(t2);
      const o3 = this.client.proposal.get(t2), a2 = Ir$2(s2, "approve()");
      if (a2) throw new Error(a2.message);
      const l2 = Nr$2(o3.requiredNamespaces, s2, "approve()");
      if (l2) throw new Error(l2.message);
      if (!q$2(i4, true)) {
        const { message: h5 } = te$1("MISSING_OR_INVALID", `approve() relayProtocol: ${i4}`);
        throw new Error(h5);
      }
      ae$2(n5) || this.validateSessionProps(n5, "sessionProperties");
    }), c(this, "isValidReject", async (e3) => {
      if (!Di$2(e3)) {
        const { message: i4 } = te$1("MISSING_OR_INVALID", `reject() params: ${e3}`);
        throw new Error(i4);
      }
      const { id: t2, reason: s2 } = e3;
      if (this.checkRecentlyDeleted(t2), await this.isValidProposalId(t2), !Mi$1(s2)) {
        const { message: i4 } = te$1("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s2)}`);
        throw new Error(i4);
      }
    }), c(this, "isValidSessionSettleRequest", (e3) => {
      if (!Di$2(e3)) {
        const { message: l2 } = te$1("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e3}`);
        throw new Error(l2);
      }
      const { relay: t2, controller: s2, namespaces: i4, expiry: n5 } = e3;
      if (!Ar$2(t2)) {
        const { message: l2 } = te$1("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(l2);
      }
      const o3 = Bi$1(s2, "onSessionSettleRequest()");
      if (o3) throw new Error(o3.message);
      const a2 = Ir$2(i4, "onSessionSettleRequest()");
      if (a2) throw new Error(a2.message);
      if (po$1(n5)) {
        const { message: l2 } = te$1("EXPIRED", "onSessionSettleRequest()");
        throw new Error(l2);
      }
    }), c(this, "isValidUpdate", async (e3) => {
      if (!Di$2(e3)) {
        const { message: a2 } = te$1("MISSING_OR_INVALID", `update() params: ${e3}`);
        throw new Error(a2);
      }
      const { topic: t2, namespaces: s2 } = e3;
      this.checkRecentlyDeleted(t2), await this.isValidSessionTopic(t2);
      const i4 = this.client.session.get(t2), n5 = Ir$2(s2, "update()");
      if (n5) throw new Error(n5.message);
      const o3 = Nr$2(i4.requiredNamespaces, s2, "update()");
      if (o3) throw new Error(o3.message);
    }), c(this, "isValidExtend", async (e3) => {
      if (!Di$2(e3)) {
        const { message: s2 } = te$1("MISSING_OR_INVALID", `extend() params: ${e3}`);
        throw new Error(s2);
      }
      const { topic: t2 } = e3;
      this.checkRecentlyDeleted(t2), await this.isValidSessionTopic(t2);
    }), c(this, "isValidRequest", async (e3) => {
      if (!Di$2(e3)) {
        const { message: a2 } = te$1("MISSING_OR_INVALID", `request() params: ${e3}`);
        throw new Error(a2);
      }
      const { topic: t2, request: s2, chainId: i4, expiry: n5 } = e3;
      this.checkRecentlyDeleted(t2), await this.isValidSessionTopic(t2);
      const { namespaces: o3 } = this.client.session.get(t2);
      if (!Fi$1(o3, i4)) {
        const { message: a2 } = te$1("MISSING_OR_INVALID", `request() chainId: ${i4}`);
        throw new Error(a2);
      }
      if (!Vi$1(s2)) {
        const { message: a2 } = te$1("MISSING_OR_INVALID", `request() ${JSON.stringify(s2)}`);
        throw new Error(a2);
      }
      if (!qi$1(o3, i4, s2.method)) {
        const { message: a2 } = te$1("MISSING_OR_INVALID", `request() method: ${s2.method}`);
        throw new Error(a2);
      }
      if (n5 && !Ji$1(n5, Se$1)) {
        const { message: a2 } = te$1("MISSING_OR_INVALID", `request() expiry: ${n5}. Expiry must be a number (in seconds) between ${Se$1.min} and ${Se$1.max}`);
        throw new Error(a2);
      }
    }), c(this, "isValidRespond", async (e3) => {
      var t2;
      if (!Di$2(e3)) {
        const { message: n5 } = te$1("MISSING_OR_INVALID", `respond() params: ${e3}`);
        throw new Error(n5);
      }
      const { topic: s2, response: i4 } = e3;
      try {
        await this.isValidSessionTopic(s2);
      } catch (n5) {
        throw (t2 = e3 == null ? void 0 : e3.response) != null && t2.id && this.cleanupAfterResponse(e3), n5;
      }
      if (!Hi$1(i4)) {
        const { message: n5 } = te$1("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i4)}`);
        throw new Error(n5);
      }
    }), c(this, "isValidPing", async (e3) => {
      if (!Di$2(e3)) {
        const { message: s2 } = te$1("MISSING_OR_INVALID", `ping() params: ${e3}`);
        throw new Error(s2);
      }
      const { topic: t2 } = e3;
      await this.isValidSessionOrPairingTopic(t2);
    }), c(this, "isValidEmit", async (e3) => {
      if (!Di$2(e3)) {
        const { message: o3 } = te$1("MISSING_OR_INVALID", `emit() params: ${e3}`);
        throw new Error(o3);
      }
      const { topic: t2, event: s2, chainId: i4 } = e3;
      await this.isValidSessionTopic(t2);
      const { namespaces: n5 } = this.client.session.get(t2);
      if (!Fi$1(n5, i4)) {
        const { message: o3 } = te$1("MISSING_OR_INVALID", `emit() chainId: ${i4}`);
        throw new Error(o3);
      }
      if (!Ki$1(s2)) {
        const { message: o3 } = te$1("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s2)}`);
        throw new Error(o3);
      }
      if (!Gi$1(n5, i4, s2.name)) {
        const { message: o3 } = te$1("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s2)}`);
        throw new Error(o3);
      }
    }), c(this, "isValidDisconnect", async (e3) => {
      if (!Di$2(e3)) {
        const { message: s2 } = te$1("MISSING_OR_INVALID", `disconnect() params: ${e3}`);
        throw new Error(s2);
      }
      const { topic: t2 } = e3;
      await this.isValidSessionOrPairingTopic(t2);
    }), c(this, "isValidAuthenticate", (e3) => {
      const { chains: t2, uri: s2, domain: i4, nonce: n5 } = e3;
      if (!Array.isArray(t2) || t2.length === 0) throw new Error("chains is required and must be a non-empty array");
      if (!q$2(s2, false)) throw new Error("uri is required parameter");
      if (!q$2(i4, false)) throw new Error("domain is required parameter");
      if (!q$2(n5, false)) throw new Error("nonce is required parameter");
      if ([...new Set(t2.map((a2) => Ye$1(a2).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: o3 } = Ye$1(t2[0]);
      if (o3 !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }), c(this, "getVerifyContext", async (e3) => {
      const { attestationId: t2, hash: s2, encryptedId: i4, metadata: n5, transportType: o3 } = e3, a2 = { verified: { verifyUrl: n5.verifyUrl || re$1, validation: "UNKNOWN", origin: n5.url || "" } };
      try {
        if (o3 === Q.link_mode) {
          const h5 = this.getAppLinkIfEnabled(n5, o3);
          return a2.verified.validation = h5 && new URL(h5).origin === new URL(n5.url).origin ? "VALID" : "INVALID", a2;
        }
        const l2 = await this.client.core.verify.resolve({ attestationId: t2, hash: s2, encryptedId: i4, verifyUrl: n5.verifyUrl });
        l2 && (a2.verified.origin = l2.origin, a2.verified.isScam = l2.isScam, a2.verified.validation = l2.origin === new URL(n5.url).origin ? "VALID" : "INVALID");
      } catch (l2) {
        this.client.logger.warn(l2);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(a2)}`), a2;
    }), c(this, "validateSessionProps", (e3, t2) => {
      Object.values(e3).forEach((s2) => {
        if (!q$2(s2, false)) {
          const { message: i4 } = te$1("MISSING_OR_INVALID", `${t2} must be in Record<string, string> format. Received: ${JSON.stringify(s2)}`);
          throw new Error(i4);
        }
      });
    }), c(this, "getPendingAuthRequest", (e3) => {
      const t2 = this.client.auth.requests.get(e3);
      return typeof t2 == "object" ? t2 : void 0;
    }), c(this, "addToRecentlyDeleted", (e3, t2) => {
      if (this.recentlyDeletedMap.set(e3, t2), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let s2 = 0;
        const i4 = this.recentlyDeletedLimit / 2;
        for (const n5 of this.recentlyDeletedMap.keys()) {
          if (s2 >= i4) break;
          this.recentlyDeletedMap.delete(n5), s2 += 1;
        }
      }
    }), c(this, "checkRecentlyDeleted", (e3) => {
      const t2 = this.recentlyDeletedMap.get(e3);
      if (t2) {
        const { message: s2 } = te$1("MISSING_OR_INVALID", `Record was recently deleted - ${t2}: ${e3}`);
        throw new Error(s2);
      }
    }), c(this, "isLinkModeEnabled", (e3, t2) => {
      var s2, i4, n5, o3, a2, l2, h5, g2, d4;
      return !e3 || t2 !== Q.link_mode ? false : ((i4 = (s2 = this.client.metadata) == null ? void 0 : s2.redirect) == null ? void 0 : i4.linkMode) === true && ((o3 = (n5 = this.client.metadata) == null ? void 0 : n5.redirect) == null ? void 0 : o3.universal) !== void 0 && ((l2 = (a2 = this.client.metadata) == null ? void 0 : a2.redirect) == null ? void 0 : l2.universal) !== "" && ((h5 = e3 == null ? void 0 : e3.redirect) == null ? void 0 : h5.universal) !== void 0 && ((g2 = e3 == null ? void 0 : e3.redirect) == null ? void 0 : g2.universal) !== "" && ((d4 = e3 == null ? void 0 : e3.redirect) == null ? void 0 : d4.linkMode) === true && this.client.core.linkModeSupportedApps.includes(e3.redirect.universal) && typeof (global$1 == null ? void 0 : global$1.Linking) < "u";
    }), c(this, "getAppLinkIfEnabled", (e3, t2) => {
      var s2;
      return this.isLinkModeEnabled(e3, t2) ? (s2 = e3 == null ? void 0 : e3.redirect) == null ? void 0 : s2.universal : void 0;
    }), c(this, "handleLinkModeMessage", ({ url: e3 }) => {
      if (!e3 || !e3.includes("wc_ev") || !e3.includes("topic")) return;
      const t2 = bo$1(e3, "topic") || "", s2 = decodeURIComponent(bo$1(e3, "wc_ev") || ""), i4 = this.client.session.keys.includes(t2);
      i4 && this.client.session.update(t2, { transportType: Q.link_mode }), this.client.core.dispatchEnvelope({ topic: t2, message: s2, sessionExists: i4 });
    }), c(this, "registerLinkModeListeners", async () => {
      var e3;
      if (Eo$1() || ne$2() && (e3 = this.client.metadata.redirect) != null && e3.linkMode) {
        const t2 = global$1 == null ? void 0 : global$1.Linking;
        if (typeof t2 < "u") {
          t2.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const s2 = await t2.getInitialURL();
          s2 && setTimeout(() => {
            this.handleLinkModeMessage({ url: s2 });
          }, 50);
        }
      }
    }), c(this, "shouldSetTVF", (e3, t2) => {
      if (!t2 || e3 !== "wc_sessionRequest") return false;
      const { request: s2 } = t2;
      return Object.keys(Fe$1).includes(s2.method);
    }), c(this, "getTVFParams", (e3, t2, s2) => {
      var i4, n5;
      try {
        const o3 = t2.request.method, a2 = this.extractTxHashesFromResult(o3, s2);
        return V$1(R$1({ correlationId: e3, rpcMethods: [o3], chainId: t2.chainId }, this.isValidContractData(t2.request.params) && { contractAddresses: [(n5 = (i4 = t2.request.params) == null ? void 0 : i4[0]) == null ? void 0 : n5.to] }), { txHashes: a2 });
      } catch (o3) {
        this.client.logger.warn("Error getting TVF params", o3);
      }
      return {};
    }), c(this, "isValidContractData", (e3) => {
      var t2;
      if (!e3) return false;
      try {
        const s2 = (e3 == null ? void 0 : e3.data) || ((t2 = e3 == null ? void 0 : e3[0]) == null ? void 0 : t2.data);
        if (!s2.startsWith("0x")) return false;
        const i4 = s2.slice(2);
        return /^[0-9a-fA-F]*$/.test(i4) ? i4.length % 2 === 0 : false;
      } catch {
      }
      return false;
    }), c(this, "extractTxHashesFromResult", (e3, t2) => {
      try {
        const s2 = Fe$1[e3];
        if (typeof t2 == "string") return [t2];
        const i4 = t2[s2.key];
        if ($e$3(i4)) return i4;
        if (typeof i4 == "string") return [i4];
      } catch (s2) {
        this.client.logger.warn("Error extracting tx hashes from result", s2);
      }
      return [];
    }), c(this, "initializeMobileSessionDetection", () => {
      if (typeof window > "u") {
        console.log(" [ENGINE] Window is undefined, skipping mobile session detection initialization");
        return;
      }
      console.log(" [ENGINE] Mobile session management delegated to DApp"), console.log(" [ENGINE] Use engine.validateAndCleanupSessions(isSessionCheck) for session validation");
    }), c(this, "validateAndCleanupSessions", async (e3 = false) => {
      const t2 = Date.now();
      if (!e3 && this.lastSessionCheckTime && t2 - this.lastSessionCheckTime < 1e4) {
        console.log(" [ENGINE] Skipping session check - too frequent (last check was", t2 - this.lastSessionCheckTime, "ms ago)");
        return;
      }
      this.lastSessionCheckTime = t2, this.isCheckingSession = true;
      try {
        const s2 = this.client.session.getAll();
        if (e3) {
          await this.cleanup();
          const n5 = this.client.session.getAll();
          console.log(" [ENGINE] Found", n5.length, "active sessions after cleanup");
        }
        const i4 = s2.map(async (n5) => {
          const o3 = this.firstDAppEntryAfterSession.get(n5.topic);
          try {
            return await this.ping({ topic: n5.topic }), o3 ? (this.firstDAppEntryAfterSession.set(n5.topic, false), { success: true, topic: n5.topic }) : (this.client.session.get(n5.topic) ? console.log(" [DEBUG] Session validation passed for:", `${n5.topic.substring(0, 8)}...`) : await this.deleteSession({ topic: n5.topic, emitEvent: false }), { success: true, topic: n5.topic });
          } catch (a2) {
            try {
              await this.deleteSession({ topic: n5.topic, emitEvent: false }), this.events.emit("session_disconnected", { error: void 0, result: { topic: n5.topic, reason: "ping_failure", timestamp: Date.now() } });
            } catch (l2) {
              console.error(" [ENGINE] Failed to disconnect session:", n5.topic, l2);
            }
            return { success: false, topic: n5.topic, error: a2 };
          }
        });
        await Promise.allSettled(i4);
      } catch (s2) {
        console.error(" [ENGINE] Error checking session status:", s2);
      } finally {
        this.isCheckingSession = false;
      }
    }), c(this, "getSessionStatus", async () => {
      if (this.isCheckingSession) {
        const e3 = this.client.session.getAll();
        return { total: e3.length, healthy: e3.length, disconnected: 0, sessions: e3.map((t2) => ({ topic: t2.topic, status: "healthy" })), note: "Status returned while session check in progress" };
      }
      this.isCheckingSession = true;
      try {
        const e3 = this.client.session.getAll(), t2 = [];
        let s2 = 0, i4 = 0;
        const n5 = e3.map(async (o3) => {
          try {
            return await this.ping({ topic: o3.topic }), { topic: o3.topic, status: "healthy" };
          } catch (a2) {
            return { topic: o3.topic, status: "disconnected", error: (a2 == null ? void 0 : a2.message) || "Ping failed" };
          }
        });
        return (await Promise.allSettled(n5)).forEach((o3) => {
          o3.status === "fulfilled" ? (t2.push(o3.value), o3.value.status === "healthy" ? s2 += 1 : i4 += 1) : (i4 += 1, t2.push({ topic: "unknown", status: "disconnected", error: "Unexpected error during ping" }));
        }), { total: e3.length, healthy: s2, disconnected: i4, sessions: t2 };
      } catch (e3) {
        return { total: 0, healthy: 0, disconnected: 0, sessions: [], error: (e3 == null ? void 0 : e3.message) || "Unknown error" };
      } finally {
        this.isCheckingSession = false;
      }
    }), c(this, "validateSessionAndGetStatus", async (e3, t2 = false) => {
      var s2;
      try {
        await this.validateAndCleanupSessions(t2);
        const i4 = await this.getSessionStatus();
        if (e3 && (s2 = i4 == null ? void 0 : i4.sessions) != null && s2.length) {
          const n5 = i4.sessions.find((o3) => o3.topic === e3);
          return (n5 == null ? void 0 : n5.status) === "healthy";
        }
        return !!(i4 && i4.total > 0 && i4.healthy > 0);
      } catch (i4) {
        return console.error(" [ENGINE] Error checking session active status:", i4), false;
      }
    });
  }
  updateSessionActivity(r3) {
    var e3;
    try {
      const t2 = `session_activity_${r3}`, s2 = Date.now();
      if (this.client.logger.debug(` [ACTIVITY] Updating activity record for session: ${r3}`), !((e3 = this.client.core) != null && e3.storage)) {
        this.client.logger.warn(` [ACTIVITY] Storage system not available for session: ${r3}`);
        return;
      }
      this.client.core.storage.setItem(t2, s2.toString()), this.client.logger.info(` [ACTIVITY] Updated session activity for ${r3} at ${new Date(s2).toISOString()}`);
    } catch (t2) {
      this.client.logger.error(` [ACTIVITY] Error updating session activity for ${r3}:`, t2);
    }
  }
  cleanupSessionActivity(r3) {
    var e3;
    try {
      const t2 = `session_activity_${r3}`;
      if (this.client.logger.debug(` [ACTIVITY] Cleaning up activity record for session: ${r3}`), !((e3 = this.client.core) != null && e3.storage)) {
        this.client.logger.warn(` [ACTIVITY] Storage system not available for session: ${r3}`);
        return;
      }
      this.client.core.storage.removeItem(t2), this.client.logger.info(` [ACTIVITY] Cleaned up session activity for ${r3}`);
    } catch (t2) {
      this.client.logger.error(` [ACTIVITY] Error cleaning up session activity for ${r3}:`, t2);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: r3 } = te$1("NOT_INITIALIZED", this.name);
      throw new Error(r3);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(T$1.message, (r3) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(r3) : this.onRelayMessage(r3);
    });
  }
  async onRelayMessage(r3) {
    const { topic: e3, message: t2, attestation: s2, transportType: i4 } = r3, { publicKey: n5 } = this.client.auth.authKeys.keys.includes(ce$1) ? this.client.auth.authKeys.get(ce$1) : { publicKey: void 0 }, o3 = await this.client.core.crypto.decode(e3, t2, { receiverPublicKey: n5, encoding: i4 === Q.link_mode ? Qs$2 : At$2 });
    try {
      isJsonRpcRequest(o3) ? (this.client.core.history.set(e3, o3), this.onRelayEventRequest({ topic: e3, payload: o3, attestation: s2, transportType: i4, encryptedId: si$2(t2) })) : isJsonRpcResponse(o3) ? (await this.client.core.history.resolve(o3), await this.onRelayEventResponse({ topic: e3, payload: o3, transportType: i4 }), this.client.core.history.delete(e3, o3.id)) : this.onRelayEventUnknownPayload({ topic: e3, payload: o3, transportType: i4 });
    } catch (a2) {
      this.client.logger.error(a2);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(M$1.expired, async (r3) => {
      const { topic: e3, id: t2 } = lo$1(r3.target);
      if (t2 && this.client.pendingRequest.keys.includes(t2)) return await this.deletePendingSessionRequest(t2, te$1("EXPIRED"), true);
      if (t2 && this.client.auth.requests.keys.includes(t2)) return await this.deletePendingAuthRequest(t2, te$1("EXPIRED"), true);
      e3 ? this.client.session.keys.includes(e3) && (await this.deleteSession({ topic: e3, expirerHasDeleted: true }), this.client.events.emit("session_expire", { topic: e3 })) : t2 && (await this.deleteProposal(t2, true), this.client.events.emit("proposal_expire", { id: t2 }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(se$1.create, (r3) => this.onPairingCreated(r3)), this.client.core.pairing.events.on(se$1.delete, (r3) => {
      this.addToRecentlyDeleted(r3.topic, "pairing");
    });
  }
  isValidPairingTopic(r3) {
    if (!q$2(r3, false)) {
      const { message: e3 } = te$1("MISSING_OR_INVALID", `pairing topic should be a string: ${r3}`);
      throw new Error(e3);
    }
    if (!this.client.core.pairing.pairings.keys.includes(r3)) {
      const { message: e3 } = te$1("NO_MATCHING_KEY", `pairing topic doesn't exist: ${r3}`);
      throw new Error(e3);
    }
    if (po$1(this.client.core.pairing.pairings.get(r3).expiry)) {
      const { message: e3 } = te$1("EXPIRED", `pairing topic: ${r3}`);
      throw new Error(e3);
    }
  }
  async isValidSessionTopic(r3) {
    if (!q$2(r3, false)) {
      const { message: e3 } = te$1("MISSING_OR_INVALID", `session topic should be a string: ${r3}`);
      throw new Error(e3);
    }
    if (this.checkRecentlyDeleted(r3), !this.client.session.keys.includes(r3)) {
      const { message: e3 } = te$1("NO_MATCHING_KEY", `session topic doesn't exist: ${r3}`);
      throw new Error(e3);
    }
    if (po$1(this.client.session.get(r3).expiry)) {
      await this.deleteSession({ topic: r3 });
      const { message: e3 } = te$1("EXPIRED", `session topic: ${r3}`);
      throw new Error(e3);
    }
    if (!this.client.core.crypto.keychain.has(r3)) {
      const { message: e3 } = te$1("MISSING_OR_INVALID", `session topic does not exist in keychain: ${r3}`);
      throw await this.deleteSession({ topic: r3 }), new Error(e3);
    }
  }
  async isValidSessionOrPairingTopic(r3) {
    if (this.checkRecentlyDeleted(r3), this.client.session.keys.includes(r3)) await this.isValidSessionTopic(r3);
    else if (this.client.core.pairing.pairings.keys.includes(r3)) this.isValidPairingTopic(r3);
    else if (q$2(r3, false)) {
      const { message: e3 } = te$1("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${r3}`);
      throw new Error(e3);
    } else {
      const { message: e3 } = te$1("MISSING_OR_INVALID", `session or pairing topic should be a string: ${r3}`);
      throw new Error(e3);
    }
  }
  async isValidProposalId(r3) {
    if (!ki$1(r3)) {
      const { message: e3 } = te$1("MISSING_OR_INVALID", `proposal id should be a number: ${r3}`);
      throw new Error(e3);
    }
    if (!this.client.proposal.keys.includes(r3)) {
      const { message: e3 } = te$1("NO_MATCHING_KEY", `proposal id doesn't exist: ${r3}`);
      throw new Error(e3);
    }
    if (po$1(this.client.proposal.get(r3).expiryTimestamp)) {
      await this.deleteProposal(r3);
      const { message: e3 } = te$1("EXPIRED", `proposal id: ${r3}`);
      throw new Error(e3);
    }
  }
};
let Ns$1 = class Ns3 extends Ci$1 {
  constructor(r3, e3) {
    super(r3, e3, pt$1, we$1), this.core = r3, this.logger = e3;
  }
};
class ft extends Ci$1 {
  constructor(r3, e3) {
    super(r3, e3, ht$1, we$1), this.core = r3, this.logger = e3;
  }
}
let Ps$1 = class Ps3 extends Ci$1 {
  constructor(r3, e3) {
    super(r3, e3, ut$1, we$1, (t2) => t2.id), this.core = r3, this.logger = e3;
  }
};
let Os$1 = class Os3 extends Ci$1 {
  constructor(r3, e3) {
    super(r3, e3, wt, ae$1, () => ce$1), this.core = r3, this.logger = e3;
  }
};
let As$1 = class As3 extends Ci$1 {
  constructor(r3, e3) {
    super(r3, e3, _t$1, ae$1), this.core = r3, this.logger = e3;
  }
};
let bs$1 = class bs3 extends Ci$1 {
  constructor(r3, e3) {
    super(r3, e3, St$1, ae$1, (t2) => t2.id), this.core = r3, this.logger = e3;
  }
};
var Cs$1 = Object.defineProperty, Vs$1 = (E2, r3, e3) => r3 in E2 ? Cs$1(E2, r3, { enumerable: true, configurable: true, writable: true, value: e3 }) : E2[r3] = e3, Ke$1 = (E2, r3, e3) => Vs$1(E2, typeof r3 != "symbol" ? r3 + "" : r3, e3);
let Ds$1 = class Ds3 {
  constructor(r3, e3) {
    this.core = r3, this.logger = e3, Ke$1(this, "authKeys"), Ke$1(this, "pairingTopics"), Ke$1(this, "requests"), this.authKeys = new Os$1(this.core, this.logger), this.pairingTopics = new As$1(this.core, this.logger), this.requests = new bs$1(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
};
var xs$1 = Object.defineProperty, Ls$1 = (E2, r3, e3) => r3 in E2 ? xs$1(E2, r3, { enumerable: true, configurable: true, writable: true, value: e3 }) : E2[r3] = e3, _$1 = (E2, r3, e3) => Ls$1(E2, typeof r3 != "symbol" ? r3 + "" : r3, e3);
let Ee$1 = class Ee3 extends J$8 {
  constructor(r3) {
    super(r3), _$1(this, "protocol", xe$1), _$1(this, "version", Le$1), _$1(this, "name", _e$1.name), _$1(this, "metadata"), _$1(this, "core"), _$1(this, "logger"), _$1(this, "events", new eventsExports.EventEmitter()), _$1(this, "engine"), _$1(this, "session"), _$1(this, "proposal"), _$1(this, "pendingRequest"), _$1(this, "auth"), _$1(this, "signConfig"), _$1(this, "on", (t2, s2) => this.events.on(t2, s2)), _$1(this, "once", (t2, s2) => this.events.once(t2, s2)), _$1(this, "off", (t2, s2) => this.events.off(t2, s2)), _$1(this, "removeListener", (t2, s2) => this.events.removeListener(t2, s2)), _$1(this, "removeAllListeners", (t2) => this.events.removeAllListeners(t2)), _$1(this, "connect", async (t2) => {
      try {
        return await this.engine.connect(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), _$1(this, "pair", async (t2) => {
      try {
        return await this.engine.pair(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), _$1(this, "approve", async (t2) => {
      try {
        return await this.engine.approve(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), _$1(this, "reject", async (t2) => {
      try {
        return await this.engine.reject(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), _$1(this, "update", async (t2) => {
      try {
        return await this.engine.update(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), _$1(this, "extend", async (t2) => {
      try {
        return await this.engine.extend(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), _$1(this, "request", async (t2) => {
      try {
        return await this.engine.request(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), _$1(this, "respond", async (t2) => {
      try {
        return await this.engine.respond(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), _$1(this, "ping", async (t2) => {
      try {
        return await this.engine.ping(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), _$1(this, "emit", async (t2) => {
      try {
        return await this.engine.emit(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), _$1(this, "disconnect", async (t2) => {
      try {
        return await this.engine.disconnect(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), _$1(this, "find", (t2) => {
      try {
        return this.engine.find(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), _$1(this, "getPendingSessionRequests", () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (t2) {
        throw this.logger.error(t2.message), t2;
      }
    }), _$1(this, "authenticate", async (t2, s2) => {
      try {
        return await this.engine.authenticate(t2, s2);
      } catch (i4) {
        throw this.logger.error(i4.message), i4;
      }
    }), _$1(this, "formatAuthMessage", (t2) => {
      try {
        return this.engine.formatAuthMessage(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), _$1(this, "approveSessionAuthenticate", async (t2) => {
      try {
        return await this.engine.approveSessionAuthenticate(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), _$1(this, "rejectSessionAuthenticate", async (t2) => {
      try {
        return await this.engine.rejectSessionAuthenticate(t2);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), this.name = (r3 == null ? void 0 : r3.name) || _e$1.name, this.metadata = (r3 == null ? void 0 : r3.metadata) || Yr$2(), this.signConfig = r3 == null ? void 0 : r3.signConfig;
    const e3 = typeof (r3 == null ? void 0 : r3.logger) < "u" && typeof (r3 == null ? void 0 : r3.logger) != "string" ? r3.logger : gt$3(k$7({ level: (r3 == null ? void 0 : r3.logger) || _e$1.logger }));
    this.core = (r3 == null ? void 0 : r3.core) || new ao$1(r3), this.logger = E$7(e3, this.name), this.session = new ft(this.core, this.logger), this.proposal = new Ns$1(this.core, this.logger), this.pendingRequest = new Ps$1(this.core, this.logger), this.engine = new qs$1(this), this.auth = new Ds$1(this.core, this.logger);
  }
  static async init(r3) {
    const e3 = new Ee3(r3);
    return await e3.initialize(), e3;
  }
  get context() {
    return y$6(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success"), setTimeout(() => {
        this.engine.processRelayMessageCache();
      }, cjs$3.toMiliseconds(cjs$3.ONE_SECOND));
    } catch (r3) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(r3.message), r3;
    }
  }
};
const be = "error", _t = "wss://relay.walletconnect.org", Ct = "wc", It = "universal_provider", $e = `${Ct}@2:${It}:`, ye = "https://rpc.walletconnect.org/v1/", w = "generic", Ot = `${ye}bundler`, f = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
var G = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global$1 < "u" ? global$1 : typeof self < "u" ? self : {};
function At() {
  this.__data__ = [], this.size = 0;
}
var jt = At;
function Ht(r3, e3) {
  return r3 === e3 || r3 !== r3 && e3 !== e3;
}
var z = Ht, Et = z;
function St(r3, e3) {
  for (var t2 = r3.length; t2--; ) if (Et(r3[t2][0], e3)) return t2;
  return -1;
}
var k = St, Nt = k, Tt = Array.prototype, Dt = Tt.splice;
function qt(r3) {
  var e3 = this.__data__, t2 = Nt(e3, r3);
  if (t2 < 0) return false;
  var i4 = e3.length - 1;
  return t2 == i4 ? e3.pop() : Dt.call(e3, t2, 1), --this.size, true;
}
var Rt = qt, xt = k;
function Lt(r3) {
  var e3 = this.__data__, t2 = xt(e3, r3);
  return t2 < 0 ? void 0 : e3[t2][1];
}
var Ut = Lt, Ft = k;
function Mt(r3) {
  return Ft(this.__data__, r3) > -1;
}
var Gt = Mt, zt = k;
function kt(r3, e3) {
  var t2 = this.__data__, i4 = zt(t2, r3);
  return i4 < 0 ? (++this.size, t2.push([r3, e3])) : t2[i4][1] = e3, this;
}
var Bt = kt, Vt = jt, Jt = Rt, Kt = Ut, Wt = Gt, Xt = Bt;
function _(r3) {
  var e3 = -1, t2 = r3 == null ? 0 : r3.length;
  for (this.clear(); ++e3 < t2; ) {
    var i4 = r3[e3];
    this.set(i4[0], i4[1]);
  }
}
_.prototype.clear = Vt, _.prototype.delete = Jt, _.prototype.get = Kt, _.prototype.has = Wt, _.prototype.set = Xt;
var B = _, Yt = B;
function Zt() {
  this.__data__ = new Yt(), this.size = 0;
}
var Qt = Zt;
function er(r3) {
  var e3 = this.__data__, t2 = e3.delete(r3);
  return this.size = e3.size, t2;
}
var tr = er;
function rr(r3) {
  return this.__data__.get(r3);
}
var ir = rr;
function sr(r3) {
  return this.__data__.has(r3);
}
var nr = sr, ar = typeof G == "object" && G && G.Object === Object && G, we = ar, or = we, cr = typeof self == "object" && self && self.Object === Object && self, hr = or || cr || Function("return this")(), C = hr, pr = C, ur = pr.Symbol, _e = ur, Ce = _e, Ie = Object.prototype, lr = Ie.hasOwnProperty, dr = Ie.toString, F = Ce ? Ce.toStringTag : void 0;
function vr(r3) {
  var e3 = lr.call(r3, F), t2 = r3[F];
  try {
    r3[F] = void 0;
    var i4 = true;
  } catch {
  }
  var s2 = dr.call(r3);
  return i4 && (e3 ? r3[F] = t2 : delete r3[F]), s2;
}
var fr = vr, mr = Object.prototype, gr = mr.toString;
function Pr(r3) {
  return gr.call(r3);
}
var br = Pr, Oe = _e, $r = fr, yr = br, wr = "[object Null]", _r = "[object Undefined]", Ae = Oe ? Oe.toStringTag : void 0;
function Cr(r3) {
  return r3 == null ? r3 === void 0 ? _r : wr : Ae && Ae in Object(r3) ? $r(r3) : yr(r3);
}
var V = Cr;
function Ir(r3) {
  var e3 = typeof r3;
  return r3 != null && (e3 == "object" || e3 == "function");
}
var $ = Ir, Or = V, Ar = $, jr = "[object AsyncFunction]", Hr = "[object Function]", Er = "[object GeneratorFunction]", Sr = "[object Proxy]";
function Nr(r3) {
  if (!Ar(r3)) return false;
  var e3 = Or(r3);
  return e3 == Hr || e3 == Er || e3 == jr || e3 == Sr;
}
var te = Nr, Tr = C, Dr = Tr["__core-js_shared__"], qr = Dr, re = qr, je = function() {
  var r3 = /[^.]+$/.exec(re && re.keys && re.keys.IE_PROTO || "");
  return r3 ? "Symbol(src)_1." + r3 : "";
}();
function Rr(r3) {
  return !!je && je in r3;
}
var xr = Rr, Lr = Function.prototype, Ur = Lr.toString;
function Fr(r3) {
  if (r3 != null) {
    try {
      return Ur.call(r3);
    } catch {
    }
    try {
      return r3 + "";
    } catch {
    }
  }
  return "";
}
var Mr = Fr, Gr = te, zr = xr, kr = $, Br = Mr, Vr = /[\\^$.*+?()[\]{}|]/g, Jr = /^\[object .+?Constructor\]$/, Kr = Function.prototype, Wr = Object.prototype, Xr = Kr.toString, Yr = Wr.hasOwnProperty, Zr = RegExp("^" + Xr.call(Yr).replace(Vr, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function Qr(r3) {
  if (!kr(r3) || zr(r3)) return false;
  var e3 = Gr(r3) ? Zr : Jr;
  return e3.test(Br(r3));
}
var ei = Qr;
function ti(r3, e3) {
  return r3 == null ? void 0 : r3[e3];
}
var ri = ti, ii = ei, si = ri;
function ni(r3, e3) {
  var t2 = si(r3, e3);
  return ii(t2) ? t2 : void 0;
}
var ie = ni, ai = ie, oi = C, ci = ai(oi, "Map"), He = ci, hi = ie, pi = hi(Object, "create"), J = pi, Ee = J;
function ui() {
  this.__data__ = Ee ? Ee(null) : {}, this.size = 0;
}
var li = ui;
function di(r3) {
  var e3 = this.has(r3) && delete this.__data__[r3];
  return this.size -= e3 ? 1 : 0, e3;
}
var vi = di, fi = J, mi = "__lodash_hash_undefined__", gi = Object.prototype, Pi = gi.hasOwnProperty;
function bi(r3) {
  var e3 = this.__data__;
  if (fi) {
    var t2 = e3[r3];
    return t2 === mi ? void 0 : t2;
  }
  return Pi.call(e3, r3) ? e3[r3] : void 0;
}
var $i = bi, yi = J, wi = Object.prototype, _i = wi.hasOwnProperty;
function Ci(r3) {
  var e3 = this.__data__;
  return yi ? e3[r3] !== void 0 : _i.call(e3, r3);
}
var Ii = Ci, Oi = J, Ai = "__lodash_hash_undefined__";
function ji(r3, e3) {
  var t2 = this.__data__;
  return this.size += this.has(r3) ? 0 : 1, t2[r3] = Oi && e3 === void 0 ? Ai : e3, this;
}
var Hi = ji, Ei = li, Si = vi, Ni = $i, Ti = Ii, Di = Hi;
function I(r3) {
  var e3 = -1, t2 = r3 == null ? 0 : r3.length;
  for (this.clear(); ++e3 < t2; ) {
    var i4 = r3[e3];
    this.set(i4[0], i4[1]);
  }
}
I.prototype.clear = Ei, I.prototype.delete = Si, I.prototype.get = Ni, I.prototype.has = Ti, I.prototype.set = Di;
var qi = I, Se = qi, Ri = B, xi = He;
function Li() {
  this.size = 0, this.__data__ = { hash: new Se(), map: new (xi || Ri)(), string: new Se() };
}
var Ui = Li;
function Fi(r3) {
  var e3 = typeof r3;
  return e3 == "string" || e3 == "number" || e3 == "symbol" || e3 == "boolean" ? r3 !== "__proto__" : r3 === null;
}
var Mi = Fi, Gi = Mi;
function zi(r3, e3) {
  var t2 = r3.__data__;
  return Gi(e3) ? t2[typeof e3 == "string" ? "string" : "hash"] : t2.map;
}
var K = zi, ki = K;
function Bi(r3) {
  var e3 = ki(this, r3).delete(r3);
  return this.size -= e3 ? 1 : 0, e3;
}
var Vi = Bi, Ji = K;
function Ki(r3) {
  return Ji(this, r3).get(r3);
}
var Wi = Ki, Xi = K;
function Yi(r3) {
  return Xi(this, r3).has(r3);
}
var Zi = Yi, Qi = K;
function es(r3, e3) {
  var t2 = Qi(this, r3), i4 = t2.size;
  return t2.set(r3, e3), this.size += t2.size == i4 ? 0 : 1, this;
}
var ts = es, rs = Ui, is = Vi, ss = Wi, ns = Zi, as = ts;
function O(r3) {
  var e3 = -1, t2 = r3 == null ? 0 : r3.length;
  for (this.clear(); ++e3 < t2; ) {
    var i4 = r3[e3];
    this.set(i4[0], i4[1]);
  }
}
O.prototype.clear = rs, O.prototype.delete = is, O.prototype.get = ss, O.prototype.has = ns, O.prototype.set = as;
var os = O, cs = B, hs = He, ps = os, us = 200;
function ls(r3, e3) {
  var t2 = this.__data__;
  if (t2 instanceof cs) {
    var i4 = t2.__data__;
    if (!hs || i4.length < us - 1) return i4.push([r3, e3]), this.size = ++t2.size, this;
    t2 = this.__data__ = new ps(i4);
  }
  return t2.set(r3, e3), this.size = t2.size, this;
}
var ds = ls, vs = B, fs = Qt, ms = tr, gs = ir, Ps = nr, bs = ds;
function A(r3) {
  var e3 = this.__data__ = new vs(r3);
  this.size = e3.size;
}
A.prototype.clear = fs, A.prototype.delete = ms, A.prototype.get = gs, A.prototype.has = Ps, A.prototype.set = bs;
var $s = A, ys = ie, ws = function() {
  try {
    var r3 = ys(Object, "defineProperty");
    return r3({}, "", {}), r3;
  } catch {
  }
}(), Ne = ws, Te = Ne;
function _s(r3, e3, t2) {
  e3 == "__proto__" && Te ? Te(r3, e3, { configurable: true, enumerable: true, value: t2, writable: true }) : r3[e3] = t2;
}
var se = _s, Cs = se, Is = z;
function Os(r3, e3, t2) {
  (t2 !== void 0 && !Is(r3[e3], t2) || t2 === void 0 && !(e3 in r3)) && Cs(r3, e3, t2);
}
var De = Os;
function As(r3) {
  return function(e3, t2, i4) {
    for (var s2 = -1, n5 = Object(e3), a2 = i4(e3), o3 = a2.length; o3--; ) {
      var c2 = a2[r3 ? o3 : ++s2];
      if (t2(n5[c2], c2, n5) === false) break;
    }
    return e3;
  };
}
var js = As, Hs = js, Es = Hs(), Ss = Es, ne = { exports: {} };
(function(r3, e3) {
  var t2 = C, i4 = e3 && !e3.nodeType && e3, s2 = i4 && true && r3 && !r3.nodeType && r3, n5 = s2 && s2.exports === i4, a2 = n5 ? t2.Buffer : void 0, o3 = a2 ? a2.allocUnsafe : void 0;
  function c2(u2, l2) {
    if (l2) return u2.slice();
    var P3 = u2.length, d4 = o3 ? o3(P3) : new u2.constructor(P3);
    return u2.copy(d4), d4;
  }
  r3.exports = c2;
})(ne, ne.exports);
var Ns = C, Ts = Ns.Uint8Array, Ds = Ts, qe = Ds;
function qs(r3) {
  var e3 = new r3.constructor(r3.byteLength);
  return new qe(e3).set(new qe(r3)), e3;
}
var Rs = qs, xs = Rs;
function Ls(r3, e3) {
  var t2 = e3 ? xs(r3.buffer) : r3.buffer;
  return new r3.constructor(t2, r3.byteOffset, r3.length);
}
var Us = Ls;
function Fs(r3, e3) {
  var t2 = -1, i4 = r3.length;
  for (e3 || (e3 = Array(i4)); ++t2 < i4; ) e3[t2] = r3[t2];
  return e3;
}
var Ms = Fs, Gs = $, Re = Object.create, zs = /* @__PURE__ */ function() {
  function r3() {
  }
  return function(e3) {
    if (!Gs(e3)) return {};
    if (Re) return Re(e3);
    r3.prototype = e3;
    var t2 = new r3();
    return r3.prototype = void 0, t2;
  };
}(), ks = zs;
function Bs(r3, e3) {
  return function(t2) {
    return r3(e3(t2));
  };
}
var Vs = Bs, Js = Vs, Ks = Js(Object.getPrototypeOf, Object), xe = Ks, Ws = Object.prototype;
function Xs(r3) {
  var e3 = r3 && r3.constructor, t2 = typeof e3 == "function" && e3.prototype || Ws;
  return r3 === t2;
}
var Le = Xs, Ys = ks, Zs = xe, Qs = Le;
function en(r3) {
  return typeof r3.constructor == "function" && !Qs(r3) ? Ys(Zs(r3)) : {};
}
var tn = en;
function rn(r3) {
  return r3 != null && typeof r3 == "object";
}
var M = rn, sn = V, nn = M, an = "[object Arguments]";
function on(r3) {
  return nn(r3) && sn(r3) == an;
}
var cn = on, Ue = cn, hn = M, Fe = Object.prototype, pn = Fe.hasOwnProperty, un = Fe.propertyIsEnumerable, ln = Ue(/* @__PURE__ */ function() {
  return arguments;
}()) ? Ue : function(r3) {
  return hn(r3) && pn.call(r3, "callee") && !un.call(r3, "callee");
}, Me = ln, dn = Array.isArray, Ge = dn, vn = 9007199254740991;
function fn(r3) {
  return typeof r3 == "number" && r3 > -1 && r3 % 1 == 0 && r3 <= vn;
}
var ze = fn, mn = te, gn = ze;
function Pn(r3) {
  return r3 != null && gn(r3.length) && !mn(r3);
}
var ae = Pn, bn = ae, $n = M;
function yn(r3) {
  return $n(r3) && bn(r3);
}
var wn = yn, W = { exports: {} };
function _n() {
  return false;
}
var Cn = _n;
(function(r3, e3) {
  var t2 = C, i4 = Cn, s2 = e3 && !e3.nodeType && e3, n5 = s2 && true && r3 && !r3.nodeType && r3, a2 = n5 && n5.exports === s2, o3 = a2 ? t2.Buffer : void 0, c2 = o3 ? o3.isBuffer : void 0, u2 = c2 || i4;
  r3.exports = u2;
})(W, W.exports);
var In = V, On = xe, An = M, jn = "[object Object]", Hn = Function.prototype, En = Object.prototype, ke = Hn.toString, Sn = En.hasOwnProperty, Nn = ke.call(Object);
function Tn(r3) {
  if (!An(r3) || In(r3) != jn) return false;
  var e3 = On(r3);
  if (e3 === null) return true;
  var t2 = Sn.call(e3, "constructor") && e3.constructor;
  return typeof t2 == "function" && t2 instanceof t2 && ke.call(t2) == Nn;
}
var Dn = Tn, qn = V, Rn = ze, xn = M, Ln = "[object Arguments]", Un = "[object Array]", Fn = "[object Boolean]", Mn = "[object Date]", Gn = "[object Error]", zn = "[object Function]", kn = "[object Map]", Bn = "[object Number]", Vn = "[object Object]", Jn = "[object RegExp]", Kn = "[object Set]", Wn = "[object String]", Xn = "[object WeakMap]", Yn = "[object ArrayBuffer]", Zn = "[object DataView]", Qn = "[object Float32Array]", ea = "[object Float64Array]", ta = "[object Int8Array]", ra = "[object Int16Array]", ia = "[object Int32Array]", sa = "[object Uint8Array]", na = "[object Uint8ClampedArray]", aa = "[object Uint16Array]", oa = "[object Uint32Array]", p = {};
p[Qn] = p[ea] = p[ta] = p[ra] = p[ia] = p[sa] = p[na] = p[aa] = p[oa] = true, p[Ln] = p[Un] = p[Yn] = p[Fn] = p[Zn] = p[Mn] = p[Gn] = p[zn] = p[kn] = p[Bn] = p[Vn] = p[Jn] = p[Kn] = p[Wn] = p[Xn] = false;
function ca(r3) {
  return xn(r3) && Rn(r3.length) && !!p[qn(r3)];
}
var ha = ca;
function pa(r3) {
  return function(e3) {
    return r3(e3);
  };
}
var ua = pa, oe = { exports: {} };
(function(r3, e3) {
  var t2 = we, i4 = e3 && !e3.nodeType && e3, s2 = i4 && true && r3 && !r3.nodeType && r3, n5 = s2 && s2.exports === i4, a2 = n5 && t2.process, o3 = function() {
    try {
      var c2 = s2 && s2.require && s2.require("util").types;
      return c2 || a2 && a2.binding && a2.binding("util");
    } catch {
    }
  }();
  r3.exports = o3;
})(oe, oe.exports);
var la = ha, da = ua, Be = oe.exports, Ve = Be && Be.isTypedArray, va = Ve ? da(Ve) : la, Je = va;
function fa(r3, e3) {
  if (!(e3 === "constructor" && typeof r3[e3] == "function") && e3 != "__proto__") return r3[e3];
}
var Ke = fa, ma = se, ga = z, Pa = Object.prototype, ba = Pa.hasOwnProperty;
function $a(r3, e3, t2) {
  var i4 = r3[e3];
  (!(ba.call(r3, e3) && ga(i4, t2)) || t2 === void 0 && !(e3 in r3)) && ma(r3, e3, t2);
}
var ya = $a, wa = ya, _a = se;
function Ca(r3, e3, t2, i4) {
  var s2 = !t2;
  t2 || (t2 = {});
  for (var n5 = -1, a2 = e3.length; ++n5 < a2; ) {
    var o3 = e3[n5], c2 = i4 ? i4(t2[o3], r3[o3], o3, t2, r3) : void 0;
    c2 === void 0 && (c2 = r3[o3]), s2 ? _a(t2, o3, c2) : wa(t2, o3, c2);
  }
  return t2;
}
var Ia = Ca;
function Oa(r3, e3) {
  for (var t2 = -1, i4 = Array(r3); ++t2 < r3; ) i4[t2] = e3(t2);
  return i4;
}
var Aa = Oa, ja = 9007199254740991, Ha = /^(?:0|[1-9]\d*)$/;
function Ea(r3, e3) {
  var t2 = typeof r3;
  return e3 = e3 ?? ja, !!e3 && (t2 == "number" || t2 != "symbol" && Ha.test(r3)) && r3 > -1 && r3 % 1 == 0 && r3 < e3;
}
var We = Ea, Sa = Aa, Na = Me, Ta = Ge, Da = W.exports, qa = We, Ra = Je, xa = Object.prototype, La = xa.hasOwnProperty;
function Ua(r3, e3) {
  var t2 = Ta(r3), i4 = !t2 && Na(r3), s2 = !t2 && !i4 && Da(r3), n5 = !t2 && !i4 && !s2 && Ra(r3), a2 = t2 || i4 || s2 || n5, o3 = a2 ? Sa(r3.length, String) : [], c2 = o3.length;
  for (var u2 in r3) (e3 || La.call(r3, u2)) && !(a2 && (u2 == "length" || s2 && (u2 == "offset" || u2 == "parent") || n5 && (u2 == "buffer" || u2 == "byteLength" || u2 == "byteOffset") || qa(u2, c2))) && o3.push(u2);
  return o3;
}
var Fa = Ua;
function Ma(r3) {
  var e3 = [];
  if (r3 != null) for (var t2 in Object(r3)) e3.push(t2);
  return e3;
}
var Ga = Ma, za = $, ka = Le, Ba = Ga, Va = Object.prototype, Ja = Va.hasOwnProperty;
function Ka(r3) {
  if (!za(r3)) return Ba(r3);
  var e3 = ka(r3), t2 = [];
  for (var i4 in r3) i4 == "constructor" && (e3 || !Ja.call(r3, i4)) || t2.push(i4);
  return t2;
}
var Wa = Ka, Xa = Fa, Ya = Wa, Za = ae;
function Qa(r3) {
  return Za(r3) ? Xa(r3, true) : Ya(r3);
}
var Xe = Qa, eo = Ia, to = Xe;
function ro(r3) {
  return eo(r3, to(r3));
}
var io = ro, Ye = De, so = ne.exports, no = Us, ao = Ms, oo = tn, Ze = Me, Qe = Ge, co = wn, ho = W.exports, po = te, uo = $, lo = Dn, vo = Je, et = Ke, fo = io;
function mo(r3, e3, t2, i4, s2, n5, a2) {
  var o3 = et(r3, t2), c2 = et(e3, t2), u2 = a2.get(c2);
  if (u2) {
    Ye(r3, t2, u2);
    return;
  }
  var l2 = n5 ? n5(o3, c2, t2 + "", r3, e3, a2) : void 0, P3 = l2 === void 0;
  if (P3) {
    var d4 = Qe(c2), Q2 = !d4 && ho(c2), ve2 = !d4 && !Q2 && vo(c2);
    l2 = c2, d4 || Q2 || ve2 ? Qe(o3) ? l2 = o3 : co(o3) ? l2 = ao(o3) : Q2 ? (P3 = false, l2 = so(c2, true)) : ve2 ? (P3 = false, l2 = no(c2, true)) : l2 = [] : lo(c2) || Ze(c2) ? (l2 = o3, Ze(o3) ? l2 = fo(o3) : (!uo(o3) || po(o3)) && (l2 = oo(c2))) : P3 = false;
  }
  P3 && (a2.set(c2, l2), s2(l2, c2, i4, n5, a2), a2.delete(c2)), Ye(r3, t2, l2);
}
var go = mo, Po = $s, bo = De, $o = Ss, yo = go, wo = $, _o = Xe, Co = Ke;
function tt(r3, e3, t2, i4, s2) {
  r3 !== e3 && $o(e3, function(n5, a2) {
    if (s2 || (s2 = new Po()), wo(n5)) yo(r3, e3, a2, t2, tt, i4, s2);
    else {
      var o3 = i4 ? i4(Co(r3, a2), n5, a2 + "", r3, e3, s2) : void 0;
      o3 === void 0 && (o3 = n5), bo(r3, a2, o3);
    }
  }, _o);
}
var Io = tt;
function Oo(r3) {
  return r3;
}
var rt = Oo;
function Ao(r3, e3, t2) {
  switch (t2.length) {
    case 0:
      return r3.call(e3);
    case 1:
      return r3.call(e3, t2[0]);
    case 2:
      return r3.call(e3, t2[0], t2[1]);
    case 3:
      return r3.call(e3, t2[0], t2[1], t2[2]);
  }
  return r3.apply(e3, t2);
}
var jo = Ao, Ho = jo, it = Math.max;
function Eo(r3, e3, t2) {
  return e3 = it(e3 === void 0 ? r3.length - 1 : e3, 0), function() {
    for (var i4 = arguments, s2 = -1, n5 = it(i4.length - e3, 0), a2 = Array(n5); ++s2 < n5; ) a2[s2] = i4[e3 + s2];
    s2 = -1;
    for (var o3 = Array(e3 + 1); ++s2 < e3; ) o3[s2] = i4[s2];
    return o3[e3] = t2(a2), Ho(r3, this, o3);
  };
}
var So = Eo;
function No(r3) {
  return function() {
    return r3;
  };
}
var To = No, Do = To, st = Ne, qo = rt, Ro = st ? function(r3, e3) {
  return st(r3, "toString", { configurable: true, enumerable: false, value: Do(e3), writable: true });
} : qo, xo = Ro, Lo = 800, Uo = 16, Fo = Date.now;
function Mo(r3) {
  var e3 = 0, t2 = 0;
  return function() {
    var i4 = Fo(), s2 = Uo - (i4 - t2);
    if (t2 = i4, s2 > 0) {
      if (++e3 >= Lo) return arguments[0];
    } else e3 = 0;
    return r3.apply(void 0, arguments);
  };
}
var Go = Mo, zo = xo, ko = Go, Bo = ko(zo), Vo = Bo, Jo = rt, Ko = So, Wo = Vo;
function Xo(r3, e3) {
  return Wo(Ko(r3, e3, Jo), r3 + "");
}
var Yo = Xo, Zo = z, Qo = ae, ec = We, tc = $;
function rc(r3, e3, t2) {
  if (!tc(t2)) return false;
  var i4 = typeof e3;
  return (i4 == "number" ? Qo(t2) && ec(e3, t2.length) : i4 == "string" && e3 in t2) ? Zo(t2[e3], r3) : false;
}
var ic = rc, sc = Yo, nc = ic;
function ac(r3) {
  return sc(function(e3, t2) {
    var i4 = -1, s2 = t2.length, n5 = s2 > 1 ? t2[s2 - 1] : void 0, a2 = s2 > 2 ? t2[2] : void 0;
    for (n5 = r3.length > 3 && typeof n5 == "function" ? (s2--, n5) : void 0, a2 && nc(t2[0], t2[1], a2) && (n5 = s2 < 3 ? void 0 : n5, s2 = 1), e3 = Object(e3); ++i4 < s2; ) {
      var o3 = t2[i4];
      o3 && r3(e3, o3, i4, n5);
    }
    return e3;
  });
}
var oc = ac, cc = Io, hc = oc, pc = hc(function(r3, e3, t2) {
  cc(r3, e3, t2);
}), uc = pc, lc = Object.defineProperty, dc = Object.defineProperties, vc = Object.getOwnPropertyDescriptors, nt = Object.getOwnPropertySymbols, fc = Object.prototype.hasOwnProperty, mc = Object.prototype.propertyIsEnumerable, at = (r3, e3, t2) => e3 in r3 ? lc(r3, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r3[e3] = t2, X = (r3, e3) => {
  for (var t2 in e3 || (e3 = {})) fc.call(e3, t2) && at(r3, t2, e3[t2]);
  if (nt) for (var t2 of nt(e3)) mc.call(e3, t2) && at(r3, t2, e3[t2]);
  return r3;
}, gc = (r3, e3) => dc(r3, vc(e3));
function v(r3, e3, t2) {
  var i4;
  const s2 = Ye$1(r3);
  return ((i4 = e3.rpcMap) == null ? void 0 : i4[s2.reference]) || `${ye}?chainId=${s2.namespace}:${s2.reference}&projectId=${t2}`;
}
function y(r3) {
  return r3.includes(":") ? r3.split(":")[1] : r3;
}
function ot(r3) {
  return r3.map((e3) => `${e3.split(":")[0]}:${e3.split(":")[1]}`);
}
function Pc(r3, e3) {
  const t2 = Object.keys(e3.namespaces).filter((s2) => s2.includes(r3));
  if (!t2.length) return [];
  const i4 = [];
  return t2.forEach((s2) => {
    const n5 = e3.namespaces[s2].accounts;
    i4.push(...n5);
  }), i4;
}
function ce(r3 = {}, e3 = {}) {
  const t2 = ct(r3), i4 = ct(e3);
  return uc(t2, i4);
}
function ct(r3) {
  var e3, t2, i4, s2;
  const n5 = {};
  if (!qe$2(r3)) return n5;
  for (const [a2, o3] of Object.entries(r3)) {
    const c2 = Tt$2(a2) ? [a2] : o3.chains, u2 = o3.methods || [], l2 = o3.events || [], P3 = o3.rpcMap || {}, d4 = pr$2(a2);
    n5[d4] = gc(X(X({}, n5[d4]), o3), { chains: Q$1(c2, (e3 = n5[d4]) == null ? void 0 : e3.chains), methods: Q$1(u2, (t2 = n5[d4]) == null ? void 0 : t2.methods), events: Q$1(l2, (i4 = n5[d4]) == null ? void 0 : i4.events), rpcMap: X(X({}, P3), (s2 = n5[d4]) == null ? void 0 : s2.rpcMap) });
  }
  return n5;
}
function bc(r3) {
  return r3.includes(":") ? r3.split(":")[2] : r3;
}
function ht(r3) {
  const e3 = {};
  for (const [t2, i4] of Object.entries(r3)) {
    const s2 = i4.methods || [], n5 = i4.events || [], a2 = i4.accounts || [], o3 = Tt$2(t2) ? [t2] : i4.chains ? i4.chains : ot(i4.accounts);
    e3[t2] = { chains: o3, methods: s2, events: n5, accounts: a2 };
  }
  return e3;
}
function he(r3) {
  return typeof r3 == "number" ? r3 : r3.includes("0x") ? parseInt(r3, 16) : (r3 = r3.includes(":") ? r3.split(":")[1] : r3, isNaN(Number(r3)) ? r3 : Number(r3));
}
const pt = {}, h = (r3) => pt[r3], pe = (r3, e3) => {
  pt[r3] = e3;
};
var $c = Object.defineProperty, yc = (r3, e3, t2) => e3 in r3 ? $c(r3, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r3[e3] = t2, j = (r3, e3, t2) => yc(r3, typeof e3 != "symbol" ? e3 + "" : e3, t2);
class wc {
  constructor(e3) {
    j(this, "name", "polkadot"), j(this, "client"), j(this, "httpProviders"), j(this, "events"), j(this, "namespace"), j(this, "chainId"), this.namespace = e3.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e3) {
    this.namespace = Object.assign(this.namespace, e3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e3 = this.namespace.chains[0];
    if (!e3) throw new Error("ChainId not found");
    return e3.split(":")[1];
  }
  request(e3) {
    return this.namespace.methods.includes(e3.request.method) ? this.client.request(e3) : this.getHttpProvider().request(e3.request);
  }
  setDefaultChain(e3, t2) {
    this.httpProviders[e3] || this.setHttpProvider(e3, t2), this.chainId = e3, this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${e3}`);
  }
  getAccounts() {
    const e3 = this.namespace.accounts;
    return e3 ? e3.filter((t2) => t2.split(":")[1] === this.chainId.toString()).map((t2) => t2.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const e3 = {};
    return this.namespace.chains.forEach((t2) => {
      var i4;
      const s2 = y(t2);
      e3[s2] = this.createHttpProvider(s2, (i4 = this.namespace.rpcMap) == null ? void 0 : i4[t2]);
    }), e3;
  }
  getHttpProvider() {
    const e3 = `${this.name}:${this.chainId}`, t2 = this.httpProviders[e3];
    if (typeof t2 > "u") throw new Error(`JSON-RPC provider for ${e3} not found`);
    return t2;
  }
  setHttpProvider(e3, t2) {
    const i4 = this.createHttpProvider(e3, t2);
    i4 && (this.httpProviders[e3] = i4);
  }
  createHttpProvider(e3, t2) {
    const i4 = t2 || v(e3, this.namespace, this.client.core.projectId);
    if (!i4) throw new Error(`No RPC url provided for chainId: ${e3}`);
    return new o$9(new f$6(i4, h("disableProviderPing")));
  }
}
var _c = Object.defineProperty, Cc = Object.defineProperties, Ic = Object.getOwnPropertyDescriptors, ut = Object.getOwnPropertySymbols, Oc = Object.prototype.hasOwnProperty, Ac = Object.prototype.propertyIsEnumerable, ue = (r3, e3, t2) => e3 in r3 ? _c(r3, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r3[e3] = t2, lt = (r3, e3) => {
  for (var t2 in e3 || (e3 = {})) Oc.call(e3, t2) && ue(r3, t2, e3[t2]);
  if (ut) for (var t2 of ut(e3)) Ac.call(e3, t2) && ue(r3, t2, e3[t2]);
  return r3;
}, dt = (r3, e3) => Cc(r3, Ic(e3)), H = (r3, e3, t2) => ue(r3, typeof e3 != "symbol" ? e3 + "" : e3, t2);
class jc {
  constructor(e3) {
    H(this, "name", "eip155"), H(this, "client"), H(this, "chainId"), H(this, "namespace"), H(this, "httpProviders"), H(this, "events"), this.namespace = e3.namespace, this.events = h("events"), this.client = h("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
  }
  async request(e3) {
    switch (e3.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(e3);
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
      case "wallet_getCapabilities":
        return await this.getCapabilities(e3);
      case "wallet_getCallsStatus":
        return await this.getCallStatus(e3);
    }
    return this.namespace.methods.includes(e3.request.method) ? await this.client.request(e3) : this.getHttpProvider().request(e3.request);
  }
  updateNamespace(e3) {
    this.namespace = Object.assign(this.namespace, e3);
  }
  setDefaultChain(e3, t2) {
    this.httpProviders[e3] || this.setHttpProvider(parseInt(e3), t2), this.chainId = parseInt(e3), this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${e3}`);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId.toString();
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e3 = this.namespace.chains[0];
    if (!e3) throw new Error("ChainId not found");
    return e3.split(":")[1];
  }
  createHttpProvider(e3, t2) {
    const i4 = t2 || v(`${this.name}:${e3}`, this.namespace, this.client.core.projectId);
    if (!i4) throw new Error(`No RPC url provided for chainId: ${e3}`);
    return new o$9(new f$6(i4, h("disableProviderPing")));
  }
  setHttpProvider(e3, t2) {
    const i4 = this.createHttpProvider(e3, t2);
    i4 && (this.httpProviders[e3] = i4);
  }
  createHttpProviders() {
    const e3 = {};
    return this.namespace.chains.forEach((t2) => {
      var i4;
      const s2 = parseInt(y(t2));
      e3[s2] = this.createHttpProvider(s2, (i4 = this.namespace.rpcMap) == null ? void 0 : i4[t2]);
    }), e3;
  }
  getAccounts() {
    const e3 = this.namespace.accounts;
    return e3 ? [...new Set(e3.filter((t2) => t2.split(":")[1] === this.chainId.toString()).map((t2) => t2.split(":")[2]))] : [];
  }
  getHttpProvider() {
    const e3 = this.chainId, t2 = this.httpProviders[e3];
    if (typeof t2 > "u") throw new Error(`JSON-RPC provider for ${e3} not found`);
    return t2;
  }
  async handleSwitchChain(e3) {
    var t2, i4;
    let s2 = e3.request.params ? (t2 = e3.request.params[0]) == null ? void 0 : t2.chainId : "0x0";
    s2 = s2.startsWith("0x") ? s2 : `0x${s2}`;
    const n5 = parseInt(s2, 16);
    if (this.isChainApproved(n5)) this.setDefaultChain(`${n5}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({ topic: e3.topic, request: { method: e3.request.method, params: [{ chainId: s2 }] }, chainId: (i4 = this.namespace.chains) == null ? void 0 : i4[0] }), this.setDefaultChain(`${n5}`);
    else throw new Error(`Failed to switch to chain 'eip155:${n5}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
    return null;
  }
  isChainApproved(e3) {
    return this.namespace.chains.includes(`${this.name}:${e3}`);
  }
  async getCapabilities(e3) {
    var t2, i4, s2;
    const n5 = (i4 = (t2 = e3.request) == null ? void 0 : t2.params) == null ? void 0 : i4[0];
    if (!n5) throw new Error("Missing address parameter in `wallet_getCapabilities` request");
    const a2 = this.client.session.get(e3.topic), o3 = ((s2 = a2 == null ? void 0 : a2.sessionProperties) == null ? void 0 : s2.capabilities) || {};
    if (o3 != null && o3[n5]) return o3 == null ? void 0 : o3[n5];
    const c2 = await this.client.request(e3);
    try {
      await this.client.session.update(e3.topic, { sessionProperties: dt(lt({}, a2.sessionProperties || {}), { capabilities: dt(lt({}, o3 || {}), { [n5]: c2 }) }) });
    } catch (u2) {
      console.warn("Failed to update session with capabilities", u2);
    }
    return c2;
  }
  async getCallStatus(e3) {
    var t2, i4;
    const s2 = this.client.session.get(e3.topic), n5 = (t2 = s2.sessionProperties) == null ? void 0 : t2.bundler_name;
    if (n5) {
      const o3 = this.getBundlerUrl(e3.chainId, n5);
      try {
        return await this.getUserOperationReceipt(o3, e3);
      } catch (c2) {
        console.warn("Failed to fetch call status from bundler", c2, o3);
      }
    }
    const a2 = (i4 = s2.sessionProperties) == null ? void 0 : i4.bundler_url;
    if (a2) try {
      return await this.getUserOperationReceipt(a2, e3);
    } catch (o3) {
      console.warn("Failed to fetch call status from custom bundler", o3, a2);
    }
    if (this.namespace.methods.includes(e3.request.method)) return await this.client.request(e3);
    throw new Error("Fetching call status not approved by the wallet.");
  }
  async getUserOperationReceipt(e3, t2) {
    var i4;
    const s2 = new URL(e3), n5 = await fetch(s2, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(formatJsonRpcRequest("eth_getUserOperationReceipt", [(i4 = t2.request.params) == null ? void 0 : i4[0]])) });
    if (!n5.ok) throw new Error(`Failed to fetch user operation receipt - ${n5.status}`);
    return await n5.json();
  }
  getBundlerUrl(e3, t2) {
    return `${Ot}?projectId=${this.client.core.projectId}&chainId=${e3}&bundler=${t2}`;
  }
}
var Hc = Object.defineProperty, Ec = (r3, e3, t2) => e3 in r3 ? Hc(r3, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r3[e3] = t2, E = (r3, e3, t2) => Ec(r3, typeof e3 != "symbol" ? e3 + "" : e3, t2);
class Sc {
  constructor(e3) {
    E(this, "name", "solana"), E(this, "client"), E(this, "httpProviders"), E(this, "events"), E(this, "namespace"), E(this, "chainId"), this.namespace = e3.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e3) {
    this.namespace = Object.assign(this.namespace, e3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e3) {
    return this.namespace.methods.includes(e3.request.method) ? this.client.request(e3) : this.getHttpProvider().request(e3.request);
  }
  setDefaultChain(e3, t2) {
    this.httpProviders[e3] || this.setHttpProvider(e3, t2), this.chainId = e3, this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${e3}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e3 = this.namespace.chains[0];
    if (!e3) throw new Error("ChainId not found");
    return e3.split(":")[1];
  }
  getAccounts() {
    const e3 = this.namespace.accounts;
    return e3 ? [...new Set(e3.filter((t2) => t2.split(":")[1] === this.chainId.toString()).map((t2) => t2.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e3 = {};
    return this.namespace.chains.forEach((t2) => {
      var i4;
      const s2 = y(t2);
      e3[s2] = this.createHttpProvider(s2, (i4 = this.namespace.rpcMap) == null ? void 0 : i4[t2]);
    }), e3;
  }
  getHttpProvider() {
    const e3 = `${this.name}:${this.chainId}`, t2 = this.httpProviders[e3];
    if (typeof t2 > "u") throw new Error(`JSON-RPC provider for ${e3} not found`);
    return t2;
  }
  setHttpProvider(e3, t2) {
    const i4 = this.createHttpProvider(e3, t2);
    i4 && (this.httpProviders[e3] = i4);
  }
  createHttpProvider(e3, t2) {
    const i4 = t2 || v(e3, this.namespace, this.client.core.projectId);
    if (!i4) throw new Error(`No RPC url provided for chainId: ${e3}`);
    return new o$9(new f$6(i4, h("disableProviderPing")));
  }
}
var Nc = Object.defineProperty, Tc = (r3, e3, t2) => e3 in r3 ? Nc(r3, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r3[e3] = t2, S = (r3, e3, t2) => Tc(r3, typeof e3 != "symbol" ? e3 + "" : e3, t2);
class Dc {
  constructor(e3) {
    S(this, "name", "cosmos"), S(this, "client"), S(this, "httpProviders"), S(this, "events"), S(this, "namespace"), S(this, "chainId"), this.namespace = e3.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e3) {
    this.namespace = Object.assign(this.namespace, e3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e3 = this.namespace.chains[0];
    if (!e3) throw new Error("ChainId not found");
    return e3.split(":")[1];
  }
  request(e3) {
    return this.namespace.methods.includes(e3.request.method) ? this.client.request(e3) : this.getHttpProvider().request(e3.request);
  }
  setDefaultChain(e3, t2) {
    this.httpProviders[e3] || this.setHttpProvider(e3, t2), this.chainId = e3, this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e3 = this.namespace.accounts;
    return e3 ? [...new Set(e3.filter((t2) => t2.split(":")[1] === this.chainId.toString()).map((t2) => t2.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e3 = {};
    return this.namespace.chains.forEach((t2) => {
      var i4;
      const s2 = y(t2);
      e3[s2] = this.createHttpProvider(s2, (i4 = this.namespace.rpcMap) == null ? void 0 : i4[t2]);
    }), e3;
  }
  getHttpProvider() {
    const e3 = `${this.name}:${this.chainId}`, t2 = this.httpProviders[e3];
    if (typeof t2 > "u") throw new Error(`JSON-RPC provider for ${e3} not found`);
    return t2;
  }
  setHttpProvider(e3, t2) {
    const i4 = this.createHttpProvider(e3, t2);
    i4 && (this.httpProviders[e3] = i4);
  }
  createHttpProvider(e3, t2) {
    const i4 = t2 || v(e3, this.namespace, this.client.core.projectId);
    if (!i4) throw new Error(`No RPC url provided for chainId: ${e3}`);
    return new o$9(new f$6(i4, h("disableProviderPing")));
  }
}
var qc = Object.defineProperty, Rc = (r3, e3, t2) => e3 in r3 ? qc(r3, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r3[e3] = t2, N = (r3, e3, t2) => Rc(r3, typeof e3 != "symbol" ? e3 + "" : e3, t2);
class xc {
  constructor(e3) {
    N(this, "name", "algorand"), N(this, "client"), N(this, "httpProviders"), N(this, "events"), N(this, "namespace"), N(this, "chainId"), this.namespace = e3.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e3) {
    this.namespace = Object.assign(this.namespace, e3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e3) {
    return this.namespace.methods.includes(e3.request.method) ? this.client.request(e3) : this.getHttpProvider().request(e3.request);
  }
  setDefaultChain(e3, t2) {
    if (!this.httpProviders[e3]) {
      const i4 = t2 || v(`${this.name}:${e3}`, this.namespace, this.client.core.projectId);
      if (!i4) throw new Error(`No RPC url provided for chainId: ${e3}`);
      this.setHttpProvider(e3, i4);
    }
    this.chainId = e3, this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e3 = this.namespace.chains[0];
    if (!e3) throw new Error("ChainId not found");
    return e3.split(":")[1];
  }
  getAccounts() {
    const e3 = this.namespace.accounts;
    return e3 ? [...new Set(e3.filter((t2) => t2.split(":")[1] === this.chainId.toString()).map((t2) => t2.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e3 = {};
    return this.namespace.chains.forEach((t2) => {
      var i4;
      e3[t2] = this.createHttpProvider(t2, (i4 = this.namespace.rpcMap) == null ? void 0 : i4[t2]);
    }), e3;
  }
  getHttpProvider() {
    const e3 = `${this.name}:${this.chainId}`, t2 = this.httpProviders[e3];
    if (typeof t2 > "u") throw new Error(`JSON-RPC provider for ${e3} not found`);
    return t2;
  }
  setHttpProvider(e3, t2) {
    const i4 = this.createHttpProvider(e3, t2);
    i4 && (this.httpProviders[e3] = i4);
  }
  createHttpProvider(e3, t2) {
    const i4 = t2 || v(e3, this.namespace, this.client.core.projectId);
    return typeof i4 > "u" ? void 0 : new o$9(new f$6(i4, h("disableProviderPing")));
  }
}
var Lc = Object.defineProperty, Uc = (r3, e3, t2) => e3 in r3 ? Lc(r3, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r3[e3] = t2, T = (r3, e3, t2) => Uc(r3, typeof e3 != "symbol" ? e3 + "" : e3, t2);
class Fc {
  constructor(e3) {
    T(this, "name", "cip34"), T(this, "client"), T(this, "httpProviders"), T(this, "events"), T(this, "namespace"), T(this, "chainId"), this.namespace = e3.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e3) {
    this.namespace = Object.assign(this.namespace, e3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e3 = this.namespace.chains[0];
    if (!e3) throw new Error("ChainId not found");
    return e3.split(":")[1];
  }
  request(e3) {
    return this.namespace.methods.includes(e3.request.method) ? this.client.request(e3) : this.getHttpProvider().request(e3.request);
  }
  setDefaultChain(e3, t2) {
    this.httpProviders[e3] || this.setHttpProvider(e3, t2), this.chainId = e3, this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e3 = this.namespace.accounts;
    return e3 ? [...new Set(e3.filter((t2) => t2.split(":")[1] === this.chainId.toString()).map((t2) => t2.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e3 = {};
    return this.namespace.chains.forEach((t2) => {
      const i4 = this.getCardanoRPCUrl(t2), s2 = y(t2);
      e3[s2] = this.createHttpProvider(s2, i4);
    }), e3;
  }
  getHttpProvider() {
    const e3 = `${this.name}:${this.chainId}`, t2 = this.httpProviders[e3];
    if (typeof t2 > "u") throw new Error(`JSON-RPC provider for ${e3} not found`);
    return t2;
  }
  getCardanoRPCUrl(e3) {
    const t2 = this.namespace.rpcMap;
    if (t2) return t2[e3];
  }
  setHttpProvider(e3, t2) {
    const i4 = this.createHttpProvider(e3, t2);
    i4 && (this.httpProviders[e3] = i4);
  }
  createHttpProvider(e3, t2) {
    const i4 = t2 || this.getCardanoRPCUrl(e3);
    if (!i4) throw new Error(`No RPC url provided for chainId: ${e3}`);
    return new o$9(new f$6(i4, h("disableProviderPing")));
  }
}
var Mc = Object.defineProperty, Gc = (r3, e3, t2) => e3 in r3 ? Mc(r3, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r3[e3] = t2, D = (r3, e3, t2) => Gc(r3, typeof e3 != "symbol" ? e3 + "" : e3, t2);
class zc {
  constructor(e3) {
    D(this, "name", "elrond"), D(this, "client"), D(this, "httpProviders"), D(this, "events"), D(this, "namespace"), D(this, "chainId"), this.namespace = e3.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e3) {
    this.namespace = Object.assign(this.namespace, e3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e3) {
    return this.namespace.methods.includes(e3.request.method) ? this.client.request(e3) : this.getHttpProvider().request(e3.request);
  }
  setDefaultChain(e3, t2) {
    this.httpProviders[e3] || this.setHttpProvider(e3, t2), this.chainId = e3, this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${e3}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e3 = this.namespace.chains[0];
    if (!e3) throw new Error("ChainId not found");
    return e3.split(":")[1];
  }
  getAccounts() {
    const e3 = this.namespace.accounts;
    return e3 ? [...new Set(e3.filter((t2) => t2.split(":")[1] === this.chainId.toString()).map((t2) => t2.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e3 = {};
    return this.namespace.chains.forEach((t2) => {
      var i4;
      const s2 = y(t2);
      e3[s2] = this.createHttpProvider(s2, (i4 = this.namespace.rpcMap) == null ? void 0 : i4[t2]);
    }), e3;
  }
  getHttpProvider() {
    const e3 = `${this.name}:${this.chainId}`, t2 = this.httpProviders[e3];
    if (typeof t2 > "u") throw new Error(`JSON-RPC provider for ${e3} not found`);
    return t2;
  }
  setHttpProvider(e3, t2) {
    const i4 = this.createHttpProvider(e3, t2);
    i4 && (this.httpProviders[e3] = i4);
  }
  createHttpProvider(e3, t2) {
    const i4 = t2 || v(e3, this.namespace, this.client.core.projectId);
    if (!i4) throw new Error(`No RPC url provided for chainId: ${e3}`);
    return new o$9(new f$6(i4, h("disableProviderPing")));
  }
}
var kc = Object.defineProperty, Bc = (r3, e3, t2) => e3 in r3 ? kc(r3, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r3[e3] = t2, q = (r3, e3, t2) => Bc(r3, typeof e3 != "symbol" ? e3 + "" : e3, t2);
class Vc {
  constructor(e3) {
    q(this, "name", "multiversx"), q(this, "client"), q(this, "httpProviders"), q(this, "events"), q(this, "namespace"), q(this, "chainId"), this.namespace = e3.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e3) {
    this.namespace = Object.assign(this.namespace, e3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e3) {
    return this.namespace.methods.includes(e3.request.method) ? this.client.request(e3) : this.getHttpProvider().request(e3.request);
  }
  setDefaultChain(e3, t2) {
    this.httpProviders[e3] || this.setHttpProvider(e3, t2), this.chainId = e3, this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${e3}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e3 = this.namespace.chains[0];
    if (!e3) throw new Error("ChainId not found");
    return e3.split(":")[1];
  }
  getAccounts() {
    const e3 = this.namespace.accounts;
    return e3 ? [...new Set(e3.filter((t2) => t2.split(":")[1] === this.chainId.toString()).map((t2) => t2.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e3 = {};
    return this.namespace.chains.forEach((t2) => {
      var i4;
      const s2 = y(t2);
      e3[s2] = this.createHttpProvider(s2, (i4 = this.namespace.rpcMap) == null ? void 0 : i4[t2]);
    }), e3;
  }
  getHttpProvider() {
    const e3 = `${this.name}:${this.chainId}`, t2 = this.httpProviders[e3];
    if (typeof t2 > "u") throw new Error(`JSON-RPC provider for ${e3} not found`);
    return t2;
  }
  setHttpProvider(e3, t2) {
    const i4 = this.createHttpProvider(e3, t2);
    i4 && (this.httpProviders[e3] = i4);
  }
  createHttpProvider(e3, t2) {
    const i4 = t2 || v(e3, this.namespace, this.client.core.projectId);
    if (!i4) throw new Error(`No RPC url provided for chainId: ${e3}`);
    return new o$9(new f$6(i4, h("disableProviderPing")));
  }
}
var Jc = Object.defineProperty, Kc = (r3, e3, t2) => e3 in r3 ? Jc(r3, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r3[e3] = t2, R = (r3, e3, t2) => Kc(r3, typeof e3 != "symbol" ? e3 + "" : e3, t2);
class Wc {
  constructor(e3) {
    R(this, "name", "near"), R(this, "client"), R(this, "httpProviders"), R(this, "events"), R(this, "namespace"), R(this, "chainId"), this.namespace = e3.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e3) {
    this.namespace = Object.assign(this.namespace, e3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e3 = this.namespace.chains[0];
    if (!e3) throw new Error("ChainId not found");
    return e3.split(":")[1];
  }
  request(e3) {
    return this.namespace.methods.includes(e3.request.method) ? this.client.request(e3) : this.getHttpProvider().request(e3.request);
  }
  setDefaultChain(e3, t2) {
    if (this.chainId = e3, !this.httpProviders[e3]) {
      const i4 = t2 || v(`${this.name}:${e3}`, this.namespace);
      if (!i4) throw new Error(`No RPC url provided for chainId: ${e3}`);
      this.setHttpProvider(e3, i4);
    }
    this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e3 = this.namespace.accounts;
    return e3 ? e3.filter((t2) => t2.split(":")[1] === this.chainId.toString()).map((t2) => t2.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const e3 = {};
    return this.namespace.chains.forEach((t2) => {
      var i4;
      e3[t2] = this.createHttpProvider(t2, (i4 = this.namespace.rpcMap) == null ? void 0 : i4[t2]);
    }), e3;
  }
  getHttpProvider() {
    const e3 = `${this.name}:${this.chainId}`, t2 = this.httpProviders[e3];
    if (typeof t2 > "u") throw new Error(`JSON-RPC provider for ${e3} not found`);
    return t2;
  }
  setHttpProvider(e3, t2) {
    const i4 = this.createHttpProvider(e3, t2);
    i4 && (this.httpProviders[e3] = i4);
  }
  createHttpProvider(e3, t2) {
    const i4 = t2 || v(e3, this.namespace);
    return typeof i4 > "u" ? void 0 : new o$9(new f$6(i4, h("disableProviderPing")));
  }
}
var Xc = Object.defineProperty, Yc = (r3, e3, t2) => e3 in r3 ? Xc(r3, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r3[e3] = t2, x = (r3, e3, t2) => Yc(r3, typeof e3 != "symbol" ? e3 + "" : e3, t2);
class Zc {
  constructor(e3) {
    x(this, "name", "tezos"), x(this, "client"), x(this, "httpProviders"), x(this, "events"), x(this, "namespace"), x(this, "chainId"), this.namespace = e3.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e3) {
    this.namespace = Object.assign(this.namespace, e3);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e3 = this.namespace.chains[0];
    if (!e3) throw new Error("ChainId not found");
    return e3.split(":")[1];
  }
  request(e3) {
    return this.namespace.methods.includes(e3.request.method) ? this.client.request(e3) : this.getHttpProvider().request(e3.request);
  }
  setDefaultChain(e3, t2) {
    if (this.chainId = e3, !this.httpProviders[e3]) {
      const i4 = t2 || v(`${this.name}:${e3}`, this.namespace);
      if (!i4) throw new Error(`No RPC url provided for chainId: ${e3}`);
      this.setHttpProvider(e3, i4);
    }
    this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e3 = this.namespace.accounts;
    return e3 ? e3.filter((t2) => t2.split(":")[1] === this.chainId.toString()).map((t2) => t2.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const e3 = {};
    return this.namespace.chains.forEach((t2) => {
      e3[t2] = this.createHttpProvider(t2);
    }), e3;
  }
  getHttpProvider() {
    const e3 = `${this.name}:${this.chainId}`, t2 = this.httpProviders[e3];
    if (typeof t2 > "u") throw new Error(`JSON-RPC provider for ${e3} not found`);
    return t2;
  }
  setHttpProvider(e3, t2) {
    const i4 = this.createHttpProvider(e3, t2);
    i4 && (this.httpProviders[e3] = i4);
  }
  createHttpProvider(e3, t2) {
    const i4 = t2 || v(e3, this.namespace);
    return typeof i4 > "u" ? void 0 : new o$9(new f$6(i4));
  }
}
var Qc = Object.defineProperty, eh = (r3, e3, t2) => e3 in r3 ? Qc(r3, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r3[e3] = t2, L = (r3, e3, t2) => eh(r3, typeof e3 != "symbol" ? e3 + "" : e3, t2);
class th {
  constructor(e3) {
    L(this, "name", w), L(this, "client"), L(this, "httpProviders"), L(this, "events"), L(this, "namespace"), L(this, "chainId"), this.namespace = e3.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e3) {
    this.namespace.chains = [...new Set((this.namespace.chains || []).concat(e3.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(e3.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(e3.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(e3.events || []))], this.httpProviders = this.createHttpProviders();
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e3) {
    return this.namespace.methods.includes(e3.request.method) ? this.client.request(e3) : this.getHttpProvider(e3.chainId).request(e3.request);
  }
  setDefaultChain(e3, t2) {
    this.httpProviders[e3] || this.setHttpProvider(e3, t2), this.chainId = e3, this.events.emit(f.DEFAULT_CHAIN_CHANGED, `${this.name}:${e3}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e3 = this.namespace.chains[0];
    if (!e3) throw new Error("ChainId not found");
    return e3.split(":")[1];
  }
  getAccounts() {
    const e3 = this.namespace.accounts;
    return e3 ? [...new Set(e3.filter((t2) => t2.split(":")[1] === this.chainId.toString()).map((t2) => t2.split(":")[2]))] : [];
  }
  createHttpProviders() {
    var e3, t2;
    const i4 = {};
    return (t2 = (e3 = this.namespace) == null ? void 0 : e3.accounts) == null || t2.forEach((s2) => {
      const n5 = Ye$1(s2);
      i4[`${n5.namespace}:${n5.reference}`] = this.createHttpProvider(s2);
    }), i4;
  }
  getHttpProvider(e3) {
    const t2 = this.httpProviders[e3];
    if (typeof t2 > "u") throw new Error(`JSON-RPC provider for ${e3} not found`);
    return t2;
  }
  setHttpProvider(e3, t2) {
    const i4 = this.createHttpProvider(e3, t2);
    i4 && (this.httpProviders[e3] = i4);
  }
  createHttpProvider(e3, t2) {
    const i4 = t2 || v(e3, this.namespace, this.client.core.projectId);
    if (!i4) throw new Error(`No RPC url provided for chainId: ${e3}`);
    return new o$9(new f$6(i4, h("disableProviderPing")));
  }
}
var rh = Object.defineProperty, ih = Object.defineProperties, sh = Object.getOwnPropertyDescriptors, vt = Object.getOwnPropertySymbols, nh = Object.prototype.hasOwnProperty, ah = Object.prototype.propertyIsEnumerable, le = (r3, e3, t2) => e3 in r3 ? rh(r3, e3, { enumerable: true, configurable: true, writable: true, value: t2 }) : r3[e3] = t2, Y = (r3, e3) => {
  for (var t2 in e3 || (e3 = {})) nh.call(e3, t2) && le(r3, t2, e3[t2]);
  if (vt) for (var t2 of vt(e3)) ah.call(e3, t2) && le(r3, t2, e3[t2]);
  return r3;
}, de = (r3, e3) => ih(r3, sh(e3)), g = (r3, e3, t2) => le(r3, typeof e3 != "symbol" ? e3 + "" : e3, t2);
class Z {
  constructor(e3) {
    g(this, "client"), g(this, "namespaces"), g(this, "optionalNamespaces"), g(this, "sessionProperties"), g(this, "events", new wt$7()), g(this, "rpcProviders", {}), g(this, "session"), g(this, "providerOpts"), g(this, "logger"), g(this, "uri"), g(this, "disableProviderPing", false), this.providerOpts = e3, this.logger = typeof (e3 == null ? void 0 : e3.logger) < "u" && typeof (e3 == null ? void 0 : e3.logger) != "string" ? e3.logger : gt$3(k$7({ level: (e3 == null ? void 0 : e3.logger) || be })), this.disableProviderPing = (e3 == null ? void 0 : e3.disableProviderPing) || false;
  }
  static async init(e3) {
    const t2 = new Z(e3);
    return await t2.initialize(), t2;
  }
  async request(e3, t2, i4) {
    const [s2, n5] = this.validateChain(t2);
    if (!this.session) throw new Error("Please call connect() before request()");
    return await this.getProvider(s2).request({ request: Y({}, e3), chainId: `${s2}:${n5}`, topic: this.session.topic, expiry: i4 });
  }
  sendAsync(e3, t2, i4, s2) {
    const n5 = (/* @__PURE__ */ new Date()).getTime();
    this.request(e3, i4, s2).then((a2) => t2(null, formatJsonRpcResult(n5, a2))).catch((a2) => t2(a2, void 0));
  }
  async enable() {
    if (!this.client) throw new Error("Sign Client not initialized");
    return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties }), await this.requestAccounts();
  }
  async disconnect() {
    var e3;
    if (!this.session) throw new Error("Please call connect() before enable()");
    await this.client.disconnect({ topic: (e3 = this.session) == null ? void 0 : e3.topic, reason: de$2("USER_DISCONNECTED") }), await this.cleanup();
  }
  async connect(e3) {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (this.setNamespaces(e3), await this.cleanupPendingPairings(), !e3.skipPairing) return await this.pair(e3.pairingTopic);
  }
  async authenticate(e3, t2) {
    if (!this.client) throw new Error("Sign Client not initialized");
    this.setNamespaces(e3), await this.cleanupPendingPairings();
    const { uri: i4, response: s2 } = await this.client.authenticate(e3, t2);
    i4 && (this.uri = i4, this.events.emit("display_uri", i4));
    const n5 = await s2();
    if (this.session = n5.session, this.session) {
      const a2 = ht(this.session.namespaces);
      this.namespaces = ce(this.namespaces, a2), this.persist("namespaces", this.namespaces), this.onConnect();
    }
    return n5;
  }
  on(e3, t2) {
    this.events.on(e3, t2);
  }
  once(e3, t2) {
    this.events.once(e3, t2);
  }
  removeListener(e3, t2) {
    this.events.removeListener(e3, t2);
  }
  off(e3, t2) {
    this.events.off(e3, t2);
  }
  get isWalletConnect() {
    return true;
  }
  async pair(e3) {
    const { uri: t2, approval: i4 } = await this.client.connect({ pairingTopic: e3, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties });
    t2 && (this.uri = t2, this.events.emit("display_uri", t2));
    const s2 = await i4();
    this.session = s2;
    const n5 = ht(s2.namespaces);
    return this.namespaces = ce(this.namespaces, n5), this.persist("namespaces", this.namespaces), this.onConnect(), this.session;
  }
  setDefaultChain(e3, t2) {
    try {
      if (!this.session) return;
      const [i4, s2] = this.validateChain(e3), n5 = this.getProvider(i4);
      n5.name === w ? n5.setDefaultChain(`${i4}:${s2}`, t2) : n5.setDefaultChain(s2, t2);
    } catch (i4) {
      if (!/Please call connect/.test(i4.message)) throw i4;
    }
  }
  async cleanupPendingPairings(e3 = {}) {
    this.logger.info("Cleaning up inactive pairings...");
    const t2 = this.client.pairing.getAll();
    if ($e$3(t2)) {
      for (const i4 of t2) e3.deletePairings ? this.client.core.expirer.set(i4.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(i4.topic);
      this.logger.info(`Inactive pairings cleared: ${t2.length}`);
    }
  }
  abortPairingAttempt() {
    this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.");
  }
  async checkStorage() {
    if (this.namespaces = await this.getFromStore("namespaces"), this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.client.session.length) {
      const e3 = this.client.session.keys.length - 1;
      this.session = this.client.session.get(this.client.session.keys[e3]), this.createProviders();
    }
  }
  async initialize() {
    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
  }
  async createClient() {
    this.client = this.providerOpts.client || await Ee$1.init({ core: this.providerOpts.core, logger: this.providerOpts.logger || be, relayUrl: this.providerOpts.relayUrl || _t, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, storage: this.providerOpts.storage, name: this.providerOpts.name, customStoragePrefix: this.providerOpts.customStoragePrefix, telemetryEnabled: this.providerOpts.telemetryEnabled }), this.logger.trace("SignClient Initialized");
  }
  createProviders() {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
    const e3 = [...new Set(Object.keys(this.session.namespaces).map((t2) => pr$2(t2)))];
    pe("client", this.client), pe("events", this.events), pe("disableProviderPing", this.disableProviderPing), e3.forEach((t2) => {
      if (!this.session) return;
      const i4 = Pc(t2, this.session), s2 = ot(i4), n5 = ce(this.namespaces, this.optionalNamespaces), a2 = de(Y({}, n5[t2]), { accounts: i4, chains: s2 });
      switch (t2) {
        case "eip155":
          this.rpcProviders[t2] = new jc({ namespace: a2 });
          break;
        case "algorand":
          this.rpcProviders[t2] = new xc({ namespace: a2 });
          break;
        case "solana":
          this.rpcProviders[t2] = new Sc({ namespace: a2 });
          break;
        case "cosmos":
          this.rpcProviders[t2] = new Dc({ namespace: a2 });
          break;
        case "polkadot":
          this.rpcProviders[t2] = new wc({ namespace: a2 });
          break;
        case "cip34":
          this.rpcProviders[t2] = new Fc({ namespace: a2 });
          break;
        case "elrond":
          this.rpcProviders[t2] = new zc({ namespace: a2 });
          break;
        case "multiversx":
          this.rpcProviders[t2] = new Vc({ namespace: a2 });
          break;
        case "near":
          this.rpcProviders[t2] = new Wc({ namespace: a2 });
          break;
        case "tezos":
          this.rpcProviders[t2] = new Zc({ namespace: a2 });
          break;
        default:
          this.rpcProviders[w] ? this.rpcProviders[w].updateNamespace(a2) : this.rpcProviders[w] = new th({ namespace: a2 });
      }
    });
  }
  registerEventListeners() {
    if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", (e3) => {
      this.events.emit("session_ping", e3);
    }), this.client.on("session_event", (e3) => {
      const { params: t2 } = e3, { event: i4 } = t2;
      if (i4.name === "accountsChanged") {
        const s2 = i4.data;
        s2 && $e$3(s2) && this.events.emit("accountsChanged", s2.map(bc));
      } else if (i4.name === "chainChanged") {
        const s2 = t2.chainId, n5 = t2.event.data, a2 = pr$2(s2), o3 = he(s2) !== he(n5) ? `${a2}:${he(n5)}` : s2;
        this.onChainChanged(o3);
      } else this.events.emit(i4.name, i4.data);
      this.events.emit("session_event", e3);
    }), this.client.on("session_update", ({ topic: e3, params: t2 }) => {
      var i4;
      const { namespaces: s2 } = t2, n5 = (i4 = this.client) == null ? void 0 : i4.session.get(e3);
      this.session = de(Y({}, n5), { namespaces: s2 }), this.onSessionUpdate(), this.events.emit("session_update", { topic: e3, params: t2 });
    }), this.client.on("session_delete", async (e3) => {
      await this.cleanup(), this.events.emit("session_delete", e3), this.events.emit("disconnect", de(Y({}, de$2("USER_DISCONNECTED")), { data: e3.topic }));
    }), this.on(f.DEFAULT_CHAIN_CHANGED, (e3) => {
      this.onChainChanged(e3, true);
    });
  }
  getProvider(e3) {
    return this.rpcProviders[e3] || this.rpcProviders[w];
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach((e3) => {
      var t2;
      this.getProvider(e3).updateNamespace((t2 = this.session) == null ? void 0 : t2.namespaces[e3]);
    });
  }
  setNamespaces(e3) {
    const { namespaces: t2, optionalNamespaces: i4, sessionProperties: s2 } = e3;
    t2 && Object.keys(t2).length && (this.namespaces = t2), i4 && Object.keys(i4).length && (this.optionalNamespaces = i4), this.sessionProperties = s2, this.persist("namespaces", t2), this.persist("optionalNamespaces", i4);
  }
  validateChain(e3) {
    const [t2, i4] = (e3 == null ? void 0 : e3.split(":")) || ["", ""];
    if (!this.namespaces || !Object.keys(this.namespaces).length) return [t2, i4];
    if (t2 && !Object.keys(this.namespaces || {}).map((a2) => pr$2(a2)).includes(t2)) throw new Error(`Namespace '${t2}' is not configured. Please call connect() first with namespace config.`);
    if (t2 && i4) return [t2, i4];
    const s2 = pr$2(Object.keys(this.namespaces)[0]), n5 = this.rpcProviders[s2].getDefaultChain();
    return [s2, n5];
  }
  async requestAccounts() {
    const [e3] = this.validateChain();
    return await this.getProvider(e3).requestAccounts();
  }
  onChainChanged(e3, t2 = false) {
    if (!this.namespaces) return;
    const [i4, s2] = this.validateChain(e3);
    s2 && (t2 || this.getProvider(i4).setDefaultChain(s2), this.namespaces[i4] ? this.namespaces[i4].defaultChain = s2 : this.namespaces[`${i4}:${s2}`] ? this.namespaces[`${i4}:${s2}`].defaultChain = s2 : this.namespaces[`${i4}:${s2}`] = { defaultChain: s2 }, this.persist("namespaces", this.namespaces), this.events.emit("chainChanged", s2));
  }
  onConnect() {
    this.createProviders(), this.events.emit("connect", { session: this.session });
  }
  async cleanup() {
    this.session = void 0, this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, this.persist("namespaces", void 0), this.persist("optionalNamespaces", void 0), this.persist("sessionProperties", void 0), await this.cleanupPendingPairings({ deletePairings: true });
  }
  persist(e3, t2) {
    this.client.core.storage.setItem(`${$e}/${e3}`, t2);
  }
  async getFromStore(e3) {
    return await this.client.core.storage.getItem(`${$e}/${e3}`);
  }
}
export {
  anumber as $,
  ApiController$1 as A,
  WalletUtil as B,
  ChainController as C,
  ConnectorController as D,
  EthersAdapter as E,
  networkList as F,
  ConstantsUtil$3 as G,
  Hash$1 as H,
  etherTestnet as I,
  etherMainnet as J,
  kaiaTestnet as K,
  kaiaMainnet as L,
  ModalController as M,
  bscTestnet as N,
  OptionsController as O,
  PACKAGE_VERSION as P,
  bscMainnet as Q,
  RouterController as R,
  SIWXUtil as S,
  ThemeController as T,
  UiHelperUtil as U,
  crossTestnet as V,
  WalletButtonController as W,
  crossMainnet as X,
  SendController as Y,
  Z,
  ahash as _,
  i$1 as a,
  randomBytes$1 as a0,
  concatBytes$2 as a1,
  process$1 as a2,
  getDefaultExportFromCjs$1 as a3,
  subscribe as a4,
  snapshot as a5,
  p$a as a6,
  a$3 as a7,
  w$5 as a8,
  ProviderUtil as a9,
  Buffer as aa,
  bytesToHex$2 as ab,
  AssetUtil as b,
  CoreHelperUtil as c,
  initializeTheming as d,
  SnackController as e,
  ConstantsUtil$4 as f,
  customElement as g,
  createView$1 as h,
  i$4 as i,
  aexists as j,
  abytes as k,
  aoutput as l,
  clean as m,
  n$3 as n,
  o$2 as o,
  createHasher as p,
  rotr$1 as q,
  r$1 as r,
  AccountController as s,
  toBytes$2 as t,
  AppKit as u,
  ApiController as v,
  ConnectionController as w,
  x$3 as x,
  ConstantsUtil as y,
  ConnectorUtil as z
};
//# sourceMappingURL=index.es-DuX4IOPH.js.map
